[{"content":"2022 å¹´åˆ | åç«¯å¼€å‘ä¸¤å¹´ç»éªŒç¤¾æ‹›é¢ç» å­—èŠ‚ ä¸€é¢   coding: å¯¹äºä¸€ä¸ªæ•°ç»„ï¼Œä»…ç”¨ä¸€æ¬¡éå†ï¼Œç­‰æ¦‚ç‡åœ°éšæœºå‡ºä¸€ä¸ªå…ƒç´ ï¼ˆå¯¹äºæ¯ä¸€ä¸ªå…ƒç´ ï¼Œä»å…¨å±€çœ‹ï¼Œä»–ä»¬è¢«é€‰æ‹©çš„æ¦‚ç‡éƒ½åº”è¯¥æ˜¯ 1/nï¼‰\n å¯¹äºç¬¬ i ä¸ªå…ƒç´ ï¼Œå®ƒåœ¨ç¬¬ i è½®è¢«é€‰ä¸­çš„æ¦‚ç‡æ˜¯ 1/i å¾€åï¼Œåªè¦é€‰æ‹©äº†æ–°çš„å…ƒç´ ï¼Œå®ƒå°±ä¼šè¢«æ·˜æ±°ï¼›ä»¥ç¬¬ i+1 è½®ä¸ºä¾‹ï¼Œå®ƒè¢«æ·˜æ±°çš„æ¦‚ç‡æ˜¯ 1/(i+1)ï¼Œé‚£ä¹ˆåè¿‡æ¥å®ƒè¢«ç•™ä¸‹çš„æ¦‚ç‡å°±æ˜¯ 1 - 1/(i+1) æœ€ç»ˆæ¯ä¸€ä¸ªå…ƒç´ è¢«é€‰æ‹©çš„æ¦‚ç‡å¦‚ä¸‹ï¼Œç¬¬ä¸€ä¸ª 1/i ä»£è¡¨å®ƒåœ¨ç¬¬ i æ¬¡è¢«é€‰ä¸­ï¼Œå…¶ä»–æ•°ä»£è¡¨å®ƒåœ¨åç»­çš„æ¯ä¸€è½®è¢«ç•™ä¸‹     followupï¼šç­‰æ¦‚ç‡åœ°éšæœºå‡º k ä¸ªå…ƒç´ \n å¯¹äºç¬¬ i ä¸ªå…ƒç´ ï¼Œå®ƒåœ¨ç¬¬ i è½®è¢«é€‰ä¸­çš„æ¦‚ç‡æ˜¯ k/i å¾€åï¼Œå®ƒå”¯ä¸€ä¼šè¢«æ·˜æ±°çš„åœºæ™¯æ˜¯ï¼šé€‰æ‹©äº†æ–°çš„å…ƒç´ ï¼ŒåŒæ—¶ä»å·²æœ‰çš„é€‰æ‹©ä¸­ï¼Œç­‰æ¦‚ç‡åœ°é€‰æ‹©åˆ°äº†å®ƒï¼›ä»¥ç¬¬ i+1 è½®ä¸ºä¾‹ï¼Œå®ƒè¢«æ·˜æ±°çš„æ¦‚ç‡æ˜¯ k/(i+1) * 1/k = 1/(i+1)ï¼Œé‚£ä¹ˆåè¿‡æ¥å®ƒè¢«ç•™ä¸‹çš„æ¦‚ç‡å°±æ˜¯ 1 - k/(i+1) * 1/k = 1 - 1/(i+1) æœ€ç»ˆæ¯ä¸€ä¸ªå…ƒç´ è¢«é€‰æ‹©çš„æ¦‚ç‡å¦‚ä¸‹ï¼Œç¬¬ä¸€ä¸ª k/i ä»£è¡¨å®ƒåœ¨ç¬¬ i æ¬¡è¢«é€‰ä¸­ï¼Œå…¶ä»–æ•°ä»£è¡¨å®ƒåœ¨åç»­çš„æ¯ä¸€è½®è¢«ç•™ä¸‹     coding: å®ç° Fisherâ€“Yates Suffle\nvoid shuffle(vector\u0026lt;int\u0026gt; v) { int n = v.size(); for (int i = n - 1; i \u0026gt;= 1; --i) { int j = rand() % (i + 1); swap(v[i], v[j]); } }   äºŒé¢  system designï¼šä¸»æ’­å¼€æ’­ï¼Œå¦‚ä½•æŠŠè¿™ä¸ªæ¶ˆæ¯æ¨é€ç»™ä»–çš„åƒä¸‡çº§ follower  è®¾è®¡æ•°æ®ä»“åº“ï¼ˆæ•°æ®åº“ä¹Ÿå¯ä»¥ï¼‰ æ¶ˆæ¯é˜Ÿåˆ—   followupï¼šæ¨é€ä¹‹åï¼Œä¸»æ’­å·²ç»ä¸‹æ’­ï¼Œæ€ä¹ˆå¤„ç† followupï¼šæ€ä¹ˆä¿è¯æ¶ˆæ¯æ¨é€æˆ–è¢«æ¶ˆè´¹ followupï¼šå¦‚ä½•ä¿è¯æ¶ˆæ¯ä¸é‡å¤  ä¸‰é¢   DB è¿ç§»æµç¨‹\n è®¾ç½®å¿«ç…§ï¼Œç¦»çº¿æ¬è¿å­˜é‡æ•°æ® åŒå†™ï¼Œå°†å¿«ç…§åçš„æ–°æ•°æ®æµå†™å…¥æ–° DB åˆ‡æ¢è·¯ç”±ï¼Œå°†è¯»çš„è¯·æ±‚å¼•å…¥æ–° DB    codingï¼šå†™ä¸€ä¸ªæœåŠ¡çš„å¤§è‡´æ¡†æ¶\n  Hotstar ä¸€é¢  å¯¹åç¨‹çš„ç†è§£ csrf token æ˜¯ä»€ä¹ˆ  Cross-site request forgery è·¨ç«™è¯·æ±‚ä¼ªé€ ï¼›æ”»å‡»è€…è¯±å¯¼å—å®³è€…è¿›å…¥ç¬¬ä¸‰æ–¹ç½‘ç«™ï¼Œåœ¨ç¬¬ä¸‰æ–¹ç½‘ç«™ä¸­ï¼Œå‘è¢«æ”»å‡»ç½‘ç«™å‘é€è·¨ç«™è¯·æ±‚ï¼Œå¹¶è·å–æ³¨å†Œå‡­è¯ï¼Œç»•è¿‡åå°éªŒè¯ï¼Œå†’å……ç”¨æˆ·å¯¹è¢«æ”»å‡»ç½‘ç«™æ‰§è¡ŒæŸé¡¹æ“ä½œ   å¯¹å¯å‘å¼æœç´¢çš„ç†è§£ï¼Œå¯¹å¯å‘å‡½æ•°çš„ç ”ç©¶å’Œä¼˜åŒ– codingï¼šå®ç° Trie codingï¼šå®ç° AC è‡ªåŠ¨æœº  äºŒé¢  é¡¹ç›®ç»å†ï¼Œè®²ç»†èŠ‚ å¯¹ tf çš„äº†è§£ codingï¼šå®ç°å¯¹è±¡æ±  codingï¼šå®ç°å†…å­˜æ±   ä¸‰é¢  å¦‚ä½•å°†ä¸€ä¸ªé•¿URLè½¬æ¢ä¸ºä¸€ä¸ªçŸ­URL  ç”¨å‘å·æœŸä¸ºæ¯ä¸ªé•¿åœ°å€åˆ†é…ä¸€ä¸ªçŸ­å·ç  0-9, a-z, A-Z ä¸€å…± 62 ä¸ªå­—ç¬¦æ„æˆ 62 è¿›åˆ¶ï¼ŒèŠ‚çœé•¿åº¦ åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ä¸åŒå‘å·æœŸä½¿ç”¨ä¸åŒå·ç æ®µï¼ˆA å‘å·å™¨ç”¨ 0-999ï¼ŒB å‘å·å™¨ç”¨ 1000-1999ï¼‰   codingï¼šè®¾è®¡æ¨¡å¼ decorator pattern å®ç° codingï¼šä¸€æ®µå¯ç¼–è¯‘é€šè¿‡çš„ cpp ä»£ç ç¼–ç ä¿å­˜åï¼Œåšå­—ç¬¦ä¸²å¤„ç†ï¼Œå»æ‰å…¶ä¸­çš„æ‰€æœ‰æ³¨é‡Š  // åæ³¨é‡Šçš„å†…å®¹ï¼Œ/* */ ä¸­çš„å†…å®¹ï¼Œéƒ½è¦å»æ‰ \\ æ¢è¡Œè¦ä¿ç•™    å››é¢  è·³æ§½åŠ¨æœº æœªæ¥é•¿çŸ­æœŸèŒä¸šè§„åˆ’ æ²¡äº†  å¾®è½¯ ä¸€é¢   è®²è®²é¡¹ç›®\n  codingï¼šå®ç°ä¸€ä¸ªç±» TextProcessorï¼ŒåŒ…å«ä»¥ä¸‹å‡½æ•°\n void set_variable(string k, string v): å°† k æ˜ å°„ä¸º v void get_text(string s): å°†å­—ç¬¦ä¸² s ä¸­ç”¨ { å’Œ } ä¸­é—´çš„å†…å®¹è¿›è¡Œæ ¼å¼åŒ–æ›¿æ¢ ä¾‹å¦‚ï¼š  auto text_processor = new TextProcessor(); text_processor-\u0026gt;set_variable(\u0026#34;Name\u0026#34;, \u0026#34;abc\u0026#34;); text_processor-\u0026gt;set_variable(\u0026#34;Date\u0026#34;, \u0026#34;2021-11-23\u0026#34;); auto content = text_process-\u0026gt;get_text(\u0026#34;Dear {Name}, welcome! {Date}\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, content); // \u0026#34;Dear abc, welcome! 2021-11-23\u0026#34;  å¾ˆç®€å•çš„å­—ç¬¦ä¸²å¤„ç†ï¼Œéœ€è¦æ³¨æ„åŒ…å«å¤šä¸ªè½¬ä¹‰å­—ç¬¦ \\ çš„æƒ…å†µ    äºŒé¢  è®²è®²é¡¹ç›® Prometheus åŸç†ï¼Œå’Œ MySQLï¼ŒElasticSearch çš„åŒºåˆ« å¯¹ kubernetes çš„ç†è§£ codingï¼š24 ç‚¹æ¸¸æˆï¼Œå‚è€ƒ leetcode 679 é¢˜  ä¸‰é¢  cpp å’Œ java çš„åŒºåˆ« cpp ä¸­åŠ¨æ€ç»‘å®šçš„æœºåˆ¶ï¼Œå®ç°åŸç† æ„é€ å‡½æ•°èƒ½å¦è°ƒç”¨è™šå‡½æ•°ï¼Œä¸ºä»€ä¹ˆ codingï¼šä¸€æ®µå¯ç¼–è¯‘é€šè¿‡çš„ cpp ä»£ç ç¼–ç ä¿å­˜åï¼Œåšå­—ç¬¦ä¸²å¤„ç†ï¼Œå»æ‰å…¶ä¸­çš„æ‰€æœ‰æ³¨é‡Šï¼ˆåŒ…æ‹¬ // å’Œ /* */ï¼‰ï¼›å’Œ Hotstar ä¸‰é¢çš„ coding ä¸€æ¨¡ä¸€æ ·  å››é¢  é—²èŠ è·³æ§½åŠ¨æœºï¼Œæœªæ¥è§„åˆ’ system designï¼šåœ°å›¾å¯¼èˆª app çš„åç«¯è®¾è®¡  ä»ç«‹é¡¹åˆ°ä¸Šçº¿ï¼Œè¿‡ç¨‹ä¸­å„ä¸ªé˜¶æ®µéœ€è¦è€ƒè™‘å“ªäº›æ–¹é¢ è®¾è®¡å„ä¸ªæŠ€æœ¯æ–¹æ¡ˆæ—¶éœ€è¦è€ƒè™‘å“ªäº›ç»†èŠ‚    äº”é¢ é¢è¯•å®˜æ˜¯å°åº¦äººï¼Œè¿˜å¥½å£éŸ³ä¸æ˜¯å¾ˆé‡\n è‡ªæˆ‘ä»‹ç»ï¼Œæ•™è‚²èƒŒæ™¯ talk about the project you\u0026rsquo;ve done with the most sense of achievement, why coding: è®¡ç®—ä¸€ä¸ªå›¾é‡Œé¢çš„çŸ©å½¢ä¸ªæ•°ï¼ˆæ²¡æ‰¾åˆ°åŸé¢˜ï¼‰  Amazon ç¬”è¯•   æœ‰ä¸¤ç»„å‰§ï¼Œæ¯ç»„ç»™å‡ºå¼€å§‹æ—¶é—´å’ŒæŒç»­æ—¶é—´ï¼Œæ±‚æ¯ç»„å„çœ‹ä¸€éƒ¨å‰§çš„æœ€å¿«çœ‹å®Œçš„æ—¶é—´ç‚¹ï¼›ä¸¾ä¸ªä¾‹ï¼ŒA ç»„æœ‰ 3 éƒ¨ï¼Œå¼€å§‹æ—¶é—´æ˜¯ [1, 2, 3]ï¼ŒæŒç»­æ—¶é—´æ˜¯ [1, 1, 1]ï¼›B ç»„æœ‰ 3 éƒ¨ï¼Œå¼€å§‹æ—¶é—´æ˜¯ [1, 2, 3]ï¼ŒæŒç»­æ—¶é—´æ˜¯ [10, 5, 1]ï¼Œé‚£ä¹ˆæœ€å¿«çœ‹å®Œçš„æ—¶é—´ç‚¹æ˜¯ 4ï¼Œå…¶ä¸­ A ç»„çœ‹ç¬¬ä¸€éƒ¨ï¼Œåœ¨ 1+1=2 æ—¶é—´ç‚¹ç»“æŸï¼Œç­‰åˆ° 3 ç‚¹çš„æ—¶å€™çœ‹ B ç»„çš„ç¬¬ä¸‰éƒ¨ï¼Œ3+1=4\n ç”¨è´ªå¿ƒï¼Œå…ˆæ‰¾åˆ°ç¬¬ä¸€ç»„æœ€å¿«çœ‹å®Œçš„æ—¶é—´ç‚¹ï¼Œå†ä»è¿™ä¸ªæ—¶é—´ç‚¹å¾€åæ‰¾ç¬¬äºŒç»„æœ€å¿«çœ‹å®Œçš„æ—¶é—´ç‚¹ã€‚é™¤æ­¤ä¹‹å¤–è¿˜è¦åœ¨å…ˆ B å A å†æ‰¾ä¸€é    æœ‰ä¸€ç»„æœåŠ¡å™¨ï¼Œé•¿åº¦ä¸º nï¼Œå„ä¸ªæœåŠ¡å™¨çš„å¼€æœºè€—ç”µä¸º A[n]ï¼ŒæŒç»­è€—ç”µä¸º B[n]ï¼›åªæœ‰è¿ç»­çš„æœåŠ¡å™¨æ‰èƒ½ç»„æˆé›†ç¾¤ï¼Œé›†ç¾¤çš„æ€»å¼€æœºè€—ç”µä¸º max(A[i\u0026hellip;j])ï¼Œæ€»æŒç»­è€—ç”µä¸º sum(A[i\u0026hellip;j]) * (j-i+1)ï¼›ç»™å‡ºä¸€ä¸ª pï¼Œæ±‚èƒ½å¤Ÿç»„æˆé›†ç¾¤ä¸”æ€»å¼€æœºè€—ç”µåŠ æ€»æŒç»­è€—ç”µå°äºç­‰äº p çš„æœ€å¤§æœåŠ¡å™¨ä¸ªæ•°ã€‚e.g. A[n] = {3,6,1,3,4}, B[n] = {2,1,3,4,5}, p = 25ï¼Œé‚£ç”±ç¬¬å››ä¸ªå’Œç¬¬äº”ä¸ªç»„æˆçš„é›†ç¾¤æ€»è€—ç”µæ˜¯ 4 + (4+5)*2 = 22ï¼Œ22 å°äº 25ï¼Œæ‰€ä»¥æ˜¯ä¸€ä¸ªå¯è¡Œçš„è§£ï¼Œè¿”å›è¿™ä¸ªé›†ç¾¤çš„æœåŠ¡å™¨æ•°é‡ 2 å°±å¯ä»¥äº†ï¼ˆä¸éœ€è¦ç»™å‡ºè¯¦ç»†çš„æ–¹æ¡ˆï¼‰\n æœåŠ¡å™¨éœ€è¦è¿ç»­ï¼Œå› æ­¤ç”¨æ»‘åŠ¨çª—å£ç¡®å®šèŒƒå›´ï¼›å¼€æœºè€—ç”µç”¨å•è°ƒé˜Ÿåˆ—è®¡ç®—    ä¸€é¢  codingï¼šleetcode 252 meeting-roomsï¼Œ1 éå†ï¼Œ2 å·®åˆ†æ•°ç»„ codingï¼šleetcode 103 zigzag treeï¼Œ1 ä¸¤ä¸ªæ ˆå±‚åºéå†ï¼Œ2 é€’å½’å‰åºéå†ï¼Œå†åè½¬å¶æ•°å±‚æ•°ç»„  äºŒé¢  system design: è´­ç‰©ç½‘ç«™  ä¸‰é¢  system design: è®¾è®¡æµè§ˆè®°å½•åŠŸèƒ½ï¼Œè€ƒè™‘é«˜å¹¶å‘  å››é¢  codingï¼šleetcode 101 å¯¹ç§°äºŒå‰æ ‘ followupï¼šå¯¹ç§°å¤šå‰æ ‘  ","permalink":"http://zintrulcre.github.io/posts/interview/interview/","summary":"2022 å¹´åˆ | åç«¯å¼€å‘ä¸¤å¹´ç»éªŒç¤¾æ‹›é¢ç» å­—èŠ‚ ä¸€é¢   coding: å¯¹äºä¸€ä¸ªæ•°ç»„ï¼Œä»…ç”¨ä¸€æ¬¡éå†ï¼Œç­‰æ¦‚ç‡åœ°éšæœºå‡ºä¸€ä¸ªå…ƒç´ ï¼ˆå¯¹äºæ¯ä¸€ä¸ªå…ƒç´ ï¼Œä»å…¨å±€çœ‹ï¼Œä»–ä»¬è¢«é€‰æ‹©çš„æ¦‚ç‡éƒ½åº”è¯¥æ˜¯ 1/nï¼‰\n å¯¹äºç¬¬ i ä¸ªå…ƒç´ ï¼Œå®ƒåœ¨ç¬¬ i è½®è¢«é€‰ä¸­çš„æ¦‚ç‡æ˜¯ 1/i å¾€åï¼Œåªè¦é€‰æ‹©äº†æ–°çš„å…ƒç´ ï¼Œå®ƒå°±ä¼šè¢«æ·˜æ±°ï¼›ä»¥ç¬¬ i+1 è½®ä¸ºä¾‹ï¼Œå®ƒè¢«æ·˜æ±°çš„æ¦‚ç‡æ˜¯ 1/(i+1)ï¼Œé‚£ä¹ˆåè¿‡æ¥å®ƒè¢«ç•™ä¸‹çš„æ¦‚ç‡å°±æ˜¯ 1 - 1/(i+1) æœ€ç»ˆæ¯ä¸€ä¸ªå…ƒç´ è¢«é€‰æ‹©çš„æ¦‚ç‡å¦‚ä¸‹ï¼Œç¬¬ä¸€ä¸ª 1/i ä»£è¡¨å®ƒåœ¨ç¬¬ i æ¬¡è¢«é€‰ä¸­ï¼Œå…¶ä»–æ•°ä»£è¡¨å®ƒåœ¨åç»­çš„æ¯ä¸€è½®è¢«ç•™ä¸‹     followupï¼šç­‰æ¦‚ç‡åœ°éšæœºå‡º k ä¸ªå…ƒç´ \n å¯¹äºç¬¬ i ä¸ªå…ƒç´ ï¼Œå®ƒåœ¨ç¬¬ i è½®è¢«é€‰ä¸­çš„æ¦‚ç‡æ˜¯ k/i å¾€åï¼Œå®ƒå”¯ä¸€ä¼šè¢«æ·˜æ±°çš„åœºæ™¯æ˜¯ï¼šé€‰æ‹©äº†æ–°çš„å…ƒç´ ï¼ŒåŒæ—¶ä»å·²æœ‰çš„é€‰æ‹©ä¸­ï¼Œç­‰æ¦‚ç‡åœ°é€‰æ‹©åˆ°äº†å®ƒï¼›ä»¥ç¬¬ i+1 è½®ä¸ºä¾‹ï¼Œå®ƒè¢«æ·˜æ±°çš„æ¦‚ç‡æ˜¯ k/(i+1) * 1/k = 1/(i+1)ï¼Œé‚£ä¹ˆåè¿‡æ¥å®ƒè¢«ç•™ä¸‹çš„æ¦‚ç‡å°±æ˜¯ 1 - k/(i+1) * 1/k = 1 - 1/(i+1) æœ€ç»ˆæ¯ä¸€ä¸ªå…ƒç´ è¢«é€‰æ‹©çš„æ¦‚ç‡å¦‚ä¸‹ï¼Œç¬¬ä¸€ä¸ª k/i ä»£è¡¨å®ƒåœ¨ç¬¬ i æ¬¡è¢«é€‰ä¸­ï¼Œå…¶ä»–æ•°ä»£è¡¨å®ƒåœ¨åç»­çš„æ¯ä¸€è½®è¢«ç•™ä¸‹     coding: å®ç° Fisherâ€“Yates Suffle","title":"2022 å¹´åˆ | åç«¯å¼€å‘ä¸¤å¹´ç»éªŒç¤¾æ‹›é¢ç»"},{"content":"å°ç±³ AX1800 ä½¿ç”¨ ShellClash ç§‘å­¦ä¸Šç½‘ æœ¬æ–‡ä»‹ç»å¦‚ä½•åœ¨å°ç±³ AX1800 ä¸Šä½¿ç”¨ ShellClash ç§‘å­¦ä¸Šç½‘ã€‚\n1 å›ºä»¶é™çº§ å°ç±³ AX1800 1.0.336 ç‰ˆæœ¬å›ºä»¶\nåœ¨ MiWiFi åå°çš„å¸¸ç”¨è®¾ç½® -\u0026gt; ç³»ç»ŸçŠ¶æ€ä¸­ç‚¹å‡»æ‰‹åŠ¨å‡çº§ï¼Œä½¿ç”¨ 1.0.336 ç‰ˆæœ¬çš„å›ºä»¶å¯¹è·¯ç”±å™¨è¿›è¡Œé™çº§ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸éœ€è¦ä»»ä½•é¢å¤–çš„æ“ä½œã€‚\nå®Œæˆåç¬¬ä¸€æ¬¡è¿›å…¥åå°é…ç½®æ—¶é€‰æ‹©ä¸è‡ªåŠ¨æ›´æ–°ï¼Œæˆ–åœ¨å°ç±³ Wi-Fi æ‰‹æœº App ä¸­å…³é—­è‡ªåŠ¨æ›´æ–°åŠŸèƒ½ã€‚\næ›´æ–°å®Œæˆåè·¯ç”±å™¨ä¼šé‡ç½®ä¸ºè·¯ç”±å™¨åº•éƒ¨è´´æ¡çš„è®¾ç½®ã€‚\n2 è§£é” SSH é¦–å…ˆç™»é™†å°ç±³è·¯ç”±å™¨åå° 192.168.31.1ï¼Œå°†æµè§ˆå™¨åœ°å€æ ä¸­ stok= åé¢çš„ä¸€éƒ¨åˆ†çš„å³ä¸ºæ‹·è´ä¸‹æ¥ã€‚\nè·å– SSH æƒé™ åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ä¸€ä¸ªæ–°é¡µç­¾ï¼Œåœ¨åœ°å€æ ä¸­è¾“å…¥ä¸‹é¢çš„é“¾æ¥ï¼Œå°†å…¶ä¸­ stok=...... ä¸­ååŠéƒ¨åˆ†çš„å…­ä¸ªç‚¹æ¢æˆåˆšæ‰æ‹·è´çš„å†…å®¹ï¼Œé¡µé¢ä¸Šæ˜¾ç¤º {\u0026quot;code\u0026quot;:0} å³ä»£è¡¨æˆåŠŸï¼Œè¿™æ ·å°±è§£é”äº† SSH åˆ°è·¯ç”±å™¨ä¸Šçš„æƒé™ã€‚\nhttp://192.168.31.1/cgi-bin/luci/;stok=....../api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B\rä¿®æ”¹ root å¯†ç  åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ä¸€ä¸ªæ–°é¡µç­¾ï¼Œåœ¨åœ°å€æ ä¸­è¾“å…¥ä¸‹é¢çš„é“¾æ¥ï¼Œå°†å…¶ä¸­ stok=...... ä¸­ååŠéƒ¨åˆ†çš„å…­ä¸ªç‚¹æ¢æˆåˆšæ‰æ‹·è´çš„å†…å®¹ï¼Œé¡µé¢ä¸Šæ˜¾ç¤º {\u0026quot;code\u0026quot;:0} å³ä»£è¡¨æˆåŠŸï¼Œè¿™æ ·å°±å°†è·¯ç”±å™¨ä¸Š root è´¦æˆ·çš„å¯†ç æ”¹ä¸ºäº† adminã€‚\nhttp://192.168.31.1/cgi-bin/luci/;stok=....../api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20echo%20-e%20'admin%5Cnadmin'%20%7C%20passwd%20root%3B\rè¿æ¥ SSH æ‰“å¼€ terminal æˆ–è€… powershellï¼Œssh åˆ°è·¯ç”±å™¨çš„ root è´¦æˆ·ä¸Šï¼Œå¯†ç æ˜¯ adminã€‚\nssh root@192.168.31.1\r3 ä½¿ç”¨ ShellClash å®‰è£… ssh åˆ°è·¯ç”±å™¨ä¸Šåï¼Œè¾“å…¥ä»¥ä¸‹å‘½ä»¤å®‰è£… ShellClashã€‚\nsh -c \u0026quot;$(curl -kfsSl https://cdn.jsdelivr.net/gh/juewuy/ShellClash@master/install.sh)\u0026quot; \u0026amp;\u0026amp; source /etc/profile \u0026amp;\u0026gt; /dev/null\ré€‰æ‹© 1 å®‰è£…åˆ° /etc ç›®å½•ä¸‹ã€‚\né…ç½® å®‰è£…å®Œæˆåï¼Œè¾“å…¥ clash å‘½ä»¤è¿›è¡Œç›¸å…³çš„é…ç½®ï¼Œç¯å¢ƒé€‰æ‹© 1 ä¸»è·¯ç”±æˆ–æ—è·¯ç”±ï¼Œä¿è¯å±€åŸŸç½‘æµé‡éƒ½èƒ½é€šè¿‡ ShellClash å®¢æˆ·ç«¯ã€‚\nUDP æµé‡å’Œ dashboard é¢æ¿æ ¹æ®éœ€æ±‚é€‰æ‹©ï¼Œéšåç­‰å¾… clash æ ¸å¿ƒå’Œ GeoIP æ•°æ®åº“ä¸‹è½½å®Œæˆã€‚\næ¥ä¸‹æ¥é€‰ 1 å¼€å§‹å¯¼å…¥é…ç½®æ–‡ä»¶ï¼Œ19å¦‚æœæœ‰ Clash è®¢é˜…é“¾æ¥çš„è¯å¯ä»¥é€‰ 2 ç”Ÿæˆ Clash é…ç½®æ–‡ä»¶ï¼Œå†ç²˜è´´è®¢é˜…çš„ urlï¼›å¦åˆ™é€‰ 1 ç›´æ¥å¯¼å…¥ã€‚\næœ€åé€‰ 1 å¯åŠ¨ Clash æœåŠ¡ã€‚\nå¯åŠ¨å®Œæˆåå†æ¬¡è¿è¡Œ clashï¼Œé€‰ 4 å…è®¸å¼€æœºå¯åŠ¨ï¼Œè¿™æ ·ä»¥åæ¯æ¬¡è·¯ç”±å™¨é‡å¯éƒ½ä¸å†éœ€è¦æ‰‹åŠ¨ SSH å¹¶é‡æ–°å¯åŠ¨ Clash äº†ã€‚åŒæ—¶è¿˜å¯ä»¥åœ¨å±€åŸŸç½‘å†…è®¿é—® http://192.168.31.1:9999/ui æ¥è¿›è¡ŒèŠ‚ç‚¹å’Œè§„åˆ™çš„ä¿®æ”¹ã€‚\n","permalink":"http://zintrulcre.github.io/posts/proxy/ax1800/","summary":"å°ç±³ AX1800 ä½¿ç”¨ ShellClash ç§‘å­¦ä¸Šç½‘ æœ¬æ–‡ä»‹ç»å¦‚ä½•åœ¨å°ç±³ AX1800 ä¸Šä½¿ç”¨ ShellClash ç§‘å­¦ä¸Šç½‘ã€‚\n1 å›ºä»¶é™çº§ å°ç±³ AX1800 1.0.336 ç‰ˆæœ¬å›ºä»¶\nåœ¨ MiWiFi åå°çš„å¸¸ç”¨è®¾ç½® -\u0026gt; ç³»ç»ŸçŠ¶æ€ä¸­ç‚¹å‡»æ‰‹åŠ¨å‡çº§ï¼Œä½¿ç”¨ 1.0.336 ç‰ˆæœ¬çš„å›ºä»¶å¯¹è·¯ç”±å™¨è¿›è¡Œé™çº§ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸éœ€è¦ä»»ä½•é¢å¤–çš„æ“ä½œã€‚\nå®Œæˆåç¬¬ä¸€æ¬¡è¿›å…¥åå°é…ç½®æ—¶é€‰æ‹©ä¸è‡ªåŠ¨æ›´æ–°ï¼Œæˆ–åœ¨å°ç±³ Wi-Fi æ‰‹æœº App ä¸­å…³é—­è‡ªåŠ¨æ›´æ–°åŠŸèƒ½ã€‚\næ›´æ–°å®Œæˆåè·¯ç”±å™¨ä¼šé‡ç½®ä¸ºè·¯ç”±å™¨åº•éƒ¨è´´æ¡çš„è®¾ç½®ã€‚\n2 è§£é” SSH é¦–å…ˆç™»é™†å°ç±³è·¯ç”±å™¨åå° 192.168.31.1ï¼Œå°†æµè§ˆå™¨åœ°å€æ ä¸­ stok= åé¢çš„ä¸€éƒ¨åˆ†çš„å³ä¸ºæ‹·è´ä¸‹æ¥ã€‚\nè·å– SSH æƒé™ åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ä¸€ä¸ªæ–°é¡µç­¾ï¼Œåœ¨åœ°å€æ ä¸­è¾“å…¥ä¸‹é¢çš„é“¾æ¥ï¼Œå°†å…¶ä¸­ stok=...... ä¸­ååŠéƒ¨åˆ†çš„å…­ä¸ªç‚¹æ¢æˆåˆšæ‰æ‹·è´çš„å†…å®¹ï¼Œé¡µé¢ä¸Šæ˜¾ç¤º {\u0026quot;code\u0026quot;:0} å³ä»£è¡¨æˆåŠŸï¼Œè¿™æ ·å°±è§£é”äº† SSH åˆ°è·¯ç”±å™¨ä¸Šçš„æƒé™ã€‚\nhttp://192.168.31.1/cgi-bin/luci/;stok=....../api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B\rä¿®æ”¹ root å¯†ç  åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ä¸€ä¸ªæ–°é¡µç­¾ï¼Œåœ¨åœ°å€æ ä¸­è¾“å…¥ä¸‹é¢çš„é“¾æ¥ï¼Œå°†å…¶ä¸­ stok=...... ä¸­ååŠéƒ¨åˆ†çš„å…­ä¸ªç‚¹æ¢æˆåˆšæ‰æ‹·è´çš„å†…å®¹ï¼Œé¡µé¢ä¸Šæ˜¾ç¤º {\u0026quot;code\u0026quot;:0} å³ä»£è¡¨æˆåŠŸï¼Œè¿™æ ·å°±å°†è·¯ç”±å™¨ä¸Š root è´¦æˆ·çš„å¯†ç æ”¹ä¸ºäº† adminã€‚\nhttp://192.168.31.1/cgi-bin/luci/;stok=....../api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20echo%20-e%20'admin%5Cnadmin'%20%7C%20passwd%20root%3B\rè¿æ¥ SSH æ‰“å¼€ terminal æˆ–è€… powershellï¼Œssh åˆ°è·¯ç”±å™¨çš„ root è´¦æˆ·ä¸Šï¼Œå¯†ç æ˜¯ adminã€‚\nssh root@192.","title":"å°ç±³ AX1800 ä½¿ç”¨ ShellClash ç§‘å­¦ä¸Šç½‘"},{"content":"Hi, I\u0026rsquo;m Zhengyu ğŸ‘‹   ğŸ‘¤ Software Engineer at Timi Studios Tencent.\n  ğŸ“· Interested in fitness, photography, reading.\n  ğŸ“„ Checkout my resume: English / ç®€ä½“ä¸­æ–‡\n  âœ‰ï¸ Contact me at zintrulcre@gmail.com\n  ","permalink":"http://zintrulcre.github.io/about/","summary":"Hi, I\u0026rsquo;m Zhengyu ğŸ‘‹   ğŸ‘¤ Software Engineer at Timi Studios Tencent.\n  ğŸ“· Interested in fitness, photography, reading.\n  ğŸ“„ Checkout my resume: English / ç®€ä½“ä¸­æ–‡\n  âœ‰ï¸ Contact me at zintrulcre@gmail.com\n  ","title":"About"},{"content":"Kafka å…¥é—¨ æ¦‚è¿° Kafka æœ€åˆæ˜¯ä¸ºäº†è§£å†³ LinkedIn æ•°æ®ç®¡é“é—®é¢˜åº”è¿è€Œç”Ÿçš„ã€‚å®ƒçš„è®¾è®¡ç›®çš„æ˜¯æä¾›ä¸€ä¸ªé«˜æ€§èƒ½çš„æ¶ˆæ¯ç³»ç»Ÿï¼Œå¯ä»¥å¤„ç†å¤šç§æ•°æ®ç±»å‹ï¼Œå¹¶èƒ½å¤Ÿå®æ—¶æä¾›çº¯å‡€ä¸”ç»“æ„åŒ–çš„ç”¨æˆ·æ´»åŠ¨æ•°æ®å’Œç³»ç»Ÿåº¦é‡æŒ‡æ ‡ã€‚\nå®ƒä¸åªæ˜¯ä¸€ä¸ªæ•°æ®å­˜å‚¨ç³»ç»Ÿï¼ˆç±»ä¼¼äºä¼ ç»Ÿçš„å…³ç³»å‹æ•°æ®åº“ã€é”®å€¼å­˜å‚¨å¼•æ“ã€æœç´¢å¼•æ“æˆ–ç¼“å­˜ç³»ç»Ÿï¼‰ï¼Œè¿˜æ˜¯ä¸€ä¸ªæŒç»­å˜åŒ–å’Œä¸æ–­å¢é•¿çš„æµå¤„ç†ç³»ç»Ÿã€‚ç°åœ¨ Kafka å·²ç»è¢«å¹¿æ³›åœ°åº”ç”¨åœ¨ç¤¾äº¤ç½‘ç»œçš„å®æ—¶æ•°æ®æµå¤„ç†å½“ä¸­ï¼Œæˆä¸ºäº†ä¸‹ä¸€ä»£æ•°æ®æ¶æ„çš„åŸºç¡€ã€‚Kafka ç»å¸¸ä¼šè¢«æ‹¿æ¥ä¸ç°æœ‰çš„ä¼ä¸šçº§æ¶ˆæ¯ç³»ç»Ÿã€å¤§æ•°æ®ç³»ç»Ÿï¼ˆå¦‚ Hadoopï¼‰å’Œæ•°æ®é›†æˆ ETL å·¥å…·ç­‰æŠ€æœ¯ä½œæ¯”è¾ƒã€‚\nä»å‘å¸ƒå’Œè®¢é˜…æ¶ˆæ¯æµçš„è§’åº¦æ¥çœ‹ï¼ŒKafka ç±»ä¼¼äº ActiveMQã€RabbitMQ æˆ– IBM çš„ MQSeries ç­‰äº§å“ï¼Œå…¶ç‰¹ç‚¹åœ¨äºå®ƒä»¥é›†ç¾¤çš„æ–¹å¼è¿è¡Œï¼Œå¯ä»¥è‡ªç”±ä¼¸ç¼©ï¼Œå¤„ç†å¤§é‡çš„åº”ç”¨ç¨‹åºï¼›å…¶æ¬¡ï¼ŒKafka å¯ä»¥æŒ‰ç…§è¦æ±‚æŒä¹…åŒ–æ•°æ®ï¼Œå³æä¾›äº†æ•°æ®ä¼ é€’çš„ä¿è¯â€”â€”å¯å¤åˆ¶ã€æŒä¹…åŒ–ï¼Œä¿ç•™å¤šé•¿æ—¶é—´å®Œå…¨å¯ä»¥ç”±å¼€å‘è€…å†³å®šã€‚æ­¤å¤–ï¼Œæ¶ˆæ¯ç³»ç»Ÿåªä¼šä¼ é€’æ¶ˆæ¯ï¼Œè€Œ Kafka çš„æµå¼å¤„ç†èƒ½åŠ›è®©æˆ‘ä»¬åªç”¨å¾ˆå°‘çš„ä»£ç å°±èƒ½å¤ŸåŠ¨æ€åœ°å¤„ç†æ´¾ç”Ÿæµå’Œæ•°æ®é›†ã€‚\n1 åŸºç¡€æ¦‚å¿µ æ¶ˆæ¯ä»£ç† åœ¨ä¸€ä¸ªåŸºäºå‘å¸ƒä¸è®¢é˜…çš„æ¶ˆæ¯ç³»ç»Ÿä¸­ï¼Œæ•°æ®æ¶ˆæ¯çš„å‘é€è€…ä¸ç›´æ¥æŠŠæ¶ˆæ¯å‘é€ç»™æ¥æ”¶è€…ï¼Œè€Œæ˜¯é€šè¿‡ä¸€ä¸ªæ¶ˆæ¯ä»£ç† message broker ä¼ é€’æ¶ˆæ¯ï¼Œæ¥æ”¶è€…è®¢é˜…æ¶ˆæ¯ä»£ç†ï¼Œå¹¶ä»¥ç‰¹å®šçš„æ–¹å¼æ¥æ”¶æ¶ˆæ¯ã€‚Kafka å°±æ˜¯ä¸€ä¸ªæ¶ˆæ¯ä»£ç†ã€‚\næ¶ˆæ¯ä»£ç† message broker æ˜¯ä¸€ç§é’ˆå¯¹å¤„ç†æ¶ˆæ¯æµè€Œä¼˜åŒ–çš„æ•°æ®åº“ï¼Œå®ƒä½œä¸ºç‹¬ç«‹çš„ä¸­é—´æœåŠ¡è¿è¡Œï¼Œç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä½œä¸ºå®¢æˆ·ç«¯è¿æ¥åˆ°æ¶ˆæ¯ä»£ç†æœåŠ¡ï¼Œåœ¨ä½¿ç”¨æ¶ˆæ¯ä»£ç†çš„æ¶æ„ä¸­ä¸»è¦æœ‰ 3 ç§è§’è‰²ï¼š\n ç”Ÿäº§è€…å°†æ¶ˆæ¯å†™å…¥æ¶ˆæ¯ä»£ç†ï¼›ç”Ÿäº§è€…ä¸€èˆ¬æ˜¯å¼‚æ­¥æ¶æ„çš„ï¼Œå½“ç”Ÿäº§è€…å‘é€æ¶ˆæ¯æ—¶ï¼Œå®ƒåªä¼šç­‰å¾…æ¶ˆæ¯ä»£ç†ç¡®è®¤æ¶ˆæ¯å·²ç»è¢«ç¼“å­˜ï¼Œè€Œä¸ç­‰å¾…æ¶ˆæ¯è¢«æ¶ˆè´¹è€…å¤„ç† æ¶ˆæ¯ä»£ç†è´Ÿè´£æ¶ˆæ¯çš„å­˜å‚¨ï¼Œå‘é€ã€é‡ä¼ ç­‰ï¼Œä¸€èˆ¬ä¼šåŒ…å«å¤šä¸ªæ¶ˆæ¯é˜Ÿåˆ— message queue æ¶ˆè´¹è€…ä»æ¶ˆæ¯ä»£ç†æ¥æ”¶æ¶ˆæ¯å¹¶è¿›è¡Œå¤„ç†ï¼›æ¶ˆè´¹è€…åªä¾èµ–äºæ¶ˆæ¯ä»£ç†ï¼Œä¸ç”Ÿäº§è€…å®Œå…¨éš”ç¦»  æ¶ˆæ¯ä»£ç†çš„ä¼˜åŠ¿ä¸»è¦æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼š\n  å®ç°å¼‚æ­¥å¤„ç†ï¼Œæå‡æ€§èƒ½\næŠŠæ¶ˆæ¯å¤„ç†æµç¨‹ä½¿ç”¨æ¶ˆæ¯ä»£ç†å¼‚æ­¥åŒ–ï¼Œä¸ä¼šé˜»å¡ç”Ÿäº§è€…æœåŠ¡ï¼Œç”Ÿäº§è€…æœåŠ¡å¯ä»¥åœ¨å¾—åˆ°å¤„ç†ç»“æœä¹‹å‰ç»§ç»­æ‰§è¡Œï¼Œå¹¶æé«˜å…¶å¹¶å‘å¤„ç†çš„èƒ½åŠ›ã€‚\n  æé«˜ç³»ç»Ÿçš„å¯ä¼¸ç¼©æ€§\nç”Ÿäº§è€…å°†å¤§é‡æ¶ˆæ¯æ¨é€åˆ°æ¶ˆæ¯ä»£ç†ä¸­ï¼Œæ¶ˆæ¯ä»£ç†å¯ä»¥å°†è¿™äº›æ¶ˆæ¯åˆ†å‘ç»™ä¸åŒçš„æ¶ˆè´¹è€…ï¼Œä½¿å¾—å¤šä¸ªæ¶ˆè´¹è€…å¹¶è¡Œåœ°å¤„ç†æ¶ˆæ¯ï¼Œå½“æ¶ˆè´¹è€…è´Ÿè½½å˜åŒ–æ—¶ï¼Œå¯ä»¥å¾ˆå®¹æ˜“åœ°å¯¹æ¶ˆè´¹è€…æœåŠ¡è¿›è¡Œæ°´å¹³ä¼¸ç¼©\n  å‰Šå³°å¡«è°·\nå½“ç”Ÿäº§è€…æ¨é€æ¶ˆæ¯çš„é€Ÿåº¦æ¯”æ¶ˆè´¹è€…å¤„ç†æ¶ˆæ¯çš„é€Ÿåº¦æ›´å¿«æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—ä½œä¸ºæ¶ˆæ¯çš„ç¼“å†²ï¼Œæ¥å‰Šå¼±å³°å€¼æµé‡ï¼Œé˜²æ­¢ç³»ç»Ÿè¢«çŸ­æ—¶é—´å†…çš„æµé‡å†²å®\n  åº”ç”¨è§£è€¦\nä½¿ç”¨æ¶ˆæ¯ä»£ç†åï¼Œç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å³å¯è§£è€¦ï¼Œä¸å†éœ€è¦æœ‰ä»»ä½•è”ç³»ï¼Œä¹Ÿä¸éœ€è¦å—å¯¹æ–¹çš„å½±å“ï¼Œåªè¦ä¿æŒä½¿ç”¨ä¸€è‡´çš„æ¶ˆæ¯æ ¼å¼å³å¯ã€‚\n  æ¶ˆæ¯å’Œæ‰¹æ¬¡ Kafka çš„æ•°æ®å•å…ƒè¢«ç§°ä¸ºæ¶ˆæ¯ï¼Œæ¶ˆæ¯ç±»ä¼¼äºå…³ç³»å‹æ•°æ®åº“é‡Œçš„ä¸€ä¸ªæ•°æ®è¡Œæˆ–ä¸€æ¡è®°å½•ï¼›æ¶ˆæ¯ç”±å­—èŠ‚æ•°ç»„ç»„æˆï¼Œå½“æ¶ˆæ¯ä»¥ä¸€ç§å¯æ§çš„æ–¹å¼å†™å…¥ä¸åŒçš„åˆ†åŒºæ—¶ï¼Œä¼šç”¨åˆ° keyï¼ŒKafka ä¼šä¸º key ç”Ÿæˆä¸€ä¸ªä¸€è‡´æ€§æ•£åˆ—å€¼ï¼Œç„¶åä½¿ç”¨æ•£åˆ—å€¼å¯¹ä¸»é¢˜åˆ†åŒºæ•°è¿›è¡Œå–æ¨¡ï¼Œä¸ºæ¶ˆæ¯é€‰å–åˆ†åŒºã€‚è¿™æ ·å¯ä»¥ä¿è¯å…·æœ‰ç›¸åŒ key çš„æ¶ˆæ¯æ€»æ˜¯è¢«å†™åˆ°ç›¸åŒçš„åˆ†åŒºä¸Šã€‚\nå¦‚æœæ¯ä¸€ä¸ªæ¶ˆæ¯éƒ½å•ç‹¬å‘é€ï¼Œä¼šå¯¼è‡´å¤§é‡çš„ç½‘ç»œå¼€é”€ã€‚ä¸ºäº†æé«˜æ•ˆç‡ï¼Œæ¶ˆæ¯ä¼šè¢«åˆ†æ‰¹æ¬¡å†™å…¥Kafkaï¼›æ‰¹æ¬¡ batch æ˜¯ä¸€ç»„æ¶ˆæ¯ï¼Œè¿™äº›æ¶ˆæ¯å±äºåŒä¸€ä¸ªä¸»é¢˜å’Œåˆ†åŒºï¼›æ‰¹æ¬¡æ•°æ®åœ¨ä¼ è¾“æ—¶ä¼šè¢«å‹ç¼©ï¼Œè¿™æ ·å¯ä»¥æå‡æ•°æ®çš„ä¼ è¾“å’Œå­˜å‚¨èƒ½åŠ›ï¼›å•ä¸ª batch çš„æ¶ˆæ¯æ•°é‡è¶Šå¤§ï¼Œå•ä½æ—¶é—´å†…å¤„ç†çš„æ¶ˆæ¯å°±è¶Šå¤šï¼Œä½†å•ä¸ª batch çš„ä¼ è¾“æ—¶é—´å°±è¶Šé•¿ï¼Œå› æ­¤éœ€è¦åœ¨æ—¶å»¶å’Œååé‡ä¹‹é—´ä½œå‡ºæƒè¡¡ã€‚\nä¸»é¢˜å’Œåˆ†åŒº Kafka çš„æ¶ˆæ¯é€šè¿‡ä¸»é¢˜ topic è¿›è¡Œåˆ†ç±»ï¼Œä¸»é¢˜å°±å¥½æ¯”å…³ç³»å‹æ•°æ®åº“çš„è¡¨ï¼Œæˆ–è€…æ–‡ä»¶ç³»ç»Ÿé‡Œçš„ç›®å½•ï¼›åŒä¸€ä¸ªä¸»é¢˜å¯ä»¥è¢«åˆ†ä¸ºè‹¥å¹²ä¸ªåˆ†åŒº partitionï¼Œä¸€ä¸ª partition å³ä¸€ä¸ªæäº¤æ—¥å¿—ï¼Œæ¶ˆæ¯ä»¥è¿½åŠ çš„æ–¹å¼å†™å…¥ partitionï¼Œç„¶åä»¥å…ˆå…¥å…ˆå‡ºçš„é¡ºåºè¯»å–ã€‚ä¸€ä¸ª topic ä¸€èˆ¬åŒ…å«å¤šä¸ª partitionï¼Œå› æ­¤æ— æ³•åœ¨æ•´ä¸ª topic çš„ç»´åº¦ä¿è¯æ¶ˆæ¯çš„é¡ºåºï¼Œåªèƒ½ä¿è¯æ¶ˆæ¯åœ¨å•ä¸ª partition å†…çš„é¡ºåºã€‚\næˆ‘ä»¬é€šå¸¸ç”¨æµ stream æ¥æè¿° Kafka ä¸­çš„æ•°æ®ï¼Œåœ¨ä¸€ä¸ª topic ä¸­ï¼Œæ— è®ºå®ƒæœ‰å¤šå°‘ä¸ªpartitionï¼Œå…¶ä¸­çš„æ•°æ®éƒ½è¢«è§†ä¸ºä¸€ä¸ª streamã€‚\nç”Ÿäº§è€…å’Œæ¶ˆè´¹è€… Kafka çš„å®¢æˆ·ç«¯æœ‰ä¸¤ç§åŸºæœ¬ç±»å‹ï¼šç”Ÿäº§è€… producerå’Œæ¶ˆè´¹è€… consumerã€‚\né»˜è®¤æƒ…å†µä¸‹ï¼Œç”Ÿäº§è€…ç”Ÿäº§çš„æ¶ˆæ¯ä¼šè¢«å‘å¸ƒåˆ°ä¸€ä¸ªç‰¹å®šçš„ topic ä¸Šã€‚æ¶ˆæ¯ä¼šè¢«å‡è¡¡åœ°åˆ†å¸ƒåˆ°è¿™ä¸ª topic çš„æ‰€æœ‰ partition ä¸Šï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥æŒ‡å®šç”Ÿäº§è€…çš„æ¶ˆæ¯ç›´æ¥å†™åˆ°æŒ‡å®šçš„ partition ä¸Šã€‚\næ¶ˆè´¹è€…ä¼šè®¢é˜…ä¸€ä¸ªæˆ–å¤šä¸ª topicï¼Œå¹¶æŒ‰ç…§æ¶ˆæ¯ç”Ÿæˆçš„é¡ºåºä¾æ¬¡è¯»å–å®ƒä»¬ã€‚æ¶ˆè´¹è€…é€šè¿‡æ£€æŸ¥æ¶ˆæ¯çš„åç§»é‡ offsetæ¥åŒº åˆ†å·²ç»è¯»å–è¿‡çš„æ¶ˆæ¯ï¼Œoffset æ˜¯ä¸€ç§å…ƒæ•°æ®ï¼Œå®ƒä¼šä¸æ–­é€’å¢ï¼›åœ¨ç»™å®šçš„ partition ä¸­ï¼Œæ¯ä¸ªæ¶ˆæ¯çš„ offset éƒ½æ˜¯å”¯ä¸€çš„ï¼Œoffset å€¼ä¼šè¢«ä¿å­˜åœ¨ Zookeeper æˆ– Kafka ä¸Šï¼Œè¿™æ ·å³ä½¿æ¶ˆè´¹è€…åœæ­¢æˆ–é‡å¯åå®ƒçš„è¯»å–çŠ¶æ€ä¾ç„¶ä¸ä¼šä¸¢å¤±ã€‚\nåœ¨ Kafka ä¸­ï¼Œå¤šä¸ªæ¶ˆè´¹è€…å¯ä»¥ç»„æˆä¸€ä¸ªæ¶ˆè´¹è€…ç¾¤ç»„ consumer groupï¼Œå®ƒä»¬å…±åŒè¯»å–åŒä¸€ä¸ª topicï¼Œgroup ä¼šä¿è¯æ¯ä¸ª partition åªèƒ½è¢«ä¸€ä¸ªæ¶ˆè´¹è€…ä½¿ç”¨ï¼Œå¹¶ä¸”è¿™ä¸ªç¾¤ç»„çš„æ¶ˆè´¹è€…å¯¹ç»™å®šçš„æ¶ˆæ¯åªå¤„ç†ä¸€æ¬¡ã€‚\nbroker å’Œé›†ç¾¤ ä¸€ä¸ªç‹¬ç«‹çš„ Kafka æœåŠ¡å™¨è¢«ç§°ä¸º brokerï¼›broker ä¼šç‹¬ç«‹æ¥æ”¶æ¥è‡ªç”Ÿäº§è€…çš„æ¶ˆæ¯ï¼Œä¸ºæ¶ˆæ¯è®¾ç½® offsetï¼Œå¹¶å°†æ¶ˆæ¯ä¿å­˜åˆ°ç£ç›˜ï¼Œå¹¶å¤„ç†æ¶ˆè´¹è€…è¯»å–åˆ†åŒºçš„è¯·æ±‚ï¼Œè¿”å›å·²ç»ä¿å­˜åˆ°ç£ç›˜ä¸Šçš„æ¶ˆæ¯ï¼›å•ä¸ªbroker æœ€å¤šå¯ä»¥å¤„ç†æ•°åƒä¸ª partition ä»¥åŠæ¯ç§’ç™¾ä¸‡çº§çš„æ¶ˆæ¯é‡ã€‚\nbroker æ˜¯ Kafka é›†ç¾¤ cluster çš„ç»„æˆéƒ¨åˆ†ï¼Œæ¯ä¸ªé›†ç¾¤éƒ½æœ‰ä¸€ä¸ª broker å……å½“é›†ç¾¤æ§åˆ¶å™¨ï¼Œè´Ÿè´£ç®¡ç†å·¥ä½œï¼ŒåŒ…æ‹¬å°† partition åˆ†é…ç»™ brokerï¼Œä»¥åŠç›‘æ§å…¶ä»– brokerã€‚åœ¨é›†ç¾¤ä¸­ï¼Œä¸€ä¸ª partition ä»å±äºä¸€ä¸ª brokerã€‚ä¸€ä¸ª partition å¯èƒ½è¢«åˆ†é…ç»™å¤šä¸ª brokerï¼Œè¿™ä¸ªæ—¶å€™ä¼šå‘ç”Ÿåˆ†åŒºå¤åˆ¶ replicationï¼Œè¿™ç§å¤åˆ¶æœºåˆ¶ä¸ºåˆ†åŒºæä¾›äº†æ¶ˆæ¯å†—ä½™ï¼Œå¦‚æœæœ‰ä¸€ä¸ª broker å¤±æ•ˆï¼Œå…¶ä»– broker å¯ä»¥æ¥ç®¡é¢†å¯¼æƒï¼›åŒæ—¶ï¼Œç›¸å…³çš„æ¶ˆè´¹è€…å’Œç”Ÿäº§è€…éƒ½è¦é‡æ–°è¿æ¥åˆ°æ–°çš„é¦–é¢†ã€‚\nKafka broker æ¶ˆæ¯ä¿ç•™çš„é»˜è®¤ç­–ç•¥æ˜¯ä¿ç•™ä¸€æ®µæ—¶é—´æˆ–ä¿ç•™æ¶ˆæ¯è¾¾åˆ°ä¸€å®šå¤§å°çš„å­—èŠ‚æ•°ï¼Œå½“æ¶ˆæ¯çš„è§„æ¨¡è¾¾åˆ°è¿™äº›ä¸Šé™æ—¶ï¼Œæ—§æ¶ˆæ¯å°±ä¼šè¿‡æœŸå¹¶è¢«åˆ é™¤ï¼Œæ¯ä¸ª topic å¯ä»¥é…ç½®è‡ªå·±çš„ä¿ç•™ç­–ç•¥ã€‚åŸºäºè¿™ä¸ªæœºåˆ¶ï¼ŒKafka å…è®¸æ¶ˆè´¹è€…éå®æ—¶åœ°ä»ç£ç›˜è¯»å–æ¶ˆæ¯ã€‚\nå¤šé›†ç¾¤ éšç€ Kafka éƒ¨ç½²æ•°é‡çš„å¢åŠ ï¼ŒåŸºäºæ•°æ®ç±»å‹åˆ†ç¦»ï¼Œå®‰å…¨éœ€æ±‚éš”ç¦»å’Œå¤šæ•°æ®ä¸­å¿ƒå®¹ç¾ç­‰åŸå› ï¼Œå»ºè®®ä½¿ç”¨å¤šé›†ç¾¤æ–¹æ¡ˆï¼Œä½† Kafka çš„æ¶ˆæ¯å¤åˆ¶æœºåˆ¶åªèƒ½åœ¨å•ä¸ªé›†ç¾¤é‡Œè¿›è¡Œï¼Œä¸èƒ½åœ¨å¤šä¸ªé›†ç¾¤ä¹‹é—´è¿›è¡Œã€‚ä¸ºæ­¤ Kafka æä¾›äº†ä¸€ä¸ªå«ä½œ MirrorMaker çš„å·¥å…·ï¼Œ å¯ä»¥ç”¨å®ƒæ¥å®ç°é›†ç¾¤é—´çš„æ¶ˆæ¯å¤åˆ¶ã€‚\nZookeeper ZooKeeper æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼åè°ƒæ¡†æ¶ï¼Œè´Ÿè´£ç®¡ç†å’Œåè°ƒ Kafka é›†ç¾¤çš„å…ƒæ•°æ®ï¼ŒåŒ…æ‹¬å½“å‰æ­£åœ¨è¿è¡Œçš„ Brokerï¼Œå­˜åœ¨äºé›†ç¾¤ä¸­çš„ topicï¼Œæ¯ä¸€ä¸ª topic ä¸­çš„ partitionï¼Œä»¥åŠ partition ä¸­çš„ leader å’Œ followerã€‚\nKafka ä½¿ç”¨ Zookeeper æ¥ç»´æŠ¤é›†ç¾¤æˆå‘˜çš„ä¿¡æ¯ï¼Œæ¯ä¸ª broker éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„æ ‡è¯†ç¬¦ idï¼Œæ ‡è¯†ç¬¦å¯ä»¥é€šè¿‡é…ç½®æ–‡ä»¶æŒ‡å®šï¼Œä¹Ÿå¯ä»¥è‡ªåŠ¨ç”Ÿæˆã€‚åœ¨ broker å¯åŠ¨çš„æ—¶å€™ï¼Œå®ƒä¼šå°†è‡ªå·±çš„ id æ³¨å†Œåˆ° Zookeeper ä¸Šï¼ŒKafka çš„å…¶ä»–ç»„ä»¶ç»„ä»¶é€šè¿‡è®¢é˜… Zookeeper æœåŠ¡å™¨çš„ /brokers/ids è·¯å¾„æ¥è·å– broker çš„ä¿¡æ¯å’Œå˜åŒ–ã€‚å½“ä¸€ä¸ª broker å› ä¸ºæ•…éšœä¸ Zookeeper æ–­å¼€è¿æ¥æ—¶ï¼ŒZookeeper ä¼šå°†è¿™ä¸ª broker åœ¨çš„ä¸´æ—¶èŠ‚ç‚¹ç§»é™¤ã€‚æ‰€æœ‰ç›‘å¬äº† broker åˆ—è¡¨çš„å…¶ä»–ç»„ä»¶ä¼šè¢«é€šçŸ¥è¯¥ broker å·²ç»ç¦»çº¿ã€‚è™½ç„¶ä¸´æ—¶èŠ‚ç‚¹å·²ç»æ¶ˆå¤±ï¼Œä¸è¿‡å®ƒçš„ id ä¼šç»§ç»­å­˜åœ¨äºå…¶ä»–æ•°æ®ç»“æ„ä¸­ï¼Œåœ¨å®Œå…¨å…³é—­è¿™ä¸ª broker ä¹‹åï¼Œå¦‚æœä½¿ç”¨ç›¸åŒçš„ id å¯åŠ¨å¦ä¸€ä¸ªå…¨æ–°çš„ brokerï¼Œå®ƒä¼šç«‹å³åŠ å…¥é›†ç¾¤ï¼Œå¹¶æ‹¥æœ‰ä¸è¿™ä¸ª broker ç›¸åŒçš„ topic å’Œ partitionã€‚\n2 ç”Ÿäº§è€… ä¸€ä¸ªåº”ç”¨ç¨‹åºåœ¨å¾ˆå¤šæƒ…å†µä¸‹éœ€è¦å¾€ Kafka å†™å…¥æ¶ˆæ¯ï¼šè®°å½•ç”¨æˆ·æ´»åŠ¨ï¼ˆç”¨äºç»Ÿè®¡å’Œåˆ†æï¼‰ã€è®°å½•åº¦é‡æŒ‡æ ‡ã€ä¿å­˜æ—¥å¿—æ¶ˆæ¯ã€ä¸å…¶ä»–åº”ç”¨ç¨‹åºè¿›è¡Œå¼‚æ­¥é€šä¿¡ã€ç¼“å­˜å³å°†å†™å…¥åˆ°æ•°æ®åº“çš„æ•°æ®ç­‰ç­‰ã€‚å¤šæ ·çš„ä½¿ç”¨åœºæ™¯æ„å‘³ç€å¤šæ ·çš„éœ€æ±‚ï¼Œæ¯ç§æ¶ˆæ¯çš„é‡è¦æ€§ï¼Œæ—¶å»¶å’Œååé‡å„ä¸ç›¸åŒã€‚ä¾‹å¦‚åœ¨ä¿¡ç”¨å¡äº‹åŠ¡å¤„ç†ç³»ç»Ÿé‡Œï¼Œæ¶ˆæ¯ä¸¢å¤±æˆ–é‡å¤æ˜¯ä¸è¢«å…è®¸çš„ï¼Œå¯ä»¥æ¥å—çš„å»¶è¿Ÿåœ¨ 500 ms å·¦å³ï¼ŒåŒæ—¶å¯¹ååé‡è¦æ±‚è¾ƒé«˜â€”â€”æˆ‘ä»¬å¸Œæœ›æ¯ç§’é’Ÿå¯ä»¥å¤„ç†ä¸€ç™¾ä¸‡ä¸ªæˆ–æ›´å¤šçš„æ¶ˆæ¯ã€‚ä¿å­˜ç½‘ç«™çš„ç‚¹å‡»ä¿¡æ¯åˆ™æ˜¯å¦ä¸€ç§åœºæ™¯ï¼Œè¿™æ—¶æˆ‘ä»¬å…è®¸ä¸¢å¤±å°‘é‡çš„æ¶ˆæ¯ä¸¢å¤±æˆ–é‡å¤ï¼Œå»¶è¿Ÿä¹Ÿå¯ä»¥é«˜ä¸€äº›ï¼Œåªè¦ä¸å½±å“ç”¨æˆ·ä½“éªŒå³å¯ã€‚\nä¸‹å›¾å±•ç¤ºäº†ä»ç”Ÿäº§è€…å‘ Kafka å‘é€æ¶ˆæ¯çš„ä¸»è¦æ­¥éª¤ã€‚\nç”Ÿäº§è€…å‘é€æ¶ˆæ¯çš„ç¬¬ä¸€æ­¥æ˜¯åˆ›å»ºä¸€ä¸ª ProducerRecord å¯¹è±¡ï¼›ProducerRecord å¿…é¡»åŒ…å« topic å’Œè¦å‘é€çš„ valueï¼ŒåŒæ—¶è¿˜å¯ä»¥æŒ‡å®š key æˆ– partitionã€‚åœ¨å‘é€ ProducerRecord å‰ï¼Œåºåˆ—åŒ–å™¨ serializer ä¼šæŠŠ key å’Œ value åºåˆ—åŒ–æˆå­—èŠ‚æ•°ç»„ã€‚\næ¥ä¸‹æ¥ï¼Œæ•°æ®è¢«ä¼ ç»™åˆ†åŒºå™¨ partitionerï¼Œå¦‚æœåœ¨ ProducerRecord å¯¹è±¡é‡ŒæŒ‡å®šäº†åˆ†åŒºï¼Œé‚£ä¹ˆä¼šç›´æ¥ä½¿ç”¨è¿™ä¸ªåˆ†åŒºï¼›å¦‚æœæ²¡æœ‰æŒ‡å®šåˆ†åŒºï¼Œé‚£ä¹ˆåˆ†åŒºå™¨ä¼šæ ¹æ® ProducerRecord å¯¹è±¡çš„ key æ¥é€‰æ‹©ä¸€ä¸ªåˆ†åŒºã€‚é€‰æ‹©å¥½åˆ†åŒºä»¥åï¼Œç”Ÿäº§è€…å°±çŸ¥é“è¯¥å¾€å“ªä¸ª topic å’Œ partition å‘é€è¿™æ¡æ¶ˆæ¯äº†ã€‚\nç´§æ¥ç€ï¼Œè¿™æ¡è®°å½•è¢«æ·»åŠ åˆ°ä¸€ä¸ª batch é‡Œï¼Œè¿™ä¸ª batch é‡Œçš„æ‰€æœ‰æ¶ˆæ¯ä¼šè¢«å‘é€åˆ°ç›¸åŒçš„ topic å’Œ partition ä¸Šã€‚ç”Ÿäº§è€…ä¼šä½¿ç”¨ä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹æŠŠæ•´ä¸ª batch å‘é€åˆ°å¯¹åº”çš„ broker ä¸Šã€‚\nKafka æœåŠ¡å™¨åœ¨æ”¶åˆ°è¿™ä¸ª batch åä¼šè¿”å›ä¸€ä¸ªå“åº”ã€‚å¦‚æœæ¶ˆæ¯æˆåŠŸå†™å…¥Kafkaï¼Œå°±è¿”å›ä¸€ä¸ª RecordMetaData å¯¹è±¡ï¼Œå®ƒåŒ…å«äº†æ¶ˆæ¯å‘é€åˆ°çš„ topic å’Œ partitionï¼Œä»¥åŠè®°å½•åœ¨åˆ†åŒºé‡Œçš„ offsetã€‚å¦‚æœå†™å…¥å¤±è´¥ï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ã€‚ç”Ÿäº§è€…åœ¨æ”¶åˆ°é”™è¯¯ä¹‹åä¼šå°è¯•é‡æ–°å‘é€æ¶ˆæ¯ï¼Œå‡ æ¬¡ä¹‹åå¦‚æœä»ç„¶å¤±è´¥ï¼Œå°±è¿”å›é”™è¯¯ä¿¡æ¯ã€‚\n2.1 åºåˆ—åŒ–å™¨ key å’Œ value çš„åºåˆ—åŒ–å™¨åœ¨ç”Ÿäº§è€… KafkaProducer çš„æ„é€ å‡½æ•°ä¸­ç”±ä¸åŒçš„ Serializer åˆå§‹åŒ–ï¼Œå¦‚æœä¼ å…¥çš„ Serializer ä¸ºç©ºï¼Œåˆ™ä½¿ç”¨é…ç½®ä¸­çš„åºåˆ—åŒ–å™¨åå­—ï¼Œåˆ©ç”¨åå°„æœºåˆ¶æ¥åˆ›å»ºå¯¹è±¡ï¼›åå°„ reflection æ˜¯æŒ‡åœ¨è¿è¡Œæ—¶ï¼Œç¨‹åºåœ¨å¯¹æŸä¸ªç±»å‹ä¸€æ— æ‰€çŸ¥çš„æƒ…å†µä¸‹ï¼Œç›´æ¥åˆ›å»ºè¯¥ç±»å‹å®ä¾‹å¹¶è°ƒç”¨å…¶æ–¹æ³•çš„æœºåˆ¶ï¼š\npublic class KafkaProducer\u0026lt;K, V\u0026gt; implements Producer\u0026lt;K, V\u0026gt; { KafkaProducer(ProducerConfig config, Serializer\u0026lt;K\u0026gt; keySerializer, Serializer\u0026lt;V\u0026gt; valueSerializer, ProducerMetadata metadata, KafkaClient kafkaClient, ProducerInterceptors\u0026lt;K, V\u0026gt; interceptors, Time time) { // ...  // key çš„ serializer  if (keySerializer == null) { // åˆ©ç”¨åå°„æ„é€ é…ç½®ç±»å‹çš„å¯¹è±¡  this.keySerializer = config.getConfiguredInstance(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, Serializer.class); this.keySerializer.configure(config.originals(Collections.singletonMap(ProducerConfig.CLIENT_ID_CONFIG, clientId)), true); } else { config.ignore(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG); this.keySerializer = keySerializer; } // value çš„ serializer  if (valueSerializer == null) { // åˆ©ç”¨åå°„æ„é€ é…ç½®ç±»å‹çš„å¯¹è±¡  this.valueSerializer = config.getConfiguredInstance(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, Serializer.class); this.valueSerializer.configure(config.originals(Collections.singletonMap(ProducerConfig.CLIENT_ID_CONFIG, clientId)), false); } else { config.ignore(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG); this.valueSerializer = valueSerializer; } // ...  } } ä»¥ StringSerializer ä¸ºä¾‹ï¼Œå®ƒå®ç°äº† Serializer æ¥å£ï¼Œå…¶ä¸­çš„ serialize å‡½æ•°ç”¨æ¥å®ç°å¯¹æ•°æ®çš„åºåˆ—åŒ–ï¼Œå®ƒå®é™…ä¸Šè°ƒç”¨äº† Java ä¸­çš„ String.getBytes å‡½æ•°è¿›è¡Œå­—ç¬¦ä¸²çš„åºåˆ—åŒ–ï¼š\npublic class StringSerializer implements Serializer\u0026lt;String\u0026gt; { private String encoding = StandardCharsets.UTF_8.name(); @Override public void configure(Map\u0026lt;String, ?\u0026gt; configs, boolean isKey) { String propertyName = isKey ? \u0026#34;key.serializer.encoding\u0026#34; : \u0026#34;value.serializer.encoding\u0026#34;; Object encodingValue = configs.get(propertyName); if (encodingValue == null) encodingValue = configs.get(\u0026#34;serializer.encoding\u0026#34;); if (encodingValue instanceof String) encoding = (String) encodingValue; } @Override public byte[] serialize(String topic, String data) { try { if (data == null) return null; else return data.getBytes(encoding); } catch (UnsupportedEncodingException e) { throw new SerializationException(\u0026#34;Error when serializing string to byte[] due to unsupported encoding \u0026#34; + encoding); } } } 2.2 åˆ†åŒºå™¨ ç”Ÿäº§è€… KafkaProducer å‘é€æ¶ˆæ¯å‰ï¼Œä¼šè°ƒç”¨ partition æ¥å£æ¥é€‰æ‹©æ¥æ”¶æ¶ˆæ¯çš„ partitionï¼Œå¦‚æœåœ¨ record ä¸­æŒ‡å®šäº† partitionï¼Œé‚£ä¹ˆä¼šç›´æ¥ä½¿ç”¨è¿™ä¸ª partitionï¼Œå¦åˆ™ä¼šè°ƒç”¨åˆ†åŒºå™¨ partitioner çš„ partition æ¥å£æ¥è·å–ã€‚\npublic class KafkaProducer\u0026lt;K, V\u0026gt; implements Producer\u0026lt;K, V\u0026gt; { private int partition(ProducerRecord\u0026lt;K, V\u0026gt; record, byte[] serializedKey, byte[] serializedValue, Cluster cluster) { Integer partition = record.partition(); return partition != null ? partition : partitioner.partition( record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster); } } KafkaProducer ä½¿ç”¨çš„é»˜è®¤åˆ†åŒºå™¨æ˜¯ DefaultPartitionerï¼Œå®ƒå®ç°äº† Partitioner æ¥å£ï¼Œå…¶ä¸­çš„ partition æ–¹æ³•ç”¨æ¥å®ç°åˆ†é… partition çš„é€»è¾‘ï¼š\npublic class DefaultPartitioner implements Partitioner { // ä¸ºæ¯ä¸ª topic ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å€¼  private final ConcurrentMap\u0026lt;String, AtomicInteger\u0026gt; topicCounterMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) { List\u0026lt;PartitionInfo\u0026gt; partitions = cluster.partitionsForTopic(topic); int numPartitions = partitions.size(); // key ä¸ºç©ºæ—¶  if (keyBytes == null) { // è·å–è‡ªå¢å€¼ nextValue  int nextValue = nextValue(topic); List\u0026lt;PartitionInfo\u0026gt; availablePartitions = cluster.availablePartitionsForTopic(topic); // å¯¹ nextValue å’Œ å½“å‰å¯ç”¨çš„ partition æ•°é‡å–ä½™  if (availablePartitions.size() \u0026gt; 0) { int part = Utils.toPositive(nextValue) % availablePartitions.size(); return availablePartitions.get(part).partition(); } else { return Utils.toPositive(nextValue) % numPartitions; } } else { // key ä¸ä¸ºç©ºæ—¶  return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; } } private int nextValue(String topic) { AtomicInteger counter = topicCounterMap.get(topic); if (null == counter) { counter = new AtomicInteger(ThreadLocalRandom.current().nextInt()); AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter); if (currentCounter != null) { counter = currentCounter; } } return counter.getAndIncrement(); } } è¿™æ®µä»£ç ä¸»è¦åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š\n å½“ key ä¸ºç©ºæ—¶ï¼Œè°ƒç”¨ nextValue è·å–ä¸€ä¸ªè‡ªå¢å€¼ï¼Œå…¶ä¸­ topicCounterMap ä¸ºæ¯ä¸€ä¸ª topic ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å€¼ï¼Œæ¯æ¬¡è°ƒç”¨ nextValue æ—¶é€’å¢ï¼Œå†å¯¹ partition çš„æ•°é‡å–ä½™å¾—åˆ°ç»“æœ å½“ key ä¸ä¸ºç©ºæ—¶ï¼Œä½¿ç”¨ murmur2 å“ˆå¸Œç®—æ³•å¯¹ key è¿›è¡Œ hash æ“ä½œå¾—åˆ°ç»“æœ  å¯ä»¥å‘ç°åªæœ‰å½“æŒ‡å®š key çš„æ—¶å€™ï¼Œæ¶ˆæ¯æ‰ä¼šè¢«åˆ†é…åˆ°åŒä¸€ä¸ª partition ä¸­ï¼Œä»è€Œä¿è¯è¢«æœ‰åºåœ°æ¶ˆè´¹ã€‚\nKafka 2.4.0 å¼•å…¥äº†æ–°çš„ç²˜æ€§åˆ†åŒºç¼“å­˜ç±» StickyPartitionCacheï¼Œå½“ key ä¸ºç©ºæ—¶ï¼Œä¸å†ä¸ºæ¯ä¸ª topic ä½¿ç”¨è½®è¯¢çš„æ–¹æ³•æ¥åˆ†é… partitionï¼Œè€Œæ˜¯ä¼šè°ƒç”¨ StickyPartitionCache.partition æ¥ä»ç¼“å­˜ä¸­è·å–å¯¹åº”çš„ partitionï¼š\npublic class DefaultPartitioner implements Partitioner { private final StickyPartitionCache stickyPartitionCache = new StickyPartitionCache(); public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster, int numPartitions) { // key ä¸ºç©ºæ—¶  if (keyBytes == null) { return stickyPartitionCache.partition(topic, cluster); } // key ä¸ä¸ºç©ºæ—¶  return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; } } // å®ç°ç²˜æ€§åˆ†åŒºç¼“å­˜çš„å†…éƒ¨ç±»ï¼Œè¿½è¸ªæ¯ä¸€ä¸ª topic çš„ç²˜æ€§ partition public class StickyPartitionCache { // ä» topic åˆ° partition çš„æ˜ å°„  private final ConcurrentMap\u0026lt;String, Integer\u0026gt; indexCache; public StickyPartitionCache() { this.indexCache = new ConcurrentHashMap\u0026lt;\u0026gt;(); } public int partition(String topic, Cluster cluster) { Integer part = indexCache.get(topic); if (part == null) { // å¦‚æœæ²¡æœ‰ç¼“å­˜åˆ™è°ƒç”¨ nextPartition é€‰æ‹©ä¸€ä¸ªåˆ†åŒºå¹¶ç¼“å­˜  return nextPartition(topic, cluster, -1); } return part; } public int nextPartition(String topic, Cluster cluster, int prevPartition) { List\u0026lt;PartitionInfo\u0026gt; partitions = cluster.partitionsForTopic(topic); Integer oldPart = indexCache.get(topic); Integer newPart = oldPart; // å¦‚æœå½“å‰ topic æ²¡æœ‰ç¼“å­˜ï¼Œæˆ–åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ batch  if (oldPart == null || oldPart == prevPartition) { List\u0026lt;PartitionInfo\u0026gt; availablePartitions = cluster.availablePartitionsForTopic(topic); if (availablePartitions.size() \u0026lt; 1) { Integer random = Utils.toPositive(ThreadLocalRandom.current().nextInt()); newPart = random % partitions.size(); } else if (availablePartitions.size() == 1) { newPart = availablePartitions.get(0).partition(); } else { while (newPart == null || newPart.equals(oldPart)) { int random = Utils.toPositive(ThreadLocalRandom.current().nextInt()); newPart = availablePartitions.get(random % availablePartitions.size()).partition(); } } // å¦‚æœæ˜¯ topic æ²¡æœ‰ç¼“å­˜  if (oldPart == null) { indexCache.putIfAbsent(topic, newPart); } else { // å¦‚æœæ˜¯åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ç¼“å­˜  indexCache.replace(topic, prevPartition, newPart); } return indexCache.get(topic); } return indexCache.get(topic); } } StickyPartitionCache ç±»ä¼šç»´æŠ¤ä¸€ä¸ªä» topic åˆ° partition çš„ç¼“å­˜ï¼Œå…¶æœ¬è´¨ä¹Ÿæ˜¯è½®è¯¢ã€‚åœ¨è€ç‰ˆæœ¬çš„ partition æ–¹æ³•ä¸­ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®š keyï¼Œé‚£ä¹ˆåŒä¸€ä¸ª topic ä¸­çš„æ¶ˆæ¯ä¼šè¢«è½®è¯¢åˆ°ä¸åŒçš„ partition ä¸­ï¼Œè¿™æ ·ä¸åŒçš„ partition ä¸­å°±ä¼šäº§ç”Ÿå¾ˆå¤šçš„ batchï¼Œä»è€Œå¯¼è‡´æ›´å¤šçš„ç½‘ç»œè¯·æ±‚ã€‚è€Œ StickyPartitionCache ä¿è¯äº†è¿™æ ·çš„æ¶ˆæ¯å¯ä»¥å…±åŒæ„æˆä¸€ä¸ªæ›´å¤§çš„ batchï¼ŒæŠ•é€’åˆ°ç›¸åŒçš„ partition ä¸­ï¼Œå‘é€ç»™ Kafka æœåŠ¡å™¨ï¼Œä»è€Œæé«˜ååé‡ã€‚\n3 æ¶ˆè´¹è€… Kafka çš„æ¶ˆè´¹è€…æœåŠ¡ç»å¸¸ä¼šåšä¸€äº›é«˜å»¶è¿Ÿçš„ IO æ“ä½œï¼Œæ¯”å¦‚æŠŠæ•°æ®å†™åˆ°ç£ç›˜ï¼Œæ•°æ®åº“æˆ– HDFSï¼Œæˆ–è€…ä½¿ç”¨æ•°æ®è¿›è¡Œæ¯”è¾ƒè€—æ—¶çš„è®¡ç®—ã€‚åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œå•ä¸ªæ¶ˆè´¹è€…æ— æ³•è·Ÿä¸Šæ•°æ®ç”Ÿæˆçš„é€Ÿåº¦ï¼Œæ‰€ä»¥åªèƒ½é€šè¿‡æ¨ªå‘ä¼¸ç¼©çš„æ–¹å¼ï¼Œå¢åŠ æ›´å¤šçš„æ¶ˆè´¹è€…ï¼Œè®©å®ƒä»¬åˆ†æ‹…è´Ÿè½½ï¼Œä»è€Œæé«˜ååé‡ã€‚\nå°±åƒå¤šä¸ªç”Ÿäº§è€…å¯ä»¥åŒæ—¶å‘ç›¸åŒçš„ topic å†™å…¥æ¶ˆæ¯ä¸€æ ·ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨å¤šä¸ªæ¶ˆè´¹è€…è®¢é˜…å¹¶ä»åŒä¸€ä¸ª topic è¯»å–æ¶ˆæ¯ï¼Œå¯¹æ¶ˆæ¯è¿›è¡Œåˆ†æµã€‚Kafka ä¸­çš„æ¶ˆè´¹è€…ä»å±äºæ¶ˆè´¹è€…ç¾¤ç»„ groupï¼Œä¸€ä¸ª group è®¢é˜…ä¸€ä¸ª topicï¼Œæ¯ä¸ªæ¶ˆè´¹è€…åˆ™æ¥æ”¶å…¶ä¸­ä¸€éƒ¨åˆ† partition çš„æ¶ˆæ¯ã€‚\n3.1 æ¶ˆè´¹è¿‡ç¨‹ Kafka ä¸­å®¢æˆ·ç«¯çš„æ¶ˆè´¹æ˜¯åŸºäº pull æ¨¡å¼çš„ï¼Œè¿™æ ·åšçš„ä¼˜åŠ¿åœ¨äºï¼Œä¸åŒæ¶ˆè´¹è€…å®¢æˆ·ç«¯çš„æ¶ˆè´¹èƒ½åŠ›å’Œæ¶ˆè´¹ç­–ç•¥ä¸åŒï¼Œå®ƒä»¬å¯ä»¥è°ƒæ•´ pull çš„é¢‘ç‡ä»¥é€‚é…è‡ªå·±çš„ IO èƒ½åŠ›ï¼›å¦‚æœä½¿ç”¨ push æ¨¡å¼åˆ™æœ‰å¯èƒ½å› ä¸ºæ¨é€é€Ÿåº¦è¿‡å¿«è€Œé€ æˆæ¶ˆè´¹è€…å®¢æˆ·ç«¯å´©æºƒã€‚\næ¶ˆè´¹æ¶ˆæ¯æ˜¯ä¸€ä¸ªä¸æ–­è½®è¯¢ poll çš„è¿‡ç¨‹ï¼Œæ¶ˆè´¹è€…æ‰€è¦åšçš„å°±æ˜¯ä¸æ–­åœ°é‡å¤è°ƒç”¨ poll ï¼Œå¹¶ç­‰å¾… Kafka æœåŠ¡å™¨è¿”å›å…¶è®¢é˜…çš„ partition ä¸Šçš„ä¸€ç»„æ¶ˆæ¯ã€‚\npublic class KafkaConsumerDemo { public static void main(String[] args) { Properties props = initConfig(); KafkaConsumer\u0026lt;String, String\u0026gt; consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(TOPIC)); try { while (IS_RUNNING.get()) { ConsumerRecords\u0026lt;String, String\u0026gt; records = consumer.poll(Duration.ofMillis(1000)); for (ConsumerRecord\u0026lt;String, String\u0026gt; record : records) { System.out.println(\u0026#34;topic=\u0026#34; + record.topic() + \u0026#34;, partition=\u0026#34; + record.partition() + \u0026#34;, offset=\u0026#34; + record.offset()); System.out.println(\u0026#34;key=\u0026#34; + record.key() + \u0026#34;, value=\u0026#34; + record.value()); } } } catch (Exception e) { e.printStackTrace(); } finally { consumer.close(); } } } poll æ–¹æ³•è¿”å›ä¸€ä¸ªè®°å½•åˆ—è¡¨ ConsumerRecordsï¼Œå…¶ä¸­æ¯æ¡è®°å½•éƒ½åŒ…å«äº†è®°å½•æ‰€å± topic å’Œ partition çš„ä¿¡æ¯ï¼Œè®°å½•æ‰€åœ¨ partition çš„ offsetï¼Œä»¥åŠè®°å½•çš„ key-valueã€‚åŒæ—¶ poll æ–¹æ³•æœ‰ä¸€ä¸ªè¶…æ—¶ timeout å‚æ•°ï¼Œæ— è®ºæœ‰æ²¡æœ‰å¯ç”¨çš„æ•°æ®ï¼Œpoll çš„æ‰§è¡Œæ—¶é—´ä¸€æ—¦è¶…è¿‡ timeout å°±ä¼šç«‹åˆ»è¿”å›ã€‚\nåœ¨æ¶ˆè´¹è€…å®¢æˆ·ç«¯é€€å‡ºä¹‹å‰åº”è¯¥è°ƒç”¨ close æ–¹æ³•æ¥å°†å…¶å…³é—­ï¼Œå¹¶ç«‹å³è§¦å‘ä¸€æ¬¡ group çš„å†å¹³è¡¡ï¼Œè€Œä¸æ˜¯ç­‰å¾… group åè°ƒå™¨æ¥å‘ç°è¿™ä¸ªå®¢æˆ·ç«¯å¿ƒè·³è¶…æ—¶å¹¶è®¤å®šå…¶å·²ä¸å†èƒ½æä¾›æœåŠ¡ã€‚\n3.2 åç§»é‡ æ¶ˆè´¹è€…å¯¹è±¡ KafkaConsumerRunner è¿è¡Œæ—¶ï¼Œé€šè¿‡å…ˆè®¢é˜… subscribe ç„¶åè½®è¯¢ poll çš„æ–¹å¼æ¥å‘ Kafka æœåŠ¡å™¨è¯·æ±‚æ•°æ®ï¼Œæ¯æ¬¡è°ƒç”¨ poll æ–¹æ³•åï¼ŒæœåŠ¡å™¨ä¼šè¿”å› partition ä¸­è¿˜æ²¡æœ‰è¢«æ¶ˆè´¹è€…è¯»å–è¿‡çš„è®°å½•ï¼Œæ¶ˆè´¹è€…å¯ä»¥è¿½è¸ªå½“å‰ partition ä¸­çš„ offsetï¼Œè€Œæ›´æ–° partition å½“å‰ offset çš„æ“ä½œå«ä½œæäº¤ submitã€‚\nå¦‚æœæ¶ˆè´¹è€…ä¸€ç›´å¤„äºè¿è¡ŒçŠ¶æ€ï¼Œé‚£ä¹ˆ offset å°±æ²¡æœ‰æ„ä¹‰ï¼›è€Œå¦‚æœæ¶ˆè´¹è€…å¤±æ•ˆæˆ–è€…æœ‰æ–°çš„æ¶ˆè´¹è€…åŠ å…¥ groupï¼Œgroup å°±ä¼šè§¦å‘å†å¹³è¡¡æœºåˆ¶ï¼Œæ¯ä¸ªæ¶ˆè´¹è€…ä¼šè¢«åˆ†é…åˆ°æ–°çš„ partitionï¼Œä¸ºäº†èƒ½å¤Ÿç»§ç»­ä¹‹å‰çš„å·¥ä½œï¼Œæ¶ˆè´¹è€…éœ€è¦è¯»å–å½“å‰ partition ä¸­æœ€åä¸€æ¬¡æäº¤çš„ offsetï¼Œç„¶åä» offset æ‰€åœ¨ä½ç½®ç»§ç»­å¤„ç†æ¶ˆæ¯ã€‚æœ€åä¸€æ¬¡æäº¤çš„ offset çš„ä½ç½®å¦‚æœåœ¨æœ€åå®é™…å¤„ç†çš„æ¶ˆæ¯ä¹‹åæˆ–ä¹‹å‰ï¼Œåˆ†åˆ«ä¼šé€ æˆæ¶ˆæ¯ä¸¢å¤±å’Œæ¶ˆæ¯é‡å¤çš„é—®é¢˜ï¼Œå› æ­¤æäº¤çš„æ–¹å¼æ˜¾å¾—å°¤ä¸ºé‡è¦ã€‚\nå¦‚æœå°†æ¶ˆè´¹è€…å¤„ç†åçš„è®°å½•ä¸ offset éƒ½ä½œä¸ºä¸€ä¸ªåŸå­æ“ä½œæˆ–äº‹åŠ¡éƒ½æäº¤åˆ°å…¶ä»–æ•°æ®åº“ä¸Šï¼Œé‚£ä¹ˆæˆ‘ä»¬ç”šè‡³å¯ä»¥ä¸ä¾èµ–äº Kafka æœåŠ¡å™¨æä¾›çš„ offsetï¼Œè€Œæ˜¯åœ¨æ¶ˆè´¹è€…å¯åŠ¨æˆ–åˆ†é…åˆ°æ–°åˆ†åŒºåï¼Œç›´æ¥è°ƒç”¨ seek æ–¹æ³•ï¼Œåœ¨ Kafka æœåŠ¡å™¨ä¸­æŸ¥æ‰¾è¿™ä¸ªç‰¹å®š offset ä½ç½®çš„æ¶ˆæ¯ã€‚\nè‡ªåŠ¨æäº¤ æœ€ç®€å•çš„æäº¤æ–¹å¼æ˜¯è®©æ¶ˆè´¹è€…è‡ªåŠ¨æäº¤ offsetï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œæ¯è¿‡ 5sï¼ˆé»˜è®¤æƒ…å†µä¸‹ï¼‰ï¼Œæ¶ˆè´¹è€…ä¼šè‡ªåŠ¨æŠŠä» poll æ–¹æ³•æ¥æ”¶åˆ°çš„æœ€å¤§ offset è¿›è¡Œæäº¤ã€‚\nä½¿ç”¨è‡ªåŠ¨æäº¤æ˜¯å­˜åœ¨éšæ‚£çš„ï¼Œå‡è®¾åœ¨è®¾ç½®çš„è‡ªåŠ¨æäº¤é—´éš”ä¹‹å†…ï¼Œgroup å‘ç”Ÿäº†å†å¹³è¡¡ï¼Œé‚£ä¹ˆå†å¹³è¡¡å®Œæˆä¹‹åæ¶ˆè´¹è€…è·å–åˆ°çš„ offset åˆ™ä¼šè½åäºå®é™…åº”è¯¥å¤„ç†çš„æ¶ˆæ¯ä½ç½®ï¼Œéƒ¨åˆ†æ¶ˆæ¯ä¼šè¢«é‡å¤å¤„ç†ã€‚è™½ç„¶å¯ä»¥é€šè¿‡ç¼©çŸ­æäº¤é—´éš”æ¥æ›´é¢‘ç¹åœ°æäº¤ offsetï¼Œå‡å°‘é‡å¤å¤„ç†æ¶ˆæ¯çš„æ•°é‡ï¼Œä½†è¿™æ ·çš„æƒ…å†µæ˜¯æ— æ³•é¿å…çš„ã€‚\nåŒæ­¥æäº¤ é€šè¿‡è°ƒç”¨ KafkaConsumer.commitSyncï¼Œå¯ä»¥å¯¹ offset è¿›è¡ŒåŒæ­¥æäº¤ï¼Œä¸ä¼ é€’ä»»ä½•å‚æ•°æ—¶é»˜è®¤æäº¤çš„æœ€å¤§ offsetã€‚\npublic class KafkaConsumer\u0026lt;K, V\u0026gt; implements Consumer\u0026lt;K, V\u0026gt; { public void commitSync(final Map\u0026lt;TopicPartition, OffsetAndMetadata\u0026gt; offsets, final Duration timeout) { acquireAndEnsureOpen(); // Acquire the light lock and ensure that the consumer hasn\u0026#39;t been closed.  long commitStart = time.nanoseconds(); try { maybeThrowInvalidGroupIdException(); offsets.forEach(this::updateLastSeenEpochIfNewer); // coordinator ç®¡ç†æ¶ˆè´¹è€…çš„æäº¤è¿‡ç¨‹  if (!coordinator.commitOffsetsSync(new HashMap\u0026lt;\u0026gt;(offsets), time.timer(timeout))) { throw new TimeoutException(\u0026#34;Timeout of \u0026#34; + timeout.toMillis() + \u0026#34;ms expired before successfully \u0026#34; + \u0026#34;committing offsets \u0026#34; + offsets); } } finally { kafkaConsumerMetrics.recordCommitSync(time.nanoseconds() - commitStart); release(); } } private void acquireAndEnsureOpen() { acquire(); if (this.closed) { release(); throw new IllegalStateException(\u0026#34;This consumer has already been closed.\u0026#34;); } } } acquireAndEnsureOpen ä¼šå°è¯•è·å–é”ï¼Œå¹¶ç¡®ä¿å½“å‰å®¢æˆ·ç«¯å°šæœªå…³é—­ï¼Œä½†å®é™…ä¸Š KafkaConsumer å¹¶ä¸æ”¯æŒè¢«å¹¶å‘è®¿é—®ï¼Œæ‰€ä»¥åœ¨è¢«å¤šä¸ªçº¿ç¨‹è°ƒç”¨æ—¶ä¼šç®€å•åœ°æŠ›å‡ºçŠ¶æ€é”™è¯¯çš„å¼‚å¸¸ã€‚\npublic final class ConsumerCoordinator extends AbstractCoordinator { public boolean commitOffsetsSync(Map\u0026lt;TopicPartition, OffsetAndMetadata\u0026gt; offsets, Timer timer) { invokeCompletedOffsetCommitCallbacks(); if (offsets.isEmpty()) return true; do { if (coordinatorUnknown() \u0026amp;\u0026amp; !ensureCoordinatorReady(timer)) { return false; } RequestFuture\u0026lt;Void\u0026gt; future = sendOffsetCommitRequest(offsets); // é˜»å¡ç­‰å¾…æäº¤ç»“æœ  client.poll(future, timer); invokeCompletedOffsetCommitCallbacks(); if (future.succeeded()) { if (interceptors != null) interceptors.onCommit(offsets); return true; } if (future.failed() \u0026amp;\u0026amp; !future.isRetriable()) throw future.exception(); timer.sleep(rebalanceConfig.retryBackoffMs); } while (timer.notExpired()); return false; } } ConsumerCoordinator.commitOffsetsSync å…ˆé€šè¿‡ sendOffsetCommitRequest è·å–åˆ°å‘é€ request åçš„ future å¯¹è±¡ï¼Œç„¶åå†ä½¿ç”¨ poll(future) é˜»å¡åœ°ç­‰å¾…å…¶æ‰§è¡Œå®Œæˆï¼›å¦‚æœåŒæ­¥æäº¤å¤±è´¥ï¼Œä½†å°šæœªè¶…æ—¶ï¼Œä¼šåœ¨ å‡½æ•°ä¸­å°è¯•é‡æ–°æäº¤ï¼Œè¿™å¯ä»¥æœ€å¤§ç¨‹åº¦åœ°ä¿è¯æ•°æ®æäº¤æˆåŠŸï¼Œä½†åŒæ—¶ä¹Ÿä¼šé™ä½ç¨‹åºçš„ååé‡ã€‚\nå¼‚æ­¥æäº¤ å’ŒåŒæ­¥æäº¤ç›¸åï¼Œå¼‚æ­¥æäº¤åœ¨æ‰§è¡Œçš„æ—¶å€™ä¸ä¼šé˜»å¡æ¶ˆè´¹è€…çº¿ç¨‹ï¼Œè¿™æ ·å¯ä»¥ä½¿å¾—æ¶ˆè´¹è€…å®¢æˆ·ç«¯çš„æ€§èƒ½å’Œååé‡å¾—åˆ°ä¸€å®šçš„æå‡ã€‚\npublic class KafkaConsumer\u0026lt;K, V\u0026gt; implements Consumer\u0026lt;K, V\u0026gt; { public void commitAsync(final Map\u0026lt;TopicPartition, OffsetAndMetadata\u0026gt; offsets, OffsetCommitCallback callback) { acquireAndEnsureOpen(); try { maybeThrowInvalidGroupIdException(); log.debug(\u0026#34;Committing offsets: {}\u0026#34;, offsets); offsets.forEach(this::updateLastSeenEpochIfNewer); coordinator.commitOffsetsAsync(new HashMap\u0026lt;\u0026gt;(offsets), callback); } finally { release(); } } } ç›¸è¾ƒäºåŒæ­¥æäº¤ commitSyncï¼Œå¼‚æ­¥æäº¤ commitAsync æ¥å£çš„å”¯ä¸€åŒºåˆ«æ˜¯åœ¨å‚æ•°é‡Œå¢åŠ äº†ä¸€ä¸ªå›è°ƒå‡½æ•°ã€‚\npublic final class ConsumerCoordinator extends AbstractCoordinator { private void doCommitOffsetsAsync(final Map\u0026lt;TopicPartition, OffsetAndMetadata\u0026gt; offsets, final OffsetCommitCallback callback) { this.subscriptions.needRefreshCommits(); RequestFuture\u0026lt;Void\u0026gt; future = sendOffsetCommitRequest(offsets); final OffsetCommitCallback cb = callback == null ? defaultOffsetCommitCallback : callback; // æ·»åŠ ç›‘å¬  future.addListener(new RequestFutureListener\u0026lt;Void\u0026gt;() { @Override public void onSuccess(Void value) { if (interceptors != null) interceptors.onCommit(offsets); completedOffsetCommits.add(new OffsetCommitCompletion(cb, offsets, null)); } @Override public void onFailure(RuntimeException e) { Exception commitException = e; if (e instanceof RetriableException) commitException = RetriableCommitFailedException.withUnderlyingMessage(e.getMessage()); completedOffsetCommits.add(new OffsetCommitCompletion(cb, offsets, commitException)); } }); } } ç±»ä¼¼åœ°ï¼ŒConsumerCoordinator.doCommitOffsetsAsync ä¼šå…ˆé€šè¿‡ sendOffsetCommitRequest è·å–åˆ° future å¯¹è±¡ï¼Œä½†åªä¸ºå…¶æ·»åŠ å¥½ç›‘å¬äº‹ä»¶å°±è¿”å›äº†ã€‚\n3.3 å†å¹³è¡¡ å†å¹³è¡¡æŒ‡å½“ partition çš„æ‰€å±æƒä»ä¸€ä¸ªæ¶ˆè´¹è€…è½¬ç§»åˆ°å¦ä¸€ä¸ªæ¶ˆè´¹è€…çš„è¡Œä¸ºï¼Œå®ƒä¸º group çš„é«˜å¯ç”¨æ€§å’Œä¼¸ç¼©æ€§æä¾›äº†ä¿è¯ï¼›ä¸€èˆ¬æœ‰ä¸‰ç§æ—¶æœºä¼šè§¦å‘å†å¹³è¡¡ï¼š\n group è®¢é˜…çš„ topic ä¸­æ–°å¢äº† partition group ä¸­æ–°å¢æˆ–ç§»é™¤äº†éƒ¨åˆ†æ¶ˆè´¹è€…ï¼Œå¯¹åº”çš„ partition éœ€è¦è¢«åˆ†é…ç»™ group å†…çš„å…¶ä»–æ¶ˆè´¹è€… group è®¢é˜…çš„ topic å‘ç”Ÿäº†å˜åŒ–ï¼Œä¾‹å¦‚ group åˆ©ç”¨æŸä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼ˆä¾‹å¦‚ \u0026ldquo;test.*\u0026quot;ï¼‰è®¢é˜…äº†ç‰¹å®šçš„ topicï¼Œåœ¨æŸä¸ªæ—¶é—´é›†ç¾¤å†…æ–°å¢äº†ä¸€ä¸ªç¬¦åˆæ­£åˆ™è¡¨è¾¾å¼çš„ topicï¼ˆä¾‹å¦‚ \u0026ldquo;test1\u0026rdquo;ï¼‰ï¼Œé‚£ä¹ˆè¯¥ topic çš„æ‰€æœ‰ partition ä¹Ÿä¼šè¢«åˆ†é…ç»™å½“å‰çš„ group  åœ¨å†å¹³è¡¡å‘ç”Ÿçš„æœŸé—´ï¼Œgroup å†…çš„æ¶ˆè´¹è€…æ— æ³•è¯»å–æ¶ˆæ¯ï¼Œå³æ•´ä¸ª group ä¼šå˜å¾—ä¸å¯ç”¨ï¼›å¹¶ä¸”å½“ä¸€ä¸ª partition è¢«é‡æ–°åˆ†é…ç»™å¦ä¸€ä¸ªæ¶ˆè´¹è€…æ—¶ï¼Œæ¶ˆè´¹è€…çš„çŠ¶æ€ä¼šä¸¢å¤±ï¼Œå³å…¶ offset æœ‰å¯èƒ½å°šæœªæäº¤ã€‚å› æ­¤ä¸€èˆ¬æƒ…å†µä¸‹åº”è¯¥å°½é‡é¿å…ä¸å¿…è¦çš„å†å¹³è¡¡çš„å‘ç”Ÿã€‚\nRangeAssignor RangeAssignor æ˜¯é»˜è®¤çš„ï¼Œä¹Ÿæ˜¯æœ€ç®€å•çš„å†å¹³è¡¡ç­–ç•¥ï¼š\npublic class RangeAssignor extends AbstractPartitionAssignor { public static final String RANGE_ASSIGNOR_NAME = \u0026#34;range\u0026#34;; @Override public Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assign(Map\u0026lt;String, Integer\u0026gt; partitionsPerTopic, Map\u0026lt;String, Subscription\u0026gt; subscriptions) { Map\u0026lt;String, List\u0026lt;MemberInfo\u0026gt;\u0026gt; consumersPerTopic = consumersPerTopic(subscriptions); Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assignment = new HashMap\u0026lt;\u0026gt;(); for (String memberId : subscriptions.keySet()) assignment.put(memberId, new ArrayList\u0026lt;\u0026gt;()); for (Map.Entry\u0026lt;String, List\u0026lt;MemberInfo\u0026gt;\u0026gt; topicEntry : consumersPerTopic.entrySet()) { String topic = topicEntry.getKey(); List\u0026lt;MemberInfo\u0026gt; consumersForTopic = topicEntry.getValue(); // æ¯ä¸ª topic çš„ partition æ•°é‡  Integer numPartitionsForTopic = partitionsPerTopic.get(topic); if (numPartitionsForTopic == null) continue; Collections.sort(consumersForTopic); // æ¯ä¸ªæ¶ˆè´¹è€…éƒ½ä¼šè¢«åˆ†é…åˆ°çš„ partition æ•°é‡  int numPartitionsPerConsumer = numPartitionsForTopic / consumersForTopic.size(); // éƒ¨åˆ†æ¶ˆè´¹è€…ä¼šè¢«åˆ†é…åˆ°çš„é¢å¤– partition  int consumersWithExtraPartition = numPartitionsForTopic % consumersForTopic.size(); List\u0026lt;TopicPartition\u0026gt; partitions = AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic); for (int i = 0, n = consumersForTopic.size(); i \u0026lt; n; i++) { int start = numPartitionsPerConsumer * i + Math.min(i, consumersWithExtraPartition); int length = numPartitionsPerConsumer + (i + 1 \u0026gt; consumersWithExtraPartition ? 0 : 1); assignment.get(consumersForTopic.get(i).memberId).addAll(partitions.subList(start, start + length)); } } return assignment; } } å¯ä»¥çœ‹åˆ° RangeAssignor.assign å‡½æ•°ä¸­ä¼šè®¡ç®— partition æ•°é‡ numPartitionsForTopic ä¸æ¶ˆè´¹è€…æ•°é‡ consumersForTopic çš„æ•´é™¤ç»“æœ numPartitionsPerConsumer å’Œå–ä½™ç»“æœ consumersWithExtraPartitionï¼Œå¹¶å°†è¿ç»­çš„ partition åˆ†é…ç»™åŒä¸€ä¸ªæ¶ˆè´¹è€…ã€‚\nRoundRobinAssignor RoundRobinAssignor ç­–ç•¥çš„åŸç†æ˜¯å°† group å†…æ‰€æœ‰æ¶ˆè´¹è€…ä»¥åŠæ‰€æœ‰ partition æŒ‰ç…§å­—å…¸åºæ’åºï¼Œç„¶åé€šè¿‡è½®è¯¢çš„æ–¹å¼é€ä¸ªåœ°è¿›è¡Œåˆ†é…ï¼š\npublic class RoundRobinAssignor extends AbstractPartitionAssignor { public static final String ROUNDROBIN_ASSIGNOR_NAME = \u0026#34;roundrobin\u0026#34;; @Override public Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assign(Map\u0026lt;String, Integer\u0026gt; partitionsPerTopic, Map\u0026lt;String, Subscription\u0026gt; subscriptions) { Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assignment = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;MemberInfo\u0026gt; memberInfoList = new ArrayList\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;String, Subscription\u0026gt; memberSubscription : subscriptions.entrySet()) { assignment.put(memberSubscription.getKey(), new ArrayList\u0026lt;\u0026gt;()); memberInfoList.add(new MemberInfo(memberSubscription.getKey(), memberSubscription.getValue().groupInstanceId())); } // ç¯å½¢é“¾è¡¨ï¼Œå­˜å‚¨æ‰€æœ‰çš„æ¶ˆè´¹è€…  CircularIterator\u0026lt;MemberInfo\u0026gt; assigner = new CircularIterator\u0026lt;\u0026gt;(Utils.sorted(memberInfoList)); // è·å– group å½“å‰è®¢é˜…çš„æ‰€æœ‰ topic çš„ partition  for (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) { final String topic = partition.topic(); while (!subscriptions.get(assigner.peek().memberId).topics().contains(topic)) assigner.next(); assignment.get(assigner.next().memberId).add(partition); } return assignment; } } ä»¥ä¸Šä¸¤ç§æ–¹å¼éƒ½å¯¹æ‰€æœ‰çš„ partition è¿›è¡Œäº†å…¨é‡é‡æ–°åˆ†é…ã€‚\nStickyAssignor StickyAssignor ç­–ç•¥çš„ç›®çš„æœ‰ä¸¤ä¸ªï¼š\n partition çš„åˆ†é…è¦å°½å¯èƒ½çš„å‡åŒ€ï¼Œåˆ†é…ç»™å„ä¸ªæ¶ˆè´¹è€…çš„ partition æ•°é‡æœ€å¤šåªç›¸å·®ä¸€ä¸ªï¼› partition çš„åˆ†é…å°½å¯èƒ½çš„ä¸å†åˆ†é…ä¹‹å‰çš„ä¿æŒç›¸åŒï¼›  å½“ä¸¤è€…å†²çªçš„æ—¶å€™ï¼Œç¬¬ä¸€ä¸ªç›®æ ‡ä¼˜å…ˆäºç¬¬äºŒä¸ªç›®æ ‡ã€‚\npublic abstract class AbstractStickyAssignor extends AbstractPartitionAssignor { public Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assign(Map\u0026lt;String, Integer\u0026gt; partitionsPerTopic, Map\u0026lt;String, Subscription\u0026gt; subscriptions) { Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; consumerToOwnedPartitions = new HashMap\u0026lt;\u0026gt;(); Set\u0026lt;TopicPartition\u0026gt; partitionsWithMultiplePreviousOwners = new HashSet\u0026lt;\u0026gt;(); if (allSubscriptionsEqual(partitionsPerTopic.keySet(), subscriptions, consumerToOwnedPartitions, partitionsWithMultiplePreviousOwners)) { log.debug(\u0026#34;Detected that all consumers were subscribed to same set of topics, invoking the \u0026#34; + \u0026#34;optimized assignment algorithm\u0026#34;); partitionsTransferringOwnership = new HashMap\u0026lt;\u0026gt;(); return constrainedAssign(partitionsPerTopic, consumerToOwnedPartitions, partitionsWithMultiplePreviousOwners); } else { log.debug(\u0026#34;Detected that not all consumers were subscribed to same set of topics, falling back to the \u0026#34; + \u0026#34;general case assignment algorithm\u0026#34;); partitionsTransferringOwnership = null; return generalAssign(partitionsPerTopic, subscriptions, consumerToOwnedPartitions); } } } AbstractStickyAssignor è™šåŸºç±»çš„ assign å‡½æ•°ä¸­å°†å†å¹³è¡¡åˆ†ä¸ºäº†ä¸¤ç§æƒ…å†µï¼Œåˆ†åˆ«æ˜¯ group é‡Œçš„æ¶ˆè´¹è€…éƒ½è®¢é˜…äº†ç›¸åŒçš„ topicï¼Œä»¥åŠè®¢é˜…çš„ topic ä¸å°½ç›¸åŒã€‚\nå¯¹äºå‰è€…ï¼Œéœ€è¦è·å–ä¸Šæ¬¡çš„åˆ†é…æƒ…å†µï¼Œå¹¶åˆ é™¤å·²ç»å¤±æ•ˆçš„ partitionï¼Œè¿™æ ·å°±è·å–åˆ°äº†ä¸€ä»½å¯ç”¨çš„ï¼Œä¸ä¹‹å‰å°½å¯èƒ½ç›¸åŒçš„é¢„åˆ†é…åå•ï¼Œä½†æ˜¯å¯èƒ½åˆ†é…ä¸å‡ï¼Œå› æ­¤è¿›å…¥ constrainedAssign å‡½æ•°æ¥è¿›è¡Œè¿›ä¸€æ­¥çš„å…¬å¹³åˆ†é…ï¼š\npublic abstract class AbstractStickyAssignor extends AbstractPartitionAssignor { private Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; constrainedAssign(Map\u0026lt;String, Integer\u0026gt; partitionsPerTopic, Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; consumerToOwnedPartitions, Set\u0026lt;TopicPartition\u0026gt; partitionsWithMultiplePreviousOwners) { // ...  // æ¶ˆè´¹è€…æ•°é‡  int numberOfConsumers = consumerToOwnedPartitions.size(); // åˆ†åŒºæ•°é‡  int totalPartitionsCount = partitionsPerTopic.values().stream().reduce(0, Integer::sum); // æ¯ä¸ªæ¶ˆè´¹è€…åˆ†é…åˆ°çš„ partition æœ€å°æ•°é‡  int minQuota = (int) Math.floor(((double) totalPartitionsCount) / numberOfConsumers); // æ¯ä¸ªæ¶ˆè´¹è€…åˆ†é…åˆ°çš„ partition æœ€å¤§æ•°é‡  int maxQuota = (int) Math.ceil(((double) totalPartitionsCount) / numberOfConsumers); // ä¼šè·å¾—é¢å¤– partition çš„æ¶ˆè´¹è€…æ•°é‡  int expectedNumMembersWithOverMinQuotaPartitions = totalPartitionsCount % numberOfConsumers; // ...  // éªŒè¯é¢„åˆ†é…çš„æ•°é‡ä¸ minQuota å’Œ maxQuota çš„å…³ç³»ï¼Œå°†è¶…è¿‡çš„ maxQuota çš„éƒ¨åˆ†ç§»é™¤å¹¶è®°å½•ï¼Œåˆ†é…ç»™ä½äº minQuota çš„æ¶ˆè´¹è€…  // æ³¨æ„è¿™ä¸€æ­¥åªèƒ½ä¿è¯èƒ½å¤Ÿå°†æ‰€æœ‰è¶…è¿‡ maxQuota çš„éƒ¨åˆ†å–å‡º  for (Map.Entry\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; consumerEntry : consumerToOwnedPartitions.entrySet()) { List\u0026lt;TopicPartition\u0026gt; ownedPartitions = consumerEntry.getValue(); // å¯¹äºé¢„åˆ†é…æ—¶æœªè¾¾åˆ° minQuota çš„æ¶ˆè´¹è€…ï¼Œå°†å¤šä½™çš„åˆ†é…ç»™å®ƒä»¬  if (ownedPartitions.size() \u0026lt; minQuota) { if (ownedPartitions.size() \u0026gt; 0) { consumerAssignment.addAll(ownedPartitions); assignedPartitions.addAll(ownedPartitions); } unfilledMembersWithUnderMinQuotaPartitions.add(consumer); } else if (ownedPartitions.size() \u0026gt;= maxQuota \u0026amp;\u0026amp; currentNumMembersWithOverMinQuotaPartitions \u0026lt; expectedNumMembersWithOverMinQuotaPartitions) { // å¯¹äºé¢„åˆ†é…æ—¶è¶…è¿‡ maxQuota çš„æ¶ˆè´¹è€…ï¼Œå°†å¤šä½™çš„ç§»é™¤å¹¶ä¿å­˜ä¸‹æ¥  currentNumMembersWithOverMinQuotaPartitions++; if (currentNumMembersWithOverMinQuotaPartitions == expectedNumMembersWithOverMinQuotaPartitions) { unfilledMembersWithExactlyMinQuotaPartitions.clear(); } List\u0026lt;TopicPartition\u0026gt; maxQuotaPartitions = ownedPartitions.subList(0, maxQuota); consumerAssignment.addAll(maxQuotaPartitions); assignedPartitions.addAll(maxQuotaPartitions); allRevokedPartitions.addAll(ownedPartitions.subList(maxQuota, ownedPartitions.size())); } else { // å¯¹äºé¢„åˆ†é…æ—¶æ°å¥½æœ‰ minQuota çš„æ¶ˆè´¹è€…ï¼Œå¦‚æœæœ‰å‰©ä½™æœªåˆ†é…çš„ partitionï¼Œåˆ™åˆ†é…ä¸€ä¸ªç»™å®ƒä»¬  List\u0026lt;TopicPartition\u0026gt; minQuotaPartitions = ownedPartitions.subList(0, minQuota); consumerAssignment.addAll(minQuotaPartitions); assignedPartitions.addAll(minQuotaPartitions); allRevokedPartitions.addAll(ownedPartitions.subList(minQuota, ownedPartitions.size())); // å¦‚æœæ²¡æœ‰åˆ†é…ï¼Œåˆ™è®°å½•ä¸‹æ¥  if (currentNumMembersWithOverMinQuotaPartitions \u0026lt; expectedNumMembersWithOverMinQuotaPartitions) { unfilledMembersWithExactlyMinQuotaPartitions.add(consumer); } } } // ä½¿ç”¨è½®è¯¢çš„æ–¹å¼ï¼Œå†å°†å¤šä½™çš„ quota åˆ†é…ç»™æœªè¾¾åˆ° minQuota çš„æ¶ˆè´¹è€…  Iterator\u0026lt;String\u0026gt; unfilledConsumerIter = unfilledMembersWithUnderMinQuotaPartitions.iterator(); for (TopicPartition unassignedPartition : unassignedPartitions) { // ...  unfilledConsumerIter = unfilledMembersWithUnderMinQuotaPartitions.iterator(); consumer = unfilledConsumerIter.next(); int currentAssignedCount = consumerAssignment.size(); if (currentAssignedCount == minQuota) { unfilledConsumerIter.remove(); unfilledMembersWithExactlyMinQuotaPartitions.add(consumer); } // ...  } // ...  } } åè€…çš„å®ç°ä¸å‰è€…ç±»ä¼¼ï¼Œæœ‰å…´è¶£çš„æœ‹å‹å¯ä»¥è‡ªè¡Œç ”ç©¶ã€‚\n4 æœåŠ¡å™¨ 4.1 å¤åˆ¶å’Œå‰¯æœ¬ å¤åˆ¶ replication æ˜¯ Kafka æœåŠ¡å™¨æ¶æ„å…·å¤‡æ•°æ®å†—ä½™ï¼Œé«˜ä¼¸ç¼©æ€§ï¼Œæ•…éšœè‡ªåŠ¨è½¬ç§»åŠŸèƒ½çš„æ ¸å¿ƒæœºåˆ¶ï¼Œå®ƒèƒ½å¤Ÿä¿è¯å½“ä¸ªåˆ«èŠ‚ç‚¹å¤±æ•ˆæ—¶ï¼ŒKafka æœåŠ¡å™¨ä»ç„¶èƒ½å¤Ÿæ­£å¸¸æä¾›æœåŠ¡ã€‚Kafka æœåŠ¡å™¨ä¸­çš„ topic è¢«åˆ†ä¸ºè‹¥å¹²ä¸ª partitionï¼Œæ¯ä¸ª partition æœ‰ n ä¸ªå‰¯æœ¬ replicaï¼Œn æ˜¯ topic çš„å¤åˆ¶å› å­ replication factorã€‚\nreplica åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼Œä¸€ç§æ˜¯é¦–é¢† leaderï¼Œæ¯ä¸ª partition æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª leaderï¼Œä¸ºäº†ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§ï¼Œæ‰€æœ‰æ¥è‡ªç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çš„è¯·æ±‚éƒ½ä¼šåˆ°è¾¾ leaderï¼›å¦ä¸€ç§æ˜¯è·Ÿéšè€… followerï¼Œå®ƒçš„ä¸»è¦åŠŸèƒ½æ˜¯è¿›è¡Œæ•°æ®çš„å¤‡ä»½ï¼Œpartition ä¸­é™¤äº† leader ä»¥å¤–çš„æ‰€æœ‰ replica éƒ½æ˜¯ followerï¼Œfollower ä¸ä¼šå¤„ç†ä»»ä½•è¯·æ±‚ï¼Œå®ƒä»¬åªä¼šå‘ leader å‘é€ pull è¯·æ±‚ï¼ˆç±»ä¼¼äºæ¶ˆè´¹è€…å®¢æˆ·ç«¯ï¼‰ï¼Œè¿›è¡Œæ¶ˆæ¯çš„å¤åˆ¶ï¼Œå¹¶å§‹ç»ˆä¿æŒä¸ leader ä¸€è‡´çš„çŠ¶æ€ï¼Œå¦‚æœ leader å‘ç”Ÿäº†å¤±æ•ˆï¼Œå…¶ä¸­çš„ä¸€ä¸ª follower ä¼šè¢«æå‡ä¸ºæ–°çš„ leaderã€‚\nå¯¹äºå®¢æˆ·ç«¯è€Œè¨€ï¼Œfollower æ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼Œå®ƒä»¬æ—¢ä¸åƒ MySQL é‚£æ ·èƒ½å¤Ÿå¸®åŠ© leader åˆ†æ‹…æ‰¿è½½è¯»è¯·æ±‚ï¼Œä¹Ÿä¸èƒ½å®ç°å°†å°±è¿‘è¯»å–æ¥æ”¹å–„æ•°æ®å±€éƒ¨æ€§ï¼Œå…¶åŸå› æœ‰ä¸¤ç‚¹ï¼šç¬¬ä¸€æ˜¯ä¸ºäº†å®ç° RyW (read your write) / WfR (write follow read)ï¼Œå³æ¯ä¸ªå†™æ“ä½œéƒ½ä¾èµ–äºä¸Šä¸€ä¸ªè¯»æ“ä½œï¼Œé¿å…å› å¤šä¸ªèŠ‚ç‚¹å†™é¡ºåºä¸åŒå¯¼è‡´çš„ dirty readï¼Œåœ¨ç²˜æ»ä¼šè¯ sticky sessions çš„å±‚é¢è§£å†³äº†ä¸€è‡´æ€§é—®é¢˜ï¼›ç¬¬äºŒæ˜¯ä¸ºäº†å®ç° monotonic readï¼Œå³å®¢æˆ·ç«¯åœ¨è¯»åˆ°ä¸€ä¸ª value ä¹‹åï¼Œåç»­çš„æ‰€æœ‰è¯»æ“ä½œéƒ½è¦è¯»åˆ°è¿™ä¸ª value æˆ–å…¶ä¹‹åæ›´æ–°ã€‚\næ•°æ®ä¸€è‡´æ€§ ä¸€èˆ¬æ¥è¯´ï¼Œæœ‰ä¸¤ç§æ–¹æ¡ˆå¯ä»¥ä¿è¯æ•°æ®çš„å¼ºä¸€è‡´æ€§ï¼šä¸»å¤‡å¤åˆ¶ primary-backup replication å’Œ åˆ†å¸ƒå¼å¤åˆ¶ quorum-based replicationã€‚\nåˆ†å¸ƒå¼å¤åˆ¶ä¸€èˆ¬é‡‡ç”¨ paxos å’Œ raft ç­‰å…±è¯†ç®—æ³• consensus algorithm å®ç°ï¼Œå…¶ç‰¹ç‚¹æ˜¯åœ¨æœ‰ 2n + 1ä¸ªèŠ‚ç‚¹çš„æƒ…å†µä¸‹ï¼Œæœ€å¤šå¯ä»¥å®¹å¿ n ä¸ªèŠ‚ç‚¹å¤±è´¥ï¼Œå®ƒçš„ä¼˜ç‚¹åœ¨äºå»¶è¿Ÿæ›´ä½ï¼ˆå› ä¸ºåªéœ€è¦éƒ¨åˆ†èŠ‚ç‚¹å†™å…¥æˆåŠŸï¼‰ã€‚\nè€Œä¸»å¤‡å¤åˆ¶éœ€è¦ç­‰å¾…æ‰€æœ‰çš„èŠ‚ç‚¹å†™å…¥æˆåŠŸï¼Œåœ¨æœ‰ n ä¸ªèŠ‚ç‚¹çš„æƒ…å†µä¸‹ï¼Œæœ€å¤šå¯ä»¥å®¹å¿ n-1 èŠ‚ç‚¹å¤±è´¥ï¼›å®ƒçš„ä¼˜ç‚¹åœ¨äºå¯ä»¥å®¹å¿æ›´å¤šçš„èŠ‚ç‚¹å¤±è´¥ï¼ˆåªè¦æœ‰ä¸€ä¸ªèŠ‚ç‚¹å­˜æ´»å°±å¯ä»¥ç»§ç»­å·¥ä½œï¼‰ï¼Œå¹¶ä¸”æœ€å°‘åªè¦æœ‰ä¸¤ä¸ªèŠ‚ç‚¹å­˜åœ¨å°±å¯ä»¥æä¾›æœåŠ¡ï¼Œè€Œå‰è€…éœ€è¦æœ‰è‡³å°‘ä¸‰ä¸ªèŠ‚ç‚¹ã€‚\nKafka ä½¿ç”¨äº†ç»å…¸çš„ä¸»å¤‡å¤åˆ¶æ–¹å¼æ¥å®ç°é›†ç¾¤ä¹‹é—´çš„æ—¥å¿—å¤åˆ¶ï¼Œæ¯ä¸ª replica éƒ½åœ¨ç£ç›˜ä¸Šç»´æŠ¤äº†ä¸€ä¸ªæ—¥å¿—ï¼Œä»–ä»¬ä¼šå°†æ¥æ”¶åˆ°çš„æ—¥å¿—æŒ‰æŒ‰é¡ºåºæ·»åŠ åˆ°æ—¥å¿—ä¸­ã€‚å½“ç”Ÿäº§è€…å°†æ¶ˆæ¯ push åˆ°æŸä¸ª partition æ—¶ï¼Œè¯¥æ¶ˆæ¯é¦–å…ˆä¼šè¢«è½¬å‘åˆ°è¯¥ partition çš„ leader ä¸Šï¼Œleader å°†å…¶è¿½åŠ åˆ°ç£ç›˜æ—¥å¿—ä¸­ï¼ŒåŒæ—¶ partition ä¸Šçš„å…¶ä»–æ‰€æœ‰ follower ä¸æ–­åœ°å‘ leader è¯·æ±‚å¹¶åŒæ­¥è¿™ä¸ªæ¶ˆæ¯ï¼Œåªæœ‰å½“æœ‰è¶³å¤Ÿå¤šçš„ follower æˆåŠŸå¤„ç†å®Œæ¶ˆæ¯åï¼Œleader æ‰ä¼šè®¤ä¸ºæ¶ˆæ¯å·²ç»å¤„ç†å®Œæˆï¼›ä½† leader å¦‚æœæ€»æ˜¯ç­‰å¾…æ‰€æœ‰ follower å¤„ç†å®Œæ¶ˆæ¯ï¼ŒåŠ¿å¿…ä¼šæé«˜ç³»ç»Ÿçš„å»¶è¿Ÿï¼Œé™ä½æœåŠ¡çš„å¯ç”¨æ€§ã€‚\nISR ä¸ºäº†è§£å†³ç­‰å¾… follower å¤„ç†å®Œæ¶ˆæ¯çš„é—®é¢˜ï¼ŒKafkaå¼•å…¥äº† ISR In-Sync Replica çš„æ¦‚å¿µã€‚partition ä¸­çš„æ‰€æœ‰ replica ç»Ÿç§°ä¸ºAR Assigned Repllicasï¼Œæ‰€æœ‰ä¸ leader ä¿æŒä¸€å®šç¨‹åº¦åŒæ­¥çš„ replica ç»„æˆäº† ISR In-Sync Replicasï¼ŒISR æ˜¯ AR çš„å­é›†ï¼ŒISR åŒ…å«äº† leaderã€‚leader æ¥æ”¶åˆ°ç”Ÿäº§è€…å‘é€çš„æ¶ˆæ¯åï¼Œfollower æ‰èƒ½ä» leader ä¸Šæ‹‰å–æ¶ˆæ¯è¿›è¡ŒåŒæ­¥ï¼ŒåŒæ­¥æœŸé—´å†… follower ç›¸å¯¹äº leader ä¼šæœ‰ä¸€å®šç¨‹åº¦çš„æ»åï¼Œæ‰€è°“çš„â€œä¸€å®šç¨‹åº¦â€æŒ‡å¯ä»¥å¿å—çš„æ»åæ—¶é—´ï¼Œè¿™ä¸ªæ»åæ—¶é—´å¯ä»¥é€šè¿‡ä¿®æ”¹é…ç½®è¿›è¡Œè°ƒæ•´ã€‚ç›¸è¾ƒäº leader æ»åè¿‡å¤šçš„å‰¯æœ¬ä¼šç»„æˆ OSR Out-Sync Relipcasï¼ŒAR = ISR + OSRã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼Œæ‰€æœ‰çš„ follower éƒ½åº”è¯¥ä¸ leader ä¿æŒä¸€å®šç¨‹åº¦çš„åŒæ­¥ï¼Œå³AR = ISR, OSR = Ã˜ã€‚\nLeader è´Ÿè´£ç»´æŠ¤å’Œè·Ÿè¸ªæ‰€æœ‰ follower çš„æ»åçŠ¶æ€ï¼Œå½“ follower è½åå¤ªå¤šæˆ–è€…å¤±æ•ˆæ—¶ï¼Œleader ä¼šå°†å…¶ä» ISR é›†åˆä¸­å‰”é™¤ï¼›å¦‚æœ OSR é›†åˆä¸­çš„ follower è¿½ä¸Šäº† leaderï¼Œleader åˆ™ä¼šå°†å…¶åŠ å…¥ ISR é›†åˆã€‚åªæœ‰ ISR é›†åˆä¸­çš„ follower æ‰æœ‰èµ„æ ¼è¢«é€‰ä¸¾ä¸ºleaderã€‚ä½†å¦‚æœå½“ ISR é›†åˆå˜ä¸ºç©ºé›†ï¼Œå³ leader å¤±æ•ˆï¼Œä¸”æ²¡æœ‰å…¶ä»–ä»»ä½•ä¸€ä¸ª follower ä¸ leader ä¹‹å‰çš„çŠ¶æ€ä¸€è‡´æ—¶ï¼Œå¯ä»¥é€šè¿‡ä¿®æ”¹é…ç½®å¼€å¯ Unclean Leader Electionï¼Œä½¿å¾— OSR é›†åˆä¸­çš„ follower å¯ä»¥æˆä¸ºæ–°çš„ leaderã€‚è¿™æ ·å¯èƒ½ä¼šé€ æˆæ•°æ®çš„é‡å¤æ¶ˆè´¹ï¼Œä½†å¥½å¤„æ˜¯å®ƒä½¿å¾— partition è‡³å°‘æœ‰ä¸€ä¸ª leader å¹¶å¯ä»¥ç»§ç»­æä¾›æœåŠ¡ï¼Œä»è€Œæé«˜äº†é«˜å¯ç”¨æ€§ã€‚åœ¨è¿™ä¸ªé—®é¢˜ä¸Šï¼ŒKafka èµ‹äºˆäº†å¼€å‘è€…é€‰æ‹© CAP ç†è®ºä¸­ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰å’Œå¯ç”¨æ€§ï¼ˆAvailabilityï¼‰çš„æƒåˆ©ã€‚\npartition åˆ†é… åœ¨åˆ›å»º topic æ—¶ï¼ŒKafka æœåŠ¡å™¨é¦–å…ˆä¼šå†³å®šå¦‚ä½•åœ¨ broker é—´åˆ†é… replicaï¼Œåˆ†é…æœ‰ä¸‰ä¸ªç›®æ ‡ï¼š\n å°½å¯èƒ½åœ¨ broker é—´å¹³å‡åœ°åˆ†å¸ƒ replica ç¡®ä¿æ¯ä¸ª replica åˆ†å¸ƒåœ¨ä¸åŒçš„ broker ä¸Š å¦‚æœä¸º broker æŒ‡å®šäº†æœºæ¶ä¿¡æ¯ï¼Œé‚£ä¹ˆå°½å¯èƒ½æŠŠæ¯ä¸ª replica åˆ†é…åˆ°ä¸åŒæœºæ¶çš„ broker ä¸Šï¼Œä¿è¯åœ¨ä¸€ä¸ªæœºæ¶ä¸å¯ç”¨çš„æƒ…å†µä¸‹ä¸ä¼šå¯¼è‡´æ•´ä¸ª partition ä¸å¯ç”¨  å¦‚ä¸‹æ˜¯åˆ†é…çš„æµç¨‹ï¼š\nobject AdminUtils extends Logging { def assignReplicasToBrokers(brokerMetadatas: Iterable[BrokerMetadata], nPartitions: Int, replicationFactor: Int, fixedStartIndex: Int = -1, startPartitionId: Int = -1): Map[Int, Seq[Int]] = { if (nPartitions \u0026lt;= 0) throw new InvalidPartitionsException(\u0026#34;Number of partitions must be larger than 0.\u0026#34;) if (replicationFactor \u0026lt;= 0) throw new InvalidReplicationFactorException(\u0026#34;Replication factor must be larger than 0.\u0026#34;) if (replicationFactor \u0026gt; brokerMetadatas.size) throw new InvalidReplicationFactorException(s\u0026#34;Replication factor: $replicationFactorlarger than available brokers: ${brokerMetadatas.size}.\u0026#34;) // æ²¡æœ‰æŒ‡å®šæœºæ¶  if (brokerMetadatas.forall(_.rack.isEmpty)) assignReplicasToBrokersRackUnaware(nPartitions, replicationFactor, brokerMetadatas.map(_.id), fixedStartIndex, startPartitionId) else { if (brokerMetadatas.exists(_.rack.isEmpty)) throw new AdminOperationException(\u0026#34;Not all brokers have rack information for replica rack aware assignment.\u0026#34;) // æŒ‡å®šæœºæ¶  assignReplicasToBrokersRackAware(nPartitions, replicationFactor, brokerMetadatas, fixedStartIndex, startPartitionId) } } // æ²¡æœ‰æŒ‡å®šæœºæ¶  private def assignReplicasToBrokersRackUnaware(nPartitions: Int, replicationFactor: Int, brokerList: Iterable[Int], fixedStartIndex: Int, startPartitionId: Int): Map[Int, Seq[Int]] = { val ret = mutable.Map[Int, Seq[Int]]() val brokerArray = brokerList.toArray // éšæœºé€‰å–ä¸€ä¸ª broker ä½œä¸ºèµ·å§‹ä½ç½® startIndex  val startIndex = if (fixedStartIndex \u0026gt;= 0) fixedStartIndex else rand.nextInt(brokerArray.length) // å½“å‰å½“å‰ partition çš„ id è®¾ç½®ä¸º 0  var currentPartitionId = math.max(0, startPartitionId) // éšæœºé€‰å– broker çš„ä½ç§»  var nextReplicaShift = if (fixedStartIndex \u0026gt;= 0) fixedStartIndex else rand.nextInt(brokerArray.length) for (_ \u0026lt;- 0 until nPartitions) { // åœ¨éå†è¿‡ broker æ•°ç›®ä¸ª partition åå°†ä½ç§»åŠ ä¸€  if (currentPartitionId \u0026gt; 0 \u0026amp;\u0026amp; (currentPartitionId % brokerArray.length == 0)) nextReplicaShift += 1 // å½“å‰ partition çš„ id åŠ ä¸Šèµ·å§‹ä½ç½®ï¼Œå¯¹ brokersize å–ä½™å¾—åˆ°ç¬¬ä¸€ä¸ªå‰¯æœ¬çš„ä½ç½®  val firstReplicaIndex = (currentPartitionId + startIndex) % brokerArray.length val replicaBuffer = mutable.ArrayBuffer(brokerArray(firstReplicaIndex)) for (j \u0026lt;- 0 until replicationFactor - 1) // è®¡ç®—å‡ºæ¯ä¸ªå‰¯æœ¬çš„ä½ç½®  replicaBuffer += brokerArray(replicaIndex(firstReplicaIndex, nextReplicaShift, j, brokerArray.length)) ret.put(currentPartitionId, replicaBuffer) //åˆ†åŒº id åŠ ä¸€  currentPartitionId += 1 } ret } } ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾ç°åœ¨æœ‰ 6 ä¸ªbrokerï¼Œæˆ‘ä»¬æ‰“ç®—åˆ›å»ºä¸€ä¸ªåŒ…å« 10 ä¸ª partition çš„topicï¼Œreplication factor = 3ï¼Œé‚£ä¹ˆæ€»å…±åº”è¯¥æœ‰ 30 ä¸ª replicaã€‚ä¸ºäº†å®ç°è¿™ä¸ªç›®æ ‡ï¼Œæˆ‘ä»¬éšæœºé€‰æ‹©ä¸€ä¸ª brokerï¼ˆå‡è®¾æ˜¯ 4ï¼‰ï¼Œç„¶åä½¿ç”¨è½®è¯¢çš„æ–¹å¼ç»™æ¯ä¸ª broker åˆ†é… partition æ¥ç¡®å®š leader çš„ä½ç½®ï¼Œäºæ˜¯ leader0 ä¼šåœ¨ broker 4 ä¸Šï¼Œleader 1 åœ¨ broker 5 ä¸Šï¼Œleader 2 åœ¨ broker 0 ä¸Šï¼Œä»¥æ­¤ç±»æ¨ã€‚ç„¶åä» leader å¼€å§‹ï¼Œä¾æ¬¡åˆ†é… followerï¼Œæ—¢ç„¶ leader 0 åœ¨ broker 4 ä¸Šï¼Œé‚£ä¹ˆå®ƒçš„ follower å°±ä¼šä¾æ¬¡åˆ†å¸ƒåœ¨ broker 5, broker 0ï¼›leader 1 åœ¨ broker 5 ä¸Šï¼Œé‚£ä¹ˆå®ƒçš„ follower å°±ä¼šä¾æ¬¡åˆ†å¸ƒåœ¨ broker 0, broker 1 ä¸Šã€‚å¦‚æœé…ç½®äº†æœºæ¶ä¿¡æ¯ï¼Œé‚£ä¹ˆå°±ä¼šæŒ‰ç…§äº¤æ›¿æœºæ¶çš„æ–¹å¼æ¥é€‰æ‹© brokerã€‚\n4.2 æ¶ˆæ¯å¤„ç† Kafka æœåŠ¡å™¨é‡‡ç”¨ Reactor æ¨¡å¼å¤„ç†æ¶ˆæ¯ã€‚Reactor æ¨¡å¼æ˜¯äº‹ä»¶é©±åŠ¨æ¶æ„çš„ä¸€ç§å®ç°æ–¹å¼ï¼Œé€‚ç”¨äºå¤„ç†å¤šä¸ªå®¢æˆ·ç«¯å¹¶å‘å‘æœåŠ¡å™¨ç«¯å‘èµ·è¯·æ±‚çš„åœºæ™¯ï¼Œå¤šä¸ªå®¢æˆ·ç«¯ä¼šå‘é€è¯·æ±‚ç»™ Reactorï¼ŒReactor çš„è¯·æ±‚åˆ†å‘çº¿ç¨‹ Acceptor å°†ä¸åŒçš„è¯·æ±‚åˆ†å‘ç»™å¤šä¸ªå·¥ä½œçº¿ç¨‹ worker thread å¤„ç†ã€‚\nbroker ä¸Šæœ‰ä¸€ä¸ª SocketServer ç»„ä»¶ï¼Œç±»ä¼¼äº Reactor æ¨¡å¼ä¸­çš„ Dispatcherï¼ŒåŒ…æ‹¬å¯¹åº”çš„ Acceptor çº¿ç¨‹å’Œå·¥ä½œçº¿ç¨‹æ± ï¼ˆåœ¨ Kafka ä¸­å«åšç½‘ç»œçº¿ç¨‹æ± ï¼Œé»˜è®¤å€¼ä¸º 3 ä¸ªï¼‰ã€‚Acceptor çº¿ç¨‹é‡‡ç”¨è½®è¯¢çš„æ–¹å¼å°†æµé‡å…¬å¹³åœ°åˆ†å‘ç»™æ‰€æœ‰ç½‘ç»œçº¿ç¨‹ï¼Œé¿å…äº†è¯·æ±‚å¤„ç†çš„å€¾æ–œï¼Œæœ‰åˆ©äºå®ç°è¾ƒä¸ºå…¬å¹³çš„è¯·æ±‚å¤„ç†è°ƒåº¦ã€‚\nç½‘ç»œçº¿ç¨‹è·å–åˆ°è¯·æ±‚åï¼Œå¹¶ä¸ä¼šç«‹å³å¤„ç†ï¼Œè€Œæ˜¯å°†è¯·æ±‚æ”¾å…¥åˆ°å…±äº«è¯·æ±‚é˜Ÿåˆ—ä¸­ï¼›éšåï¼ŒIO çº¿ç¨‹æ± ï¼ˆé»˜è®¤æœ‰ 8 ä¸ªï¼‰è´Ÿè´£ä»å…±äº«è¯·æ±‚é˜Ÿåˆ—ä¸­å–å‡ºè¯·æ±‚ï¼Œå¹¶æ‰§è¡ŒçœŸæ­£çš„å¤„ç†ï¼Œå¦‚æœæ˜¯ç”Ÿäº§è€…å‘é€çš„ push requestï¼Œåˆ™å°†æ¶ˆæ¯å†™å…¥åˆ°åº•å±‚çš„ç£ç›˜æ—¥å¿—ä¸­ï¼Œå¦‚æœæ˜¯æ¶ˆè´¹è€…å‘é€çš„ pull requestï¼Œåˆ™ä»ç£ç›˜æˆ–é¡µç¼“å­˜ä¸­è¯»å–æ¶ˆæ¯ã€‚IO çº¿ç¨‹å¤„ç†å®Œè¯·æ±‚åï¼Œä¼šå°†ç”Ÿæˆçš„å“åº”å‘é€åˆ°ç½‘ç»œçº¿ç¨‹æ± çš„å“åº”é˜Ÿåˆ—ä¸­ï¼Œç„¶åç”±å¯¹åº”çš„ç½‘ç»œçº¿ç¨‹å°† response è¿”å›ç»™å®¢æˆ·ç«¯ï¼›å…¶ä¸­è¯·æ±‚é˜Ÿåˆ—æ˜¯æ‰€æœ‰ç½‘ç»œçº¿ç¨‹å…±äº«çš„ï¼Œè€Œå“åº”é˜Ÿåˆ—æ˜¯æ¯ä¸ªç½‘ç»œçº¿ç¨‹ä¸“å±çš„ã€‚åœ¨ IO çº¿ç¨‹æ± å’Œç›¸åº”é˜Ÿåˆ—ä¹‹é—´è¿˜æœ‰ä¸€ä¸ª Purgatory ç»„ä»¶ï¼Œç”¨äºç¼“å­˜å»¶æ—¶è¯·æ±‚ã€‚\n4.3 ç‰©ç†å­˜å‚¨ Kafka çš„åŸºæœ¬å­˜å‚¨å•å…ƒæ˜¯ partitionï¼Œpartition æ— æ³•åœ¨å¤šä¸ª broker é—´å†è¿›è¡Œç»†åˆ†ï¼Œä¹Ÿæ— æ³•åœ¨åŒä¸€ä¸ª broker çš„å¤šä¸ªç£ç›˜ä¸Šå†è¿›è¡Œç»†åˆ†ã€‚å› æ­¤ï¼Œpartition çš„å¤§å°å—åˆ°å•ä¸ªæŒ‚è½½ç‚¹å¯ç”¨ç©ºé—´çš„é™åˆ¶ï¼ˆä¸€ä¸ªæŒ‚è½½ç‚¹ç”±å•ä¸ªç£ç›˜æˆ–å¤šä¸ªç£ç›˜ç»„æˆï¼Œå¦‚æœé…ç½®äº†JBOD å±äºå•ä¸ªç£ç›˜ï¼ŒRAID å±äºå¤šä¸ªç£ç›˜ï¼‰ã€‚åœ¨é…ç½® Kafka çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‡å®šç”¨äºå­˜å‚¨ partition çš„ç›®å½•ã€‚\næ–‡ä»¶ç®¡ç† æˆ‘ä»¬å¯ä»¥å•ç‹¬ä¸ºæ¯ä¸€ä¸ª topic é…ç½®æ•°æ®ä¿ç•™è§„åˆ™ï¼Œè§„å®šæ•°æ®è¢«åˆ é™¤ä¹‹å‰å¯ä»¥ä¿ç•™å¤šé•¿æ—¶é—´ï¼Œæˆ–è€…æ¸…ç†æ•°æ®ä¹‹å‰å¯ä»¥ä¿ç•™çš„æ•°æ®é‡å¤§å°ã€‚\nå› ä¸ºåœ¨ä¸€ä¸ªå¤§æ–‡ä»¶é‡ŒæŸ¥æ‰¾å’Œåˆ é™¤æ¶ˆæ¯æ˜¯å¾ˆè€—æ—¶çš„ï¼Œå› æ­¤æˆ‘ä»¬æŠŠ partition åˆ†æˆè‹¥å¹²ä¸ªç‰‡æ®µ segmentã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ¯ä¸ª segment åŒ…å« 1GB æˆ–ä¸€å‘¨çš„æ•°æ®ï¼ˆä»¥è¾ƒå°çš„ä¸ºå‡†ï¼‰ã€‚å½“ broker å¾€ partition å†™å…¥æ•°æ®æ—¶ï¼Œå¦‚æœå½“å‰ segment è¾¾åˆ°ä¸Šé™ï¼Œåˆ™å…³é—­å½“å‰æ–‡ä»¶å¹¶æ‰“å¼€ä¸€ä¸ªæ–°æ–‡ä»¶è¿›è¡Œå†™å…¥ï¼Œå½“å‰æ­£åœ¨å†™å…¥æ•°æ®çš„ segment å«ä½œæ´»è·ƒç‰‡æ®µ active segmentï¼Œactive segment æ°¸è¿œä¸ä¼šè¢«åˆ é™¤ã€‚\nsegment ç”±ç´¢å¼•æ–‡ä»¶ index file å’Œæ•°æ®æ–‡ä»¶ data file ç»„æˆï¼Œä¸¤ä¸ªæ–‡ä»¶ä¸€ä¸€å¯¹åº”ï¼Œæˆå¯¹å‡ºç°ï¼Œåç¼€åˆ†åˆ«ä¸º .index å’Œ .logï¼›å…¶å‘½åè§„åˆ™ä¸ºï¼špartition ä¸­å…¨å±€çš„ç¬¬ä¸€ä¸ª segment ä» 0 å¼€å§‹ï¼Œåç»­æ¯ä¸ª segment ä¸ºä¸Šä¸€ä¸ª segment æœ€åä¸€æ¡æ¶ˆæ¯çš„ offset å€¼ï¼š\n$ ll 0000000000000000000.index 0000000000000000000.log 0000000000000368769.ndex 0000000000000368769.log 0000000000000737337.index 0000000000000737337.log 0000000000001105814.index 0000000000001105814.log broker ä¼šä¸ºæ¯ä¸ª segment ç»´æŠ¤ä¸€ä¸ªæ–‡ä»¶å¥æŸ„ï¼Œå³ä½¿ segment æ˜¯ä¸æ´»è·ƒçš„ã€‚\nå› ä¸º segment ä¸­ä¿å­˜çš„æ•°æ®æ ¼å¼ä¸ç”Ÿäº§è€…å‘é€è¿‡æ¥ï¼Œä»¥åŠå‘é€ç»™æ¶ˆè´¹è€…çš„æ•°æ®æ ¼å¼éƒ½æ˜¯ä¸€è‡´çš„ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨é›¶æ‹·è´ zero copy æŠ€æœ¯æ¥å°†æ•°æ®æ‹·è´åˆ°é¡µç¼“å­˜ page cache ä¸­ï¼ŒåŒæ—¶é¿å…å¯¹ç”Ÿäº§è€…å·²ç»å‹ç¼©è¿‡çš„æ¶ˆæ¯è¿›è¡Œè§£å‹å’Œå‹ç¼©ã€‚åŒæ—¶ï¼Œæ¥æ”¶æ•°æ®æ—¶å¹¶ä¸éœ€è¦ç­‰å¾…æ•°æ®è¢«å†™å…¥ç£ç›˜ï¼Œè€Œæ˜¯åªè¦ç¡®è®¤æ•°æ®è¢«å†™å…¥åˆ°é¡µç¼“å­˜å³å¯ï¼Œéšåæ“ä½œç³»ç»Ÿä¼šæ ¹æ® LRU ç®—æ³•å®šæœŸå°†é¡µç¼“å­˜ä¸Šçš„è„æ•°æ®å†™åˆ°ç‰©ç†ç£ç›˜ä¸Šï¼Œè¿™é‡Œçš„å®šæœŸæ—¶é—´é—´éš”æ˜¯ç”±æäº¤æ—¶é—´æ¥ç¡®å®šçš„ï¼Œé»˜è®¤æ˜¯ 5 ç§’ã€‚\næ–‡ä»¶å‹ç¼© æ—¥å¿—å‹ç¼©æ˜¯Kafka çš„ä¸€ä¸ªé«˜çº§ç‰¹æ€§ï¼Œå› ä¸ºæœ‰äº†è¿™ä¸ªç‰¹æ€§ï¼ŒKafka å¯ä»¥ç”¨æ¥é•¿æ—¶é—´åœ°ä¿å­˜æ•°æ®ã€‚\né™¤äº† key, value, offset ä¹‹å¤–ï¼Œç”Ÿäº§è€…å‘é€æ¥çš„æ¶ˆæ¯é‡Œè¿˜åŒ…å«äº†æ¶ˆæ¯å¤§å°ã€æ ¡éªŒå’Œã€æ¶ˆæ¯æ ¼å¼ç‰ˆæœ¬å·ã€å‹ç¼©ç®—æ³•å’Œæ—¶é—´æˆ³ç­‰ä¿¡æ¯ï¼Œæ—¶é—´æˆ³å¯ä»¥æ˜¯ç”Ÿäº§è€…å‘é€æ¶ˆæ¯çš„æ—¶é—´ï¼Œä¹Ÿå¯ä»¥æ˜¯æ¶ˆæ¯åˆ°è¾¾broker çš„æ—¶é—´ï¼ˆå¯é…ç½®ï¼‰ï¼›å¦‚æœç”Ÿäº§è€…å‘é€çš„æ˜¯å‹ç¼©è¿‡çš„æ¶ˆæ¯ï¼Œé‚£ä¹ˆåŒä¸€ä¸ª batch çš„æ¶ˆæ¯ä¼šè¢«å‹ç¼©åœ¨ä¸€èµ·ï¼Œè¢«å½“ä½œåŒ…è£…æ¶ˆæ¯ Wrapper messageï¼›æ­¤åï¼Œbroker å†æŠŠè¿™ä¸ªæ¶ˆæ¯ç»„å‘é€ç»™æ¶ˆè´¹è€…ã€‚\nKafka å°†æ¶ˆæ¯æ„é€ ä¸ºé€’å½’çš„æ¨¡å¼ï¼Œå¤–å±‚æ˜¯ä¸€ä¸ªåŒ…è£…æ¶ˆæ¯ï¼Œå…¶å€¼åˆæ˜¯ä¸€ä¸ªæ¶ˆæ¯é›†åˆï¼Œç§°ä¸ºå†…å±‚æ¶ˆæ¯ Inner messageï¼Œå¤–å±‚æ¶ˆæ¯å¯èƒ½æœ‰å¤šæ¡ï¼Œæ¯æ¡å¤–å±‚æ¶ˆæ¯çš„å€¼éƒ½åŒ…è£…äº†å¤šæ¡å†…å±‚æ¶ˆæ¯ï¼Œåœ¨å¤–å±‚æŒ‡å®šä¸€ä¸ªå‹ç¼©æ–¹æ³•ï¼Œå†å¯¹å†…å±‚æ¶ˆæ¯ä½¿ç”¨è¿™ç§å‹ç¼©æ–¹æ³•è¿›è¡Œè§£å‹ç¼©å³å¯ã€‚\nå¼•ç”¨ Mirror of Apache Kafka - GitHub\nApache Kafka Documentation\nKafka æƒå¨æŒ‡å—\næ·±å…¥ç†è§£ Kafka\nApache Kafkaå®æˆ˜\nKafka åˆ†åŒºæœºåˆ¶äº§ç”Ÿçš„æ¶ˆæ¯æ¨é€å’Œæ¶ˆè´¹é€»è¾‘ \n","permalink":"http://zintrulcre.github.io/posts/message-broker/kafka/","summary":"Kafka å…¥é—¨ æ¦‚è¿° Kafka æœ€åˆæ˜¯ä¸ºäº†è§£å†³ LinkedIn æ•°æ®ç®¡é“é—®é¢˜åº”è¿è€Œç”Ÿçš„ã€‚å®ƒçš„è®¾è®¡ç›®çš„æ˜¯æä¾›ä¸€ä¸ªé«˜æ€§èƒ½çš„æ¶ˆæ¯ç³»ç»Ÿï¼Œå¯ä»¥å¤„ç†å¤šç§æ•°æ®ç±»å‹ï¼Œå¹¶èƒ½å¤Ÿå®æ—¶æä¾›çº¯å‡€ä¸”ç»“æ„åŒ–çš„ç”¨æˆ·æ´»åŠ¨æ•°æ®å’Œç³»ç»Ÿåº¦é‡æŒ‡æ ‡ã€‚\nå®ƒä¸åªæ˜¯ä¸€ä¸ªæ•°æ®å­˜å‚¨ç³»ç»Ÿï¼ˆç±»ä¼¼äºä¼ ç»Ÿçš„å…³ç³»å‹æ•°æ®åº“ã€é”®å€¼å­˜å‚¨å¼•æ“ã€æœç´¢å¼•æ“æˆ–ç¼“å­˜ç³»ç»Ÿï¼‰ï¼Œè¿˜æ˜¯ä¸€ä¸ªæŒç»­å˜åŒ–å’Œä¸æ–­å¢é•¿çš„æµå¤„ç†ç³»ç»Ÿã€‚ç°åœ¨ Kafka å·²ç»è¢«å¹¿æ³›åœ°åº”ç”¨åœ¨ç¤¾äº¤ç½‘ç»œçš„å®æ—¶æ•°æ®æµå¤„ç†å½“ä¸­ï¼Œæˆä¸ºäº†ä¸‹ä¸€ä»£æ•°æ®æ¶æ„çš„åŸºç¡€ã€‚Kafka ç»å¸¸ä¼šè¢«æ‹¿æ¥ä¸ç°æœ‰çš„ä¼ä¸šçº§æ¶ˆæ¯ç³»ç»Ÿã€å¤§æ•°æ®ç³»ç»Ÿï¼ˆå¦‚ Hadoopï¼‰å’Œæ•°æ®é›†æˆ ETL å·¥å…·ç­‰æŠ€æœ¯ä½œæ¯”è¾ƒã€‚\nä»å‘å¸ƒå’Œè®¢é˜…æ¶ˆæ¯æµçš„è§’åº¦æ¥çœ‹ï¼ŒKafka ç±»ä¼¼äº ActiveMQã€RabbitMQ æˆ– IBM çš„ MQSeries ç­‰äº§å“ï¼Œå…¶ç‰¹ç‚¹åœ¨äºå®ƒä»¥é›†ç¾¤çš„æ–¹å¼è¿è¡Œï¼Œå¯ä»¥è‡ªç”±ä¼¸ç¼©ï¼Œå¤„ç†å¤§é‡çš„åº”ç”¨ç¨‹åºï¼›å…¶æ¬¡ï¼ŒKafka å¯ä»¥æŒ‰ç…§è¦æ±‚æŒä¹…åŒ–æ•°æ®ï¼Œå³æä¾›äº†æ•°æ®ä¼ é€’çš„ä¿è¯â€”â€”å¯å¤åˆ¶ã€æŒä¹…åŒ–ï¼Œä¿ç•™å¤šé•¿æ—¶é—´å®Œå…¨å¯ä»¥ç”±å¼€å‘è€…å†³å®šã€‚æ­¤å¤–ï¼Œæ¶ˆæ¯ç³»ç»Ÿåªä¼šä¼ é€’æ¶ˆæ¯ï¼Œè€Œ Kafka çš„æµå¼å¤„ç†èƒ½åŠ›è®©æˆ‘ä»¬åªç”¨å¾ˆå°‘çš„ä»£ç å°±èƒ½å¤ŸåŠ¨æ€åœ°å¤„ç†æ´¾ç”Ÿæµå’Œæ•°æ®é›†ã€‚\n1 åŸºç¡€æ¦‚å¿µ æ¶ˆæ¯ä»£ç† åœ¨ä¸€ä¸ªåŸºäºå‘å¸ƒä¸è®¢é˜…çš„æ¶ˆæ¯ç³»ç»Ÿä¸­ï¼Œæ•°æ®æ¶ˆæ¯çš„å‘é€è€…ä¸ç›´æ¥æŠŠæ¶ˆæ¯å‘é€ç»™æ¥æ”¶è€…ï¼Œè€Œæ˜¯é€šè¿‡ä¸€ä¸ªæ¶ˆæ¯ä»£ç† message broker ä¼ é€’æ¶ˆæ¯ï¼Œæ¥æ”¶è€…è®¢é˜…æ¶ˆæ¯ä»£ç†ï¼Œå¹¶ä»¥ç‰¹å®šçš„æ–¹å¼æ¥æ”¶æ¶ˆæ¯ã€‚Kafka å°±æ˜¯ä¸€ä¸ªæ¶ˆæ¯ä»£ç†ã€‚\næ¶ˆæ¯ä»£ç† message broker æ˜¯ä¸€ç§é’ˆå¯¹å¤„ç†æ¶ˆæ¯æµè€Œä¼˜åŒ–çš„æ•°æ®åº“ï¼Œå®ƒä½œä¸ºç‹¬ç«‹çš„ä¸­é—´æœåŠ¡è¿è¡Œï¼Œç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä½œä¸ºå®¢æˆ·ç«¯è¿æ¥åˆ°æ¶ˆæ¯ä»£ç†æœåŠ¡ï¼Œåœ¨ä½¿ç”¨æ¶ˆæ¯ä»£ç†çš„æ¶æ„ä¸­ä¸»è¦æœ‰ 3 ç§è§’è‰²ï¼š\n ç”Ÿäº§è€…å°†æ¶ˆæ¯å†™å…¥æ¶ˆæ¯ä»£ç†ï¼›ç”Ÿäº§è€…ä¸€èˆ¬æ˜¯å¼‚æ­¥æ¶æ„çš„ï¼Œå½“ç”Ÿäº§è€…å‘é€æ¶ˆæ¯æ—¶ï¼Œå®ƒåªä¼šç­‰å¾…æ¶ˆæ¯ä»£ç†ç¡®è®¤æ¶ˆæ¯å·²ç»è¢«ç¼“å­˜ï¼Œè€Œä¸ç­‰å¾…æ¶ˆæ¯è¢«æ¶ˆè´¹è€…å¤„ç† æ¶ˆæ¯ä»£ç†è´Ÿè´£æ¶ˆæ¯çš„å­˜å‚¨ï¼Œå‘é€ã€é‡ä¼ ç­‰ï¼Œä¸€èˆ¬ä¼šåŒ…å«å¤šä¸ªæ¶ˆæ¯é˜Ÿåˆ— message queue æ¶ˆè´¹è€…ä»æ¶ˆæ¯ä»£ç†æ¥æ”¶æ¶ˆæ¯å¹¶è¿›è¡Œå¤„ç†ï¼›æ¶ˆè´¹è€…åªä¾èµ–äºæ¶ˆæ¯ä»£ç†ï¼Œä¸ç”Ÿäº§è€…å®Œå…¨éš”ç¦»  æ¶ˆæ¯ä»£ç†çš„ä¼˜åŠ¿ä¸»è¦æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼š\n  å®ç°å¼‚æ­¥å¤„ç†ï¼Œæå‡æ€§èƒ½\næŠŠæ¶ˆæ¯å¤„ç†æµç¨‹ä½¿ç”¨æ¶ˆæ¯ä»£ç†å¼‚æ­¥åŒ–ï¼Œä¸ä¼šé˜»å¡ç”Ÿäº§è€…æœåŠ¡ï¼Œç”Ÿäº§è€…æœåŠ¡å¯ä»¥åœ¨å¾—åˆ°å¤„ç†ç»“æœä¹‹å‰ç»§ç»­æ‰§è¡Œï¼Œå¹¶æé«˜å…¶å¹¶å‘å¤„ç†çš„èƒ½åŠ›ã€‚\n  æé«˜ç³»ç»Ÿçš„å¯ä¼¸ç¼©æ€§\nç”Ÿäº§è€…å°†å¤§é‡æ¶ˆæ¯æ¨é€åˆ°æ¶ˆæ¯ä»£ç†ä¸­ï¼Œæ¶ˆæ¯ä»£ç†å¯ä»¥å°†è¿™äº›æ¶ˆæ¯åˆ†å‘ç»™ä¸åŒçš„æ¶ˆè´¹è€…ï¼Œä½¿å¾—å¤šä¸ªæ¶ˆè´¹è€…å¹¶è¡Œåœ°å¤„ç†æ¶ˆæ¯ï¼Œå½“æ¶ˆè´¹è€…è´Ÿè½½å˜åŒ–æ—¶ï¼Œå¯ä»¥å¾ˆå®¹æ˜“åœ°å¯¹æ¶ˆè´¹è€…æœåŠ¡è¿›è¡Œæ°´å¹³ä¼¸ç¼©\n  å‰Šå³°å¡«è°·\nå½“ç”Ÿäº§è€…æ¨é€æ¶ˆæ¯çš„é€Ÿåº¦æ¯”æ¶ˆè´¹è€…å¤„ç†æ¶ˆæ¯çš„é€Ÿåº¦æ›´å¿«æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—ä½œä¸ºæ¶ˆæ¯çš„ç¼“å†²ï¼Œæ¥å‰Šå¼±å³°å€¼æµé‡ï¼Œé˜²æ­¢ç³»ç»Ÿè¢«çŸ­æ—¶é—´å†…çš„æµé‡å†²å®\n  åº”ç”¨è§£è€¦\nä½¿ç”¨æ¶ˆæ¯ä»£ç†åï¼Œç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å³å¯è§£è€¦ï¼Œä¸å†éœ€è¦æœ‰ä»»ä½•è”ç³»ï¼Œä¹Ÿä¸éœ€è¦å—å¯¹æ–¹çš„å½±å“ï¼Œåªè¦ä¿æŒä½¿ç”¨ä¸€è‡´çš„æ¶ˆæ¯æ ¼å¼å³å¯ã€‚\n  æ¶ˆæ¯å’Œæ‰¹æ¬¡ Kafka çš„æ•°æ®å•å…ƒè¢«ç§°ä¸ºæ¶ˆæ¯ï¼Œæ¶ˆæ¯ç±»ä¼¼äºå…³ç³»å‹æ•°æ®åº“é‡Œçš„ä¸€ä¸ªæ•°æ®è¡Œæˆ–ä¸€æ¡è®°å½•ï¼›æ¶ˆæ¯ç”±å­—èŠ‚æ•°ç»„ç»„æˆï¼Œå½“æ¶ˆæ¯ä»¥ä¸€ç§å¯æ§çš„æ–¹å¼å†™å…¥ä¸åŒçš„åˆ†åŒºæ—¶ï¼Œä¼šç”¨åˆ° keyï¼ŒKafka ä¼šä¸º key ç”Ÿæˆä¸€ä¸ªä¸€è‡´æ€§æ•£åˆ—å€¼ï¼Œç„¶åä½¿ç”¨æ•£åˆ—å€¼å¯¹ä¸»é¢˜åˆ†åŒºæ•°è¿›è¡Œå–æ¨¡ï¼Œä¸ºæ¶ˆæ¯é€‰å–åˆ†åŒºã€‚è¿™æ ·å¯ä»¥ä¿è¯å…·æœ‰ç›¸åŒ key çš„æ¶ˆæ¯æ€»æ˜¯è¢«å†™åˆ°ç›¸åŒçš„åˆ†åŒºä¸Šã€‚","title":"Kafka å…¥é—¨"},{"content":"Prometheus å…¥é—¨ Prometheus æ˜¯ä¸€ä¸ªå¼€æºçš„ç›‘æ§è§£å†³æ–¹æ¡ˆï¼Œä¹Ÿæ˜¯äº‘åŸç”ŸåŸºé‡‘ä¼š CNCF çš„æ¯•ä¸šé¡¹ç›®ï¼Œå®ƒèƒ½å¤Ÿæä¾›æŒ‡æ ‡æ•°æ®çš„é‡‡é›†ã€å­˜å‚¨ã€æŸ¥è¯¢ã€å‘Šè­¦ç­‰åŠŸèƒ½ã€‚æœ¬æ–‡ä¸»è¦ä»‹ç» Prometheus çš„åŸºç¡€æ¦‚å¿µå’Œåº”ç”¨ä¸­éœ€è¦æ³¨æ„çš„ä¸€äº›é—®é¢˜ã€‚\n1 ç›‘æ§ç³»ç»Ÿ 1.1 ç›‘æ§æ¨¡å¼ ç›‘æ§ç³»ç»Ÿæ‰§è¡Œç›‘æ§æ£€æŸ¥çš„æ¨¡å¼æœ‰ä¸¤ç§ï¼Œåˆ†åˆ«æ˜¯ pull å’Œ pushã€‚Prometheus é‡‡ç”¨äº† pull æ¨¡å¼è¿›è¡Œæ•°æ®æ”¶é›†ï¼ŒåŒæ—¶ä¹Ÿæ”¯æŒä½¿ç”¨ Pushgateway çš„ push æ¨¡å¼è¿›è¡Œæ•°æ®ä¸­è½¬ã€‚\npull æ–¹å¼çš„ç‰¹ç‚¹æ˜¯æœ‰æ‹‰å–é—´éš”ï¼Œä¸èƒ½åŠæ—¶è·å–æ•°å€¼çš„å˜åŒ–ï¼Œå› æ­¤éœ€è¦è¿›ä¸€æ­¥çš„æ•°æ®å¤„ç†ï¼›å®ƒçš„ä¼˜ç‚¹æ˜¯åœ¨å‘Šè­¦æ—¶å¯ä»¥æŒ‰ç…§ç­–ç•¥åˆ†ç‰‡ï¼Œä»…æ‹‰å–éœ€è¦çš„æ•°æ®ï¼Œå¹¶ä¸”æ”¯æŒèšåˆåœºæ™¯ï¼›ç¼ºç‚¹æ˜¯ç›‘æ§çš„æ•°æ®é‡åºå¤§ï¼Œå¯¹å­˜å‚¨æœ‰è¾ƒé«˜çš„è¦æ±‚ï¼Œåˆ‡éœ€è¦è€ƒè™‘æ•°æ®çš„å†·çƒ­åˆ†ç¦»ã€‚\npush æ–¹å¼çš„ç‰¹ç‚¹æ˜¯ç”±æœåŠ¡ä¸»åŠ¨å°†æ•°æ®æ¨å‘ç›‘æ§ç³»ç»Ÿï¼Œå®æ—¶æ€§æ›´é«˜ï¼›å®ƒçš„ç¼ºç‚¹æ˜¯æ¨é€æ•°æ®çš„ä¸å¯é¢„çŸ¥æ€§ï¼Œå› ä¸ºå½“å¤§é‡æ•°æ®è¢«æ¨é€åˆ°ç›‘æ§ç³»ç»Ÿæ—¶ï¼Œæ•°æ®çš„ç¼“å­˜å’Œè§£æä¼šæ¶ˆè€—å¤§é‡èµ„æºï¼Œæ­¤æ—¶å¦‚æœå› ä¸ºç½‘ç»œåŸå› æ•°æ®çš„æ”¶å‘æ²¡æœ‰å¾—åˆ°ç¡®è®¤ï¼Œå¾ˆå®¹æ˜“äº§ç”Ÿæ•°æ®çš„é‡å‘å’Œé‡å¤ï¼Œå› æ­¤éœ€è¦è¿›è¡Œå»é‡ç­‰æ“ä½œã€‚\npull æ¨¡å¼åœ¨äº‘åŸç”Ÿç¯å¢ƒä¸­æ›´æœ‰ä¼˜åŠ¿ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥é€šè¿‡æœåŠ¡å‘ç°å¯¹æ‰€æœ‰éœ€è¦è¿›è¡Œç›‘æ§çš„èŠ‚ç‚¹è¿›è¡Œç»Ÿä¸€çš„æ•°æ®æ‹‰å–ï¼Œå¦‚æœä½¿ç”¨ push æ¨¡å¼åˆ™éœ€è¦åœ¨æ¯ä¸ªè¢«ç›‘æ§çš„æœåŠ¡ä¸­éƒ¨ç½²ä¸ŠæŠ¥æ•°æ®çš„å®¢æˆ·ç«¯ï¼Œå¹¶é…ç½®ç›‘æ§æœåŠ¡å™¨çš„ä¿¡æ¯ï¼Œè¿™ä¼šåŠ å¤§éƒ¨ç½²çš„éš¾åº¦ã€‚\n1.2 Prometheus Prometheus æ˜¯ä¸€å¥—å¼€æºçš„æ•°æ®é‡‡é›†ä¸ç›‘æ§æ¡†æ¶ï¼Œå¯ä»¥åšåå°æœåŠ¡å™¨çš„ç›‘æ§å‘Šè­¦ï¼Œæ­¤å¤„ç”¨æ¥é‡‡é›†è¢«æµ‹æœåŠ¡çš„æ€§èƒ½æŒ‡æ ‡æ•°æ®ï¼ŒåŒ…æ‹¬CPUå ç”¨æ¯”ç‡ã€å†…å­˜æ¶ˆè€—ã€ç½‘ç»œIOç­‰ã€‚\nç‰¹ç‚¹ Prometheus æœ€ä¸»è¦çš„ç‰¹ç‚¹æœ‰ 4 ä¸ªï¼š\n é€šè¿‡ PromQL å®ç°å¤šç»´åº¦æ•°æ®æ¨¡å‹çš„çµæ´»æŸ¥è¯¢ï¼›è¿™ä½¿å¾—ç›‘æ§æŒ‡æ ‡å¯ä»¥å…³è”åˆ°å¤šä¸ªæ ‡ç­¾ï¼Œå¹¶å¯¹æ—¶é—´åºåˆ—è¿›è¡Œåˆ‡ç‰‡å’Œåˆ‡å—ï¼Œä»¥æ”¯æŒå„ç§æŸ¥è¯¢å’Œå‘Šè­¦åœºæ™¯ å®šä¹‰äº†å¼€æ”¾æŒ‡æ ‡æ•°æ®çš„æ ‡å‡†ï¼Œå¯ä»¥æ–¹ä¾¿åœ°è‡ªå®šä¹‰æ¢é’ˆï¼ˆexporterï¼‰ åˆ©ç”¨ Pushgateway ç»„ä»¶å¯ä»¥ä»¥ push çš„æ–¹å¼æ¥æ”¶ç›‘æ§æ•°æ® æä¾›äº†å®¹å™¨åŒ–ç‰ˆæœ¬  æ¶æ„ Prometheus çš„æ¶æ„ä¸»è¦ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š\n  Prometheus Server\nPrometheus æœåŠ¡å™¨ä¸»è¦åŒ…å«äº†ä½¿ç”¨ pull æ¨¡å¼æŠ“å–ç›‘æ§æ•°æ®ï¼Œé€šè¿‡æœ¬åœ°å­˜å‚¨ï¼ˆæœ¬åœ°ç£ç›˜ï¼‰å’Œè¿œç¨‹å­˜å‚¨ï¼ˆOpenTSDB, InfluxDB, ElasticSearch ç­‰ï¼‰ä¿å­˜æ•°æ®ï¼Œä½¿ç”¨ PromQL æŸ¥è¯¢æ•°æ®ä¸‰å¤§åŠŸèƒ½ã€‚\nPromQL (Prometheus Query Language) æ˜¯ Prometheus å†…ç½®çš„æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼Œæä¾›äº†å¯¹æ—¶é—´åºåˆ—æ•°æ®çš„æŸ¥è¯¢ï¼Œèšåˆå’Œé€»è¾‘è¿ç®—ç­‰æ“ä½œçš„æ”¯æŒï¼Œè¢«å¹¿æ³›åœ°åº”ç”¨åœ¨æ•°æ®çš„æŸ¥è¯¢ï¼Œå¯è§†åŒ–å’Œå‘Šè­¦ä¸­ã€‚å…³äº PromQL çš„ç›¸å…³æ“ä½œå¯ä»¥å‚è€ƒ æ¢ç´¢PromQLã€‚\n  Pushgateway\nPushgateway æ˜¯ç”¨æ¥å®ç° push æ¨¡å¼ç›‘æ§çš„ç»„ä»¶ï¼Œä¸€èˆ¬åº”ç”¨äºçŸ­ä½œä¸šï¼Œæ‰¹å¤„ç†ä½œä¸šï¼Œæˆ–å½“æœåŠ¡ä¸ Prometheus æœåŠ¡å™¨ä¹‹é—´æœ‰ç½‘ç»œéš”ç¦»æ—¶ï¼›å®ƒçš„ä¸»è¦é—®é¢˜æ˜¯å­˜åœ¨å•ç‚¹æ•…éšœï¼Œä¸€ä¸ª Pushgateway çš„å®•æœºä¼šå¯¼è‡´æ‰€æœ‰è¢«æ¨é€åˆ°è¿™ä¸ª Pushgateway ä¸Šçš„æ•°æ®çš„ä¸¢å¤±ï¼Œå¦‚æœä½¿ç”¨å¤šä¸ª Pushgateway å®ä¾‹ç»„æˆçš„é›†ç¾¤ï¼Œé‚£ä¹ˆæ¯ä¸€æ¬¡æ•°æ®æ¨é€åªä¼šè¢«åˆ†å‘åˆ°å•ä¸ªå®ä¾‹ä¸Šï¼Œä½† Prometheus Server æ¯æ¬¡ä¼šåœ¨æ‰€æœ‰çš„ Pushgateway å®ä¾‹ä¸Šè¿›è¡Œæ•°æ®é‡‡é›†ï¼Œè¿™ä¼šå¯¼è‡´æ•°æ®é”™ä¹±ï¼Œç›®å‰å®˜æ–¹å¯¹æ­¤å¹¶æ²¡æœ‰è§£å†³æ–¹æ¡ˆï¼Œä¸€ä¸ªæ¯”è¾ƒå¥½çš„å¼€æºæ–¹æ¡ˆæ˜¯ä½¿ç”¨åŠ¨æ€ä¸€è‡´æ€§å“ˆå¸Œ + åŸºäº consul çš„ service checkï¼›é™¤æ­¤ä¹‹å¤–ï¼ŒPushgateway ä¸ä¼šè‡ªåŠ¨åˆ é™¤ä»»ä½•æŒ‡æ ‡æ•°æ®ï¼Œå³ä½¿åœ¨è¿›è¡Œè¿‡ push æ“ä½œçš„ pod è¢«é”€æ¯ä¹‹åï¼Œå…¶ä¸ŠæŠ¥çš„æ‰€æœ‰æ•°æ®ä»ç„¶æ®‹ç•™åœ¨ Pushgateway ä¸­ï¼Œéœ€è¦æ‰‹åŠ¨ã€‚\n  Job/Exporter\nJob å’Œ Exporter éƒ½æ˜¯ Prometheus çš„ target ç›‘æ§å¯¹è±¡ï¼›exporter çš„æœºåˆ¶æ˜¯å°†ç›‘æ§æ•°æ®æš´éœ²å‡ºæ¥ï¼ŒPrometheus å¯¹è¿™äº›æŒ‡æ ‡è¿›è¡Œé‡‡é›†ï¼›æ¯ä¸ª exporter éœ€è¦å•ç‹¬ç»´æŠ¤ï¼Œå¦‚æœæ•°é‡è¿‡å¤šå¯ä»¥è€ƒè™‘ä½¿ç”¨ Telegraf è¿›è¡Œç»Ÿä¸€ç®¡ç†ã€‚\n  Service Discovery\nç›¸æ¯”äºè¯»å–æ–‡ä»¶é…ç½®ï¼Œåœ¨äº‘åŸç”Ÿå’Œå®¹å™¨ç¯å¢ƒä¸‹è¢«ç›‘æ§å®ä¾‹éƒ½æ˜¯ä¼šåŠ¨æ€å˜åŒ–çš„ï¼Œè€Œé€šè¿‡æœåŠ¡å‘ç°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å¾ˆæ–¹ä¾¿åœ°è·å–éœ€è¦è¢«æ£€æ§çš„ target çš„å®ä¾‹ä¿¡æ¯ï¼›æœåŠ¡å‘ç°ä¸­çš„ relabeling æœºåˆ¶å¯ä»¥ä» target å®ä¾‹ä¸­è·å–å…ƒæ ‡ç­¾æ•°æ®ï¼Œä»è€Œå¯¹ä¸åŒå¼€å‘ç¯å¢ƒè¿›è¡ŒåŒºåˆ†ã€‚\n  Alertmanager\nPrometheus å°†æ•°æ®é‡‡é›†å’Œå‘Šè­¦åˆ†ç¦»æˆäº†ä¸¤ä¸ªæ¨¡å—ï¼Œå‘Šè­¦æ¨¡å—å«åš Alertmanagerï¼Œå®ƒæ˜¯ç‹¬ç«‹äº Prometheus çš„ä¸€ä¸ªç»„ä»¶ï¼Œéœ€è¦å•ç‹¬éƒ¨ç½²ï¼Œå¤šä¸ª Alertmanager å¯ä»¥é…ç½®ä¸ºä¸€ä¸ªé›†ç¾¤æ¥é¿å…å•ç‚¹é—®é¢˜ã€‚æŠ¥è­¦è§„åˆ™è¢«é…ç½®åœ¨ Prometheus Servers ä¸Šï¼Œäº§ç”Ÿå‘Šè­¦ä¿¡æ¯æ—¶ä¼šé€šçŸ¥ AlertMangerï¼ŒAlertManager ä¼šé€šè¿‡ silencing, inhibition ç­‰æ–¹å¼èšåˆï¼Œå¹¶é€šè¿‡ emailã€PagerDutyã€HipChatã€Slack ç­‰æ–¹å¼å‘é€å‘Šè­¦æç¤ºã€‚\n  Dashboard\nWeb UI, Grafana, API Client ç­‰ç»Ÿç§°ä¸º Dashboardã€‚\n  å±€é™æ€§  Prometheus æ˜¯åŸºäº metrics çš„ç³»ç»Ÿï¼Œä¸é€‚åˆå­˜å‚¨æ—¥å¿— Prometheus è®¤ä¸ºåªæœ‰è¿‘æœŸçš„æ•°æ®æ‰éœ€è¦è¢«æŸ¥è¯¢ï¼Œå› æ­¤æœ¬åœ°å­˜å‚¨åªä¼šä¿å­˜çŸ­æœŸæ•°æ®ï¼›TB çº§ä»¥ä¸Šçš„å†å²æ•°æ®éœ€è¦æ­é… OpenTSDB ç­‰è¿œç«¯å­˜å‚¨ä½¿ç”¨ Prometheus çš„é›†ç¾¤æ–¹æ¡ˆæœ‰ federation å’Œå¼€æºçš„ Thanosï¼Œä½†éƒ½å­˜åœ¨å„ç§ç»†èŠ‚ä¸Šçš„æŠ€æœ¯é—®é¢˜ï¼ˆå¦‚è€—å°½ CPU å’Œæœºå™¨èµ„æºï¼‰ï¼Œå…¶æˆç†Ÿåº¦éƒ½æ¯”ä¸ä¸Šåœ¨æ—¶åºæ•°æ®åº“ä¸­æ’åç¬¬ä¸€çš„ InfluxDB  2 æ•°æ®æ¨¡å‹ 2.1 æ—¶åºæ•°æ® Prometheus å­˜å‚¨çš„æ˜¯æ—¶åºæ•°æ®ï¼Œå³ç”±åç§° nameï¼Œæ ‡ç­¾ label ä¸å€¼ value å®šä¹‰çš„æŒ‡æ ‡ metricï¼›Prometheus ä¸­æ‰€æœ‰çš„æŒ‡æ ‡éƒ½æ˜¯æ—¶åºæ•°æ®ï¼Œå¹¶ä»¥åç§°å’Œæ ‡ç­¾è¿›è¡ŒåŒºåˆ†ï¼›å…·æœ‰ç›¸åŒåç§°å’Œæ ‡ç­¾çš„æ•°æ®å±äºç›¸åŒæ—¶åºï¼Œè¿™äº›æ—¶åºæ•°æ®æ‹¥æœ‰ä¸åŒçš„æ—¶é—´æˆ³ã€‚\næŒ‡æ ‡å‘½å æŒ‡æ ‡çš„åå­—ç”± ASCII å­—ç¬¦ï¼Œæ•°å­—ï¼Œä¸‹åˆ’çº¿ï¼Œä»¥åŠå†’å·ç»„æˆï¼Œä¸”æ»¡è¶³æ­£åˆ™è¡¨è¾¾å¼ [a-zA-Z0-9_:]*, å…¶å‘½ååº”è¯¥å…·æœ‰è¯­ä¹‰åŒ–ï¼Œç”¨äºè¡¨ç¤ºä¸€ä¸ªå¯ä»¥åº¦é‡çš„æŒ‡æ ‡ï¼Œä¾‹å¦‚ http_requests_totalï¼›æ—¶åºçš„æ ‡ç­¾å¯ä»¥ç”¨äºåŒºåˆ†å…·ä½“ä¸åŒçš„æ–¹æ³•å’Œå‚æ•°å˜é‡ï¼Œä¾‹å¦‚ http_requests_total{method=\u0026quot;POST\u0026quot;}ã€‚\nä¸€ä¸ª metric çš„å‘½ååº”è¯¥å…·æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š\n  ä»¥å‘½åç©ºé—´æˆ–åº”ç”¨åç§°ä½œä¸ºå‰ç¼€ï¼Œé¿å…ä¸é€šä½œç”¨åŸŸçš„ç›¸åŒåç§°äº§ç”Ÿå†²çªï¼Œä¾‹å¦‚ prometheus_notifications_total, http_request_duration_seconds\n  ä»¥åŸºæœ¬å•ä½ï¼ˆç§’ï¼Œç±³ï¼Œå­—èŠ‚ï¼Œä¸ªæ•°ç­‰ï¼‰ä½œä¸ºåç¼€ï¼Œä¾‹å¦‚ http_requests_total, node_memory_usage_bytes\n  å°†æ‰€æœ‰æ ‡ç­¾çš„å…±åŒé€»è¾‘éƒ¨åˆ†æŠ½ç¦»ä½œä¸ºåç§°ï¼Œå°†å¯å˜é‡ä½œä¸ºæ ‡ç­¾çš„ä¸€éƒ¨åˆ†\n  æŒ‡æ ‡ç±»å‹ æŒ‡æ ‡æ˜¯æ•´ä¸ªç›‘æ§ç³»ç»Ÿçš„æ ¸å¿ƒï¼ŒPrometheus ä¸­çš„æŒ‡æ ‡ç±»å‹ Metrics Type æœ‰ä»¥ä¸‹å››ç§ï¼š\n Counter  Counter æ˜¯åªå¢ä¸å‡çš„è®¡æ•°å™¨ï¼Œä¸€èˆ¬ç”¨äºè®°å½•æœåŠ¡è¯·æ±‚ï¼Œè¿”å›æˆ–é”™è¯¯çš„æ€»é‡ï¼Œå®ƒä¼šåœ¨ç¨‹åºé‡å¯æ—¶è¢«é‡ç½®ä¸º 0ã€‚ä¾‹å¦‚ Prometheus Server ä¸­ http_requests_total è¡¨ç¤ºå½“å‰å¤„ç†çš„ http è¯·æ±‚æ€»æ•°ã€‚\nä¸ºäº†èƒ½å¤Ÿç›´è§‚åœ°å±•ç¤ºæŒ‡æ ‡æ•°æ®è®¡æ•°çš„å˜åŒ–æƒ…å†µï¼Œä¸€èˆ¬éœ€è¦è®¡ç®— Counter æ•°æ®çš„å¢é•¿é€Ÿç‡ï¼Œå»ºè®® PromQL ä¸­çš„ rate, topk, increase, irate ç­‰å‡½æ•°ä½¿ç”¨ã€‚\nGauge  Gauge è¡¨ç¤ºå¯ä»¥ä»»æ„å˜åŒ–çš„å¿«ç…§æ•°æ®ï¼Œä¸€èˆ¬ç”¨äºè®°å½•å†…å­˜ä½¿ç”¨ç‡ï¼ŒCPU æ¸©åº¦ï¼Œç¨‹åºä¸­çš„ goroutine æ•°é‡ç­‰ã€‚ä¾‹å¦‚ Prometheus Server ä¸­ go_goroutines è¡¨ç¤ºå½“å‰ goroutines çš„æ•°é‡ã€‚\nGauge ç»å¸¸ç»“åˆ PromQL ä¸­çš„æœ€å¤§å€¼ maxï¼Œæœ€å°å€¼minï¼Œæ€»å’Œ sum å‡½æ•°ï¼Œæˆ–åŸºäºçº¿æ€§å›å½’çš„æ—¶é—´åºåˆ—é¢„æµ‹å‡½æ•° predict_linear ï¼Œè·å–æŒ‡æ ‡åœ¨ä¸€æ®µæ—¶é—´å†…çš„å˜åŒ–æƒ…å†µçš„ delta ç­‰å‡½æ•°ä½¿ç”¨ã€‚\nHistogram  Histogram ç”¨äºå¯¹ä¸€å®šæ—¶é—´èŒƒå›´å†…çš„æ•°æ®è¿›è¡Œé‡‡æ ·ï¼Œè®°å½•å„ä¸ªæ¡¶ä¸­çš„æ•°æ®ä¸ªæ•°ã€‚ä¾‹å¦‚ Prometheus Server ä¸­ prometheus_local_storage_series_chunks_persisted è¡¨ç¤ºæ¯ä¸ªæ—¶é—´åºåˆ—éœ€è¦å­˜å‚¨çš„ chunks æ•°é‡ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ histogram_quantile è®¡ç®—å¾…æŒä¹…åŒ–çš„æ•°æ®çš„åˆ†ä½æ•° quantile æ•°æ®ã€‚\nSummary  Summary å’Œ Histogram ç±»ä¼¼ï¼Œä¹Ÿç”¨äºè¡¨ç¤ºä¸€æ®µæ—¶é—´èŒƒå›´å†…çš„æ•°æ®é‡‡æ ·ç»“æœï¼Œå®ƒç›´æ¥å­˜å‚¨äº†åˆ†ä½æ•° quantile æ•°æ®ï¼ˆé€šè¿‡å®¢æˆ·ç«¯è®¡ç®—ï¼‰ï¼Œè€Œéæ ¹æ®ç»Ÿè®¡åŒºé—´è®¡ç®—ã€‚å¯¹äºåˆ†ä½æ•°çš„è®¡ç®—ï¼ŒSummary åœ¨é€šè¿‡ PromQL è¿›è¡ŒæŸ¥è¯¢æ—¶æœ‰æ›´å¥½çš„æ€§èƒ½è¡¨ç°ï¼Œè€Œ Histogram åˆ™ä¼šæ¶ˆè€—æ›´å¤šçš„èµ„æºã€‚åä¹‹ï¼Œå¯¹äºå®¢æˆ·ç«¯è€Œè¨€ï¼ŒHistogram æ¶ˆè€—çš„èµ„æºæ›´å°‘ã€‚\n2.2 æ•°æ®é‡‡é›† Prometheus server çš„æ•°æ®é‡‡é›†åŸºäº Pull æ¨¡å‹ï¼Œå…¶å·¥ä½œæµç¨‹å¤§è‡´ä¸º Prometheus server ä¼šå®šæœŸåœ°ä» exporter ä¸Šé€šè¿‡ HTTP æ¥å£è·å– metrics ç»“æ„çš„æ•°æ®ï¼Œå¹¶è¿›è¡Œå­˜å‚¨ï¼Œå¦‚æœ Prometheus Server ä¸ Exporter ä¸èƒ½å¤Ÿç›´æ¥è¿›è¡Œé€šä¿¡ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°† exporter ä¸Šçš„æ•°æ®æ¨é€åˆ° Pushgateway ä¸Šï¼Œå¹¶è®© Prometheus Server ä» PushGateway ä¸Šè·å–æ•°æ®ã€‚\næœ¯è¯­ Exporterï¼šæ‰€æœ‰å‘ Prometheus server æä¾›æ•°æ®çš„ç¨‹åºéƒ½å¯ä»¥è¢«ç§°ä¸º exporterï¼ŒPrometheus server ä¼šå‘¨æœŸæ€§åœ°ä» exporter æä¾›çš„HTTP æœåŠ¡ URL æ‹‰å–æ•°æ®ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨ Prometheus server çš„é…ç½®æ–‡ä»¶ /etc/prometheus/prometheus.yml ä¸­æ·»åŠ ä¸€ä¸ªtargetï¼Œå¹¶é‡å¯æœåŠ¡å³å¯å®šä½åˆ° exporter å¹¶æ‹‰å–æ•°æ®ã€‚\nInstanceï¼šä»»æ„ä¸€ä¸ªç‹¬ç«‹çš„æ•°æ®æº target éƒ½å¯ä»¥è¢«ç§°ä¸º Instance å®ä¾‹ï¼Œå®ƒæ˜¯ç”¨æ¥æä¾›æ•°æ®çš„æœ€å°å•ä½ã€‚\nJobï¼šåŒ…å«ç›¸åŒç±»å‹çš„å®ä¾‹çš„é›†åˆå«åš Jobï¼Œä¾‹å¦‚åœ¨ k8s é›†ç¾¤ä¸Šè¢«å¤åˆ¶å‡ºçš„å¯å¼¹æ€§ä¼¸ç¼©çš„ä¸€ç»„ pod ä¸­çš„ç›¸åŒè¿›ç¨‹ã€‚\n2.3 Pushgateway ç”±äº Prometheus server é‡‡ç”¨ pull æ¨¡å¼è·å–æ•°æ®ï¼Œå¦‚æœ Prometheus server å’Œ exporter ç”±äºä¸åœ¨ä¸€ä¸ªå­ç½‘ç¯å¢ƒæˆ–ç”±äºé˜²ç«å¢™åŸå› å¯¼è‡´ä¸¤è€…æ— æ³•ç›´æ¥é€šä¿¡ï¼Œæˆ–åœ¨æˆ‘ä»¬éœ€è¦å°†å¤šä¸ª exporter çš„æ•°æ®æ±‡æ€»åˆ°ä¸€èµ·æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä¸»åŠ¨å°†æ•°æ®æ¨é€åˆ° Pushgateway ä¸Šï¼Œé—´æ¥åœ°è¿›è¡Œæ•°æ®é‡‡é›†ï¼›ä½†å®ƒçš„å¼Šç«¯ä¹Ÿå¾ˆæ˜æ˜¾ï¼Œé‚£å°±æ˜¯å•ç‚¹æ•…éšœï¼Œå¦‚æœå”¯ä¸€çš„ Pushgateway å‡ºç°ä¸å¯ç”¨çš„æƒ…å†µï¼Œé‚£ä¹ˆæ‰€æœ‰çš„æ•°æ®éƒ½æ— æ³•è¢« Prometheus server è·å–ã€‚\nPushgateway ä¸éœ€è¦ä»»ä½•é…ç½®ï¼Œç›´æ¥å¯åŠ¨ docker image åå³å¯ä½¿ç”¨ã€‚\ndocker pull prom/pushgateway\rdocker run -d -p 9091:9091 prom/pushgateway\rå¯åŠ¨å¥½ Pushgateway ä¹‹åï¼Œéœ€è¦åœ¨ Prometheus server çš„é™æ€é…ç½®ä¸­æ·»åŠ  Pushgatewayï¼š\ndocker exec -it --user root f257794e5e3d sh vi /etc/prometheus/prometheus.yml scrape_configs:\r- job_name: \u0026quot;pushgateway\u0026quot;\rstatic_configs:\r- targets: [\u0026quot;ip:port\u0026quot;]\rä¿®æ”¹é…ç½®åï¼Œå‘é€ä¿¡å·ç»™ Prometheus Server ä½¿å…¶åŠ è½½æœ€æ–°çš„é…ç½®ï¼š\nkill -HUP $pid é»˜è®¤æƒ…å†µä¸‹ï¼ŒPushgateway å°†æ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œå› æ­¤ä¸€æ—¦ Pushagateway æœåŠ¡å› ä¸ºæ•…éšœè€Œåœæ­¢è¿è¡Œï¼Œé‚£ä¹ˆæ‰€æœ‰å°šæœªè¢« Prometheus server è·å–çš„æ•°æ®éƒ½å°†ä¼šä¸¢å¤±ï¼Œä¸ºæ­¤å¯ä»¥åœ¨å¯åŠ¨ Pushgateway æœåŠ¡æ—¶é€šè¿‡æŒ‡å®š persistence.file å‚æ•°å°†æ•°æ®æŒä¹…åŒ–ï¼š\npushgateway --persistence.file=\u0026#34;/tmp/pushgateway_persist\u0026#34; é»˜è®¤æƒ…å†µä¸‹ï¼Œæ–‡ä»¶æ¯äº”åˆ†é’ŸæŒä¹…åŒ–å†™å…¥ä¸€æ¬¡ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿®æ”¹ persistence.interval å‚æ•°æ¥è¿›è¡Œè°ƒæ•´ã€‚\næ¨é€æ•°æ® å‘ Pushgateway æ¨é€æ•°æ®æ—¶å¯ä»¥ä½¿ç”¨ PUT å’Œ POST ä¸¤ç§æ–¹æ³•ï¼Œå…¶ä¸­ PUT ä¼šå°†å®ä¾‹ä¸­çš„æ‰€æœ‰ metrics æ›¿æ¢ä¸ºæ–°æ¨é€çš„ metricsï¼Œè€Œ POST åˆ™åªä¼šå°† name ç›¸åŒ metrics æ›¿æ¢ï¼ˆå‰ææ˜¯è¿™éƒ¨åˆ†æ•°æ®åœ¨ç›¸åŒçš„ job/instance ä¸‹ï¼‰ï¼›\nå‡è®¾å°†è¦è¿›è¡Œæ¨é€çš„æ•°æ®å¦‚ä¸‹ï¼š\n$ cat req1.txt # TYPE foo GAUGE foo{id=\u0026#34;1\u0026#34;} 1 foo{id=\u0026#34;2\u0026#34;} 2 foo{id=\u0026#34;3\u0026#34;} 3 # TYPE bar GAUGE bar{id=\u0026#34;11\u0026#34;} 11 å°†å…¶æ¨é€åˆ° Pushgateway ä¸Šå¹¶æ£€æŸ¥ï¼š\n$ curl -X POST --data-binary @req1.txt localhost:9091/metrics/job/test $ curl localhost:9091/metrics | grep test bar{id=\u0026#34;11\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 11 foo{id=\u0026#34;1\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 1 foo{id=\u0026#34;2\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 2 foo{id=\u0026#34;3\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 3 ä½¿ç”¨ POST æ–¹æ³•æ¨é€å¦ä¸€ç»„æ•°æ®ï¼š\n$ cat req2.txt # TYPE foo GAUGE foo{id=\u0026#34;4\u0026#34;} 4 foo{id=\u0026#34;5\u0026#34;} 5 $ curl -X POST --data-binary @req2.txt localhost:9091/metrics/job/test $ curl localhost:9091/metrics | grep test bar{id=\u0026#34;11\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 11 foo{id=\u0026#34;4\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 4 foo{id=\u0026#34;5\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 5 å¯ä»¥çœ‹åˆ°åŸæœ‰çš„ name ä¸º foo çš„æ•°æ®éƒ½è¢«è¦†ç›–äº†ï¼›\nä½¿ç”¨ PUT æ–¹æ³•æ¨é€ç¬¬äºŒç»„æ•°æ®ï¼š\n$ curl -X PUT --data-binary @req2.txt localhost:9091/metrics/job/test $ curl localhost:9091/metrics | grep test foo{id=\u0026#34;4\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 4 foo{id=\u0026#34;5\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 5 å¯ä»¥çœ‹åˆ°åŸæœ‰çš„æ‰€æœ‰æ•°æ®ï¼ˆåŒ…æ‹¬ name ä¸åŒçš„ bar æ•°æ®ï¼‰éƒ½è¢«è¦†ç›–äº†ã€‚\næ¨é€ä¸èƒ½åŒ…å«æ—¶é—´æˆ³\nPrometheus pull æ•°æ®æ—¶ä¸ä¼šé‡‡é›†ä¸å½“å‰æ—¶é—´å·®åœ¨ 5 åˆ†é’Ÿä»¥ä¸Šçš„æ•°æ®ï¼Œå®˜æ–¹è®¤ä¸º pushgateway ä¸€èˆ¬ç”¨åœ¨ä¸´æ—¶ä»»åŠ¡å’Œæ‰¹å¤„ç†ä½œä¸šä¸Šï¼Œä¸ºäº†é˜²æ­¢è¿™äº›ä»»åŠ¡å› ä¸ºå­˜åœ¨çš„æ—¶é—´ä¸å¤Ÿé•¿å¯¼è‡´ Prometheus è¿˜æ²¡æ¥å¾—åŠ pull æ•°æ®å°±ç»“æŸäº†ï¼Œæ‰€ä»¥ä¸å…è®¸åœ¨å‘ pushgateway æ¨é€æ•°æ®æ—¶å¸¦ä¸Šæ—¶é—´æˆ³ã€‚\nåˆ é™¤æ•°æ® å¦‚æœæƒ³è¦åˆ é™¤ Pushgateway ä¸Šç‰¹å®šçš„æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨å®˜æ–¹æä¾›çš„ http APIï¼š\n åˆ é™¤ç‰¹å®š job å’Œ instance çš„æ‰€æœ‰æ•°æ®ï¼š  curl -X DELETE http://pushgateway.example.org:9091/metrics/job/some_job/instance/some_instance  åˆ é™¤ç‰¹å®š job ï¼Œä¸” instance=\u0026quot;\u0026quot; ä¸‹çš„æ‰€æœ‰æ•°æ®ï¼Œæ³¨æ„è¿™ä¸ä¼šåˆ é™¤å…¶ä»– instance çš„æ•°æ®ï¼š  curl -X DELETE http://pushgateway.example.org:9091/metrics/job/some_job  åˆ é™¤ä¸€ä¸ªå®ä¾‹ä¸Šçš„æ‰€æœ‰æ•°æ®ï¼ˆéœ€è¦åœ¨å¯åŠ¨æ—¶åŠ ä¸Šå‚æ•° --web.enable-admin-api æ‰èƒ½ç”¨ï¼‰ï¼š  curl -X PUT http://pushgateway.example.org:9091/api/v1/admin/wipe ","permalink":"http://zintrulcre.github.io/posts/cloud/intro-to-prometheus/","summary":"Prometheus å…¥é—¨ Prometheus æ˜¯ä¸€ä¸ªå¼€æºçš„ç›‘æ§è§£å†³æ–¹æ¡ˆï¼Œä¹Ÿæ˜¯äº‘åŸç”ŸåŸºé‡‘ä¼š CNCF çš„æ¯•ä¸šé¡¹ç›®ï¼Œå®ƒèƒ½å¤Ÿæä¾›æŒ‡æ ‡æ•°æ®çš„é‡‡é›†ã€å­˜å‚¨ã€æŸ¥è¯¢ã€å‘Šè­¦ç­‰åŠŸèƒ½ã€‚æœ¬æ–‡ä¸»è¦ä»‹ç» Prometheus çš„åŸºç¡€æ¦‚å¿µå’Œåº”ç”¨ä¸­éœ€è¦æ³¨æ„çš„ä¸€äº›é—®é¢˜ã€‚\n1 ç›‘æ§ç³»ç»Ÿ 1.1 ç›‘æ§æ¨¡å¼ ç›‘æ§ç³»ç»Ÿæ‰§è¡Œç›‘æ§æ£€æŸ¥çš„æ¨¡å¼æœ‰ä¸¤ç§ï¼Œåˆ†åˆ«æ˜¯ pull å’Œ pushã€‚Prometheus é‡‡ç”¨äº† pull æ¨¡å¼è¿›è¡Œæ•°æ®æ”¶é›†ï¼ŒåŒæ—¶ä¹Ÿæ”¯æŒä½¿ç”¨ Pushgateway çš„ push æ¨¡å¼è¿›è¡Œæ•°æ®ä¸­è½¬ã€‚\npull æ–¹å¼çš„ç‰¹ç‚¹æ˜¯æœ‰æ‹‰å–é—´éš”ï¼Œä¸èƒ½åŠæ—¶è·å–æ•°å€¼çš„å˜åŒ–ï¼Œå› æ­¤éœ€è¦è¿›ä¸€æ­¥çš„æ•°æ®å¤„ç†ï¼›å®ƒçš„ä¼˜ç‚¹æ˜¯åœ¨å‘Šè­¦æ—¶å¯ä»¥æŒ‰ç…§ç­–ç•¥åˆ†ç‰‡ï¼Œä»…æ‹‰å–éœ€è¦çš„æ•°æ®ï¼Œå¹¶ä¸”æ”¯æŒèšåˆåœºæ™¯ï¼›ç¼ºç‚¹æ˜¯ç›‘æ§çš„æ•°æ®é‡åºå¤§ï¼Œå¯¹å­˜å‚¨æœ‰è¾ƒé«˜çš„è¦æ±‚ï¼Œåˆ‡éœ€è¦è€ƒè™‘æ•°æ®çš„å†·çƒ­åˆ†ç¦»ã€‚\npush æ–¹å¼çš„ç‰¹ç‚¹æ˜¯ç”±æœåŠ¡ä¸»åŠ¨å°†æ•°æ®æ¨å‘ç›‘æ§ç³»ç»Ÿï¼Œå®æ—¶æ€§æ›´é«˜ï¼›å®ƒçš„ç¼ºç‚¹æ˜¯æ¨é€æ•°æ®çš„ä¸å¯é¢„çŸ¥æ€§ï¼Œå› ä¸ºå½“å¤§é‡æ•°æ®è¢«æ¨é€åˆ°ç›‘æ§ç³»ç»Ÿæ—¶ï¼Œæ•°æ®çš„ç¼“å­˜å’Œè§£æä¼šæ¶ˆè€—å¤§é‡èµ„æºï¼Œæ­¤æ—¶å¦‚æœå› ä¸ºç½‘ç»œåŸå› æ•°æ®çš„æ”¶å‘æ²¡æœ‰å¾—åˆ°ç¡®è®¤ï¼Œå¾ˆå®¹æ˜“äº§ç”Ÿæ•°æ®çš„é‡å‘å’Œé‡å¤ï¼Œå› æ­¤éœ€è¦è¿›è¡Œå»é‡ç­‰æ“ä½œã€‚\npull æ¨¡å¼åœ¨äº‘åŸç”Ÿç¯å¢ƒä¸­æ›´æœ‰ä¼˜åŠ¿ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥é€šè¿‡æœåŠ¡å‘ç°å¯¹æ‰€æœ‰éœ€è¦è¿›è¡Œç›‘æ§çš„èŠ‚ç‚¹è¿›è¡Œç»Ÿä¸€çš„æ•°æ®æ‹‰å–ï¼Œå¦‚æœä½¿ç”¨ push æ¨¡å¼åˆ™éœ€è¦åœ¨æ¯ä¸ªè¢«ç›‘æ§çš„æœåŠ¡ä¸­éƒ¨ç½²ä¸ŠæŠ¥æ•°æ®çš„å®¢æˆ·ç«¯ï¼Œå¹¶é…ç½®ç›‘æ§æœåŠ¡å™¨çš„ä¿¡æ¯ï¼Œè¿™ä¼šåŠ å¤§éƒ¨ç½²çš„éš¾åº¦ã€‚\n1.2 Prometheus Prometheus æ˜¯ä¸€å¥—å¼€æºçš„æ•°æ®é‡‡é›†ä¸ç›‘æ§æ¡†æ¶ï¼Œå¯ä»¥åšåå°æœåŠ¡å™¨çš„ç›‘æ§å‘Šè­¦ï¼Œæ­¤å¤„ç”¨æ¥é‡‡é›†è¢«æµ‹æœåŠ¡çš„æ€§èƒ½æŒ‡æ ‡æ•°æ®ï¼ŒåŒ…æ‹¬CPUå ç”¨æ¯”ç‡ã€å†…å­˜æ¶ˆè€—ã€ç½‘ç»œIOç­‰ã€‚\nç‰¹ç‚¹ Prometheus æœ€ä¸»è¦çš„ç‰¹ç‚¹æœ‰ 4 ä¸ªï¼š\n é€šè¿‡ PromQL å®ç°å¤šç»´åº¦æ•°æ®æ¨¡å‹çš„çµæ´»æŸ¥è¯¢ï¼›è¿™ä½¿å¾—ç›‘æ§æŒ‡æ ‡å¯ä»¥å…³è”åˆ°å¤šä¸ªæ ‡ç­¾ï¼Œå¹¶å¯¹æ—¶é—´åºåˆ—è¿›è¡Œåˆ‡ç‰‡å’Œåˆ‡å—ï¼Œä»¥æ”¯æŒå„ç§æŸ¥è¯¢å’Œå‘Šè­¦åœºæ™¯ å®šä¹‰äº†å¼€æ”¾æŒ‡æ ‡æ•°æ®çš„æ ‡å‡†ï¼Œå¯ä»¥æ–¹ä¾¿åœ°è‡ªå®šä¹‰æ¢é’ˆï¼ˆexporterï¼‰ åˆ©ç”¨ Pushgateway ç»„ä»¶å¯ä»¥ä»¥ push çš„æ–¹å¼æ¥æ”¶ç›‘æ§æ•°æ® æä¾›äº†å®¹å™¨åŒ–ç‰ˆæœ¬  æ¶æ„ Prometheus çš„æ¶æ„ä¸»è¦ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š\n  Prometheus Server\nPrometheus æœåŠ¡å™¨ä¸»è¦åŒ…å«äº†ä½¿ç”¨ pull æ¨¡å¼æŠ“å–ç›‘æ§æ•°æ®ï¼Œé€šè¿‡æœ¬åœ°å­˜å‚¨ï¼ˆæœ¬åœ°ç£ç›˜ï¼‰å’Œè¿œç¨‹å­˜å‚¨ï¼ˆOpenTSDB, InfluxDB, ElasticSearch ç­‰ï¼‰ä¿å­˜æ•°æ®ï¼Œä½¿ç”¨ PromQL æŸ¥è¯¢æ•°æ®ä¸‰å¤§åŠŸèƒ½ã€‚\nPromQL (Prometheus Query Language) æ˜¯ Prometheus å†…ç½®çš„æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼Œæä¾›äº†å¯¹æ—¶é—´åºåˆ—æ•°æ®çš„æŸ¥è¯¢ï¼Œèšåˆå’Œé€»è¾‘è¿ç®—ç­‰æ“ä½œçš„æ”¯æŒï¼Œè¢«å¹¿æ³›åœ°åº”ç”¨åœ¨æ•°æ®çš„æŸ¥è¯¢ï¼Œå¯è§†åŒ–å’Œå‘Šè­¦ä¸­ã€‚å…³äº PromQL çš„ç›¸å…³æ“ä½œå¯ä»¥å‚è€ƒ æ¢ç´¢PromQLã€‚","title":"Prometheus å…¥é—¨"},{"content":"Python æºç å­¦ä¹ ï¼ˆ5ï¼‰ï¼šåç¨‹ åç¨‹ coroutine æ˜¯ä¸€ç§ç”¨æˆ·æ€çš„è½»é‡çº§çº¿ç¨‹ï¼Œå®ƒå¯ä»¥åœ¨å‡½æ•°çš„ç‰¹å®šä½ç½®æš‚åœæˆ–æ¢å¤ï¼ŒåŒæ—¶è°ƒç”¨è€…å¯ä»¥ä»åç¨‹ä¸­è·å–çŠ¶æ€æˆ–å°†çŠ¶æ€ä¼ é€’ç»™åç¨‹ï¼›Pythonä¸­çš„ç”Ÿæˆå™¨ generator å°±æ˜¯ä¸€ä¸ªå…¸å‹çš„åç¨‹åº”ç”¨ï¼Œæœ¬æ–‡ç®€å•åœ°å¯¹ Python ä¸­ç”Ÿæˆå™¨çš„å®ç°è¿›è¡Œåˆ†æã€‚\n1 ç”Ÿæˆå™¨ å¦‚æœ Python ä¸­çš„å‡½æ•°å«æœ‰ yield å…³é”®å­—ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨è¿™ä¸ªå‡½æ•°æ—¶ï¼Œå®ƒä¸ä¼šå¦‚åŒæ™®é€šçš„å‡½æ•°ä¸€æ ·è¿è¡Œåˆ° return è¯­å¥å¹¶è¿”å›ä¸€ä¸ªå˜é‡ï¼Œè€Œæ˜¯ä¼šç«‹å³è¿”å›ä¸€ä¸ªç”Ÿæˆå™¨å¯¹è±¡ï¼›ä»¥ä¸€ä¸ªæ–æ³¢é‚£å¥‘æ•°åˆ—ç”Ÿæˆå‡½æ•°ä¸ºä¾‹ï¼š\ndef FibonacciSequenceGenerator(): a, b = 0, 1 while True: yield a + b a, b = b, a + b if __name__ == \u0026#34;__main__\u0026#34;: fsg = FibonacciSequenceGenerator() print(fsg) print(type(fsg)) $ python3 main.py \u0026lt;generator object FibonacciSequenceGenerator at 0x7fb4720b1ac0\u0026gt; \u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; å¯ä»¥çœ‹åˆ°å‡½æ•° FibonacciSequenceGenerator è¿”å›äº†ä¸€ä¸ªç±»å‹ä¸º generator çš„ç”Ÿæˆå™¨å¯¹è±¡ fï¼›å¯¹äºç”Ÿæˆå™¨å¯¹è±¡ï¼Œæˆ‘ä»¬ä¸èƒ½åƒæ“ä½œæ™®é€šå‡½æ•°ä¸€æ ·ç›´æ¥è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼Œè€Œæ˜¯è¦ä½¿ç”¨ next() æˆ– fsg.send() æ¥è¿›è¡Œå‡½æ•°åˆ‡æ¢ï¼Œä½¿å¾—ç”Ÿæˆå™¨å‡½æ•°å¼€å§‹æˆ–ç»§ç»­æ‰§è¡Œï¼Œç›´åˆ° yield æ‰€åœ¨è¡Œæˆ–æ˜¯å‡½æ•°æœ«å°¾å†å°†æ‰§è¡Œæƒäº¤è¿˜ç»™è°ƒç”¨æ–¹ï¼š\nfor i in range(100): print(next(fsg)) $ python3 main.py 1 2 3 5 # ... 218922995834555169026 354224848179261915075 573147844013817084101 ç”Ÿæˆå™¨çš„è¿™ç§è¡Œä¸ºä¸çº¿ç¨‹åˆ‡æ¢éå¸¸ç±»ä¼¼ï¼Œå®ƒåŒ…å«äº†æ‰§è¡Œï¼Œä¿å­˜ï¼Œæ¢å¤ä¸Šä¸‹æ–‡çš„æ­¥éª¤ï¼Œç”¨ç”Ÿæˆå™¨æ¥æ¨¡æ‹Ÿçº¿ç¨‹çš„è¡Œä¸ºå¯ä»¥é¿å…ä»ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„åˆ‡æ¢ï¼Œä»è€Œæå‡æ•ˆç‡ã€‚\n2 åç¨‹ 2.1 ç”Ÿæˆå™¨å¯¹è±¡ é€šè¿‡ç±»å‹å¯¹è±¡çš„ tp_name å˜é‡å¯ä»¥æ‰¾åˆ°ç”Ÿæˆå™¨ generator å¯¹è±¡åœ¨æºç ä¸­å¯¹åº”çš„ç»“æ„ä½“æ˜¯ PyGenObjectï¼Œå®ƒçš„ç±»å‹å¯¹è±¡æ˜¯ PyGen_Typeï¼š\n// Inlcude/genobject.h  /* _PyGenObject_HEAD defines the initial segment of generator and coroutine objects. */ #define _PyGenObject_HEAD(prefix) \\ PyObject_HEAD \\ /* Note: gi_frame can be NULL if the generator is \u0026#34;finished\u0026#34; */\\ PyFrameObject *prefix##_frame; \\ /* True if generator is being executed. */\\ char prefix##_running; \\ /* The code object backing the generator */\\ PyObject *prefix##_code; \\ /* List of weak reference. */\\ PyObject *prefix##_weakreflist; \\ /* Name of the generator. */\\ PyObject *prefix##_name; \\ /* Qualified name of the generator. */\\ PyObject *prefix##_qualname; \\ _PyErr_StackItem prefix##_exc_state;  typedef struct { /* The gi_ prefix is intended to remind of generator-iterator. */ _PyGenObject_HEAD(gi) } PyGenObject; // Inlcude/genobject.c  PyTypeObject PyGen_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) \u0026#34;generator\u0026#34;, /* tp_name */ sizeof(PyGenObject), /* tp_basicsize */ 0, /* tp_itemsize */ /* methods */ (destructor)gen_dealloc, /* tp_dealloc */ // ...  (iternextfunc)gen_iternext, /* tp_iternext */ _PyGen_Finalize, /* tp_finalize */ }; PyGenObject ç»“æ„ä½“ä¸­çš„æˆå‘˜å˜é‡ä¸å¤šï¼Œåˆ†åˆ«æ˜¯ï¼š\n å®šé•¿å¯¹è±¡å…¬å…±å¤´éƒ¨ PyObject_HEADï¼Œå…¶ä¸­åŒ…æ‹¬å¼•ç”¨è®¡æ•° ob_refcnt å’Œç±»å‹å¯¹è±¡æŒ‡é’ˆ ob_typeï¼› ç”Ÿæˆå™¨æ˜¯å¦æ­£åœ¨è¿è¡Œçš„æ ‡å¿— gi_runningï¼› ç”Ÿæˆå™¨è¿è¡Œæ—¶ä¾èµ–çš„æ ˆå¸§å¯¹è±¡ gi_frameï¼› ç”Ÿæˆå™¨å¯¹åº”çš„ä»£ç å¯¹è±¡ gi_codeï¼› ç”Ÿæˆå™¨çš„å¼±å¼•ç”¨åˆ—è¡¨ gi_weakreflistï¼› ç”Ÿæˆå™¨çš„åç§° gi_name å’Œ gi_qualnameï¼› ç”Ÿæˆå™¨çš„å¼‚å¸¸çŠ¶æ€ gi_exec_stateï¼›  ç”Ÿæˆå™¨åœ¨åˆšè¢«åˆ›å»ºæ—¶ï¼Œå¹¶ä¸ä¼šç«‹å³æ‰§è¡Œï¼Œå¹¶ä¸”å…¶æ ˆå¸§å¯¹è±¡ä¸­æœ€åä¸€æ¡æ‰§è¡Œè¿‡çš„æŒ‡ä»¤ä¹Ÿä¸ºç©ºï¼š\nprint(fsg.gi_running) print(fsg.gi_frame.f_lasti) $ python3 main.py False -1 å½“ç„¶å®ƒçš„æ ˆå¸§å¯¹è±¡ä¹Ÿæ˜¯å’Œä»£ç å¯¹è±¡ç›¸å…³è”çš„ï¼š\nprint(fsg.gi_code) print(fsg.gi_frame) print(fsg.gi_frame.f_code) $ python3 main.py \u0026lt;code object FibonacciSequenceGenerator at 0x7f8283e49c90, file \u0026#34;main.py\u0026#34;, line 89\u0026gt; \u0026lt;frame at 0x7f8283f17610, file \u0026#39;main.py\u0026#39;, line 89, code FibonacciSequenceGenerator\u0026gt; \u0026lt;code object FibonacciSequenceGenerator at 0x7f8283e49c90, file \u0026#34;main.py\u0026#34;, line 89\u0026gt; 2.2 æ‰§è¡Œ next next() å‡½æ•°æ˜¯ Python çš„å†…ç½®å‡½æ•°ï¼Œç”¨äºé©±åŠ¨ç”Ÿæˆå™¨çš„æ‰§è¡Œï¼Œæˆ–è€…è¯´å°†ç¨‹åºçš„è°ƒç”¨æ ˆä»å½“å‰å‡½æ•°åˆ‡æ¢åˆ°ç”Ÿæˆå™¨ä¸­ï¼›å…¶æºç å¦‚ä¸‹ï¼š\n// Python/bltinmodule.c builtin_next(PyObject *self, PyObject *const *args, Py_ssize_t nargs) { PyObject *it, *res; if (!_PyArg_CheckPositional(\u0026#34;next\u0026#34;, nargs, 1, 2)) return NULL; it = args[0]; if (!PyIter_Check(it)) { PyErr_Format(PyExc_TypeError, \u0026#34;\u0026#39;%.200s\u0026#39; object is not an iterator\u0026#34;, Py_TYPE(it)-\u0026gt;tp_name); return NULL; } res = (*Py_TYPE(it)-\u0026gt;tp_iternext)(it); if (res != NULL) { return res; } else if (nargs \u0026gt; 1) { PyObject *def = args[1]; if (PyErr_Occurred()) { if(!PyErr_ExceptionMatches(PyExc_StopIteration)) return NULL; PyErr_Clear(); } Py_INCREF(def); return def; } else if (PyErr_Occurred()) { return NULL; } else { PyErr_SetNone(PyExc_StopIteration); return NULL; } } é™¤å»å‰åä¸¤å¤§å—ç±»å‹æ£€æŸ¥ï¼Œæœ€æ ¸å¿ƒçš„éƒ¨åˆ†æ˜¯ res = (*it-\u0026gt;ob_type-\u0026gt;tp_iternext)(it)ï¼Œå³è·å–å‚æ•°ä¸­ args[0] çš„ç±»å‹å¯¹è±¡ï¼Œå¹¶è°ƒç”¨å…¶ tp_iternext å‡½æ•°æŒ‡é’ˆï¼Œå†æ£€æŸ¥è¿”å›çš„ç»“æœï¼›å› æ­¤å½“æˆ‘ä»¬å¯¹ç”Ÿæˆå™¨å¯¹è±¡ fsg è°ƒç”¨ next å‡½æ•°æ—¶ï¼Œå®é™…ä¸Šæ˜¯è°ƒç”¨äº†ç”Ÿæˆå™¨ç±»å‹å¯¹è±¡ PyGen_Type çš„ gen_iternext å‡½æ•°ï¼Œæ¥é©±åŠ¨ç”Ÿæˆå™¨å¼€å§‹æˆ–ç»§ç»­è¿è¡Œï¼Œè€Œè¿™ä¸ª gen_iternext å‡½æ•°åˆ™è°ƒç”¨äº† gen_send_ex å‡½æ•°ï¼š\n// Objects/genobject.c static PyObject * gen_iternext(PyGenObject *gen) { return gen_send_ex(gen, NULL, 0, 0); } static PyObject * gen_send_ex(PyGenObject *gen, PyObject *arg, int exc, int closing) { PyFrameObject *f = gen-\u0026gt;gi_frame; // ...  /* Generators always return to their most recent caller, not * necessarily their creator. */ Py_XINCREF(tstate-\u0026gt;frame); assert(f-\u0026gt;f_back == NULL); f-\u0026gt;f_back = tstate-\u0026gt;frame; gen-\u0026gt;gi_running = 1; gen-\u0026gt;gi_exc_state.previous_item = tstate-\u0026gt;exc_info; tstate-\u0026gt;exc_info = \u0026amp;gen-\u0026gt;gi_exc_state; if (exc) { assert(_PyErr_Occurred(tstate)); _PyErr_ChainStackItem(NULL); } result = _PyEval_EvalFrame(tstate, f, exc); tstate-\u0026gt;exc_info = gen-\u0026gt;gi_exc_state.previous_item; gen-\u0026gt;gi_exc_state.previous_item = NULL; gen-\u0026gt;gi_running = 0; // ... } gen_send_ex å‡½æ•°å¾ˆé•¿ï¼Œä½†å…¶ä¸­æœ€å…³é”®çš„åªæœ‰ä¸Šé¢æˆªå–çš„éƒ¨åˆ†ï¼Œè¿™éƒ¨åˆ†ä»£ç é¦–å…ˆå°†ç”Ÿæˆå™¨å¯¹è±¡çš„æ ˆå¸§æŒ‚åˆ°å½“å‰è°ƒç”¨é“¾ä¸Š f-\u0026gt;f_back = tstate-\u0026gt;frame;ï¼Œå¹¶ä¿®æ”¹ç”Ÿæˆå™¨å¯¹è±¡çš„è¿è¡ŒçŠ¶æ€ gen-\u0026gt;gi_running = 1ï¼Œæ¥ä¸‹æ¥å†é€šè¿‡è°ƒç”¨ _PyEval_EvalFrame æ¥æ‰§è¡Œç”Ÿæˆå™¨æ ˆå¸§ï¼Œå…³äº _PyEval_EvalFrame å‡½æ•°çš„æµç¨‹å·²ç»åœ¨å‰æ–‡è®¨è®ºè¿‡ï¼Œç®€å•åœ°æ¥è¯´å°±æ˜¯é€šè¿‡åœ¨ä¸€ä¸ªå¾ªç¯ä¸­é€šè¿‡ switch case ä¸æ–­åœ°æ‰§è¡Œç”Ÿæˆå™¨å¯¹è±¡å¯¹åº”çš„å­—èŠ‚ç ã€‚\nsend å’Œ next å‡½æ•°ç±»ä¼¼ï¼Œsend å‡½æ•°ä¹Ÿå¯ä»¥ç”¨æ¥é©±åŠ¨ç”Ÿæˆå™¨æ‰§è¡Œï¼Œä»è°ƒç”¨å½¢å¼ä¸Šæ¥çœ‹å®ƒä»¬ä¹‹é—´å”¯ä¸€çš„åŒºåˆ«å°±æ˜¯ send å‡½æ•°ä¼šé¢å¤–çš„ä¼ å…¥ä¸€ä¸ªå‚æ•°ï¼Œè€Œä» send å‡½æ•°çš„æºç ä¸­å¯ä»¥çœ‹åˆ°å®ƒåŒæ ·åœ°ä¹Ÿä¼šè°ƒç”¨ gen_send_ex å‡½æ•°ï¼Œä¸è¿‡å…¶ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå¯¹è±¡æŒ‡é’ˆï¼ˆè€Œä¸åƒ gen_iternext å‡½æ•°ä¸­ä¸€æ ·ä¼ å…¥äº†ä¸€ä¸ª NULLï¼‰ï¼š\n// Objects/genobject.c static PyMethodDef gen_methods[] = { {\u0026#34;send\u0026#34;,(PyCFunction)_PyGen_Send, METH_O, send_doc}, // ... }; PyObject * _PyGen_Send(PyGenObject *gen, PyObject *arg) { return gen_send_ex(gen, arg, 0, 0); } æŸ¥çœ‹ä¸€ä¸‹ä¸¤è€…å¯¹åº”çš„å­—èŠ‚ç æŒ‡ä»¤ä¸­çš„åŒºåˆ«ï¼š\nimport os, sys def FibonacciSequenceGenerator(): a, b = 0, 1 while True: yield a + b a, b = b, a + b def DriveCo(co): r = next(fsg) r = fsg.send(1) if __name__ == \u0026#34;__main__\u0026#34;: fsg = FibonacciSequenceGenerator() DriveCo(fsg) import dis dis.dis(DriveCo) $ python3 main.py 10 0 LOAD_GLOBAL 0 (next) 2 LOAD_GLOBAL 1 (fsg) 4 CALL_FUNCTION 1 6 STORE_FAST 1 (r) 11 8 LOAD_GLOBAL 1 (fsg) 10 LOAD_METHOD 2 (send) 12 LOAD_CONST 1 (1) 14 CALL_METHOD 1 16 STORE_FAST 1 (r) 18 LOAD_CONST 0 (None) 20 RETURN_VALUE å¯ä»¥çœ‹åˆ°ç›¸æ¯”äº next å‡½æ•°çš„å­—èŠ‚ç æŒ‡ä»¤ï¼Œsend å‡½æ•°åªæ˜¯åœ¨è°ƒç”¨å‡½æ•°ï¼ˆCALL_FUNCTION / CALL_METHODï¼‰å‰åŠ ä¸Šäº† LOAD_CONST æŒ‡ä»¤æ¥å°†å‚æ•°ç½®å…¥æ ˆé¡¶ã€‚\n2.3 æš‚åœ åœ¨ Python ä¸­å¯ä»¥ä½¿ç”¨å†…ç½®çš„ yield å‡½æ•°æ¥æš‚åœç”Ÿæˆå™¨å¯¹è±¡çš„æ‰§è¡Œå¹¶è¿”å›ä¸€ä¸ªå€¼ï¼Œæˆ‘ä»¬å¯ä»¥ç ”ç©¶ä¸€ä¸‹ FibonacciSequenceGenerator å‡½æ•°ä»¥åŠ yield è¯­å¥å¯¹åº”çš„å­—èŠ‚ç æŒ‡ä»¤ï¼š\nimport dis dis.dis(fsg) $ python3 main.py 2 0 LOAD_CONST 1 ((0, 1)) 2 UNPACK_SEQUENCE 2 4 STORE_FAST 0 (a) 6 STORE_FAST 1 (b) 4 \u0026gt;\u0026gt; 8 LOAD_FAST 0 (a) 10 LOAD_FAST 1 (b) 12 BINARY_ADD 14 YIELD_VALUE 16 POP_TOP 5 18 LOAD_FAST 1 (b) 20 LOAD_FAST 0 (a) 22 LOAD_FAST 1 (b) 24 BINARY_ADD 26 ROT_TWO 28 STORE_FAST 0 (a) 30 STORE_FAST 1 (b) 32 JUMP_ABSOLUTE 8 34 LOAD_CONST 0 (None) 36 RETURN_VALUE å…¶ä¸­ç¬¬ 2 è¡Œï¼ˆa, b = 0, 1ï¼‰å’Œç¬¬ 5 è¡Œï¼ˆa, b = b, a + bï¼‰éƒ½æ˜¯åœ¨è¿›è¡Œ a, b å˜é‡çš„èµ‹å€¼æ“ä½œï¼Œè€Œåœ¨ç¬¬ 4 è¡Œåˆ™å¯ä»¥çœ‹åˆ°åœ¨æ‰§è¡Œ yield a + b æ“ä½œæ—¶ï¼Œå®é™…ä¸Šæ˜¯å…ˆé€šè¿‡ LOAD_FAST å’Œ BINARY_ADD å°†æ–°è®¡ç®—å‡ºçš„å€¼ä¿å­˜åœ¨æ ˆé¡¶ï¼Œå†è¿›è¡Œäº† YIELD_VALUE å’Œ POP_TOP æŒ‡ä»¤æ“ä½œï¼ŒæŸ¥çœ‹ä¸€ä¸‹è¿™ä¸¤ä¸ªæŒ‡ä»¤çš„æºç ï¼š\n// Python/ceval.c  PyObject* _Py_HOT_FUNCTION _PyEval_EvalFrameDefault(PyThreadState *tstate, PyFrameObject *f, int throwflag) { // ...  case TARGET(POP_TOP): { PyObject *value = POP(); Py_DECREF(value); FAST_DISPATCH(); } // ...  case TARGET(YIELD_VALUE): { retval = POP(); if (co-\u0026gt;co_flags \u0026amp; CO_ASYNC_GENERATOR) { PyObject *w = _PyAsyncGenValueWrapperNew(retval); Py_DECREF(retval); if (w == NULL) { retval = NULL; goto error; } retval = w; } f-\u0026gt;f_stacktop = stack_pointer; goto exiting; } // ...  return _Py_CheckFunctionResult(tstate, NULL, retval, __func__); } å¯ä»¥çœ‹åˆ° YIELD_VALUE æŒ‡ä»¤çš„æ“ä½œéå¸¸ç®€å•ï¼Œå®ƒä¼šå…ˆå–å‡ºæ ˆé¡¶çš„æ•°æ®ä½œä¸º yield è¯­å¥çš„è¿”å›å€¼ï¼Œå†ä¿®æ”¹æŒ‡å‘å½“å‰æ ˆå¸§é¡¶éƒ¨çš„æŒ‡é’ˆæ‰€æŒ‡å‘çš„åœ°å€ï¼Œæœ€åé€šè¿‡ goto è¯­å¥ç»“æŸæ‰§è¡Œï¼›éšåï¼Œ_PyEval_EvalFrameDefault å‡½æ•°ä¼šå°†ç”Ÿæˆå™¨å¯¹è±¡çš„æ ˆå¸§ä»å½“å‰è°ƒç”¨é“¾ä¸­ç§»é™¤ï¼Œå¹¶è¿”å› retvalã€‚\n3 æ€»ç»“ è‡³æ­¤å¯ä»¥å‘ç° Python ä¸­çš„ç”Ÿæˆå™¨æ˜¯å®Œå…¨ç¬¦åˆåç¨‹çš„å®šä¹‰ï¼ˆå¯ä»¥åœ¨ç”¨æˆ·æ€ä¸­æ–­å’Œæ¢å¤ï¼‰çš„ï¼›åŒæ—¶ç”±äº Python è™šæ‹Ÿæœºæœ¬èº«çš„å®ç°æ˜¯ åŸºäºæ ˆçš„ï¼ˆStack-Basedï¼‰ï¼Œå› æ­¤ç”Ÿæˆå™¨å¯¹è±¡åœ¨å­—èŠ‚ç å±‚é¢çš„å®ç°ä¹Ÿæ˜¯éå¸¸ç®€æ´çš„ã€‚è€Œåç¨‹å¯ä»¥åœ¨çº¿ç¨‹çš„åŸºç¡€ä¹‹ä¸Šï¼Œå€ŸåŠ©åŸºäº epoll ç­‰ IO å¤šè·¯å¤ç”¨çš„äº‹ä»¶å¾ªç¯ï¼Œæ¥é©±åŠ¨ä¸åŒçš„å­ç¨‹åºï¼ˆsubroutineï¼‰å’Œä¸Šä¸‹æ–‡çš„æ‰§è¡Œï¼Œå®ç°å½¢ä¼¼é˜»å¡å¼ä½†å®é™…æ˜¯å¼‚æ­¥çš„ç¼–ç¨‹æ¨¡å‹ï¼Œé€‚ç”¨äº IO å¯†é›†å‹åœºæ™¯ã€‚\n","permalink":"http://zintrulcre.github.io/posts/python/python-source-code-coroutine/","summary":"Python æºç å­¦ä¹ ï¼ˆ5ï¼‰ï¼šåç¨‹ åç¨‹ coroutine æ˜¯ä¸€ç§ç”¨æˆ·æ€çš„è½»é‡çº§çº¿ç¨‹ï¼Œå®ƒå¯ä»¥åœ¨å‡½æ•°çš„ç‰¹å®šä½ç½®æš‚åœæˆ–æ¢å¤ï¼ŒåŒæ—¶è°ƒç”¨è€…å¯ä»¥ä»åç¨‹ä¸­è·å–çŠ¶æ€æˆ–å°†çŠ¶æ€ä¼ é€’ç»™åç¨‹ï¼›Pythonä¸­çš„ç”Ÿæˆå™¨ generator å°±æ˜¯ä¸€ä¸ªå…¸å‹çš„åç¨‹åº”ç”¨ï¼Œæœ¬æ–‡ç®€å•åœ°å¯¹ Python ä¸­ç”Ÿæˆå™¨çš„å®ç°è¿›è¡Œåˆ†æã€‚\n1 ç”Ÿæˆå™¨ å¦‚æœ Python ä¸­çš„å‡½æ•°å«æœ‰ yield å…³é”®å­—ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨è¿™ä¸ªå‡½æ•°æ—¶ï¼Œå®ƒä¸ä¼šå¦‚åŒæ™®é€šçš„å‡½æ•°ä¸€æ ·è¿è¡Œåˆ° return è¯­å¥å¹¶è¿”å›ä¸€ä¸ªå˜é‡ï¼Œè€Œæ˜¯ä¼šç«‹å³è¿”å›ä¸€ä¸ªç”Ÿæˆå™¨å¯¹è±¡ï¼›ä»¥ä¸€ä¸ªæ–æ³¢é‚£å¥‘æ•°åˆ—ç”Ÿæˆå‡½æ•°ä¸ºä¾‹ï¼š\ndef FibonacciSequenceGenerator(): a, b = 0, 1 while True: yield a + b a, b = b, a + b if __name__ == \u0026#34;__main__\u0026#34;: fsg = FibonacciSequenceGenerator() print(fsg) print(type(fsg)) $ python3 main.py \u0026lt;generator object FibonacciSequenceGenerator at 0x7fb4720b1ac0\u0026gt; \u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; å¯ä»¥çœ‹åˆ°å‡½æ•° FibonacciSequenceGenerator è¿”å›äº†ä¸€ä¸ªç±»å‹ä¸º generator çš„ç”Ÿæˆå™¨å¯¹è±¡ fï¼›å¯¹äºç”Ÿæˆå™¨å¯¹è±¡ï¼Œæˆ‘ä»¬ä¸èƒ½åƒæ“ä½œæ™®é€šå‡½æ•°ä¸€æ ·ç›´æ¥è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼Œè€Œæ˜¯è¦ä½¿ç”¨ next() æˆ– fsg.send() æ¥è¿›è¡Œå‡½æ•°åˆ‡æ¢ï¼Œä½¿å¾—ç”Ÿæˆå™¨å‡½æ•°å¼€å§‹æˆ–ç»§ç»­æ‰§è¡Œï¼Œç›´åˆ° yield æ‰€åœ¨è¡Œæˆ–æ˜¯å‡½æ•°æœ«å°¾å†å°†æ‰§è¡Œæƒäº¤è¿˜ç»™è°ƒç”¨æ–¹ï¼š\nfor i in range(100): print(next(fsg)) $ python3 main.","title":"Python æºç å­¦ä¹ ï¼ˆ5ï¼‰ï¼šåç¨‹"},{"content":"Python æºç å­¦ä¹ ï¼ˆ4ï¼‰ï¼šç¼–è¯‘å™¨å’Œè™šæ‹Ÿæœº Python æ˜¯ä¸€ç§è§£é‡Šå‹è¯­è¨€ï¼Œä¸€èˆ¬åœ¨ä½¿ç”¨å‰æˆ‘ä»¬ä¼šä» Python å®˜æ–¹ç½‘ç«™ä¸Šä¸‹è½½ä½¿ç”¨ C è¯­è¨€å¼€å‘ç¼–è¯‘çš„ CPython è§£é‡Šå™¨ï¼Œæœ¬æ–‡ç”¨åˆ°çš„æºç å‡æ¥è‡ª CPythonã€‚\nPython è§£é‡Šå™¨ï¼ˆPython Interpreterï¼‰ç”± Python ç¼–è¯‘å™¨ï¼ˆPython Compilerï¼‰å’Œ Python è™šæ‹Ÿæœºï¼ˆPython Virutal Machineï¼‰ä¸¤éƒ¨åˆ†ç»„æˆã€‚å½“æˆ‘ä»¬é€šè¿‡ Python å‘½ä»¤æ‰§è¡Œ Python ä»£ç æ—¶ï¼ŒPython ç¼–è¯‘å™¨ä¼šå°† Python ä»£ç ç¼–è¯‘ä¸º Python å­—èŠ‚ç ï¼ˆbytecodeï¼‰ï¼›éšå Python è™šæ‹Ÿæœºä¼šè¯»å–å¹¶é€æ­¥æ‰§è¡Œè¿™äº›å­—èŠ‚ç ã€‚\n1 Python ç¼–è¯‘å™¨ 1.1 ä»£ç å¯¹è±¡ Python æä¾›äº†å†…ç½®å‡½æ•° compileï¼Œå¯ä»¥ç¼–è¯‘ Python ä»£ç å¹¶ç”Ÿæˆä¸€ä¸ªåŒ…å«å­—èŠ‚ç ä¿¡æ¯çš„å¯¹è±¡ï¼Œä¸¾ä¾‹å¦‚ä¸‹ï¼š\n# test.py def Square(a): return a * a print(f\u0026#34;result:\\t\\t{Square(5)}\u0026#34;) # main.py f = \u0026#34;test.py\u0026#34; code_obj = compile(open(f).read(), f, \u0026#39;exec\u0026#39;) exec(code_obj) print(f\u0026#34;code_obj:\\t{code_obj}\u0026#34;) print(f\u0026#34;type:\\t\\t{type(code_obj)}\u0026#34;) $ python3 main.py result: 25 code_obj: \u0026lt;code object \u0026lt;module\u0026gt; at 0x7f052c156b30, file \u0026#34;test.py\u0026#34;, line 1\u0026gt; type: \u0026lt;class \u0026#39;code\u0026#39;\u0026gt; å¯ä»¥çœ‹åˆ°ç”Ÿæˆçš„ code_obj å¯¹è±¡çš„ç±»å‹æ˜¯ class 'code'ï¼Œå®ƒåœ¨æºç ä¸­å¯¹åº”çš„ç»“æ„ä½“æ˜¯ä»£ç å¯¹è±¡ PyCodeObjectï¼›ä»£ç å¯¹è±¡æ˜¯åç»­æ­¥éª¤ä¸­ Python è™šæ‹Ÿæœºæ“ä½œçš„æ ¸å¿ƒï¼Œå®ƒå°†å­—èŠ‚ç ç›¸å…³çš„å‚æ•°ä¸ªæ•°ã€å±€éƒ¨å˜é‡ã€å˜é‡åç§°ã€æŒ‡ä»¤åºåˆ—ç­‰ä¿¡æ¯åŒ…è£…æˆäº†ä¸€ä¸ªç»“æ„ä½“ï¼š\n// Include/cpython/code.h  /* Bytecode object */ struct PyCodeObject { PyObject_HEAD int co_argcount; /* #arguments, except *args */ int co_posonlyargcount; /* #positional only arguments */ int co_kwonlyargcount; /* #keyword only arguments */ int co_nlocals; /* #local variables */ int co_stacksize; /* #entries needed for evaluation stack */ int co_flags; /* CO_..., see below */ int co_firstlineno; /* first source line number */ PyObject *co_code; /* instruction opcodes */ PyObject *co_consts; /* list (constants used) */ PyObject *co_names; /* list of strings (names used) */ PyObject *co_varnames; /* tuple of strings (local variable names) */ PyObject *co_freevars; /* tuple of strings (free variable names) */ PyObject *co_cellvars; /* tuple of strings (cell variable names) */ /* The rest aren\u0026#39;t used in either hash or comparisons, except for co_name, used in both. This is done to preserve the name and line number for tracebacks and debuggers; otherwise, constant de-duplication would collapse identical functions/lambdas defined on different lines. */ Py_ssize_t *co_cell2arg; /* Maps cell vars which are arguments. */ PyObject *co_filename; /* unicode (where it was loaded from) */ PyObject *co_name; /* unicode (name, for reference) */ PyObject *co_lnotab; /* string (encoding addr\u0026lt;-\u0026gt;lineno mapping) See Objects/lnotab_notes.txt for details. */ void *co_zombieframe; /* for optimization only (see frameobject.c) */ PyObject *co_weakreflist; /* to support weakrefs to code objects */ /* Scratch space for extra data relating to the code object. Type is a void* to keep the format private in codeobject.c to force people to go through the proper APIs. */ void *co_extra; /* Per opcodes just-in-time cache * * To reduce cache size, we use indirect mapping from opcode index to * cache object: * cache = co_opcache[co_opcache_map[next_instr - first_instr] - 1] */ // co_opcache_map is indexed by (next_instr - first_instr).  // * 0 means there is no cache for this opcode.  // * n \u0026gt; 0 means there is cache in co_opcache[n-1].  unsigned char *co_opcache_map; _PyOpcache *co_opcache; int co_opcache_flag; // used to determine when create a cache.  unsigned char co_opcache_size; // length of co_opcache. }; å…¶ä¸­æ¯”è¾ƒé‡è¦çš„æˆå‘˜æœ‰ä¸¤ä¸ªï¼Œåˆ†åˆ«æ˜¯ç¼–è¯‘åç”Ÿæˆçš„æŒ‡ä»¤åºåˆ— co_code å’Œæ‰§è¡Œå½“å‰ä»£ç å—æ‰€éœ€çš„æ ˆç©ºé—´å¤§å° co_stacksizeã€‚\n1.2 å­—èŠ‚ç  åœ¨æ‰€æœ‰çš„è¿™äº›æˆå‘˜å˜é‡ä¸­ï¼ŒPyObject *co_code å­˜å‚¨äº†ç¼–è¯‘åç”Ÿæˆçš„æŒ‡ä»¤åºåˆ—ï¼Œå®ƒæ˜¯ä»¥å­—èŠ‚çš„æ–¹å¼å­˜å‚¨çš„ï¼š\n# test.py def Square(a): return a * a print(f\u0026#34;result:\\t\\t{Square(5)}\u0026#34;) # main.py f = \u0026#34;test.py\u0026#34; code_obj = compile(open(f).read(), f, \u0026#39;exec\u0026#39;) print(f\u0026#34;code obj:\\t{code_obj}\u0026#34;) print(f\u0026#34;stack size:\\t{code_obj.co_stacksize}\u0026#34;) result = exec(code_obj) bytecode = code_obj.co_code print(f\u0026#34;bytecode:\\t{bytecode}\u0026#34;) $ python3 main.py code obj: \u0026lt;code object \u0026lt;module\u0026gt; at 0x7f26cea5ab30, file \u0026#34;test.py\u0026#34;, line 1\u0026gt; stack size: 4 result: 25 bytecode: b\u0026#39;d\\x00d\\x01\\x84\\x00Z\\x00e\\x01d\\x02e\\x00d\\x03\\x83\\x01\\x9b\\x00\\x9d\\x02\\x83\\x01\\x01\\x00d\\x04S\\x00\u0026#39; æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Python å†…ç½®æ¨¡å— dis æ¥å°†è¿™äº›å­—èŠ‚ç åç¼–è¯‘æˆç±»ä¼¼äºæ±‡ç¼–è¯­è¨€çš„æ ¼å¼ï¼š\nimport dis dis.dis(bytecode) 0 LOAD_CONST 0 (0) 2 LOAD_CONST 1 (1) 4 MAKE_FUNCTION 0 6 STORE_NAME 0 (0) 8 LOAD_NAME 1 (1) 10 LOAD_CONST 2 (2) 12 LOAD_NAME 0 (0) 14 LOAD_CONST 3 (3) 16 CALL_FUNCTION 1 18 FORMAT_VALUE 0 20 BUILD_STRING 2 22 CALL_FUNCTION 1 24 POP_TOP 26 LOAD_CONST 4 (4) 28 RETURN_VALUE åœ¨åç¼–è¯‘åçš„è¾“å‡ºç»“æœä¸­ï¼Œç¬¬ä¸€åˆ—ä»£è¡¨å­—èŠ‚ç ä¸­æ¯ä¸€æ¡æŒ‡ä»¤çš„åç§»é‡ offsetï¼›ç¬¬äºŒåˆ—ä»£è¡¨å„æ¡åŠ©è®°ç¬¦ mnemonics çš„åç§°ï¼Œè¿™äº›åŠ©è®°ç¬¦å¯ä»¥å¾ˆæ–¹ä¾¿åœ°å¸®åŠ©æˆ‘ä»¬ç†è§£åœ¨åç»­çš„æ­¥éª¤ä¸­ Python è™šæ‹Ÿæœºè¦æ‰§è¡Œçš„äº‹ä»¶ï¼›ç¬¬ä¸‰åˆ—åˆ™æ˜¯æ¯æ¡æŒ‡ä»¤çš„æ“ä½œæ•° opargsã€‚\nåŒæ—¶ï¼Œåœ¨å­—èŠ‚ç å¯¹åº”çš„åå…­è¿›åˆ¶è¡¨ç¤ºä¸­ï¼Œæ¯ä¸€ä½æ•°å­—ä¹Ÿåˆ†åˆ«ä»£è¡¨äº†ä¸åŒçš„åŠ©è®°ç¬¦å’Œæ“ä½œæ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡æ‰“å°å‡ºå­—èŠ‚ç çš„åå…­è¿›åˆ¶ä»¥æŸ¥çœ‹å…¶å†…å®¹ï¼š\nprint(bytecode.hex()) 64 00 64 01 84 00 5a 00 65 01 64 02 65 00 64 03 83 01 9b 00 9d 02 83 01 01 00 64 04 53 00 ä»¥ä¸Šé¢åç¼–è¯‘åçš„è¾“å‡ºä¸ºä¾‹ï¼Œåœ¨ offset == 0 çš„åœ°æ–¹å¯ä»¥æ‰¾åˆ°æ•°å­— 64ï¼Œå³ LOAD_CONST åŠ è½½å¸¸é‡åŠ©è®°ç¬¦å¯¹åº”çš„æ“ä½œç  opcodeï¼Œå…¶åç´§è·Ÿç€çš„æ˜¯å®ƒçš„æ“ä½œæ•° opargs == 0ï¼›è€ŒæŒ‡ä»¤ç¬¬å››è¡Œå¯¹åº”çš„ offset == 6ï¼Œå¯ä»¥çœ‹åˆ° STORE_NAME åŠ©è®°ç¬¦å¯¹åº”çš„æ“ä½œç  opcode == 5a ï¼Œå…¶æ“ä½œæ•° opargs == 0ï¼›ä»¥æ­¤ç±»æ¨ã€‚\nPython çš„ opcode æ¨¡å—æä¾›äº†å…³äº Python è™šæ‹Ÿæœºä¸­åŠ©è®°ç¬¦å’Œæ“ä½œç çš„ç›¸å…³ä¿¡æ¯ï¼Œä¹Ÿå¯ä»¥åœ¨æºç çš„ Include/opcode.h ä¸­æ‰¾åˆ°ç›¸å…³å®šä¹‰ï¼š\nimport opcode print(opcode.opname[0x64]) print(opcode.opname[0x5a]) print(opcode.opmap[\u0026#39;LOAD_NAME\u0026#39;]) print(opcode.opmap[\u0026#39;RETURN_VALUE\u0026#39;]) LOAD_CONST STORE_NAME 101 83 1.3 ç¼–è¯‘åŸç† Python ç¼–è¯‘å™¨çš„å®ç°å’Œå…¶ä»–è¯­è¨€ç±»ä¼¼ï¼ŒåŒ…å«äº†è¯æ³•åˆ†æ Lexicalï¼Œè¯­æ³•åˆ†æ Syntax Analysis å’Œè¯­ä¹‰åˆ†æ Semantic Analysis ç­‰æ­¥éª¤ï¼Œæœ¬æ–‡ä¸å†èµ˜è¿°ç¼–è¯‘åŸç†çš„éƒ¨åˆ†ã€‚\n2 Python è™šæ‹Ÿæœº ç±»ä¼¼äº x86-64, arm å¹³å°å’Œ Java è™šæ‹Ÿæœºï¼ŒPython è™šæ‹Ÿæœºä¹Ÿæ˜¯ åŸºäºæ ˆçš„ï¼ˆStack-Basedï¼‰ï¼Œå®ƒçš„å‡½æ•°è°ƒç”¨éƒ½æ˜¯é€šè¿‡è°ƒç”¨æ ˆ call stack å’Œæ ˆå¸§ stackframe æ¥å®ç°çš„ã€‚\n2.1 è°ƒç”¨æ ˆ è°ƒç”¨æ ˆæ˜¯ CPU å¯„å­˜å™¨ä¸­çš„ä¸€å—å†…å­˜åŒºåŸŸï¼Œå®ƒæ˜¯ä¸€ç§ FILO çš„æ•°æ®ç»“æ„ï¼Œå¯ä»¥è¿›è¡Œæ’å…¥æˆ–åˆ é™¤æ“ä½œçš„ä¸€è¾¹ç§°ä¸ºæ ˆé¡¶ï¼Œå¦ä¸€è¾¹åˆ™ç§°ä¸ºæ ˆåº•ï¼›å¯¹äºæœ€å¸¸è§çš„ x86-64 æ¶æ„æ¥è¯´ï¼Œæ ˆåœ°å€ç©ºé—´æ˜¯è‡ªé¡¶å‘ä¸‹ï¼ˆhead downï¼‰å¢é•¿çš„ï¼š\nåœ¨ x86-64 å¹³å°ä¸‹ï¼Œå®ƒæ‹¥æœ‰ 16 ä¸ªé€šç”¨å¯„å­˜å™¨ general-purpose registersï¼Œå¯„å­˜å™¨è¢«é›†æˆåœ¨ CPU èŠ¯ç‰‡ä¸Šï¼Œå…¶ä¸­ rbp å¯„å­˜å™¨ä¿å­˜å½“å‰æ ˆå¸§çš„æ ˆåº•ï¼ˆæœ¬æ¬¡å‡½æ•°è°ƒç”¨å¼€å§‹æ—¶çš„ä½ç½®ï¼‰ï¼Œrsp å¯„å­˜å™¨ä¿å­˜å½“å‰æ ˆå¸§çš„æ ˆé¡¶ï¼ˆå‡½æ•°è¿è¡Œæ—¶çš„å½“å‰ä½ç½®ï¼‰ï¼Œrbp å’Œ rsp ä¹‹é—´çš„ç©ºé—´åˆ™è¢«ç§°ä¸ºæœ¬æ¬¡å‡½æ•°è°ƒç”¨çš„æ ˆå¸§ stack frameï¼›åœ¨æ¯ä¸€æ¬¡å‘ç”Ÿå‡½æ•°è°ƒç”¨æ—¶ï¼Œè°ƒç”¨æ ˆä¸Šéƒ½ä¼šç»´æŠ¤ä¸€ä¸ªç‹¬ç«‹çš„æ ˆå¸§ä»¥å­˜å‚¨å‡½æ•°è¿”å›å€¼ã€å‚æ•°ã€å±€éƒ¨å˜é‡ç­‰ä¿¡æ¯ï¼›å…¶ä»–é€šç”¨å¯„å­˜å™¨çš„åŠŸèƒ½å¦‚ä¸‹ã€‚\næ ˆç›¸å…³çš„æœ€å¸¸è§æ“ä½œæœ‰ push å’Œ popï¼Œpush æ“ä½œä¼šå°†ä¸€ä¸ªæ“ä½œæ•°æ’å…¥æ ˆé¡¶ï¼Œè¿™åŒ…å«äº†ä¸¤ä¸ªæ­¥éª¤ï¼Œåˆ†åˆ«æ˜¯å…ˆå°† rsp å¯„å­˜å™¨ä¿å­˜çš„åœ°å€å‡å» 8ï¼Œå†å°†æ“ä½œæ•°å†™å…¥åˆ°è¿™ä¸ªåœ°å€ä¸­ï¼›è€Œ pop åˆ™æ­£å¥½ç›¸åï¼Œå®ƒå…ˆä» rsp å¯„å­˜å™¨å­˜å‚¨çš„åœ°å€å–å‡ºæ•°æ®ï¼Œå†™å…¥åˆ°å…¶ä»–å¯„å­˜å™¨ä¸­ï¼Œå†å¯¹å…¶åœ°å€åŠ ä¸Š 8ã€‚\nä»¥è°ƒè¯•ä¸€ä¸ªç®€å•çš„ Swap å‡½æ•°è°ƒç”¨ä¸ºä¾‹ï¼›æœ¬æ–‡ä½¿ç”¨çš„æ‰€æœ‰æ±‡ç¼–è¯­è¨€éƒ½æ˜¯ AT\u0026amp;T Syntax çš„ï¼š\n// main.cpp #include \u0026lt;iostream\u0026gt; using namespace std; void Swap(int\u0026amp; a, int \u0026amp;b) { int c = a; a = b; b = c; } int main() { int a = 5, b = 9; Swap(a, b); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } ç”¨ gdb æ‰“å¼€å¹¶åœ¨ main å‡½æ•°å¤„æ–­ç‚¹ï¼›åœ¨ main å‡½æ•°æ ˆå¸§ä¸­ï¼Œä¼šé€šè¿‡ movl æŒ‡ä»¤å°†ä¸¤ä¸ªå¸¸é‡æ‹·è´åˆ°å†…å­˜ä¸­ï¼š\n$ g++ -g -O0 -o main main.cpp $ gdb main (gdb) b main (gdb) r (gdb) layout reg \u0026gt; 0x400852 \u0026lt;main()+9\u0026gt; movl $0x5,-0x14(%rbp) # å°†å¸¸é‡ 9 ä¿å­˜åœ¨ rbp - 18 çš„ä½ç½®\r0x400859 \u0026lt;main()+16\u0026gt; movl $0x9,-0x18(%rbp) # å°†å¸¸é‡ 5 ä¿å­˜åœ¨ rbp - 14 çš„ä½ç½®\råœ¨è°ƒç”¨å‡½æ•° Swap å‰ï¼Œä¼šåˆ†åˆ«å°†ä¸¤ä¸ªå‚æ•°å­˜å…¥ rdi å’Œ rsi å¯„å­˜å™¨ä¸­ï¼š\n0x400860 \u0026lt;main()+23\u0026gt; lea -0x18(%rbp),%rdx 0x400864 \u0026lt;main()+27\u0026gt; lea -0x14(%rbp),%rax 0x400868 \u0026lt;main()+31\u0026gt; mov %rdx,%rsi 0x40086b \u0026lt;main()+34\u0026gt; mov %rax,%rdi \u0026gt; 0x40086e \u0026lt;main()+37\u0026gt; callq 0x40081d \u0026lt;Swap(int\u0026amp;, int\u0026amp;)\u0026gt; (gdb) p *$rsi $6 = 9 (gdb) p *$rdi $7 = 5 åœ¨ callq æŒ‡ä»¤å¤„ä½¿ç”¨ stepi è¿›å…¥åˆ° Swap å‡½æ•°ä¸­ï¼Œæ­¤æ—¶ rbp å’Œ rsp æŒ‡é’ˆè¿˜åˆ†åˆ«æŒ‡å‘ main å‡½æ•°æ ˆå¸§çš„åº•éƒ¨å’Œé¡¶éƒ¨ï¼Œèƒ½å¤Ÿå‘ç°æ ˆåœ°å€ç©ºé—´çš„ç¡®æ˜¯å‘ä¸‹å¢é•¿çš„ï¼š\n\u0026gt; 0x40086e \u0026lt;main()+37\u0026gt; callq 0x40081d \u0026lt;Swap(int\u0026amp;, int\u0026amp;)\u0026gt; (gdb) si \u0026gt; 0x40081d \u0026lt;Swap(int\u0026amp;, int\u0026amp;)\u0026gt; push %rbp 0x40081e \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+1\u0026gt; mov %rsp,%rbp rbp 0x7fffffffe110 0x7fffffffe110 rsp 0x7fffffffe0e8 0x7fffffffe0e8 æ­¤æ—¶æ ˆå¸§ç»“æ„å¤§è‡´å¦‚ä¸‹ï¼š\næ‰§è¡Œæ¥ä¸‹æ¥çš„ push æŒ‡ä»¤ï¼Œå°† rbp çš„å€¼å­˜å…¥æ ˆé¡¶ï¼Œå¯ä»¥çœ‹åˆ° rsp çš„å€¼å‘ç”Ÿäº†å˜åŒ–ï¼š\n(gdb) ni 0x40081d \u0026lt;Swap(int\u0026amp;, int\u0026amp;)\u0026gt; push %rbp \u0026gt; 0x40081e \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+1\u0026gt; mov %rsp,%rbp rbp 0x7fffffffe110 0x7fffffffe110 rsp 0x7fffffffe0e0 0x7fffffffe0e0 ç»§ç»­æ‰§è¡Œä¸‹ä¸€æ¡ mov æŒ‡ä»¤ï¼Œé‡ç½® rbp çš„å€¼ï¼Œè¿›å…¥æ–°çš„æ ˆå¸§ï¼š\n(gdb) ni rbp 0x7fffffffe0e0 0x7fffffffe0e0 rsp 0x7fffffffe0e0 0x7fffffffe0e0 æ­¤æ—¶æ ˆå¸§ç»“æ„å˜æˆäº†å¦‚ä¸‹ï¼š\nå†ç»è¿‡ä¸€ç³»åˆ—çš„ mov æŒ‡ä»¤æ“ä½œï¼Œå°† a å’Œ b çš„å€¼äº¤æ¢ä¹‹åï¼Œæ‰§è¡Œä¸‹ä¸€æ¡ pop æŒ‡ä»¤ï¼Œå°†å­˜å‚¨çš„ä¸Šä¸€ä¸ªæ ˆå¸§åœ°å€å†™å…¥ rbp ä¸­ï¼ŒåŒæ—¶ä¿®æ”¹ rspï¼›ä¹‹åå†æ‰§è¡Œ retq æŒ‡ä»¤å³å¯ç»§ç»­è¿è¡Œ main å‡½æ•°çš„ä¸‹ä¸€æ¡æ±‡ç¼–æŒ‡ä»¤äº†ï¼š\n\u0026gt; 0x400847 \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+42\u0026gt; pop %rbp 0x400848 \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+43\u0026gt; retq rbp 0x7fffffffe0e0 0x7fffffffe0e0 rsp 0x7fffffffe0e0 0x7fffffffe0e0 (gdb) ni 0x400847 \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+42\u0026gt; pop %rbp \u0026gt; 0x400848 \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+43\u0026gt; retq rbp 0x7fffffffe110 0x7fffffffe110 rsp 0x7fffffffe0e8 0x7fffffffe0e8 Python ä¸­å‡½æ•°è°ƒç”¨é“¾å’Œè°ƒç”¨æ ˆä¹‹é—´çš„å…³ç³»ä¹Ÿå’Œ x86-64 å¹³å°ç±»ä¼¼ï¼Œåªä¸è¿‡æ˜¯æŠŠä»£ç å—å’Œæ ˆå¸§åˆ†åˆ«è¿›è¡Œäº†å°è£…è€Œå·²ã€‚\n2.2 æ ˆå¸§å¯¹è±¡ Python ä¸­çš„ä»£ç å¯¹è±¡ PyCodeObject æœ¬èº«åªåŒ…å«äº†å­—èŠ‚ç ç›¸å…³çš„ä¿¡æ¯ï¼Œå¹¶ä¸å…·å¤‡ç”¨äºæ‰§è¡Œå­—èŠ‚ç æ‰€éœ€è¦çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå› æ­¤éœ€è¦å¼•å…¥æ ˆå¸§å¯¹è±¡ PyFrameObjectï¼Œä½œä¸ºä»£ç å¯¹è±¡è¿è¡Œçš„å®¹å™¨ï¼Œå¹¶ç”¨æ¥æ¨¡æ‹Ÿå…¶ä»–å¹³å°ä¸‹çš„æ ˆå¸§ï¼š\n// cpython/Include/frameobject.h struct _frame { PyObject_VAR_HEAD struct _frame *f_back; /* previous frame, or NULL */ PyCodeObject *f_code; /* code segment */ PyObject *f_builtins; /* builtin symbol table (PyDictObject) */ PyObject *f_globals; /* global symbol table (PyDictObject) */ PyObject *f_locals; /* local symbol table (any mapping) */ PyObject **f_valuestack; /* points after the last local */ PyObject *f_trace; /* Trace function */ int f_stackdepth; /* Depth of value stack */ char f_trace_lines; /* Emit per-line trace events? */ char f_trace_opcodes; /* Emit per-opcode trace events? */ /* Borrowed reference to a generator, or NULL */ PyObject *f_gen; int f_lasti; /* Last instruction if called */ /* Call PyFrame_GetLineNumber() instead of reading this field directly. As of 2.3 f_lineno is only valid when tracing is active (i.e. when f_trace is set). At other times we use PyCode_Addr2Line to calculate the line from the current bytecode index. */ int f_lineno; /* Current line number */ int f_iblock; /* index in f_blockstack */ PyFrameState f_state; /* What state the frame is in */ PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */ PyObject *f_localsplus[1]; /* locals+stack, dynamically sized */ }; // cpython/Include/pyframe.h typedef struct _frame PyFrameObject; å¯ä»¥çœ‹åˆ°æ ˆå¸§å¯¹è±¡ä¸­å¤§è‡´åŒ…å«äº†ä»¥ä¸‹æ•°æ®ï¼Œå®ƒä»¬æ„æˆäº† Python è™šæ‹Ÿæœºæ‰§è¡Œå½“å‰æ ˆå¸§æ‰€éœ€è¦çš„æ‰€æœ‰ä¸Šä¸‹æ–‡ï¼š\n ä¸Šä¸€ä¸ªè¿è¡Œçš„æ ˆå¸§å¯¹è±¡çš„æŒ‡é’ˆ struct _frame *f_backï¼›Python è™šæ‹Ÿæœºä¸­è¿è¡Œçš„æ‰€æœ‰æ ˆå¸§å¯¹è±¡çš„ *f_back å…±åŒç»„æˆè°ƒç”¨æ ˆç»“æ„ï¼Œä»…æœ‰åˆå§‹æ ˆå¸§æœ‰ f_back == NULLï¼› ä»£ç å¯¹è±¡æŒ‡é’ˆ PyCodeObject *f_codeï¼Œå®ƒåŒ…å«äº†å½“å‰è¿è¡Œæ ˆå¸§æ‰€æ‰§è¡Œçš„å­—èŠ‚ç ä¿¡æ¯ï¼› ä»£ç å¯¹è±¡æ‰§è¡ŒæœŸé—´çš„æ ˆç»“æ„ PyObject **f_valuestackï¼Œåœ¨å¯¹å­—èŠ‚ç è¿›è¡Œè¿ç®—æ—¶ï¼Œéœ€è¦ä»æ ˆé¡¶è¯»å–æ•°æ®ï¼Œå¹¶å°†è¿ç®—ç»“æœå­˜å‚¨åœ¨æ ˆé¡¶ï¼Œf_valuestack å°±æ˜¯ç”¨æ¥ç”¨æ¥å­˜å‚¨æ•°æ®çš„æ ˆç»“æ„ï¼Œå®ƒçš„å¤§å°ç”±å¯¹åº”çš„ä»£ç å¯¹è±¡ f_code çš„å †æ ˆå¤§å°å†³å®šï¼› ä»£ç å¯¹è±¡æ‰§è¡ŒæœŸé—´ä½¿ç”¨çš„æ ˆç»“æ„çš„æ·±åº¦ int f_stackdepthï¼› ä¸Šä¸€æ¡æ‰§è¡Œè¿‡çš„å­—èŠ‚ç æŒ‡ä»¤ int f_lastiï¼Œç±»ä¼¼äº rip å¯„å­˜å™¨ï¼› å†…ç½®å‘½åç©ºé—´ã€å…¨å±€å‘½åç©ºé—´ã€å±€éƒ¨å‘½åç©ºé—´çš„æŒ‡é’ˆ PyObject *f_builtins, PyObject *f_globals, PyObject *f_localsï¼Œå®ƒä»¬æ˜¯ç”¨æ¥å®ç° Python ä¸­ä»ç¬¦å·åˆ°å¯¹è±¡çš„æ˜ å°„çš„ç»“æ„ï¼Œä¸€èˆ¬ç”¨å­—å…¸å®ç°ï¼Œæš‚ä¸è®¨è®ºï¼› ç”¨äºè·Ÿè¸ªä»£ç æ‰§è¡Œæƒ…å†µçš„å‡½æ•°æŒ‡é’ˆ PyObject *f_trace å’Œç›¸å…³æ•°æ® char f_trace_lines, char f_trace_opcodesï¼Œæš‚ä¸è®¨è®ºï¼› ç”¨äºæ‰§è¡Œç”Ÿæˆå™¨ä»£ç çš„æ•°æ® PyObject *f_genï¼Œæš‚ä¸è®¨è®ºï¼›  Python åœ¨ sys æ¨¡å—ä¸­æä¾›äº† _getframe å‡½æ•°æ¥è·å–æ ˆå¸§å¯¹è±¡ï¼›ä»¥ä¸€ä¸ªç®€å•çš„ Swap å‡½æ•°ä¸ºä¾‹ï¼Œåœ¨æœ€æ·±å±‚çš„å‡½æ•°è°ƒç”¨å¤„æ‰“å°å‡ºæ ˆå¸§å¯¹è±¡çš„ä¿¡æ¯ï¼š\nimport sys def Swap(a, b): frame = sys._getframe() while frame is not None: print(f\u0026#34;frame:\\t{frame}\u0026#34;) print(f\u0026#34;name:\\t{frame.f_code.co_name}\u0026#34;) print(f\u0026#34;locals:\\t{frame.f_locals.keys()}\\n\u0026#34;) print(f\u0026#34;back:\\t{frame.f_back}\\n\u0026#34;) frame = frame.f_back return b, a def main(): a, b = 5, 9 a, b = Swap(a, b) print(a, b) if __name__ == \u0026#34;__main__\u0026#34;: main() è¿è¡Œåå¯ä»¥è§‚å¯Ÿåˆ°ï¼Œåœ¨ Python ç¨‹åºå¼€å§‹æ‰§è¡Œæ—¶ä¼šå…ˆåˆ›å»ºä¸€ä¸ªå«åš module çš„æ ˆå¸§å¯¹è±¡ç”¨äºæ‰§è¡Œå½“å‰è„šæœ¬ä¸­çš„ä»£ç ï¼›åœ¨æ¯æ¬¡å‡½æ•°è°ƒç”¨çš„è¿‡ç¨‹ä¸­ï¼Œéƒ½ä¼šåˆ›å»ºå‡ºä¸€ä¸ªæ–°çš„æ ˆå¸§å¯¹è±¡ï¼Œè¿™äº›æ ˆå¸§å¯¹è±¡ä¼šä½¿ç”¨ f_back æŒ‡é’ˆä¿å­˜ä¸Šä¸€ä¸ªæ‰§è¡Œæ ˆå¸§çš„åœ°å€ï¼Œå¹¶åœ¨ä¹‹åè°ƒç”¨å…¶ä»–å‡½æ•°çš„æ—¶å€™è¢«å‹å…¥æ ˆé¡¶ï¼š\n$ python3 main.py frame: \u0026lt;frame at 0x7fe37d7e5900, file \u0026#39;/main.py\u0026#39;, line 36, code Swap\u0026gt; name: Swap locals: dict_keys([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;frame\u0026#39;]) back: \u0026lt;frame at 0x7fe71ca65040, file \u0026#39;/main.py\u0026#39;, line 46, code main\u0026gt; frame: \u0026lt;frame at 0x7fe376115040, file \u0026#39;/main.py\u0026#39;, line 46, code main\u0026gt; name: main locals: dict_keys([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]) back: \u0026lt;frame at 0x141f6f0, file \u0026#39;/main.py\u0026#39;, line 50, code \u0026lt;module\u0026gt;\u0026gt; frame: \u0026lt;frame at 0x1ade6f0, file \u0026#39;/main.py\u0026#39;, line 50, code \u0026lt;module\u0026gt;\u0026gt; name: \u0026lt;module\u0026gt; locals: dict_keys([\u0026#39;__name__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__package__\u0026#39;, \u0026#39;__loader__\u0026#39;, \u0026#39;__spec__\u0026#39;, \u0026#39;__annotations__\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;__file__\u0026#39;, \u0026#39;__cached__\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;Swap\u0026#39;, \u0026#39;main\u0026#39;]) back: None 9 5 2.2.1 å›æ”¶å’Œåˆ†é… å‰æ–‡è®¨è®ºè¿‡ç±»å‹å¯¹è±¡ï¼Œä»åˆšæ‰è·å–æ ˆå¸§å¯¹è±¡çš„ä¾‹å­é‡Œèƒ½å¤Ÿçœ‹åˆ°é€šè¿‡ sys._getframe() è·å–çš„ frame å¯¹è±¡çš„ç±»å‹åä¸º frameï¼Œä¸éš¾æ‰¾åˆ°å®ƒçš„ç±»å‹å¯¹è±¡å®é™…ä¸Šæ˜¯ PyFrame_Typeï¼Œæˆ‘ä»¬å¯ä»¥ä»ç±»å‹å¯¹è±¡åˆå§‹åŒ–æ—¶ä½¿ç”¨çš„å‡½æ•°æŒ‡é’ˆæ‰¾åˆ°å®ƒçš„ç›¸å…³æ“ä½œï¼š\nPyTypeObject PyFrame_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) \u0026#34;frame\u0026#34;, sizeof(PyFrameObject), sizeof(PyObject *), (destructor)frame_dealloc, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ (reprfunc)frame_repr, /* tp_repr */ 0, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ 0, /* tp_hash */ 0, /* tp_call */ 0, /* tp_str */ PyObject_GenericGetAttr, /* tp_getattro */ PyObject_GenericSetAttr, /* tp_setattro */ 0, /* tp_as_buffer */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */ 0, /* tp_doc */ (traverseproc)frame_traverse, /* tp_traverse */ (inquiry)frame_tp_clear, /* tp_clear */ 0, /* tp_richcompare */ 0, /* tp_weaklistoffset */ 0, /* tp_iter */ 0, /* tp_iternext */ frame_methods, /* tp_methods */ frame_memberlist, /* tp_members */ frame_getsetlist, /* tp_getset */ 0, /* tp_base */ 0, /* tp_dict */ }; å…¶ä¸­å¯¹æ ˆå¸§å¯¹è±¡è¿›è¡Œææ„çš„å‡½æ•°æ˜¯ frame_deallocï¼Œæ­¤å¤„çœç•¥äº†éƒ¨åˆ†ä»£ç ï¼š\n#define PyFrame_MAXFREELIST 200  static void _Py_HOT_FUNCTION frame_dealloc(PyFrameObject *f) { // ...  Py_XDECREF(f-\u0026gt;f_back); Py_DECREF(f-\u0026gt;f_builtins); Py_DECREF(f-\u0026gt;f_globals); Py_CLEAR(f-\u0026gt;f_locals); Py_CLEAR(f-\u0026gt;f_trace); PyCodeObject *co = f-\u0026gt;f_code; if (co-\u0026gt;co_zombieframe == NULL) { co-\u0026gt;co_zombieframe = f; } else { struct _Py_frame_state *state = get_frame_state(); #ifdef Py_DEBUG  // frame_dealloc() must not be called after _PyFrame_Fini()  assert(state-\u0026gt;numfree != -1); #endif  if (state-\u0026gt;numfree \u0026lt; PyFrame_MAXFREELIST) { ++state-\u0026gt;numfree; f-\u0026gt;f_back = state-\u0026gt;free_list; state-\u0026gt;free_list = f; } else { PyObject_GC_Del(f); } } Py_DECREF(co); Py_TRASHCAN_SAFE_END(f) } struct _Py_frame_state { PyFrameObject *free_list; /* number of frames currently in free_list */ int numfree; }; è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨éå¸¸é«˜é¢‘çš„å‡½æ•°ï¼ˆå‡ ä¹æ¯ä¸€æ¬¡æ ˆå¸§é€€å‡ºæ—¶éƒ½ä¼šè°ƒç”¨ï¼‰ï¼Œå› æ­¤é‡‡ç”¨äº†ä¸€äº›ç­–ç•¥æ¥è¿›è¡Œä¼˜åŒ–ä»¥é™ä½è°ƒç”¨å‡½æ•°çš„å¼€é”€ï¼›ä¸€ç§æ˜¯åœ¨é¦–æ¬¡è¿›è¡Œæ ˆå¸§å¯¹è±¡ f çš„å›æ”¶æ—¶ä¼šå…ˆåˆ¤æ–­æ ˆå¸§å¯¹è±¡å…³è”çš„ä»£ç å¯¹è±¡ co çš„æˆå‘˜æŒ‡é’ˆ co_zombieframe æ˜¯å¦ä¸ºç©º if (co-\u0026gt;co_zombieframe == NULL)ï¼›å¦‚æœæ˜¯ï¼Œåˆ™ä¼šå°†è¯¥æ ˆå¸§å¯¹è±¡ f ä¿å­˜åœ¨ä»£ç å¯¹è±¡çš„è¿™ä¸ªæŒ‡é’ˆä¸­ co-\u0026gt;co_zombieframe = fï¼Œè¿™æ ·çš„è¯åœ¨ä¸‹ä¸€æ¬¡æ‰§è¡Œç›¸åŒçš„ä»£ç å¯¹è±¡ co æ—¶ï¼Œå°±æ— éœ€å†æ¬¡é‡æ–°è¿›è¡Œæ ˆå¸§å¯¹è±¡ f çš„å†…å­˜åˆ†é…ï¼ˆåªè¦ä»£ç å¯¹è±¡ co ä¸å› ä¸ºå¼•ç”¨è®¡æ•°é™ä½ä¸º 0 è€Œè¢« gcï¼‰ï¼›å¯¹äºæ ˆå¸§å¯¹è±¡æ¥è¯´ï¼Œä»…æœ‰ ob_type, ob_size, f_code, f_valuestack å‡ ä¸ªæˆå‘˜å˜é‡ä¼šä¿ç•™åŸæœ‰çš„å€¼ï¼Œå› ä¸ºè¿™äº›æˆå‘˜å˜é‡ä¸å…¶ä»–å¯¹è±¡æ²¡æœ‰å…³è”ï¼Œè€Œ f_locals, f_trace, f_exc_type ç­‰æŒ‡é’ˆä¾ç„¶ä¼šè¢«é€šè¿‡ Py_CLEAR ç½®ä¸º NULLï¼Œå› ä¸ºé€šè¿‡è¿™äº›æŒ‡é’ˆå…³è”çš„å¯¹è±¡å¯èƒ½ä¼šé€šè¿‡å…¶ä»–é€”å¾„è¢«å›æ”¶ï¼Œä»è€Œå¯¼è‡´æ‚¬ç©ºæŒ‡é’ˆçš„é—®é¢˜ã€‚\nå¦ä¸€ä¸ªä¼˜åŒ–ç­–ç•¥æ˜¯å½“ä»£ç å¯¹è±¡ co çš„æˆå‘˜æŒ‡é’ˆ co-\u0026gt;co_zombieframe ä¸ä¸ºç©ºï¼Œå³å†æ¬¡æ‰§è¡Œç›¸åŒæ ˆå¸§æ—¶ï¼Œä¼šä½¿ç”¨ç”± Python çº¿ç¨‹ç»´æŠ¤çš„ç¼“å­˜æ ˆå¸§é“¾è¡¨ state-\u0026gt;free_list å°†æ ˆå¸§å¯¹è±¡å­˜å‚¨ä¸‹æ¥ï¼Œæ­¤æ—¶å¦‚æœæœ‰æ–°çš„æ ˆå¸§å¯¹è±¡è¢«å®šä¹‰çš„è¯ï¼Œå¯ä»¥ç›´æ¥ä»ç¼“å­˜æ ˆå¸§é“¾è¡¨ state-\u0026gt;free_list ä¸­è·å–ä¸€ä¸ªå·²ç»åˆ†é…å†…å­˜çš„æ ˆå¸§å¯¹è±¡ç›´æ¥èµ‹å€¼å¹¶ä½¿ç”¨ï¼Œä»¥è¾¾åˆ°å‡å°‘åˆ†é…å’Œå›æ”¶å†…å­˜çš„æ•ˆæœã€‚æ­¤å¤„å¯ä»¥ç»“åˆåˆ†é…æ ˆå¸§çš„ frame_alloc å‡½æ•°æ¥çœ‹ï¼š\nstatic inline PyFrameObject* frame_alloc(PyCodeObject *code) { // ...  if (state-\u0026gt;free_list == NULL) { f = PyObject_GC_NewVar(PyFrameObject, \u0026amp;PyFrame_Type, extras); if (f == NULL) { return NULL; } } else { #ifdef Py_DEBUG  // frame_alloc() must not be called after _PyFrame_Fini()  assert(state-\u0026gt;numfree != -1); #endif  assert(state-\u0026gt;numfree \u0026gt; 0); --state-\u0026gt;numfree; f = state-\u0026gt;free_list; state-\u0026gt;free_list = state-\u0026gt;free_list-\u0026gt;f_back; if (Py_SIZE(f) \u0026lt; extras) { PyFrameObject *new_f = PyObject_GC_Resize(PyFrameObject, f, extras); if (new_f == NULL) { PyObject_GC_Del(f); return NULL; } f = new_f; } _Py_NewReference((PyObject *)f); } // ... } å¯ä»¥çœ‹åˆ°åœ¨è¿›è¡Œæ ˆå¸§å¯¹è±¡çš„åˆ†é…æ—¶ï¼Œä¼šä¼˜å…ˆåˆ¤æ–­ç¼“å­˜æ ˆå¸§é“¾è¡¨ state-\u0026gt;free_list æ˜¯å¦ä¸ºç©ºï¼Œä¸ä¸ºç©ºçš„è¯åˆ™ä¼šä»å…¶é“¾è¡¨å¤´éƒ¨å–å‡ºä¸€ä¸ªå·²ç»åˆ†é…å¥½å†…å­˜çš„æ ˆå¸§å¯¹è±¡ï¼Œå¯¹å…¶èµ‹å€¼å¹¶ä½¿ç”¨ã€‚\nè¿™é¡¹ä¼˜åŒ–ï¼ˆå°†æœªä½¿ç”¨çš„æ ˆå¸§å¯¹è±¡ä¿å­˜åœ¨ç¼“å­˜æ ˆå¸§é“¾è¡¨ä¸­ï¼Œå¹¶åœ¨åˆ›å»ºå…¶ä»–æ ˆå¸§å¯¹è±¡æ—¶é‡å¤åˆ©ç”¨ï¼‰ä¸å‰è€…ï¼ˆåœ¨æ ˆå¸§é€€å‡ºæ—¶å°†æ ˆå¸§å¯¹è±¡éšä»£ç å¯¹è±¡ä¿å­˜ä¸‹æ¥ï¼Œåœ¨æ‰§è¡Œç›¸åŒä»£ç å¯¹è±¡æ—¶ç›´æ¥ä½¿ç”¨ï¼‰çš„åšæ³•æœ‰äº›å†²çªï¼Œå› æ­¤å‰è€…åœ¨æœ€æ–°çš„ PR 26076 ä¸­å·²ç»è¢«ç§»é™¤äº†ã€‚\n2.3 è¿è¡Œè¿‡ç¨‹ 2.3.1 è°ƒç”¨æµç¨‹ Python çš„ main å‡½æ•°åœ¨ cpython/Programs/python.c æ–‡ä»¶ä¸­ï¼Œè¿™éƒ¨åˆ†å®ç°æ¯”è¾ƒç®€å•ï¼Œå…¶è°ƒç”¨é“¾å¯ä»¥æ€»ç»“å¦‚ä¸‹ï¼š\nä»è°ƒç”¨é“¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œåœ¨çœŸæ­£æ‰§è¡Œ Python ä»£ç ä¹‹å‰ï¼Œä¼šå…ˆè¯»å–é…ç½®å¹¶è¿›è¡Œåˆå§‹åŒ–ï¼Œè¿™äº›é…ç½®ä¼šè¢«ä¿å­˜åˆ° cpython/Include/cpython/initconfig.h æ–‡ä»¶å®šä¹‰çš„ PyConfig ç»“æ„ä½“ä¸­ï¼Œè¿™ä¸ªç»“æ„ä½“åŒ…å«äº† Python è¿è¡Œæ—¶çš„ç¯å¢ƒå˜é‡ï¼Œè¿è¡Œæ¨¡å¼ç­‰ä¿¡æ¯ï¼›è€Œè°ƒç”¨é“¾ä¸­ pymain_run_python å‡½æ•°åçš„äº”ä¸ªåˆ†æ”¯å°±åˆ†åˆ«ä»£è¡¨äº† Python é€šè¿‡å‘½ä»¤è¡Œã€æ–‡ä»¶ã€æ ‡å‡†è¾“å…¥ç­‰æ–¹å¼è¿è¡Œçš„äº”ç§æ¨¡å¼ï¼Œä½†æ— è®ºæ˜¯é‚£ç§æ¨¡å¼ï¼Œæœ€ç»ˆéƒ½ä¼šé€šè¿‡è°ƒç”¨ run_eval_code_obj ä»¥åŠ PyEval_EvalCode å‡½æ•°æ¥æ‰§è¡Œç¼–è¯‘åçš„ä»£ç å¯¹è±¡ï¼Œåè€…å°±æ˜¯ Python è™šæ‹Ÿæœºæ‰§è¡ŒæŒ‡ä»¤çš„å…¥å£ä¹‹ä¸€ã€‚\n2.3.2 è¿è¡Œæ ˆå¸§ Python è™šæ‹Ÿæœºä¸­æ‰§è¡ŒæŒ‡ä»¤çš„å…¥å£æœ‰ PyEval_EvalCode å’Œ PyEval_EvalCodeExï¼Œå‰è€…ç›¸å¯¹äºåè€…çœç•¥äº†éƒ¨åˆ†å‚æ•°ï¼Œä»…å°†å¿…é¡»çš„ä»£ç å¯¹è±¡ï¼Œå…¨å±€å˜é‡å’Œå±€éƒ¨å˜é‡ä½œä¸ºå‚æ•°ä¼ å…¥ï¼Œå…¶ä»–å‚æ•°å‡è®¾ä¸º NULLã€‚\n// cpython/Python/eval.h PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyObject *, PyObject *, PyObject *); PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure); // cpython/Python/ceval.c PyObject * PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals) { return PyEval_EvalCodeEx(co, globals, locals, (PyObject **)NULL, 0, (PyObject **)NULL, 0, (PyObject **)NULL, 0, NULL, NULL); } è€Œ PyEval_EvalCodeEx å®é™…ä¸Šä¼šè°ƒç”¨ _PyEval_EvalCodeWithName å‡½æ•°ï¼Œè¿›è¡Œå‚æ•°ä¸ªæ•°å’Œç±»å‹çš„æ ¡éªŒï¼Œä»¥åŠçº¿ç¨‹çŠ¶æ€çš„æ£€æŸ¥ï¼Œå¹¶æœ€ç»ˆè°ƒç”¨äº† _PyEval_EvalCode å‡½æ•°ï¼š\nPyObject * _PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals, PyObject *const *args, Py_ssize_t argcount, PyObject *const *kwnames, PyObject *const *kwargs, Py_ssize_t kwcount, int kwstep, PyObject *const *defs, Py_ssize_t defcount, PyObject *kwdefs, PyObject *closure, PyObject *name, PyObject *qualname) { PyThreadState *tstate = _PyThreadState_GET(); return _PyEval_EvalCode(tstate, _co, globals, locals, args, argcount, kwnames, kwargs, kwcount, kwstep, defs, defcount, kwdefs, closure, name, qualname); } PyObject * PyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals, PyObject *const *args, int argcount, PyObject *const *kws, int kwcount, PyObject *const *defs, int defcount, PyObject *kwdefs, PyObject *closure) { return _PyEval_EvalCodeWithName(_co, globals, locals, args, argcount, kws, kws != NULL ? kws + 1 : NULL, kwcount, 2, defs, defcount, kwdefs, closure, NULL, NULL); } _PyEval_EvalCode å‡½æ•°ä¼šå¯¹ä»£ç å¯¹è±¡å‚æ•° PyCodeObject *co åŠå…¶å‚æ•°è¿›è¡Œå¸¸è§„æ£€æŸ¥ï¼Œå¹¶åˆå§‹åŒ–æ ˆå¸§å¯¹è±¡ PyFrameObject *fï¼Œå¹¶è°ƒç”¨ _PyEval_EvalFrameï¼š\n// cpython/Python/ceval.c PyObject * _PyEval_EvalCode(PyThreadState *tstate, PyObject *_co, PyObject *globals, PyObject *locals, PyObject *const *args, Py_ssize_t argcount, PyObject *const *kwnames, PyObject *const *kwargs, Py_ssize_t kwcount, int kwstep, PyObject *const *defs, Py_ssize_t defcount, PyObject *kwdefs, PyObject *closure, PyObject *name, PyObject *qualname) { PyObject *retval = NULL; /* Create the frame */ PyFrameObject *f = _PyFrame_New_NoTrack(tstate, co, globals, locals); if (f == NULL) { return NULL; } PyObject **fastlocals = f-\u0026gt;f_localsplus; PyObject **freevars = f-\u0026gt;f_localsplus + co-\u0026gt;co_nlocals; // ...  retval = _PyEval_EvalFrame(tstate, f, 0); fail: /* Jump here from prelude on failure */ /* decref\u0026#39;ing the frame can cause __del__ methods to get invoked, which can call back into Python. While we\u0026#39;re done with the current Python frame (f), the associated C stack is still in use, so recursion_depth must be boosted for the duration. */ if (Py_REFCNT(f) \u0026gt; 1) { Py_DECREF(f); _PyObject_GC_TRACK(f); } else { ++tstate-\u0026gt;recursion_depth; Py_DECREF(f); --tstate-\u0026gt;recursion_depth; } return retval; } _PyEval_EvalFrame å‡½æ•°è°ƒç”¨äº†ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œè¿™ä¸ªæŒ‡é’ˆæ˜¯éš Python è§£é‡Šå™¨åˆå§‹åŒ–çš„ï¼š\n// cpython/Python/internal/pycore_ceval.h static inline PyObject* _PyEval_EvalFrame(PyThreadState *tstate, PyFrameObject *f, int throwflag) { return tstate-\u0026gt;interp-\u0026gt;eval_frame(tstate, f, throwflag); } // cpython/Python/pystate.c PyInterpreterState * PyInterpreterState_New(void) { // ...  interp-\u0026gt;eval_frame = _PyEval_EvalFrameDefault; // ... } _PyEval_EvalFrameDefault æ˜¯æ•´ä¸ªè°ƒç”¨é“¾çš„ç»ˆç‚¹ï¼Œå®ƒçš„å‡½æ•°ä¸»ä½“æ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œä¸æ–­åœ°è¯»å…¥å­—èŠ‚ç ï¼Œå¹¶é€šè¿‡ switch è¯­å¥åˆ¤æ–­å…¶ç±»å‹å¹¶æ‰§è¡Œï¼Œ\nPyObject* _Py_HOT_FUNCTION _PyEval_EvalFrameDefault(PyThreadState *tstate, PyFrameObject *f, int throwflag) { _Py_EnsureTstateNotNULL(tstate); // ...  main_loop: for (;;) { opcode = _Py_OPCODE(*next_instr); switch (opcode) { case TARGET(LOAD_CONST): { PREDICTED(LOAD_CONST); PyObject *value = GETITEM(consts, oparg); Py_INCREF(value); PUSH(value); FAST_DISPATCH(); // ...  } // ... è¿™å°±æ˜¯æ•´ä¸ªè°ƒç”¨å’Œè¿è¡Œæ ˆå¸§å¯¹è±¡çš„è¿‡ç¨‹äº†ï¼Œæ•´ç†å¦‚ä¸‹ï¼š\n2.3.3 è°ƒè¯• æœ€åä»¥ [1.2](#1.2 å­—èŠ‚ç ) èŠ‚çš„ test.py ä»£ç ä¸ºä¾‹ï¼Œç®€å•åœ°ç”¨ gdb æ¥è¿›è¡Œ _PyEval_EvalFrameDefault å‡½æ•°ä¸­é€ä¸ªå­—èŠ‚ç æŒ‡ä»¤çš„è°ƒè¯•ï¼š\n$ gdb -ex r --args python3 test.py (gdb) b _PyEval_EvalFrameDefault Breakpoint 1 at 0x41fa90: file Python/ceval.c, line 919. (gdb) r (gdb) n # ... å¦‚æœæœ‰å¯¹åº”ç‰ˆæœ¬çš„æºç æ–‡ä»¶çš„è¯ä¹Ÿå¯ä»¥ç›´æ¥æ–­ç‚¹åœ¨ switch (opcode) { æ‰€åœ¨çš„è¡Œæ•°ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸æ–­åœ°å¾€åæ‰§è¡Œç›´åˆ°è¿™ä¸€è¡Œä¹‹åï¼š\n(gdb) layout split 1487 case TARGET(LOAD_CONST): { 1488 PREDICTED(LOAD_CONST); \u0026gt; 1489 PyObject *value = GETITEM(consts, oparg); 1490 Py_INCREF(value); 1491 PUSH(value); 1492 FAST_DISPATCH(); 1493 } (gdb) p opcode $1 = 100 (gdb) p oparg $2 = 0 å¯ä»¥çœ‹åˆ°åœ¨æ‰§è¡Œ LOAD_CONST åŠ©è®°ç¬¦æ—¶ï¼Œå…¶å¯¹åº”çš„ opcode çš„åå…­è¿›åˆ¶è¡¨ç¤ºä¸º64ï¼Œåè¿›åˆ¶è¡¨ç¤ºä¸º 100ï¼ŒLOAD_CONST é¦–å…ˆè·å–äº† oparg çš„å€¼ï¼Œå¹¶å¡«å…¥åˆ°æ ˆé¡¶ï¼›\n2343 case TARGET(STORE_NAME): { \u0026gt; 2344 PyObject *name = GETITEM(names, oparg); 2345 PyObject *v = POP(); 2346 PyObject *ns = f-\u0026gt;f_locals; 2347 int err; 2348 if (ns == NULL) { 2349 _PyErr_Format(tstate, PyExc_SystemError, 2350 \u0026#34;no locals found when storing %R\u0026#34;, name); 2351 Py_DECREF(v); 2352 goto error; 2353 } 2354 if (PyDict_CheckExact(ns)) 2355 err = PyDict_SetItem(ns, name, v); 2356 else 2357 err = PyObject_SetItem(ns, name, v); 2358 Py_DECREF(v); 2359 if (err != 0) 2360 goto error; 2361 DISPATCH(); 2362 } STORE_NAME ä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œå®ƒä»æ ˆé¡¶å–å‡ºä¸€ä¸ªæ•°å€¼ï¼Œå¹¶å­˜å‚¨åœ¨å±€éƒ¨å‘½åç©ºé—´ä¸­ï¼›\n2828 case TARGET(BUILD_MAP): { 2829 Py_ssize_t i; \u0026gt; 2830 PyObject *map = _PyDict_NewPresized((Py_ssize_t)oparg); 2831 if (map == NULL) 2832 goto error; 2833 for (i = oparg; i \u0026gt; 0; i--) { 2834 int err; 2835 PyObject *key = PEEK(2*i); 2836 PyObject *value = PEEK(2*i - 1); 2837 err = PyDict_SetItem(map, key, value); 2838 if (err != 0) { 2839 Py_DECREF(map); 2840 goto error; 2841 } 2842 } 2843 2844 while (oparg--) { 2845 Py_DECREF(POP()); 2846 Py_DECREF(POP()); 2847 } 2848 PUSH(map); 2849 DISPATCH(); 2850 } (gdb) p opcode $9 = 105 (gdb) p oparg $10 = 0 BUILD_MAP ç¨å¾®å¤æ‚ä¸€äº›ï¼Œå®ƒä¼šæ„é€ ä¸€ä¸ª Python ä¸­çš„å­—å…¸å¯¹è±¡ï¼ˆæºç ä¸­ PyDictObject ç»“æ„ä½“çš„å®ä¾‹å¯¹è±¡ï¼Œç”¨å“ˆå¸Œè¡¨å®ç°ï¼‰ï¼Œå¹¶ä¸æ–­åœ°ä»æ ˆå¸§ä¸Šè·å– key å’Œ value æ’å…¥åˆ°å­—å…¸ä¸­ï¼›\n2312 case TARGET(LOAD_BUILD_CLASS): { 2313 _Py_IDENTIFIER(__build_class__); 2314 \u0026gt; 2315 PyObject *bc; 2316 if (PyDict_CheckExact(f-\u0026gt;f_builtins)) { 2317 bc = _PyDict_GetItemIdWithError(f-\u0026gt;f_builtins, \u0026amp;PyId___build_class__); 2318 if (bc == NULL) { 2319 if (!_PyErr_Occurred(tstate)) { 2320 _PyErr_SetString(tstate, PyExc_NameError, 2321 \u0026#34;__build_class__ not found\u0026#34;); 2322 } 2323 goto error; 2324 } 2325 Py_INCREF(bc); 2326 } 2327 else { 2328 PyObject *build_class_str = _PyUnicode_FromId(\u0026amp;PyId___build_class__); 2329 if (build_class_str == NULL) 2330 goto error; 2331 bc = PyObject_GetItem(f-\u0026gt;f_builtins, build_class_str); 2332 if (bc == NULL) { 2333 if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) 2334 _PyErr_SetString(tstate, PyExc_NameError, 2335 \u0026#34;__build_class__ not found\u0026#34;); 2336 goto error; 2337 } 2338 } 2339 PUSH(bc); 2340 DISPATCH(); 2341 } (gdb) p opcode $11 = 71 (gdb) p oparg $12 = 0 LOAD_BUILD_CLASS åˆ™ä¼šä»å†…ç½®å‘½åç©ºé—´ä¸­é€šè¿‡å“ˆå¸Œæ–¹æ³•æ‰¾åˆ°å‡½æ•°æŒ‡é’ˆï¼Œå¹¶æ’å…¥æ ˆé¡¶ï¼›\nå…¶ä»–çš„å­—èŠ‚ç æŒ‡ä»¤è¿˜æœ‰å¾ˆå¤šï¼Œéƒ½å¯ä»¥é€šè¿‡é˜…è¯»æºç æˆ–è€…ä½¿ç”¨ gdb è°ƒè¯•çš„æ–¹æ³•æ‰¾åˆ°å…¶å®é™…æ‰§è¡Œçš„ä»£ç ï¼›ç›¸æ¯”äºæ±‡ç¼–æŒ‡ä»¤ï¼Œå­—èŠ‚ç æŒ‡ä»¤å®é™…ä¸Šä»£è¡¨äº†ç”±è®¸å¤šè¡Œä»£ç ç»„æˆçš„åŠŸèƒ½ï¼Œè€Œ Python è™šæ‹Ÿæœºåˆ™æ˜¯é€šè¿‡å­—èŠ‚ç æŒ‡ä»¤æ¨¡æ‹Ÿå‡ºäº†å¯¹æ±‡ç¼–æŒ‡ä»¤çš„æ‰§è¡Œè¿‡ç¨‹ã€‚\n","permalink":"http://zintrulcre.github.io/posts/python/python-source-code-interpreter/","summary":"Python æºç å­¦ä¹ ï¼ˆ4ï¼‰ï¼šç¼–è¯‘å™¨å’Œè™šæ‹Ÿæœº Python æ˜¯ä¸€ç§è§£é‡Šå‹è¯­è¨€ï¼Œä¸€èˆ¬åœ¨ä½¿ç”¨å‰æˆ‘ä»¬ä¼šä» Python å®˜æ–¹ç½‘ç«™ä¸Šä¸‹è½½ä½¿ç”¨ C è¯­è¨€å¼€å‘ç¼–è¯‘çš„ CPython è§£é‡Šå™¨ï¼Œæœ¬æ–‡ç”¨åˆ°çš„æºç å‡æ¥è‡ª CPythonã€‚\nPython è§£é‡Šå™¨ï¼ˆPython Interpreterï¼‰ç”± Python ç¼–è¯‘å™¨ï¼ˆPython Compilerï¼‰å’Œ Python è™šæ‹Ÿæœºï¼ˆPython Virutal Machineï¼‰ä¸¤éƒ¨åˆ†ç»„æˆã€‚å½“æˆ‘ä»¬é€šè¿‡ Python å‘½ä»¤æ‰§è¡Œ Python ä»£ç æ—¶ï¼ŒPython ç¼–è¯‘å™¨ä¼šå°† Python ä»£ç ç¼–è¯‘ä¸º Python å­—èŠ‚ç ï¼ˆbytecodeï¼‰ï¼›éšå Python è™šæ‹Ÿæœºä¼šè¯»å–å¹¶é€æ­¥æ‰§è¡Œè¿™äº›å­—èŠ‚ç ã€‚\n1 Python ç¼–è¯‘å™¨ 1.1 ä»£ç å¯¹è±¡ Python æä¾›äº†å†…ç½®å‡½æ•° compileï¼Œå¯ä»¥ç¼–è¯‘ Python ä»£ç å¹¶ç”Ÿæˆä¸€ä¸ªåŒ…å«å­—èŠ‚ç ä¿¡æ¯çš„å¯¹è±¡ï¼Œä¸¾ä¾‹å¦‚ä¸‹ï¼š\n# test.py def Square(a): return a * a print(f\u0026#34;result:\\t\\t{Square(5)}\u0026#34;) # main.py f = \u0026#34;test.py\u0026#34; code_obj = compile(open(f).read(), f, \u0026#39;exec\u0026#39;) exec(code_obj) print(f\u0026#34;code_obj:\\t{code_obj}\u0026#34;) print(f\u0026#34;type:\\t\\t{type(code_obj)}\u0026#34;) $ python3 main.py result: 25 code_obj: \u0026lt;code object \u0026lt;module\u0026gt; at 0x7f052c156b30, file \u0026#34;test.","title":"Python æºç å­¦ä¹ ï¼ˆ4ï¼‰ï¼šç¼–è¯‘å™¨å’Œè™šæ‹Ÿæœº"},{"content":"Python æºç å­¦ä¹ ï¼ˆ3ï¼‰ï¼šlist ç±»å‹ Python ä¸­çš„ list ç±»å‹åœ¨æºç ä¸­æ˜¯ä¸€ä¸ªåä¸º PyListObject çš„ç»“æ„ä½“ï¼Œå®šä¹‰åœ¨ listobject.h æ–‡ä»¶ä¸­ï¼š\n// Include/cpython/listobject.h typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for \u0026#39;allocated\u0026#39; elements. The number * currently in use is ob_size. * Invariants: * 0 \u0026lt;= ob_size \u0026lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated; } PyListObject; å®ƒçš„å®ç°å’Œ C++ ä¸­çš„ std::vector ç±»ä¼¼ï¼Œéƒ½æ˜¯é€šè¿‡ç»´æŠ¤ä¸€ä¸ªåŠ¨æ€æ•°ç»„ï¼Œåœ¨å¢åŠ æ•°æ®çš„æ—¶å€™åŠ¨æ€æ‰©å¤§æ•°ç»„çš„å®¹é‡æ¥å®ç°çš„ï¼›PyListObject ç»“æ„ä¸­åŒ…å«äº†ä¸€ä¸ªå˜é•¿å¯¹è±¡å¤´éƒ¨ PyObject_VAR_HEADï¼Œob_size è¡¨ç¤ºå½“å‰åŠ¨æ€æ•°ç»„çš„é•¿åº¦ï¼Œ**ob_item æ˜¯æŒ‡å‘åŠ¨æ€æ•°ç»„çš„æŒ‡é’ˆï¼Œallocated æ˜¯åŠ¨æ€æ•°ç»„çš„å®¹é‡ï¼›æˆ‘ä»¬å¯ä»¥ä»å®ƒçš„ç±»å‹æŒ‡é’ˆ PyTypeObject PyList_Type ä¸­æ‰¾åˆ°ç”¨æ¥æ“ä½œ list å¯¹è±¡çš„ç›¸å…³æ–¹æ³•ï¼š\n// Objects/listobject.c PyTypeObject PyList_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) \u0026#34;list\u0026#34;, sizeof(PyListObject), list_methods, /* tp_methods */ // ... }; static PyMethodDef list_methods[] = { {\u0026#34;__getitem__\u0026#34;, (PyCFunction)list_subscript, METH_O|METH_COEXIST, \u0026#34;x.__getitem__(y) \u0026lt;==\u0026gt; x[y]\u0026#34;}, LIST___REVERSED___METHODDEF LIST___SIZEOF___METHODDEF LIST_CLEAR_METHODDEF LIST_COPY_METHODDEF LIST_APPEND_METHODDEF LIST_INSERT_METHODDEF LIST_EXTEND_METHODDEF LIST_POP_METHODDEF LIST_REMOVE_METHODDEF LIST_INDEX_METHODDEF LIST_COUNT_METHODDEF LIST_REVERSE_METHODDEF LIST_SORT_METHODDEF {\u0026#34;__class_getitem__\u0026#34;, (PyCFunction)Py_GenericAlias, METH_O|METH_CLASS, PyDoc_STR(\u0026#34;See PEP 585\u0026#34;)}, {NULL, NULL} /* sentinel */ }; #define LIST_APPEND_METHODDEF \\ {\u0026#34;append\u0026#34;, (PyCFunction)list_append, METH_O, list_append__doc__},  PyDoc_STRVAR(list_append__doc__, \u0026#34;append($self, object, /)\\n\u0026#34; \u0026#34;--\\n\u0026#34; \u0026#34;\\n\u0026#34; \u0026#34;Append object to the end of the list.\u0026#34;); #define LIST_COPY_METHODDEF \\ {\u0026#34;copy\u0026#34;, (PyCFunction)list_copy, METH_NOARGS, list_copy__doc__},  PyDoc_STRVAR(list_copy__doc__, \u0026#34;copy($self, /)\\n\u0026#34; \u0026#34;--\\n\u0026#34; \u0026#34;\\n\u0026#34; \u0026#34;Return a shallow copy of the list.\u0026#34;); Python ä¸­ä¹ŸæŠŠæ‰€è°“çš„å‡½æ•°å°è£…æˆäº†ä¸€ä¸ªå«åš PyMethodDef çš„ç±»å‹ï¼Œå…¶ä¸­åŒ…æ‹¬äº†å‡½æ•°çš„åç§° *ml_nameã€å¯¹åº”çš„ C å‡½æ•°å®ç° ml_methã€C å‡½æ•°æ‰€éœ€è¦çš„æ ‡å¿— ml_flagsï¼Œä»¥åŠå‡½æ•°è¯´æ˜ *ml_docï¼š\n// Include/methodobject.h struct PyMethodDef { const char *ml_name; /* The name of the built-in function/method */ PyCFunction ml_meth; /* The C function that implements it */ int ml_flags; /* Combination of METH_xxx flags, which mostly describe the args expected by the C func */ const char *ml_doc; /* The __doc__ attribute, or NULL */ }; typedef struct PyMethodDef PyMethodDef; 1 append å¦‚ list_append__doc__ ä¸­æ‰€æè¿°çš„ï¼Œlist_append å‡½æ•°çš„ç›®çš„æ˜¯å‘ list çš„æœ«å°¾æ·»åŠ æ–°çš„å…ƒç´ ï¼š\n// Objects/listobject.c static PyObject * list_append(PyListObject *self, PyObject *object) /*[clinic end generated code: output=7c096003a29c0eae input=43a3fe48a7066e91]*/ { if (app1(self, object) == 0) Py_RETURN_NONE; return NULL; } static int app1(PyListObject *self, PyObject *v) { Py_ssize_t n = PyList_GET_SIZE(self); assert (v != NULL); assert((size_t)n + 1 \u0026lt; PY_SSIZE_T_MAX); if (list_resize(self, n+1) \u0026lt; 0) return -1; Py_INCREF(v); PyList_SET_ITEM(self, n, v); return 0; } static int list_resize(PyListObject *self, Py_ssize_t newsize) { PyObject **items; size_t new_allocated, num_allocated_bytes; Py_ssize_t allocated = self-\u0026gt;allocated; /* Bypass realloc() when a previous overallocation is large enough to accommodate the newsize. If the newsize falls lower than half the allocated size, then proceed with the realloc() to shrink the list. */ if (allocated \u0026gt;= newsize \u0026amp;\u0026amp; newsize \u0026gt;= (allocated \u0026gt;\u0026gt; 1)) { assert(self-\u0026gt;ob_item != NULL || newsize == 0); Py_SET_SIZE(self, newsize); return 0; } /* This over-allocates proportional to the list size, making room * for additional growth. The over-allocation is mild, but is * enough to give linear-time amortized behavior over a long * sequence of appends() in the presence of a poorly-performing * system realloc(). * Add padding to make the allocated size multiple of 4. * The growth pattern is: 0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ... * Note: new_allocated won\u0026#39;t overflow because the largest possible value * is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t. */ new_allocated = ((size_t)newsize + (newsize \u0026gt;\u0026gt; 3) + 6) \u0026amp; ~(size_t)3; /* Do not overallocate if the new size is closer to overallocated size * than to the old size. */ if (newsize - Py_SIZE(self) \u0026gt; (Py_ssize_t)(new_allocated - newsize)) new_allocated = ((size_t)newsize + 3) \u0026amp; ~(size_t)3; if (newsize == 0) new_allocated = 0; num_allocated_bytes = new_allocated * sizeof(PyObject *); items = (PyObject **)PyMem_Realloc(self-\u0026gt;ob_item, num_allocated_bytes); if (items == NULL) { PyErr_NoMemory(); return -1; } self-\u0026gt;ob_item = items; Py_SET_SIZE(self, newsize); self-\u0026gt;allocated = new_allocated; return 0; } å¯ä»¥çœ‹åˆ°åœ¨ list_append ä¸­å…ˆè°ƒç”¨äº† list_resizeï¼Œè¿™ä¸ªå‡½æ•°å¯èƒ½ä¼šè¿›è¡Œä¸¤ä¸ªæ“ä½œï¼š\n åœ¨æ·»åŠ å…ƒç´ åï¼Œå¦‚æœæ–°çš„åŠ¨æ€æ•°ç»„é•¿åº¦ newsize åœ¨åŒºé—´ [allocated / 2, allocated] å†…ï¼ˆå°äºå½“å‰å®¹é‡ allocated ä¸”å¤§äºç­‰äºå½“å‰å®¹é‡çš„ä¸€åŠ allocated \u0026gt;\u0026gt; 1ï¼‰ï¼Œåˆ™å°†æ•°ç»„å®¹é‡ç¼©å°ä¸º newsizeï¼› å¦åˆ™é€šè¿‡å…¬å¼ new_allocated = ((size_t)newsize + (newsize \u0026gt;\u0026gt; 3) + 6) \u0026amp; ~(size_t)3 è®¡ç®—å‡º append ä¹‹ååŠ¨æ€æ•°ç»„åº”è¯¥è¢«åˆ†é…çš„æ–°å®¹é‡ new_allocatedï¼Œå¹¶é‡æ–°åˆ†é…å†…å­˜ã€‚  å…¶ä¸­ç¬¬äºŒæ­¥çš„å…¬å¼ä¸å¤ªç›´è§‚ï¼Œå¯ä»¥åˆ—è¡¨è§‚å¯Ÿå…·ä½“å€¼çš„å˜åŒ–ï¼š\n   åŠ¨æ€æ•°ç»„é•¿åº¦ ob_size å½“å‰å®¹é‡ allocated append åæ–°çš„é•¿åº¦ newsize append åæ–°çš„å®¹é‡ new_allocated     0 0 1 (1 + 0 + 6) \u0026amp; 252 = 111 \u0026amp; 11111100 = 4   3 4 4 4 âˆˆ [2, 4]ï¼ˆä¸å˜ï¼‰   4 8 5 (5 + 0 + 6) \u0026amp; 252 = 1011 \u0026amp; 11111100 = 8   7 8 8 8 âˆˆ [4, 8]ï¼ˆä¸å˜ï¼‰   8 16 9 (9 + 1 + 6) \u0026amp; 252 = 10000 \u0026amp; 11111100 = 16   15 16 16 16 âˆˆ [8, 16]ï¼ˆä¸å˜ï¼‰   16 16 17 (16 + 2 + 6) \u0026amp; 252 = 10011 \u0026amp; 11111100 = 24    å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œåªæœ‰å½“ append åæ–°çš„é•¿åº¦ newsize å¤§äºå½“å‰å®¹é‡ allocated æ—¶ï¼Œæ‰ä¼šå°†å®¹é‡è°ƒæ•´ä¸ºä¸€ä¸ªæ›´å¤§çš„å€¼ï¼Œè¿™ä¸ªå€¼ä»¥ 4 çš„å€æ•°æ¥è¡¥è¶³å’Œå¡«å……ï¼›ä½¿ç”¨ python æµ‹è¯•ä»£ç æ¥éªŒè¯ä¸Šè¡¨çš„è®¡ç®—ç»“æœï¼š\nimport sys l = [] s = sys.getsizeof(l) print((sys.getsizeof(l) - s) // 8) for _ in range(17): l.append(0) print(\u0026#34;newsize\u0026#34;, len(l), \u0026#34;new_allocated\u0026#34;, (sys.getsizeof(l) - s) // 8) $ python3 main.py newsize 1 new_allocated 4 newsize 2 new_allocated 4 newsize 3 new_allocated 4 newsize 4 new_allocated 4 newsize 5 new_allocated 8 newsize 6 new_allocated 8 newsize 7 new_allocated 8 newsize 8 new_allocated 8 newsize 9 new_allocated 16 newsize 10 new_allocated 16 newsize 11 new_allocated 16 newsize 12 new_allocated 16 newsize 13 new_allocated 16 newsize 14 new_allocated 16 newsize 15 new_allocated 16 newsize 16 new_allocated 16 newsize 17 new_allocated 24 ä½¿ç”¨ Python3.9 å‰åçš„ç‰ˆæœ¬æµ‹è¯•è¾ƒå¤§æ•°æ®æ—¶å¯èƒ½ä¼šæœ‰å‡ºå…¥ï¼Œå› ä¸ºè®¡ç®— new_allocated çš„è¿‡ç¨‹è¿›è¡Œè¿‡ä¿®æ”¹ï¼š\nå’Œ std::vector ç±»ä¼¼ï¼Œç”±æ‘Šè¿˜åˆ†æçš„æ–¹æ³•å¯çŸ¥ list_append çš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º O(1)ã€‚\n2 copy å¦‚ list_copy__doc__ ä¸­æ‰€æè¿°çš„ï¼Œlist_copy å‡½æ•°çš„ç›®çš„æ˜¯è¿”å›ä¸€ä¸ªæµ…æ‹·è´ï¼ˆshallow copyï¼‰çš„ listï¼š\nstatic PyObject * list_copy(PyListObject *self, PyObject *Py_UNUSED(ignored)) { return list_copy_impl(self); } static PyObject * list_copy_impl(PyListObject *self) { return list_slice(self, 0, Py_SIZE(self)); } static PyObject * list_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh) { PyListObject *np; PyObject **src, **dest; Py_ssize_t i, len; len = ihigh - ilow; np = (PyListObject *) list_new_prealloc(len); if (np == NULL) return NULL; src = a-\u0026gt;ob_item + ilow; dest = np-\u0026gt;ob_item; for (i = 0; i \u0026lt; len; i++) { PyObject *v = src[i]; Py_INCREF(v); dest[i] = v; } Py_SET_SIZE(np, len); return (PyObject *)np; } ä» PyListObject çš„å®šä¹‰ä¸­å¯ä»¥å¾—çŸ¥åŠ¨æ€æ•°ç»„æŒ‡é’ˆ PyObject **ob_item æ‰€æŒ‡å‘çš„åŠ¨æ€æ•°ç»„ä¸­å­˜å‚¨çš„æ˜¯å¯¹è±¡çš„æŒ‡é’ˆï¼Œå› æ­¤åœ¨ list_slice å‡½æ•°ä¸­ï¼Œä¹Ÿåªæ˜¯ç®€å•åœ°å°† PyListObject *a ä¸­æ¯ä¸€ä¸ª PyObject çš„æŒ‡é’ˆä¾æ¬¡èµ‹äºˆ PyListObject *npï¼Œå¹¶å°†å…¶å¼•ç”¨è®¡æ•°åŠ  1ï¼›å¯¹äºè¢«æ‹·è´çš„ list ä¸­çš„ä»»æ„ä¸€ä¸ªå€¼å¾—ä¿®æ”¹éƒ½ä¼šåæ˜ åˆ°æ‹·è´åˆ°çš„ list ä¸Šï¼š\na = [1, True, [1, 2]] b = a print(a, b) a[0], a[1], a[2] = 0, False, [3, 4] print(a, b) è¿™é‡Œçš„ b = a ä¸­åœ¨ C++ ä¸­ä¸€èˆ¬è¡¨ç¤ºæ‹·è´æ„é€ æˆ–æ‹·è´èµ‹å€¼æ“ä½œï¼Œä½†åœ¨ Python ä¸­å®é™…ä¸Šåˆ™ä¼šè°ƒç”¨ list_copyï¼š\n$ python3 main.py [1, True, [1, 2]] [1, True, [1, 2]] [0, False, [3, 4]] [0, False, [3, 4]] å¦‚æœæƒ³è¦å¯¹ä¸€ä¸ª list è¿›è¡Œæ·±æ‹·è´ï¼Œå¯ä»¥è°ƒç”¨ copy æ¨¡å—çš„ deepcopy å‡½æ•°ï¼Œè¿™æ˜¯ä¸€ä¸ªç”¨ Python å®ç°çš„æ¨¡å—ï¼š\ndef deepcopy(x, memo=None, _nil=[]): \u0026#34;\u0026#34;\u0026#34;Deep copy operation on arbitrary Python objects. See the module\u0026#39;s __doc__ string for more info. \u0026#34;\u0026#34;\u0026#34; if memo is None: memo = {} d = id(x) y = memo.get(d, _nil) if y is not _nil: return y cls = type(x) copier = _deepcopy_dispatch.get(cls) if copier is not None: y = copier(x, memo) else: if issubclass(cls, type): y = _deepcopy_atomic(x, memo) else: copier = getattr(x, \u0026#34;__deepcopy__\u0026#34;, None) if copier is not None: y = copier(memo) else: # ... # If is its own copy, don\u0026#39;t memoize. if y is not x: memo[d] = y _keep_alive(x, memo) # Make sure x lives at least as long as d return y deepcopy ä¼šé€šè¿‡ _deepcopy_dispatch.get æ¥è·å–å†…ç½®å®¹å™¨çš„æ‹·è´å™¨ï¼Œå°†å†…ç½®å®¹å™¨ä¸­çš„æ•°æ®ä¾æ¬¡é€’å½’åœ°è¿›è¡Œæ‹·è´ï¼›ä¸ºäº†é˜²æ­¢æŸäº›å®¹å™¨å­˜å‚¨çš„å€¼å½“ä¸­åŒ…å«æŒ‡å‘è‡ªå·±çš„æŒ‡é’ˆï¼Œæˆ–æ˜¯æ— é™é‡å¤çš„æ•°æ®ï¼Œå‡½æ•°ä¸­ä¼šä½¿ç”¨ä¸€ä¸ª dict å˜é‡ memo æ¥è®°å½•å·²ç»è¢«æ‹·è´è¿‡çš„æ•°æ®ï¼Œé˜²æ­¢ deepcopy æ— é™åœ°é€’å½’ä¸‹å»ã€‚\nå¦‚æœå®¹å™¨ä¸­å­˜å‚¨çš„æ˜¯è‡ªå®šä¹‰ç±»å‹çš„å¯¹è±¡ï¼Œdeepcopy ä¼šé€šè¿‡ copier = getattr(x, \u0026quot;__deepcopy__\u0026quot;, None) è·å–åˆ°è¿™ä¸ªç±»å‹ä¸­çš„å‡½æ•° __deepcopy__ï¼Œå¹¶å°†å…¶ä½œä¸ºä¸€ä¸ªæ‹·è´å™¨ç”¨æ¥ç”Ÿæˆæ–°çš„å¯¹è±¡ï¼Œè¿™ä¹Ÿå°±æ„å‘³ç€æˆ‘ä»¬éœ€è¦å®ç° __deepcopy__ å‡½æ•°æ¥ä¿è¯å®ƒå¯ä»¥è¢«æ­£ç¡®åœ°æ·±æ‹·è´ï¼Œä»¥ä¸€ä¸ªè‡ªå®šä¹‰çš„æœ‰å‘å›¾ç»“æ„ä¸ºä¾‹ï¼š\nimport copy class DirectedGraphNode: def __init__(self, idx, node_list): self.idx = idx self.node_list = node_list def point_to(self, node): self.node_list.append(node) def __repr__(self): return \u0026#39;id {}, idx {}, node_list {}\u0026#39;.format(id(self), self.idx, [node.idx for node in self.node_list]) def __deepcopy__(self, memo): print(f\u0026#34;DirectedGraphNode: __deepcopy__ from {repr(self)}\u0026#34;) if self in memo: exist_obj = memo.get(self) return exist_obj cp_obj = DirectedGraphNode(self.idx, []) memo[self] = cp_obj for node in self.node_list: cp_obj.point_to(copy.deepcopy(node, memo)) print(f\u0026#34; copy done, self: {repr(self)}\u0026#34;) return cp_obj a = DirectedGraphNode(1, []) b = DirectedGraphNode(2, []) a.point_to(b) b.point_to(a) print(repr(a)) print(repr(b)) c = copy.deepcopy(a) print(repr(c)) for node in c.node_list: print(repr(node)) åœ¨å®ƒçš„ __deepcopy__ å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä»¥å…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘ï¼Œå…ˆæ„é€ å‡ºæ–°çš„èŠ‚ç‚¹å¯¹è±¡ cp_objï¼Œå†å°†å®ƒæŒ‡å‘çš„æ‰€æœ‰èŠ‚ç‚¹ä»¥é€’å½’çš„æ–¹å¼ä¾æ¬¡è¿›è¡Œæ·±æ‹·è´ï¼Œå¦‚æœåœ¨æ‹·è´çš„è¿‡ç¨‹ä¸­å‘ç°èŠ‚ç‚¹æ˜¯å·²ç»è¢«æ‹·è´è¿‡çš„ï¼Œåˆ™ç›´æ¥è¿”å› exist_objï¼š\n$ python3 main.py id 139867268624336, idx 1, node_list [2] id 139867268624240, idx 2, node_list [1] DirectedGraphNode: __deepcopy__ from id 139867268624336, idx 1, node_list [2] DirectedGraphNode: __deepcopy__ from id 139867268624240, idx 2, node_list [1] DirectedGraphNode: __deepcopy__ from id 139867268624336, idx 1, node_list [2] copy done, self: id 139867268624240, idx 2, node_list [1] copy done, self: id 139867268624336, idx 1, node_list [2] id 139867268624048, idx 1, node_list [2] id 139867268623040, idx 2, node_list [1] ","permalink":"http://zintrulcre.github.io/posts/python/source-code-3-list-and-dict/","summary":"Python æºç å­¦ä¹ ï¼ˆ3ï¼‰ï¼šlist ç±»å‹ Python ä¸­çš„ list ç±»å‹åœ¨æºç ä¸­æ˜¯ä¸€ä¸ªåä¸º PyListObject çš„ç»“æ„ä½“ï¼Œå®šä¹‰åœ¨ listobject.h æ–‡ä»¶ä¸­ï¼š\n// Include/cpython/listobject.h typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for \u0026#39;allocated\u0026#39; elements. The number * currently in use is ob_size. * Invariants: * 0 \u0026lt;= ob_size \u0026lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations.","title":"Python æºç å­¦ä¹ ï¼ˆ3ï¼‰ï¼šlist ç±»å‹"},{"content":"ProtoBuf è¯­æ³•å’Œç¼–ç åŸç†å…¥é—¨ åºåˆ—åŒ–æ˜¯æŒ‡å°†ç»“æ„åŒ–æ•°æ®è½¬æ¢æˆæ˜“äºå­˜å‚¨æˆ–å‘é€çš„æ•°æ®æ ¼å¼çš„è¿‡ç¨‹ï¼ŒProtocol Buffer ç®€ç§° ProtoBufï¼Œæ˜¯ä¸€ç§è¯­è¨€æ— å…³ï¼Œå¹³å°æ— å…³çš„åºåˆ—åŒ–å·¥å…·ï¼Œç”±è°·æ­Œåœ¨ 2008 å¹´å¼€æºã€‚ç›¸è¾ƒäºå¸¸è§çš„åºåˆ—åŒ–å·¥å…· XML, JSON, YAML, CSV ç­‰ï¼ŒProtoBuf çš„ä¼˜åŠ¿ä¸»è¦åŒ…æ‹¬åºåˆ—åŒ–åæ•°æ®é‡å°ï¼Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–è¿‡ç¨‹é€Ÿåº¦å¿«ï¼Œä½¿ç”¨æ—¶åªéœ€å®šä¹‰ proto æ–‡ä»¶ä½¿å¾—å…¶ç»´æŠ¤æˆæœ¬ä½ï¼Œå¯å‘åå…¼å®¹ç­‰ï¼›ä½†å› ä¸ºå…¶æ•°æ®ä»¥äºŒè¿›åˆ¶æ•°æ®æµçš„å½¢å¼å­˜åœ¨ï¼Œä¹Ÿæœ‰äººç±»ä¸å¯è¯»çš„åŠ£åŠ¿ã€‚\næœ¬æ–‡ä¸»è¦ä»‹ç» ProtoBuf çš„ä½¿ç”¨æ–¹æ³•ï¼ŒåŒ…æ‹¬ .proto æ–‡ä»¶çš„è¯­æ³•ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨ protoc å·¥å…·æ¥ç”Ÿæˆä¸é€šè¯­è¨€çš„ä»£ç ï¼›ä»¥åŠå…¶ç¼–ç åŸç†ã€‚\n1 è¯­æ³• é¦–å…ˆä» https://github.com/protocolbuffers/protobuf æ‰¾åˆ°æœ€æ–°ç‰ˆæœ¬çš„ ProtoBufï¼Œä¸‹è½½é¢„ç¼–è¯‘å¥½çš„äºŒè¿›åˆ¶æ–‡ä»¶ protoc è§£å‹åˆ°ç¯å¢ƒå˜é‡ç›®å½•ï¼Œæœ¬æ–‡ä½¿ç”¨çš„æ˜¯ 3.15.7 ç‰ˆæœ¬ï¼š\n$ protoc --version libprotoc 3.15.7 ä»¥ä¸€ä¸ªç®€å•çš„ proto æ–‡ä»¶ä¸ºä¾‹ï¼Œå®ƒçš„è¯­æ³•å’Œ C++ ç±»ä¼¼ï¼š\n// msg.proto syntax = \u0026#34;proto3\u0026#34;;package Message;message SearchRequest { reserved 6, 9 to 12; reserved \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;; string query = 1; int32 page_number = 2; int32 result_per_page = 3;}message ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; }}message SearchResponse {  repeated ResultType.Result results = 1;}ä½¿ç”¨ protoc å·¥å…·ç”ŸæˆæŒ‡å®šè¯­è¨€çš„ä»£ç ï¼š\nprotoc --proto_path=./ --go_out=./go_out/ --cpp_out=./cpp_out/ msg.proto å…¶ä¸­ --proto_path æˆ– -I ç”¨äºå‚æ•°æŒ‡å®šç”Ÿæˆæ‰€éœ€çš„ proto æ–‡ä»¶å’Œè¢«å¯¼å…¥çš„ proto æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•ï¼Œä¸æŒ‡å®šçš„è¯é»˜è®¤ä¸ºå½“å‰ç›®å½•ï¼›go_out å’Œ cpp_out åˆ†åˆ«ä¸ºç”Ÿæˆçš„ go æ–‡ä»¶å’Œ cpp æ–‡ä»¶æŒ‡å®šç›®å½•ï¼›æœ€åæ˜¯æˆ‘ä»¬æ‰€éœ€è¦è½¬æ¢çš„æ‰€æœ‰ proto æ–‡ä»¶ï¼›æ›´å¤šçš„å‚æ•°å¯ä»¥è¾“å…¥ protoc --help æŸ¥çœ‹ã€‚\n1.1 æ•°æ®ç»“æ„ msg.proto æ–‡ä»¶é‡ŒåŒ…å«äº†ä¸¤éƒ¨åˆ†å†…å®¹ï¼šé¦–å…ˆéœ€è¦æŒ‡å®š ProtoBuf çš„ç‰ˆæœ¬ä¸º proto3ï¼Œä¸æŒ‡å®šçš„è¯ç¼–è¯‘å™¨åˆ™ä¼šé»˜è®¤ä½¿ç”¨è€ç‰ˆæœ¬çš„ proto2 è¯­æ³•ï¼›ç„¶åæ˜¯å®šä¹‰æˆ‘ä»¬æ‰€éœ€è¦çš„ message ç±»å‹ã€‚message ç±»å‹ä¸­æœ‰å¾ˆå¤šå­—æ®µï¼Œæ¯ä¸ªå­—æ®µéƒ½å¯¹åº”ä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„ç¼–å·ï¼Œè¿™äº›ç¼–å·æ˜¯ç”¨æ¥åœ¨åºåˆ—åŒ–åçš„äºŒè¿›åˆ¶æ•°æ®æµä¸­è¯†åˆ«å­—æ®µç”¨çš„ã€‚\nå­—æ®µå’Œç¼–å· å­—æ®µï¼ˆfieldï¼‰åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼š\n å”¯ä¸€çš„ï¼ˆsingularï¼‰ï¼šå­—æ®µçš„é»˜è®¤ç±»å‹ï¼Œè¿™æ ·çš„å­—æ®µå¯¹åº”çš„æ•°æ®åªèƒ½æ˜¯ 0 ä¸ªæˆ– 1 ä¸ªï¼› é‡å¤çš„ï¼ˆrepeatedï¼‰ï¼šç±»ä¼¼äºæ•°ç»„ï¼Œè¿™æ ·çš„å­—æ®µå¯¹åº”çš„æ•°æ®å¯ä»¥æœ‰ä»»æ„å¤šä¸ªï¼Œå¹¶ä¸”ä¼šä¿ç•™å…¶é¡ºåºã€‚  åœ¨å°†å­—æ®µå¯¹åº”åˆ°ç¼–å·ï¼ˆnumberï¼‰ä¸Šæ—¶ï¼Œéœ€è¦æ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š\n æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ [1, 19000) å’Œ (19999, 2^29 - 1] åŒºé—´å†…çš„ä»»æ„ç¼–å·ç”¨æ¥æ ‡è¯†å­—æ®µï¼Œä¸­é—´ [19000, 19999] æ˜¯ä¸º ProtoBuf çš„å®ç°æ‰€é¢„ç•™çš„ï¼› åœ¨å¯¹ proto æ–‡ä»¶è¿›è¡Œç¼–ç æ—¶ï¼Œç¼–å· 1 åˆ° 15 éœ€è¦å ç”¨ 1 ä¸ªå­—èŠ‚ï¼Œ16 åˆ° 2047 éœ€è¦å ç”¨ 2 ä¸ªå­—èŠ‚ï¼Œå› æ­¤ä¸€èˆ¬ä¼šå°†å¸¸ç”¨çš„å­—æ®µå¯¹åº”åˆ°ç¼–å· 1 åˆ° 15ä¸Šä»¥èŠ‚çº¦ç©ºé—´ï¼› ä¸€æ—¦ä½¿ç”¨äº†æŸä¸ªç¼–å·å°±ä¸èƒ½ä¿®æ”¹å…¶å¯¹åº”å­—æ®µçš„ç±»å‹äº†ï¼Œå¦åˆ™ä¼šé€ æˆæ— æ³•å…¼å®¹çš„é—®é¢˜ã€‚  ç»„åˆå’ŒåµŒå¥—ç»“æ„ æˆ‘ä»¬å¯ä»¥ç›´æ¥åœ¨ä¸€ä¸ª message ç±»å‹é‡Œç›´æ¥åµŒå¥—å£°æ˜å¹¶ä½¿ç”¨å¦ä¸€ä¸ª message ç»“æ„ï¼š\nmessage SearchResponse {  message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1;}å¦‚æœè¦ä½¿ç”¨åœ¨å¦ä¸€ä¸ª message ç±»å‹é‡ŒåµŒå¥—å£°æ˜çš„å­ message ç±»å‹ï¼Œåˆ™éœ€è¦åœ¨å®šä¹‰æ—¶åŠ ä¸Šå…¶çˆ¶ message ç±»å‹çš„åç§°ï¼š\nmessage ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; }}message SearchResponse {  repeated ResultType.Result results = 1;}ç±»ä¼¼çš„ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä»¥ç»„åˆçš„æ–¹å¼åœ¨ä¸€ä¸ª message ç±»å‹é‡Œå¼•å…¥å¦ä¸€ä¸ª message ç±»å‹ä½œä¸ºå­—æ®µï¼Œå¹¶ä¸ºå…¶èµ‹äºˆ repeated å±æ€§ï¼›å¦‚æœå¼•å…¥çš„ message ç±»å‹åœ¨å¦ä¸€ä¸ª proto æ–‡ä»¶ä¸­åˆ™éœ€è¦ import å¯¹åº”çš„æ–‡ä»¶ï¼š\n// msg.proto import \u0026#34;result.proto\u0026#34;;message SearchResponse { repeated Result results = 1;}// result.proto message Result { string url = 1; string title = 2; repeated string snippets = 3;}import import çš„æ–¹å¼æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯ä»¥ç›¸å¯¹è·¯å¾„çš„æ–¹å¼ importï¼Œå¦‚ä¸Šé¢çš„ä¾‹å­ï¼›å¦ä¸€ç§æ˜¯åœ¨ä½¿ç”¨ protoc å·¥å…·ç”Ÿæˆä»£ç æ—¶ä½¿ç”¨ -I æŒ‡ä»¤æŒ‡å®šæ‰€éœ€è¦åŒ…å«çš„ proto æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•ï¼Œå¹¶ä»¥ç»å¯¹è·¯å¾„çš„æ–¹å¼ importï¼š\n$ tree . |-- msg.proto `-- result `-- result.proto 1 directory, 2 files $ protoc -I. -I./result/ --go_out=./ msg.proto 1.2 å…³é”®å­— åŒ… åŒ…ï¼ˆpackageï¼‰çš„åŠŸèƒ½å¾ˆç®€å•ï¼Œç±»ä¼¼äº C è¯­è¨€ä¸­çš„ namespaceï¼Œå®ƒå¯ä»¥ç”¨æ¥é¿å…ä¸åŒçš„ ProtoBuf æ¶ˆæ¯ä¹‹é—´çš„å‘½åå†²çªï¼š\npackage Message;æœåŠ¡ æœåŠ¡ï¼ˆserviceï¼‰æ˜¯ç”¨æ¥å®šä¹‰ RPC æ‰€ä½¿ç”¨çš„æ¶ˆæ¯ç±»å‹çš„ï¼Œåœ¨ gPRC æœ‰éå¸¸å……åˆ†çš„åº”ç”¨ï¼Œå®ƒçš„å®šä¹‰å’Œ Go çš„å‡½æ•°å®šä¹‰æ¯”è¾ƒç±»ä¼¼ï¼š\nservice SearchService { rpc Search (SearchRequest) returns (SearchResponse);}é€‰é¡¹ é€‰é¡¹ï¼ˆoptionï¼‰å¯ä»¥æ”¹å˜ proto æ–‡ä»¶ä¸­æŸäº›é¢„å®šä¹‰ä¸Šä¸‹æ–‡çš„å¤„ç†æ–¹å¼ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºï¼š\n optimize_for ä¿®æ”¹ä»£ç ç”Ÿæˆçš„æ–¹å¼ï¼Œæœ‰ SPEED é«˜åº¦ä¼˜åŒ–ï¼ŒCODE_SIZE å‡å°‘ä»£ç ï¼Œä»¥åŠ LITE_RUNTIME ç²¾ç®€åŠŸèƒ½ä¸‰ç§ç±»å‹ï¼› packed é’ˆå¯¹ repeated ç±»å‹çš„å­—æ®µï¼Œç”Ÿæˆæ›´ç´§å‡‘çš„ä»£ç ï¼› deprecated é’ˆå¯¹å­—æ®µï¼Œè¡¨æ˜å·²ç»åºŸå¼ƒï¼Œä¸€èˆ¬åªä¼šç”Ÿæˆæ³¨é‡Šï¼Œåº”è¯¥å°½é‡æ­é… reserved å…³é”®å­—ä½¿ç”¨ã€‚  option optimize_for = CODE_SIZE;// ...  repeated int32 samples = 4 [packed=true]; int32 old_field = 6 [deprecated=true];ç‰ˆæœ¬å…¼å®¹ ä¸ºäº†ä½¿å¾—æ–°ç‰ˆæœ¬çš„ proto æ–‡ä»¶èƒ½å¤Ÿå…¼å®¹è€ç‰ˆæœ¬çš„ï¼Œæˆ‘ä»¬ä¸èƒ½ä¿®æ”¹ä»»ä½•å·²æœ‰å­—æ®µçš„ç±»å‹ï¼Œé˜²æ­¢åœ¨ä½¿ç”¨ä»¥å¾€ç‰ˆæœ¬çš„è€ä»£ç åœ¨è§£ææ–°ç‰ˆæœ¬çš„æ•°æ®ç»“æ„æ—¶å‘ç”Ÿå…¼å®¹æ€§é—®é¢˜ã€‚\nå½“æˆ‘ä»¬ä¸å†ä½¿ç”¨æŸäº›å­—æ®µæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†å­—æ®µåŠå…¶å¯¹åº”çš„ç¼–å·éƒ½åˆ é™¤æˆ–æ³¨é‡Šæ‰ï¼›ä¸ºäº†é˜²æ­¢æˆ‘ä»¬ä¸å°å¿ƒå†æ¬¡ä½¿ç”¨ç›¸åŒçš„ç¼–å·å¹¶å°†å…¶å¯¹åº”åˆ°ä¸åŒç±»å‹çš„å­—æ®µä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ reserved å…³é”®å­—æ¥å¯¹å·²ç»è¢«åˆ é™¤çš„å­—æ®µå’Œç¼–å·è¿›è¡Œæ ‡æ³¨ï¼Œè®©ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥è¿™äº›å­—æ®µå’Œç¼–å·æ˜¯å¦æœ‰è¢«å†æ¬¡ä½¿ç”¨ï¼š\n// msg.proto message SearchRequest { reserved 3, 6, 9 to 12; reserved \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;; string query = 1; int32 page_number = 2; int32 result_per_page = 3;}$ protoc -I. --go_out=./ msg.proto msg.proto: Field \u0026#34;result_per_page\u0026#34; uses reserved number 3. 1.3 æ•°æ®ç±»å‹ åŸºç¡€ç±»å‹ ä¸‹é¢çš„åˆ—è¡¨åˆ—å‡ºäº† proto æ–‡ä»¶ä¸­å¯ä»¥ä½¿ç”¨çš„æ‰€æœ‰åŸºç¡€æ•°æ®ç±»å‹\n   ç±»å‹ é»˜è®¤å€¼ è¯´æ˜ C++ ç±»å‹ Python ç±»å‹ Go ç±»å‹     double 0  double float float64   float 0  float float float32   int32 0 ä½¿ç”¨ varint ç¼–ç ï¼Œå› æ­¤å¦‚æœæœ‰è´Ÿæ•°å»ºè®®ä½¿ç”¨ sint32 int32 int int32   int64 0 ä½¿ç”¨ varint ç¼–ç ï¼Œå› æ­¤å¦‚æœæœ‰è´Ÿæ•°å»ºè®®ä½¿ç”¨ sint64 int64 int/long[3] int64   uint32 0 ä½¿ç”¨ varint ç¼–ç  uint32 int/long[3] uint32   uint64 0 ä½¿ç”¨ varint ç¼–ç  uint64 int/long[3] uint64   sint32 0 ä½¿ç”¨ varint ç¼–ç ï¼Œæœ‰ç¬¦å· int32 int int32   sint64 0 ä½¿ç”¨ varint ç¼–ç ï¼Œæœ‰ç¬¦å· int64 int/long[3] int64   fixed32 0 å›ºå®š 4 å­—èŠ‚ï¼Œå¦‚æœæ•°å€¼è¶…è¿‡ 228 åˆ™æ¯” uint32 æ•ˆç‡æ›´é«˜ uint32 int/long[3] uint32   fixed64 0 å›ºå®š 8 å­—èŠ‚ï¼Œå¦‚æœæ•°å€¼è¶…è¿‡ 256 åˆ™æ¯” uint64 æ•ˆç‡æ›´é«˜ uint64 int/long[3] uint64   sfixed32 0 å›ºå®š 4 å­—èŠ‚ int32 int int32   sfixed64 0 å›ºå®š 8 å­—èŠ‚ int64 int/long[3] int64   bool false  bool bool bool   string \u0026quot;\u0026quot; å¿…é¡»ä»¥ UTF-8 æˆ– 7ä½ ASCII ç¼–ç ï¼Œé•¿åº¦ä¸èƒ½è¶…è¿‡ 232 string str/unicode[4] string   bytes \u0026quot;\u0026quot; é•¿åº¦ä¸è¶…è¿‡ 232 çš„ä»»æ„å­—èŠ‚åºåˆ— string str []byte    é™¤äº†è¿™äº›åŸºç¡€ç±»å‹ä¹‹å¤–ï¼Œæšä¸¾ç±»å‹ï¼ˆenumsï¼‰çš„é»˜è®¤æ˜¯ 0ï¼ˆä¹Ÿå°±æ˜¯å®šä¹‰çš„ç¬¬ä¸€ä¸ªæšä¸¾å€¼ï¼‰ï¼Œrepeated å­—æ®µçš„é»˜è®¤å€¼ä¸ºç©ºã€‚\nmap ProtoBuf çš„ä¸€å¤§äº®ç‚¹å°±æ˜¯å†…ç½®äº† map æ•°æ®ç±»å‹ï¼Œå…¶ key_type å¯ä»¥æ˜¯ä»»æ„æ•´æ•°ç±»å‹æˆ–å­—ç¬¦ä¸²ç±»å‹ï¼š\nmap\u0026lt;key_type, value_type\u0026gt; map_field = N;map ç›®å‰ä¸èƒ½è¢« repeated ä¿®é¥°ï¼Œä½†å¯ä»¥é€šè¿‡è‡ªå®šä¹‰ä¸€ä¸ªç±»ä¼¼äº map çš„ç»“æ„æ¥å®ç°å…¶æ•ˆæœï¼Œéœ€è¦è‡ªè¡Œè§£å†³ä» key_type åˆ° value_type çš„æ˜ å°„å…³ç³»ï¼š\nmessage MapFieldEntry { key_type key = 1; value_type value = 2;}repeated MapFieldEntry map_field = N;æšä¸¾ç±»å‹ proto æ–‡ä»¶ä¸­çš„æšä¸¾ç±»å‹å®šä¹‰å¤§è‡´å¦‚ä¸‹ï¼š\nmessage EnumRequest { enum Corpus { option allow_alias = true; UNIVERSAL = 0; WEB = 1; NET = 1; IMAGES = 2; LOCAL = 3; } Corpus corpus = 1;}åœ¨ä½¿ç”¨æšä¸¾ç±»å‹æ—¶éœ€è¦æ³¨æ„å‡ ç‚¹ï¼š\n æšä¸¾å€¼å®šä¹‰å¿…é¡»åœ¨ 32 ä½æ•´æ•°æ•´æ•°èŒƒå›´å†…ï¼Œå¹¶ä¸”ä¸å»ºè®®ä½¿ç”¨è´Ÿæ•°ï¼ˆå› ä¸ºæšä¸¾å€¼åœ¨åºåˆ—åŒ–æ—¶ä½¿ç”¨ varint ç¼–ç ï¼‰ï¼› åœ¨æšä¸¾ç±»å‹çš„å®šä¹‰ä¸­å¿…é¡»æœ‰ä¸€ä¸ªå€¼ä¸º 0 çš„æšä¸¾å˜é‡ï¼› å¦‚æœè¦å®šä¹‰å€¼ç›¸åŒçš„æšä¸¾ç±»å‹ï¼Œå¿…é¡»åŠ ä¸Š option allow_alias = trueã€‚  ç‰¹æ®Šç±»å‹ é™¤äº† double, float, int32 ç­‰åŸºç¡€æ•°æ®ç±»å‹ï¼Œproto æ–‡ä»¶é‡Œè¿˜å¯ä»¥å®šä¹‰ä¸€äº›ç‰¹æ®Šçš„æ•°æ®ç±»å‹ï¼š\n Any åŒ…å«ä»»æ„å­—èŠ‚æ•°çš„åºåˆ—åŒ–æ¶ˆæ¯ï¼› Oneof ç±»ä¼¼äº unionï¼Œè¡¨ç¤ºå¤šä¸ªå­—æ®µå…±äº«åŒä¸€å—å†…å­˜ï¼Œå¹¶ä¸”åªæœ‰å…¶ä¸­ä¸€ä¸ªèƒ½å¤Ÿè¢«èµ‹å€¼ï¼›  2 ç¼–ç è¿‡ç¨‹ ProtoBuf çš„ç¼–ç è¿‡ç¨‹åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼šå…ˆå¯¹å­—æ®µçš„å®šä¹‰è¿›è¡Œç¼–ç ï¼Œä»¥ä¾¿åœ¨è§£ç è¿‡ç¨‹ä¸­è¯†åˆ«å…¶ç±»å‹ï¼›å†å¯¹æ•°æ®çš„å€¼è¿›è¡Œç¼–ç ï¼Œå¯¹å…¶è¿›è¡Œå‹ç¼©ã€‚å…¶ä¸­ç¬¬ä¸€éƒ¨åˆ†å®é™…ä¸Šæ˜¯ä½¿ç”¨ä¸€å®šçš„è§„åˆ™å¯¹å­—æ®µçš„ç±»å‹å’Œç¼–å·è¿›è¡Œç¼–ç ï¼Œå¾—åˆ°å­—æ®µçš„æ ‡ç­¾ Tagï¼Œè€Œå¹¶æ²¡æœ‰ç”¨åˆ°å­—æ®µçš„åå­—ï¼Œå› æ­¤åœ¨å®é™…ä½¿ç”¨ä¸­å³ä½¿ä¿®æ”¹å­—æ®µçš„åå­—ä¹Ÿæ˜¯ä¸ä¼šå‘ç”Ÿå…¼å®¹æ€§é—®é¢˜çš„ï¼›ç¬¬äºŒéƒ¨åˆ†åˆ™æ˜¯ä½¿ç”¨ä¸åŒçš„ç®—æ³•å¯¹ä¸åŒç±»å‹çš„æ•°æ®è¿›è¡Œå‹ç¼©å¾—åˆ°å€¼ Valueï¼Œä¸»è¦ç”¨åˆ°çš„ä¸¤ç§ç®—æ³•åˆ†åˆ«æ˜¯ Varint å’Œ ZigZagã€‚å°†è¿™ä¸¤éƒ¨åˆ†ç¼–ç å®Œæˆåï¼Œå†å°†æ ‡ç­¾ Tagï¼Œå­—èŠ‚é•¿åº¦ Lengthï¼ˆåªæœ‰å˜é•¿ç±»å‹éœ€è¦ï¼‰ï¼Œå€¼ Value æ‹¼æ¥åœ¨ä¸€èµ·ï¼Œå°±å¾—åˆ°äº†ç¼–ç åçš„äºŒè¿›åˆ¶æ•°æ®ã€‚\n2.1 æ ‡ç­¾ç¼–ç  å¯¹æ ‡ç­¾çš„ç¼–ç æ­¥éª¤æ˜¯å…ˆå°†å­—æ®µç±»å‹æ˜ å°„åˆ°ä¸€ä¸ªæ•°å­— wire_type ä¸Šï¼Œå†å°†å­—æ®µç¼–å· field_num å‘å·¦ä½ç§» 3 ä½ï¼Œå¹¶å°†ä¸¤è€…è¿›è¡Œæˆ–æ“ä½œï¼Œå³ (field_number \u0026lt;\u0026lt; 3) | wire_typeã€‚å­—æ®µç±»å‹å’Œ wire_type çš„æ˜ å°„å…³ç³»å¦‚ä¸‹ï¼š\n   wire_type å«ä¹‰ å­˜å‚¨ç»“æ„ å¯¹åº”çš„å­—æ®µç±»å‹     0 ä½¿ç”¨ Varint å‹ç¼© [Tag Value] int32, int64, uint32, uint64, sint32, sint64, bool, enum   1 64 ä½ [Tag Value] fixed64, sfixed64, double   2 æŒ‰é•¿åº¦åŒºåˆ† [Tag Length Value] string, bytes, embedded messages, packed repeated fields   3 Start group  groups (å¼ƒç”¨)   4 End group  groups (å¼ƒç”¨)   5 32 ä½ [Tag Value] fixed32, sfixed32, float    è§£ç æ—¶ä¸ºäº†èƒ½å¤Ÿè·å–å­˜å‚¨ç»“æ„çš„å®šä¹‰ï¼Œå¿…é¡»æä¾›æ­£ç¡®çš„ proto æ–‡ä»¶ã€‚\nä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾è¦å¯¹ä¸€ä¸ªå­—æ®µç¼–å· field_number = 2ï¼Œå­—æ®µç±»å‹ä¸º sint64 çš„å­—æ®µè¿›è¡Œç¼–ç ï¼Œå®ƒçš„ wire_type = 0ï¼Œèƒ½å¤ŸçŸ¥é“ (field_number \u0026lt;\u0026lt; 3) | wire_type = 10000ï¼Œå³ç¼–ç åå¾—åˆ° 10ï¼›\nç±»ä¼¼çš„ï¼Œåœ¨è§£ç æ—¶ä¼šå…ˆå–å…¶åä¸‰ä½ \u0026amp; 111 å¾—åˆ° wire_type = 0ï¼Œå†å‘å³ä½ç§» 3 ä½å¾—åˆ° field_number = 2ã€‚\næ€»ç»“ä¸€ä¸‹ï¼Œå¯¹äºå­—æ®µç¼–ç åçš„å­—èŠ‚ï¼Œåä¸‰ä½è¡¨ç¤ºç±»å‹ï¼Œå‰ç½®ä½è¡¨ç¤ºå­—æ®µç¼–å·ã€‚\n2.2 Varint å¯¹ WireType == 0 çš„æ•´æ•°ç±»å‹çš„ä¸»è¦ç¼–ç æ–¹å¼æ˜¯ä½¿ç”¨ Varintï¼Œä½¿ç”¨ Varint ç¼–ç åçš„äºŒè¿›åˆ¶æ•°æ®é•¿åº¦æ˜¯ä¸å›ºå®šçš„ï¼Œæ•°å€¼è¶Šå°çš„æ•°å­—ç¼–ç åçš„å­—èŠ‚é•¿åº¦è¶Šå°ã€‚å…¶æ­¥éª¤åˆ†ä¸º 3 æ­¥ï¼š\n å¯¹äºä¸€ä¸ªæ•°å­—çš„äºŒè¿›åˆ¶ä½è¡¨ç¤ºï¼Œå°†å…¶æ‹†åˆ†ä¸º 7 ä¸ªä¸€ç»„çš„å­—èŠ‚ï¼› åœ¨æ¯ä¸€ç»„çš„å¤´éƒ¨æ·»åŠ ä¸€ä¸ªæœ€é«˜æœ‰æ•ˆä½ï¼ˆmost significant bitï¼‰ï¼Œåªæœ‰æœ€å¤§ä¸€ç»„æœ‰ msb = 0ï¼Œå…¶ä»–ç»„çš„ msb éƒ½ç­‰äº 1ï¼› æŒ‰ç…§å°ç«¯åºæ’åˆ—è¿™äº›å­—èŠ‚ã€‚  ä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œå¯¹äºæ•°å­— 582963 æ¥è¯´ï¼š\n å®ƒçš„äºŒè¿›åˆ¶è¡¨ç¤ºæ˜¯ 10001110010100110011ï¼Œå°†å…¶æ‹†åˆ†ä¸ºä¸‰ç»„ï¼Œåˆ†åˆ«æ˜¯ 0100011, 1001010, 0110011ï¼Œå³ 35, 74, 51ï¼› åœ¨æœ€å¤§çš„ä¸€ç»„å‰åŠ ä¸Šæœ€é«˜æœ‰æ•ˆä½ 0ï¼Œå¾—åˆ° 00100011ï¼Œä»ç„¶æ˜¯ 35ï¼›åœ¨å…¶ä»–ç»„å‰åŠ ä¸Šæœ€é«˜æœ‰æ•ˆä½ 1ï¼Œå¾—åˆ° 11001010ï¼Œ10110011ï¼Œåˆ†åˆ«æ˜¯ 202, 179ï¼› å°†è¿™ä¸‰ä¸ªå­—èŠ‚æŒ‰å°ç«¯åºæ’åˆ—ï¼Œå¾—åˆ° 10110011 11001010 00100011ï¼Œåˆ†åˆ«æ˜¯ 179, 202, 35ï¼Œå³é€šè¿‡ Varint ç¼–ç æœ€åå¾—åˆ°çš„ç»“æœã€‚  ç”¨ ProtoBuf å¯¹æ•°å­— 582963 è¿›è¡Œç¼–ç æµ‹è¯•ï¼š\nmessage SingleNumber { int32 Num = 1;}func main() { sn := SingleNumber { Num: 582963, } bytes, err := proto.Marshal(\u0026amp;sn) if err != nil { panic(err) } fmt.Println(bytes) } å¾—åˆ°çš„ç»“æœä¸ä¸Šè¿°æ­¥éª¤ç›¸åŒï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå­—èŠ‚ 8 æ˜¯å¯¹å­—æ®µè¿›è¡Œç¼–ç å¾—åˆ°çš„ keyï¼š\n$ go run main.go msg.pb.go [8 179 202 35] è§£ç è¿‡ç¨‹ä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼š\nfunc main() { b := []byte{8, 179, 202, 35} var sn SingleNumber err := proto.Unmarshal(b, \u0026amp;sn) if err != nil { panic(err) } fmt.Println(sn.GetNum()) } $ go run main.go msg.pb.go 582963 2.3 ZigZag Varint ç¼–ç çš„æœ¬è´¨åœ¨äºå»æ‰æ•°å­—äºŒè¿›åˆ¶è¡¨ç¤ºçš„å‰ç½® 0 ä»è€Œå‡å°‘æ•°æ®æ‰€å ç”¨çš„å­—èŠ‚æ•°ï¼›è€Œå¯¹äºç”¨è¡¥ç è¡¨ç¤ºçš„è´Ÿæ•°æ¥è¯´ï¼Œä½¿ç”¨ Varint è¿›è¡Œç¼–ç çš„è¯ï¼Œ32 ä½çš„æ•°å­—ä¼šå ç”¨ 5 ä¸ªå­—èŠ‚ï¼Œ64 ä½çš„æ•°å­—ä¼šå ç”¨ 10 ä¸ªå­—èŠ‚ï¼Œæ•ˆæœå°±æ˜¾å¾—éå¸¸å·®äº†ã€‚å¯¹æ­¤ ProtoBuf é‡‡ç”¨äº† ZigZag æ¥è¿›è¡Œä¼˜åŒ–ï¼ŒZigZag å¯ä»¥å°†æœ‰ç¬¦å·æ•´æ•°æ˜ å°„ä¸ºæ— ç¬¦å·æ•´æ•°ï¼›æ­£æ•°çš„ç¼–ç ç»“æœç›¸å½“äºå°†å…¶ä¹˜ä»¥ 2ï¼Œè´Ÿæ•°çš„ç¼–ç ç»“æœç›¸å½“äºå°†å…¶ç»å¯¹å€¼ä¹˜ä»¥ 2 å¹¶å‡ 1ï¼Œç¼–ç åçš„å€¼å¯¹åº”çš„åŸå§‹æ•°æ®åœ¨æ­£è´Ÿæ•°ä¹‹é—´æ‘‡æ‘†ï¼Œå¦‚ä¸‹è¡¨ï¼š\n   åŸå§‹çš„æœ‰ç¬¦å·æ•´æ•° ç¼–ç åçš„æ— ç¬¦å·æ•´æ•°     0 0   -1 1   1 2   -2 3   2147483647 4294967294   -2147483648 4294967295    å®ƒçš„è¿‡ç¨‹ä¹Ÿéå¸¸ç®€å•ï¼š\n å‡è®¾è¢«ç¼–ç æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ˜¯ numï¼Œå°† num å·¦ç§» 1 ä½å¾—åˆ° x å°† num å³ç§» 31 ä½ï¼ˆnum æœ¬èº«çš„ä½æ•° - 1ï¼‰å¾—åˆ° yï¼Œå³ç”¨ç¬¦å·ä½è¦†ç›– num çš„æ¯ä¸€ä½ å°† x å’Œ y è¿›è¡Œå¼‚æˆ–æ“ä½œï¼Œå¾—åˆ°ç»“æœ z = x ^ y  ä¸¾ä¸ªä¾‹å­ï¼Œå¯¹äºæ­£æ•° 5ï¼š\n x = 5 \u0026laquo; 1 = 00000000 00000000 00000000 00001010 y = 5 \u0026raquo; 31 = 00000000 00000000 00000000 00000000 z = x ^ y = 00000000 00000000 00000000 00001010ï¼Œå¾—åˆ° 10  å¯¹äºè´Ÿæ•° -5ï¼š\n x = -5 \u0026laquo; 1 = 11111111 11111111 11111111 11110110 y = -5 \u0026raquo; 31 = 11111111 11111111 11111111 11111111 z = x ^ y = 00000000 00000000 00000000 00001001ï¼Œå¾—åˆ° 9  åœ¨ ProtoBuf ä¸­ï¼Œè´Ÿæ•°ä¼šå…ˆç”¨ ZigZagï¼Œå†ç”¨ Varint è¿›è¡Œç¼–ç ï¼Œè¾¾åˆ°è¿›ä¸€æ­¥å‹ç¼©æ•°æ®çš„æ•ˆæœã€‚\n2.4 å…¶ä»–ç¼–ç è¿‡ç¨‹ å˜é•¿ç±»å‹ å¯¹äº WireType == 2 çš„å˜é•¿ç±»å‹ï¼ˆstring, bytes ç­‰ï¼‰æ¥è¯´ï¼Œå…¶åºåˆ—åŒ–åçš„äºŒè¿›åˆ¶æ•°æ®æµæ˜¯ä»¥ [Tag Length Value] çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå…¶ä¸­ Length æ˜¯å˜é•¿éƒ¨åˆ†çš„é•¿åº¦ï¼Œä¾‹å¦‚ï¼š\nmessage SingleNumber { int32 Num = 1; string Str = 2;}func main() { sn := SingleNumber { Num: 582963, Str: \u0026#34;helloworld\u0026#34; } bytes, err := proto.Marshal(\u0026amp;sn) if err != nil { panic(err) } fmt.Println(bytes) } $ go run main.go msg.pb.go [8 179 202 35 18 10 104 101 108 108 111 119 111 114 108 100] åœ¨è¾“å‡ºçš„ç»“æœä¸­ï¼Œç¬¬äº”ä¸ªå­—èŠ‚ 18 æ˜¯ string Str = 2 çš„ Tagï¼Œå…¶ä¸­ field_num = 2, wire_type = 2ï¼›ç¬¬å…­ä¸ªå­—èŠ‚ 10 ä»£è¡¨è¿™ä¸ªå˜é•¿ç±»å‹çš„ Lengthï¼Œå³ä»ç¬¬ä¸ƒä¸ªå­—èŠ‚åˆ°ç¬¬åå…­ä¸ªå­—èŠ‚éƒ½æ˜¯å­˜å‚¨çš„ Valueï¼Œæ¯ä¸€ä¸ªå€¼å‡æ˜¯ç”¨ ASCII ç å­˜å‚¨çš„å­—ç¬¦ã€‚\nå›ºå®šé•¿åº¦ç±»å‹ å¯¹äº WireType == 1 æˆ– WireType == 5 çš„å›ºå®šé•¿åº¦ç±»å‹ï¼ˆfixed32, fixed64 ç­‰ï¼‰æ¥è¯´ï¼Œå…¶åºåˆ—åŒ–åçš„äºŒè¿›åˆ¶æ•°æ®çš„é•¿åº¦å›ºå®šä¸º 4 æˆ– 8 ä¸ªå­—èŠ‚ï¼Œä¾‹å¦‚ï¼š\nmessage SingleNumber { int32 Num = 1; string Str = 2; fixed32 A = 3; fixed64 B = 4; float C = 5;}func main() { sn := SingleNumber { // Num: 582963, \t// Str: \u0026#34;helloworld\u0026#34;, \tA: 256, B: 257, } bytes, err := proto.Marshal(\u0026amp;sn) if err != nil { fmt.Println(err) return } fmt.Println(bytes) } $ go run main.go msg.pb.go [29 0 1 0 0 33 1 1 0 0 0 0 0 0] å¾—åˆ°çš„ç»“æœä¸­ç¬¬ 1 ä¸ªå­—èŠ‚æ˜¯ fixed32 A = 3 çš„ tagï¼Œå…¶ä¸­ field_num = 3, wire_type = 5ï¼Œå…¶åçš„ 4 ä¸ªå­—èŠ‚æŒ‰ç…§å­—èŠ‚åºç›´æ¥å­˜å‚¨ï¼›ç¬¬ 5 ä¸ªå­—èŠ‚æ˜¯ fixed64 B = 4 çš„ tagï¼Œå…¶ä¸­ field_num = 4, wire_type = 1ï¼Œå…¶åçš„ 8 ä¸ªå­—èŠ‚åŒæ ·æ˜¯æŒ‰ç…§å­—èŠ‚åºç›´æ¥å­˜å‚¨çš„ã€‚\n","permalink":"http://zintrulcre.github.io/posts/serialization/protocol-buffer/","summary":"ProtoBuf è¯­æ³•å’Œç¼–ç åŸç†å…¥é—¨ åºåˆ—åŒ–æ˜¯æŒ‡å°†ç»“æ„åŒ–æ•°æ®è½¬æ¢æˆæ˜“äºå­˜å‚¨æˆ–å‘é€çš„æ•°æ®æ ¼å¼çš„è¿‡ç¨‹ï¼ŒProtocol Buffer ç®€ç§° ProtoBufï¼Œæ˜¯ä¸€ç§è¯­è¨€æ— å…³ï¼Œå¹³å°æ— å…³çš„åºåˆ—åŒ–å·¥å…·ï¼Œç”±è°·æ­Œåœ¨ 2008 å¹´å¼€æºã€‚ç›¸è¾ƒäºå¸¸è§çš„åºåˆ—åŒ–å·¥å…· XML, JSON, YAML, CSV ç­‰ï¼ŒProtoBuf çš„ä¼˜åŠ¿ä¸»è¦åŒ…æ‹¬åºåˆ—åŒ–åæ•°æ®é‡å°ï¼Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–è¿‡ç¨‹é€Ÿåº¦å¿«ï¼Œä½¿ç”¨æ—¶åªéœ€å®šä¹‰ proto æ–‡ä»¶ä½¿å¾—å…¶ç»´æŠ¤æˆæœ¬ä½ï¼Œå¯å‘åå…¼å®¹ç­‰ï¼›ä½†å› ä¸ºå…¶æ•°æ®ä»¥äºŒè¿›åˆ¶æ•°æ®æµçš„å½¢å¼å­˜åœ¨ï¼Œä¹Ÿæœ‰äººç±»ä¸å¯è¯»çš„åŠ£åŠ¿ã€‚\næœ¬æ–‡ä¸»è¦ä»‹ç» ProtoBuf çš„ä½¿ç”¨æ–¹æ³•ï¼ŒåŒ…æ‹¬ .proto æ–‡ä»¶çš„è¯­æ³•ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨ protoc å·¥å…·æ¥ç”Ÿæˆä¸é€šè¯­è¨€çš„ä»£ç ï¼›ä»¥åŠå…¶ç¼–ç åŸç†ã€‚\n1 è¯­æ³• é¦–å…ˆä» https://github.com/protocolbuffers/protobuf æ‰¾åˆ°æœ€æ–°ç‰ˆæœ¬çš„ ProtoBufï¼Œä¸‹è½½é¢„ç¼–è¯‘å¥½çš„äºŒè¿›åˆ¶æ–‡ä»¶ protoc è§£å‹åˆ°ç¯å¢ƒå˜é‡ç›®å½•ï¼Œæœ¬æ–‡ä½¿ç”¨çš„æ˜¯ 3.15.7 ç‰ˆæœ¬ï¼š\n$ protoc --version libprotoc 3.15.7 ä»¥ä¸€ä¸ªç®€å•çš„ proto æ–‡ä»¶ä¸ºä¾‹ï¼Œå®ƒçš„è¯­æ³•å’Œ C++ ç±»ä¼¼ï¼š\n// msg.proto syntax = \u0026#34;proto3\u0026#34;;package Message;message SearchRequest { reserved 6, 9 to 12; reserved \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;; string query = 1; int32 page_number = 2; int32 result_per_page = 3;}message ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; }}message SearchResponse {  repeated ResultType.","title":"ProtoBuf è¯­æ³•å’Œç¼–ç åŸç†å…¥é—¨"},{"content":"Python æºç å­¦ä¹ ï¼ˆ2ï¼‰ï¼šint ç±»å‹ Python ä¸­çš„æ ‡å‡†æ•°æ®ç±»å‹æœ‰å…­ç§ï¼Œåˆ†åˆ«æ˜¯ number, string, list, tuple, set, dictionaryï¼Œå‰æ–‡å·²ç»é˜è¿°è¿‡å®ƒä»¬çš„å¯¹è±¡ç±»å‹éƒ½æ˜¯ç»§æ‰¿äº† PyBaseObject_Type ç±»å‹çš„ PyType_Type ç±»å‹çš„å®ä¾‹å¯¹è±¡ï¼Œæœ¬æ–‡åˆ™ä¸»è¦æ¢ç©¶ Python ä¸­ int ç±»å‹çš„å®ç°ã€‚\nä¸åŒäº C å’Œ C++ ä¸­çš„ int ç±»å‹ï¼ŒPython ä¸­çš„ int ç±»å‹æœ€å¤§çš„ç‰¹ç‚¹æ˜¯å®ƒä¸€èˆ¬æ˜¯ä¸ä¼šæº¢å‡ºçš„ï¼Œå¯¹æ¯”ç”¨ C å’Œ Python åˆ†åˆ«è¾“å‡ºä¸¤ä¸ªä¸€ç™¾ä¸‡ç›¸ä¹˜çš„ç»“æœï¼š\n\u0026gt;\u0026gt;\u0026gt; x = 10000000000 \u0026gt;\u0026gt;\u0026gt; print(x) 10000000000 åœ¨ C è¯­è¨€ä¸­ä¼šå‘ç”Ÿæº¢å‡ºï¼š\nprintf(\u0026#34;%d\\n\u0026#34;, 1000000 * 1000000); printf(\u0026#34;%u\\n\u0026#34;, 1000000 * 1000000); -727379968 3567587328 1 int ç±»å‹åœ¨å†…å­˜ä¸­çš„å­˜å‚¨æ–¹å¼ 1.1 å†…å­˜ç»“æ„ Python ä¸­çš„ int æ•´æ•°ç±»å‹å®é™…ä¸Šæ˜¯ä¸€ä¸ªåä¸º PyLongObject çš„ç»“æ„ä½“ï¼Œå®šä¹‰åœ¨ longintrepr.h æ–‡ä»¶ä¸­ï¼š\n// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base;  // Objects/longobject.h #if PYLONG_BITS_IN_DIGIT == 30 typedef uint32_t digit; // ... #elif PYLONG_BITS_IN_DIGIT == 15 typedef unsigned short digit; // ... #endif typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */ // Include/longintrepr.h struct _longobject { PyObject_VAR_HEAD digit ob_digit[1]; }; å®ƒç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼Œåˆ†åˆ«æ˜¯ï¼š\n  ä¸€ä¸ªå˜é•¿å¯¹è±¡ PyVarObject ob_baseï¼Œå…¶ä¸­åŒ…æ‹¬å¼•ç”¨è®¡æ•° Py_ssize_t ob_refcntã€ç±»å‹æŒ‡é’ˆ PyTypeObject *ob_typeã€å˜é•¿éƒ¨åˆ†çš„é•¿åº¦ Py_ssize_t ob_sizeï¼Œè¡¨æ˜ PyLongObject ä¹Ÿæ˜¯ä¸€ä¸ªå˜é•¿å¯¹è±¡ï¼›\n  ä¸€ä¸ª digit ç±»å‹çš„æ•°ç»„ ob_digit ï¼Œç”¨äºå­˜å‚¨æ•´æ•°å€¼ï¼Œæ•°ç»„é•¿åº¦é»˜è®¤ä¸º 1ï¼Œåœ¨åˆå§‹åŒ–æ—¶å¦‚æœé•¿åº¦ä¸å¤Ÿåˆ™ä¼šè¢«æ‰©å¤§ï¼› digit æ˜¯ä¸€ä¸ªè¢« PYLONG_BITS_IN_DIGIT  å®æ§åˆ¶çš„ç±»å‹ï¼Œåœ¨ç¼–è¯‘ Python è§£é‡Šå™¨æ—¶å¯ä»¥é€šè¿‡ä¿®æ”¹è¿™ä¸ªå®æ¥æŒ‡å®šå…¶ç±»å‹ï¼›å¦‚æœæ²¡æœ‰æŒ‡å®š PYLONG_BITS_IN_DIGIT  å®çš„å€¼ï¼Œåˆ™é»˜è®¤ä¼šæ ¹æ®æ“ä½œç³»ç»Ÿçš„ç±»å‹æ¥å†³å®šï¼Œå½“æŒ‡é’ˆå ç”¨ 8 å­—èŠ‚ä»¥ä¸Šç©ºé—´æ—¶ï¼ˆ64 ä½ä»¥ä¸Šæ“ä½œç³»ç»Ÿï¼‰ï¼ŒPYLONG_BITS_IN_DIGIT = 30ï¼Œdigit å³ä¸º uint32_tï¼Œå¦åˆ™ PYLONG_BITS_IN_DIGIT = 15ï¼Œdigit åˆ™æ˜¯ unsigned shortï¼š\n  #ifndef PYLONG_BITS_IN_DIGIT #if SIZEOF_VOID_P \u0026gt;= 8 #define PYLONG_BITS_IN_DIGIT 30 #else #define PYLONG_BITS_IN_DIGIT 15 #endif #endif\n\r`PyLongObject` çš„å†…å­˜ç»“æ„å¤§è‡´å¦‚å›¾ï¼š\r![PyLongObject](https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/PyLongObject.png)\r### 1.2 æ•°æ®è¡¨ç¤º\råœ¨ `ob_digit` æ•°ç»„ä¸­ï¼Œæ•°æ®çš„è¡¨ç¤ºéµå¾ªä¸¤ä¸ªåŸåˆ™ï¼š\r1. `ob_size` çš„ç»å¯¹å€¼è¡¨ç¤º `ob_digit` æ•°ç»„çš„é•¿åº¦ï¼Œ`ob_size = 0` è¡¨ç¤º `PyLongObject` çš„æ•°å€¼ç­‰äº 0ï¼›æ•°æ®çš„æ­£è´Ÿç”± `ob_size` çš„æ­£è´Ÿæ¥æ ‡è¯†ï¼Œ`ob_size \u0026gt; 0` è¡¨ç¤º `PyLongObject \u0026gt; 0`ï¼Œ`ob_size \u0026lt; 0` è¡¨ç¤º `PyLongObject \u0026lt; 0`ï¼›\r2. `ob_digit` æ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªæœ€å¤§ä¸º `2^30`ï¼ˆå‡è®¾ `PYLONG_BITS_IN_DIGIT == 30`ï¼‰çš„æ•´æ•°ï¼Œå¦‚æœæ•´æ•°è¶…è¿‡äº†è¿™ä¸ªå€¼ï¼Œåˆ™ä¼šæ¸…é›¶å¹¶ä½¿å…¶åä¸€ä½è‡ªå¢ 1ï¼Œå‡è®¾ `ob_size = n`ï¼Œé‚£ä¹ˆæ•°æ®çš„ç»å¯¹å€¼åˆ™ç­‰äº `ob_digit[0] + ob_digit[1] * 2^30 + ob_digit[2] * 2^60 + ... + ob_digit[n-1] * 2^(30 * (n-1))`ï¼›\rä¾‹å¦‚å¯¹äºæ•´æ•° 4294967297ï¼Œå¯ä»¥è¢«è¡¨ç¤ºä¸º `1 + 4 * 2^30`ï¼Œå› æ­¤å…¶ `ob_size = 2`, `ob_digit[0] = 1`, `ob_digit[1] = 4`ï¼Œå…¶å†…å­˜ç»“æ„å¤§è‡´å¦‚å›¾ï¼š\r![PyLongObject-1](https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/PyLongObject-1.png)\ré€šè¿‡è¿™ç§å¤§æ•°å­˜å‚¨æ–¹å¼ï¼ŒPython ä»è¯­è¨€å±‚é¢è§£å†³äº† `2^(30*2147483648) - 1` ä»¥ä¸‹ï¼ˆ`ob_size` çš„ç±»å‹ `Py_ssize_t` æ˜¯é€šè¿‡ `typedef long int Py_ssize_t` å®šä¹‰çš„ï¼‰çš„å¤§æ•°çš„æº¢å‡ºé—®é¢˜ã€‚\r### 1.3 åˆ›å»ºå¯¹è±¡\råœ¨ Python ä¸­ï¼Œ `PyLongObject` å¯¹è±¡ä¸€èˆ¬æ˜¯é€šè¿‡ `_PyLong_New` å‡½æ•°åˆ›å»ºå‡ºæ¥çš„ï¼š\r```cpp\r/* Allocate a new int object with size digits.\rReturn NULL and set exception if we run out of memory. */\r#define MAX_LONG_DIGITS \\\r((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/sizeof(digit))\rPyLongObject *\r_PyLong_New(Py_ssize_t size)\r{\rPyLongObject *result;\r/* Number of bytes needed is: offsetof(PyLongObject, ob_digit) +\rsizeof(digit)*size. Previous incarnations of this code used\rsizeof(PyVarObject) instead of the offsetof, but this risks being\rincorrect in the presence of padding between the PyVarObject header\rand the digits. */\rif (size \u0026gt; (Py_ssize_t)MAX_LONG_DIGITS) {\rPyErr_SetString(PyExc_OverflowError,\r\u0026quot;too many digits in integer\u0026quot;);\rreturn NULL;\r}\rresult = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) +\rsize*sizeof(digit));\rif (!result) {\rPyErr_NoMemory();\rreturn NULL;\r}\r_PyObject_InitVar((PyVarObject*)result, \u0026amp;PyLong_Type, size);\rreturn result;\r}\rè¿™ä¸ªå‡½æ•°éå¸¸ç®€å•ï¼Œä¸»è¦æ˜¯åšäº†ä¸¤ä»¶äº‹ï¼š\n å†…å­˜åˆ†é…å‰åçš„æ£€æŸ¥ï¼ŒåŒ…æ‹¬å‚æ•° size ä¸èƒ½è¶…è¿‡ MAX_LONG_DIGITSï¼Œä¹Ÿå°±æ˜¯è¯´ PyLongObject æ‰€è¡¨ç¤ºçš„æ•´æ•°å¤§å°ä¸èƒ½è¶…è¿‡ 2^(30*2147483648) - 1ï¼Œä»¥åŠç”Ÿæˆä½¿ç”¨ malloc åˆ†é…å†…å­˜å¤±è´¥åçš„æŠ¥é”™ä¿¡æ¯ï¼› ä¸º PyLongObject å¯¹è±¡ç”³è¯·å†…å­˜ï¼Œå…¶å¤§å°åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç¬¬ä¸€éƒ¨åˆ†æ˜¯ PyVarObject åœ¨å†…å­˜å¯¹é½åæ‰€å ç”¨çš„ç©ºé—´ï¼Œå³ offsetof(PyLongObject, ob_digit)ï¼›ç¬¬äºŒéƒ¨åˆ†æ˜¯ ob_digit æ•°ç»„æ‰€å ç”¨çš„ç©ºé—´ï¼Œå…¶ä¸­å‚æ•° size æ˜¯ ob_digit æ•°ç»„çš„é•¿åº¦ã€‚  1.4 æ•°æ®è½¬åŒ– æ¯ä¸€ä¸ª PyLongObject å¯¹è±¡éƒ½æ‹¥æœ‰ä¸åŒçš„å†…å­˜åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ Python ä¸­çš„ id å‡½æ•°æ¥æŸ¥çœ‹ä¸€ä¸ªå˜é‡çš„æ ‡è¯†ï¼Œè¿™ä¸ªæ ‡è¯†ä¼šå› å†…å­˜åœ°å€çš„ä¸åŒè€Œæ”¹å˜ï¼š\nfor i in range(5): print(id(i)) $ python3 main.py 139748219328384 139748219328416 139748219328448 139748219328480 139748219328512 å¯ä»¥çœ‹å‡º 0 åˆ° 4 è¿™ 5 ä¸ªæ•°çš„æ ‡è¯†é‡Œæ¯ä¸¤ä¸ªéƒ½ç›¸å·®äº† 32ï¼Œåˆšå¥½ç¬¦åˆæ¯ä¸€ä¸ª PyLongObject å¯¹è±¡æ‰€å ç”¨çš„ç©ºé—´ 32 å­—èŠ‚ï¼Œè€Œä¸æ˜¯ C è¯­è¨€é‡Œä¸€ä¸ª long ç±»å‹å˜é‡é€šå¸¸æ‰€å ç”¨çš„ 4 å­—èŠ‚æˆ– 8 å­—èŠ‚ï¼Œè¿™æ˜¯å› ä¸ºæ‰€æœ‰åŸå§‹çš„æ•°æ®éƒ½ä¼šè¢«è½¬åŒ–ä¸º PyLongObject å¯¹è±¡ã€‚\næ•°æ®è½¬åŒ–çš„æ–¹æ³•æœ‰å¾ˆå¤šï¼Œä»¥ PyLong_FromLong ä¸ºä¾‹ï¼Œå®ƒä¼šå°†ä¸€ä¸ª long ç±»å‹çš„æ•´æ•°è½¬åŒ–ä¸º PyLongObject å¯¹è±¡ï¼š\n// Objects/longobject.c /* interpreter state */ #define _PY_NSMALLPOSINTS 257 #define _PY_NSMALLNEGINTS 5  #define NSMALLNEGINTS _PY_NSMALLNEGINTS #define NSMALLPOSINTS _PY_NSMALLPOSINTS  #define IS_SMALL_INT(ival) (-NSMALLNEGINTS \u0026lt;= (ival) \u0026amp;\u0026amp; (ival) \u0026lt; NSMALLPOSINTS)  PyObject * PyLong_FromLong(long ival) { PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so \u0026gt;\u0026gt; doesn\u0026#39;t propagate sign bit */ int ndigits = 0; int sign; if (IS_SMALL_INT(ival)) { return get_small_int((sdigit)ival); } if (ival \u0026lt; 0) { /* negate: can\u0026#39;t write this as abs_ival = -ival since that invokes undefined behaviour when ival is LONG_MIN */ abs_ival = 0U-(unsigned long)ival; sign = -1; } else { abs_ival = (unsigned long)ival; sign = ival == 0 ? 0 : 1; } /* Fast path for single-digit ints */ if (!(abs_ival \u0026gt;\u0026gt; PyLong_SHIFT)) { v = _PyLong_New(1); if (v) { Py_SET_SIZE(v, sign); v-\u0026gt;ob_digit[0] = Py_SAFE_DOWNCAST( abs_ival, unsigned long, digit); } return (PyObject*)v; } #if PyLong_SHIFT==15  /* 2 digits */ if (!(abs_ival \u0026gt;\u0026gt; 2*PyLong_SHIFT)) { v = _PyLong_New(2); if (v) { Py_SET_SIZE(v, 2 * sign); v-\u0026gt;ob_digit[0] = Py_SAFE_DOWNCAST( abs_ival \u0026amp; PyLong_MASK, unsigned long, digit); v-\u0026gt;ob_digit[1] = Py_SAFE_DOWNCAST( abs_ival \u0026gt;\u0026gt; PyLong_SHIFT, unsigned long, digit); } return (PyObject*)v; } #endif  /* Larger numbers: loop to determine number of digits */ t = abs_ival; while (t) { ++ndigits; t \u0026gt;\u0026gt;= PyLong_SHIFT; } v = _PyLong_New(ndigits); if (v != NULL) { digit *p = v-\u0026gt;ob_digit; Py_SET_SIZE(v, ndigits * sign); t = abs_ival; while (t) { *p++ = Py_SAFE_DOWNCAST( t \u0026amp; PyLong_MASK, unsigned long, digit); t \u0026gt;\u0026gt;= PyLong_SHIFT; } } return (PyObject *)v; } è™½ç„¶çœ‹èµ·æ¥æ¯”è¾ƒé•¿ï¼Œä½†å…¶å®æ€è·¯éå¸¸ç®€å•ï¼š\n åˆ›å»ºç”¨äºå­˜å‚¨è¿”å›å€¼çš„æŒ‡é’ˆ PyLongObject *zï¼Œä¿å­˜æ•°æ®ç»å¯¹å€¼çš„å˜é‡ unsigned long abs_ival, tï¼Œæ ‡è¯†æ•°ç»„é•¿åº¦çš„ int ndigits å’Œæ ‡è¯†æ•°æ®æ­£è´Ÿçš„ int signï¼› å¦‚æœæ•°æ®èŒƒå›´åœ¨ [-5, 257) å†…ï¼Œåˆ™é€šè¿‡ get_small_int å‡½æ•°è¿”å›ç»“æœï¼› è·å–æ•°æ®çš„ç»å¯¹å€¼å’Œæ­£è´Ÿç¬¦å·ï¼› å¦‚æœæ•°æ®ç»å¯¹å€¼æ²¡æœ‰è¶…è¿‡ ob_digit æ•°ç»„çš„å•ä¸ªå…ƒç´ æ‰€èƒ½è¡¨ç¤ºçš„å¤§å°ï¼Œåˆ™é€šè¿‡ä¸€ä¸ªå¿«é€Ÿè·¯å¾„è¿”å›ç»“æœï¼› å¯¹äºè¾ƒå¤§çš„æ•°æ®ï¼Œç¡®å®šå…¶ ob_digit æ•°ç»„çš„é•¿åº¦ï¼Œé€ä½ç½®å…¥ã€‚  å¯ä»¥æ³¨æ„åˆ°ï¼Œç¬¬ 2 æ­¥é’ˆå¯¹ [-5, 257) åŒºé—´å†…çš„å°æ•´æ•°åšäº†ç‰¹æ®Šå¤„ç†ï¼Œæœ€ç»ˆåœ¨è°ƒç”¨åˆ° __PyLong_GetSmallInt_internal å‡½æ•°æ—¶ï¼Œä¼šé€šè¿‡ tstate-\u0026gt;interp-\u0026gt;small_ints[index] ç¼“å­˜æ•°ç»„è·å–å°æ•´æ•°å¯¹åº”çš„æŒ‡é’ˆå¯¹è±¡å¹¶å°†å…¶è¿”å›ï¼Œè¿™é‡Œçš„ small_ints æ•°ç»„æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œä¸€èˆ¬ç§°ä¸ºå°æ•´æ•°å¯¹è±¡æ± ï¼Œæ˜¯é’ˆå¯¹å¸¸ç”¨çš„å°æ•´æ•°åšçš„ä¸€ä¸ªä¼˜åŒ–ï¼š\n// Objects/longobject.c static inline PyObject* __PyLong_GetSmallInt_internal(int value) { PyThreadState *tstate = _PyThreadState_GET(); #ifdef Py_DEBUG  _Py_EnsureTstateNotNULL(tstate); #endif  assert(-_PY_NSMALLNEGINTS \u0026lt;= value \u0026amp;\u0026amp; value \u0026lt; _PY_NSMALLPOSINTS); size_t index = _PY_NSMALLNEGINTS + value; PyObject *obj = (PyObject*)tstate-\u0026gt;interp-\u0026gt;small_ints[index]; // _PyLong_GetZero() and _PyLong_GetOne() must not be called  // before _PyLong_Init() nor after _PyLong_Fini()  assert(obj != NULL); return obj; } 2 æ•°å­¦è¿ç®— PyLongObject çš„ç±»å‹å¯¹è±¡æ˜¯ PyLong_Typeï¼ŒPyLong_Type çš„æˆå‘˜å˜é‡ PyNumberMethods *tp_as_number ç”± static PyNumberMethods long_as_number* ç»“æ„ä½“æŒ‡é’ˆåˆå§‹åŒ–ï¼Œå…¶ä¸­åŒ…å«äº†è®¸å¤šæ•°å­¦è¿ç®—çš„å‡½æ•°æŒ‡é’ˆï¼Œå½“æˆ‘ä»¬å¯¹ PyLong_Type è¿›è¡Œæ•°å­¦è¿ç®—æ—¶ï¼Œå®é™…ä¸Šä¼šè°ƒç”¨è¿™äº›å‡½æ•°ï¼š\n// Objects/longobject.c PyTypeObject PyLong_Type = { // ...  \u0026amp;long_as_number, /* tp_as_number */ // ... }; static PyNumberMethods long_as_number = { (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ long_mod, /*nb_remainder*/ long_divmod, /*nb_divmod*/ long_pow, /*nb_power*/ // ... }; 2.1 åŠ æ³• PyLong_Type çš„åŠ æ³•è¿ç®—å¯¹åº”çš„å‡½æ•°æ˜¯ long_addï¼Œå…¶å®ç°å’Œç›¸å…³çš„å®å®šä¹‰å¦‚ä¸‹ï¼š\n// Objects/longobject.c #define CHECK_BINOP(v,w) \\ do { \\ if (!PyLong_Check(v) || !PyLong_Check(w)) \\ Py_RETURN_NOTIMPLEMENTED; \\ } while(0)  /* convert a PyLong of size 1, 0 or -1 to an sdigit */ #define MEDIUM_VALUE(x) (assert(-1 \u0026lt;= Py_SIZE(x) \u0026amp;\u0026amp; Py_SIZE(x) \u0026lt;= 1), \\ Py_SIZE(x) \u0026lt; 0 ? -(sdigit)(x)-\u0026gt;ob_digit[0] : \\ (Py_SIZE(x) == 0 ? (sdigit)0 : \\ (sdigit)(x)-\u0026gt;ob_digit[0]))  static PyObject * long_add(PyLongObject *a, PyLongObject *b) { PyLongObject *z; CHECK_BINOP(a, b); if (Py_ABS(Py_SIZE(a)) \u0026lt;= 1 \u0026amp;\u0026amp; Py_ABS(Py_SIZE(b)) \u0026lt;= 1) { return PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b)); } if (Py_SIZE(a) \u0026lt; 0) { if (Py_SIZE(b) \u0026lt; 0) { z = x_add(a, b); if (z != NULL) { /* x_add received at least one multiple-digit int, and thus z must be a multiple-digit int. That also means z is not an element of small_ints, so negating it in-place is safe. */ assert(Py_REFCNT(z) == 1); Py_SET_SIZE(z, -(Py_SIZE(z))); } } else z = x_sub(b, a); } else { if (Py_SIZE(b) \u0026lt; 0) z = x_sub(a, b); else z = x_add(a, b); } return (PyObject *)z; } å¯ä»¥çœ‹åˆ°å®ƒçš„å®ç°éå¸¸ç®€å•ï¼Œä¸»è¦åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š\n åˆ›å»ºä¸€ä¸ªç”¨äºå­˜å‚¨è¿”å›å€¼çš„æŒ‡é’ˆ PyLongObject *zï¼› æ£€æŸ¥ä¸¤ä¸ªå‚æ•°æ˜¯å¦éƒ½æ˜¯ PyLongObject ç±»å‹çš„æŒ‡é’ˆ CHECK_BINOP(a, b)ï¼› å¦‚æœä¸¤ä¸ªå‚æ•°éƒ½æ»¡è¶³ ob_size \u0026lt;= 1ï¼ˆå³ç»å¯¹å€¼å‡å°äº 2^30ï¼‰ï¼Œé‚£ä¹ˆå…ˆé€šè¿‡ MEDIUM_VALUE è·å–ä¸¤ä¸ª ob_digit[0] çš„å€¼ï¼Œå¹¶å°†ä¸¤æ•°ç›´æ¥ç›¸åŠ ï¼ˆä¸€å®šä¸ä¼šæº¢å‡ºï¼‰ï¼Œå†é€šè¿‡ PyLong_FromLong å°†è¿™ä¸ªæ•°åŒ…è£…ä¸ºä¸€ä¸ª PyLongObject æŒ‡é’ˆå¹¶è¿”å›ï¼›é€šå¸¸æˆ‘ä»¬è¿›è¡Œè¿ç®—çš„æ•°éƒ½ä¸ä¼šå¤ªå¤§ï¼Œå› æ­¤è¿™é‡Œå¯ä»¥åˆ©ç”¨ç®€åŒ–çš„è¿ç®—æ­¥éª¤å’Œ CPU åˆ†æ”¯é¢„æµ‹æ¥æé«˜æ•ˆç‡ï¼› åˆ¤æ–­ä¸¤è€…çš„æ­£è´Ÿå…³ç³»ï¼Œå°†é—®é¢˜ç®€åŒ–ä¸ºç»å¯¹å€¼åŠ å‡æ³•ï¼Œåˆ©ç”¨è¾…åŠ©å‡½æ•° x_add å’Œ x_sub è¿›è¡Œè¿ç®—å¹¶è¿”å›ç»“æœã€‚  2.2 ç»å¯¹å€¼åŠ æ³• ç»å¯¹å€¼åŠ æ³•å‡½æ•° x_add çš„å®šä¹‰å¦‚ä¸‹ï¼š\n#if PYLONG_BITS_IN_DIGIT == 30 #define PyLong_SHIFT 30 // ... #endif #define PyLong_BASE ((digit)1 \u0026lt;\u0026lt; PyLong_SHIFT) #define PyLong_MASK ((digit)(PyLong_BASE - 1))  /* Add the absolute values of two integers. */ static PyLongObject * x_add(PyLongObject *a, PyLongObject *b) { Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b)); PyLongObject *z; Py_ssize_t i; digit carry = 0; /* Ensure a is the larger of the two: */ if (size_a \u0026lt; size_b) { { PyLongObject *temp = a; a = b; b = temp; } { Py_ssize_t size_temp = size_a; size_a = size_b; size_b = size_temp; } } z = _PyLong_New(size_a+1); if (z == NULL) return NULL; for (i = 0; i \u0026lt; size_b; ++i) { carry += a-\u0026gt;ob_digit[i] + b-\u0026gt;ob_digit[i]; z-\u0026gt;ob_digit[i] = carry \u0026amp; PyLong_MASK; carry \u0026gt;\u0026gt;= PyLong_SHIFT; } for (; i \u0026lt; size_a; ++i) { carry += a-\u0026gt;ob_digit[i]; z-\u0026gt;ob_digit[i] = carry \u0026amp; PyLong_MASK; carry \u0026gt;\u0026gt;= PyLong_SHIFT; } z-\u0026gt;ob_digit[i] = carry; return long_normalize(z); } å…¶æ­¥éª¤å¤§è‡´åˆ†ä¸ºä»¥ä¸‹å‡ æ­¥ï¼š\n è·å–ä¸¤ä¸ªå‚æ•°çš„ ob_size çš„ç»å¯¹å€¼ï¼Œåˆ›å»ºå­˜å‚¨è¿”å›å€¼çš„æŒ‡é’ˆ PyLongObject *zï¼Œ å¦‚æœ a-\u0026gt;ob_size \u0026lt; b-\u0026gt;ob_size åˆ™äº¤æ¢ä¸¤è€…ï¼Œä¿è¯ a çš„å€¼è¾ƒå¤§ï¼› å°† z çš„ ob_size è®¾ç½®ä¸º size_a + 1ï¼Œä¿è¯ä¸ä¼šæº¢å‡ºï¼› ä»¥ i = 0 ä¸ºä¸‹æ ‡ï¼Œä»å°åˆ°å¤§ä¾æ¬¡å¯¹ä¸¤æ•°çš„æ¯ä¸€ä½è¿›è¡Œç›¸åŠ æ“ä½œï¼Œå°†æ²¡æœ‰è¶…è¿‡ 2^30 çš„éƒ¨åˆ†å­˜å‚¨åœ¨ z-\u0026gt;ob_digit[i] ä¸­ï¼Œè¶…è¿‡çš„éƒ¨åˆ†è¿›ä½ä¿å­˜åœ¨ carry ä¸­ï¼›è¿™é‡Œå……åˆ†åˆ©ç”¨äº†ä¸¤ä¸ªå°äº 2^30 çš„æ•°ç›¸åŠ ä¸ä¼šæº¢å‡ºçš„ç‰¹æ€§ï¼›å¦‚æœ size_a \u0026gt; size_b è¿˜éœ€è¦å°† a-\u0026gt;ob_digit å¤šä½™çš„éƒ¨åˆ†æŒ‰ç…§ç›¸åŒçš„æ–¹æ³•ç½®å…¥ z-\u0026gt;ob_digité‡Œï¼› å¾—åˆ°çš„ç»“æœ z ä¸­ï¼Œå…¶ ob_digit çš„æœ€åä¸€ä¸ªå…ƒç´ å¯èƒ½ç­‰äº 0ï¼Œå› æ­¤é€šè¿‡ long_normalize å‡½æ•°å°†å…¶è½¬æ¢ä¸ºç¬¦åˆ PyLongObject å®šä¹‰çš„æ ¼å¼è¿”å›ã€‚  æ•´ä¸ªè¿‡ç¨‹å¯ä»¥æŠ½è±¡ä¸ºç±»ä¼¼ 2^30 è¿›åˆ¶çš„åŠ æ³•ï¼Œå’Œåè¿›åˆ¶åŠ æ³•çš„è¿‡ç¨‹å‡ ä¹å®Œå…¨ä¸€æ ·ï¼Œåªä¸è¿‡æ˜¯æŠŠåè¿›åˆ¶æ¯ä¸€ä½çš„æ•°å­—æ¢æˆäº†ä¸€ä¸ªæœ€å¤§å€¼ä¸º 2^30 çš„æ•°å­—ï¼Œæ¯é€¢ 2^30 è¿›ä¸€ä½ï¼›ä¸¾ä¸ªä¾‹ï¼Œå‡è®¾æœ‰ a-\u0026gt;ob_digit = {4, 5, 6}, b-\u0026gt;ob_digit = {1073741823, 1073741823}ï¼Œé‚£ä¹ˆæ•´ä¸ªåŠ æ³•çš„æ­¥éª¤ä¸ºï¼š\n v-\u0026gt;ob_digit[0] = (4 + 1073741823) % 1073741824 = 3, carry = 1ï¼› v-\u0026gt;ob_digit[1] = (5 + 1073741823 + 1) % 1073741824 = 5, carry = 1ï¼› v-\u0026gt;ob_digit[2] = (6 + 1) % 1073741824 = 7, carry = 0ï¼› v-\u0026gt;ob_digit[3] = 0ï¼›  ç»“æœå³ v-\u0026gt;ob_digit = {3, 5, 7, 0}ï¼Œæœ€åä¸€ä¸ªå…ƒç´  0 éœ€è¦é€šè¿‡ long_normalize å‡½æ•°å»æ‰ã€‚\n2.3 ç»å¯¹å€¼å‡æ³• ç»å¯¹å€¼å‡æ³•çš„å®ç°å¦‚ä¸‹ï¼š\n/* Subtract the absolute values of two integers. */ static PyLongObject * x_sub(PyLongObject *a, PyLongObject *b) { Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b)); PyLongObject *z; Py_ssize_t i; int sign = 1; digit borrow = 0; /* Ensure a is the larger of the two: */ if (size_a \u0026lt; size_b) { sign = -1; { PyLongObject *temp = a; a = b; b = temp; } { Py_ssize_t size_temp = size_a; size_a = size_b; size_b = size_temp; } } else if (size_a == size_b) { /* Find highest digit where a and b differ: */ i = size_a; while (--i \u0026gt;= 0 \u0026amp;\u0026amp; a-\u0026gt;ob_digit[i] == b-\u0026gt;ob_digit[i]) ; if (i \u0026lt; 0) return (PyLongObject *)PyLong_FromLong(0); if (a-\u0026gt;ob_digit[i] \u0026lt; b-\u0026gt;ob_digit[i]) { sign = -1; { PyLongObject *temp = a; a = b; b = temp; } } size_a = size_b = i+1; } z = _PyLong_New(size_a); if (z == NULL) return NULL; for (i = 0; i \u0026lt; size_b; ++i) { /* The following assumes unsigned arithmetic works module 2**N for some N\u0026gt;PyLong_SHIFT. */ borrow = a-\u0026gt;ob_digit[i] - b-\u0026gt;ob_digit[i] - borrow; z-\u0026gt;ob_digit[i] = borrow \u0026amp; PyLong_MASK; borrow \u0026gt;\u0026gt;= PyLong_SHIFT; borrow \u0026amp;= 1; /* Keep only one sign bit */ } for (; i \u0026lt; size_a; ++i) { borrow = a-\u0026gt;ob_digit[i] - borrow; z-\u0026gt;ob_digit[i] = borrow \u0026amp; PyLong_MASK; borrow \u0026gt;\u0026gt;= PyLong_SHIFT; borrow \u0026amp;= 1; /* Keep only one sign bit */ } assert(borrow == 0); if (sign \u0026lt; 0) { Py_SET_SIZE(z, -Py_SIZE(z)); } return maybe_small_long(long_normalize(z)); } å…¶æ­¥éª¤å’Œç»å¯¹å€¼åŠ æ³•ç±»ä¼¼ï¼Œå¤§è‡´åˆ†ä¸ºä»¥ä¸‹å‡ æ­¥ï¼š\n è·å–ä¸¤ä¸ªå‚æ•°çš„ ob_size çš„ç»å¯¹å€¼ï¼Œåˆ›å»ºå­˜å‚¨è¿”å›å€¼çš„æŒ‡é’ˆ PyLongObject *zï¼Œ å¦‚æœ a-\u0026gt;ob_size \u0026lt; b-\u0026gt;ob_size åˆ™äº¤æ¢ä¸¤è€…ï¼Œä¿è¯ a çš„å€¼è¾ƒå¤§ï¼Œå¹¶ç”¨ sign è®°å½•è¿ç®—ç»“æœä¸ºè´Ÿï¼›å¦‚æœ a-\u0026gt;ob_size == b-\u0026gt;ob_size åˆ™ä»æœ€é«˜ä½ä¾æ¬¡å¾€ä½ä½æ‰¾åˆ°ç¬¬ä¸€æ¬¡å‡ºç° a-\u0026gt;ob_digit[i] != b-\u0026gt;ob_digit[i] çš„ä½ç½®ï¼Œæ¯”è¾ƒ a-\u0026gt;ob_digit[i] å’Œ b-\u0026gt;ob_digit[i]ï¼Œå¹¶å†³å®šæ˜¯å¦äº¤æ¢ä¸¤è€…ä»¥åŠ sign çš„å€¼ï¼› å°† z çš„ ob_size è®¾ç½®ä¸º size_aï¼› ä»¥ i = 0 ä¸ºä¸‹æ ‡ï¼Œä»å°åˆ°å¤§ä¾æ¬¡å¯¹ä¸¤æ•°çš„æ¯ä¸€ä½è¿›è¡Œç›¸å‡æ“ä½œï¼Œå¦‚æœè¢«å‡æ•° a-\u0026gt;ob_digit[i] å°äºå‡æ•° b-\u0026gt;ob_digit[i] åˆ™è¦å‘é«˜ä½ a-\u0026gt;ob_digit[i + 1] å€Ÿ 1ï¼›åœ¨åè¿›åˆ¶çš„å‡æ³•ä¸­å‘é«˜ä½å€Ÿåˆ°çš„æ•°æ˜¯ 10ï¼Œè¿™é‡Œå‘ digit æ•°ç»„çš„é«˜ä½å€Ÿåˆ°çš„åˆ™æ˜¯ 2^30ï¼›ä½† digit æ˜¯é€šè¿‡ typedef uint32_t digit å®šä¹‰å‡ºæ¥ï¼Œé€šè¿‡å…¬å¼ borrow = a-\u0026gt;ob_digit[i] - b-\u0026gt;ob_digit[i] - borrow å®é™…ä¸Šå¾—åˆ°çš„æ˜¯ 2^32 + a-\u0026gt;ob_digit[i] - b-\u0026gt;ob_digit[i]ï¼Œæ‰€ä»¥è¿˜éœ€è¦ä¸ PyLong_MASK åš \u0026amp; æ“ä½œï¼Œå–å 30 ä½ï¼Œä¾¿èƒ½å¾—åˆ°å€Ÿä½ç›¸å‡åçš„ç»“æœï¼Œå†å°†ç»“æœå­˜å‚¨åœ¨ z-\u0026gt;ob_digit[i] ä¸­ï¼›å€Ÿä½éƒ¨åˆ† borrow å‘å³ä½ç§» 30 ä½åè¿˜å‰© 2 ä½ï¼Œåªéœ€è¦å°†å…¶ä¸ 1 è¿›è¡Œ \u0026amp; æ“ä½œå³å¯çŸ¥é“æ­¤æ¬¡å‡æ³•è¿ç®—æ˜¯å¦æœ‰å€Ÿä½ï¼›å¦‚æœ size_a \u0026gt; size_b è¿˜éœ€è¦å°† a-\u0026gt;ob_digit å¤šä½™çš„éƒ¨åˆ†æŒ‰ç…§ç›¸åŒçš„æ–¹æ³•ç½®å…¥ z-\u0026gt;ob_digité‡Œï¼› å¾—åˆ°çš„ç»“æœ z ä¸­ï¼Œå…¶ ob_digit çš„æœ€åä¸€ä¸ªå…ƒç´ å¯èƒ½ç­‰äº 0ï¼Œå› æ­¤é€šè¿‡ long_normalize å‡½æ•°å°†å…¶è½¬æ¢ä¸ºç¬¦åˆ PyLongObject å®šä¹‰çš„æ ¼å¼è¿”å›ã€‚  å¯ä»¥çœ‹åˆ°è¿™é‡Œçš„æ­¥éª¤ä¹Ÿè·Ÿåè¿›åˆ¶å‡æ³•å‡ ä¹å®Œå…¨ç›¸åŒï¼Œéƒ½è·Ÿ NOIP å…¥é—¨çš„å¤§æ•°åŠ å‡æ³•åŠ æ³•æ€è·¯ç›¸åŒã€‚\n","permalink":"http://zintrulcre.github.io/posts/python/source-code-2/","summary":"Python æºç å­¦ä¹ ï¼ˆ2ï¼‰ï¼šint ç±»å‹ Python ä¸­çš„æ ‡å‡†æ•°æ®ç±»å‹æœ‰å…­ç§ï¼Œåˆ†åˆ«æ˜¯ number, string, list, tuple, set, dictionaryï¼Œå‰æ–‡å·²ç»é˜è¿°è¿‡å®ƒä»¬çš„å¯¹è±¡ç±»å‹éƒ½æ˜¯ç»§æ‰¿äº† PyBaseObject_Type ç±»å‹çš„ PyType_Type ç±»å‹çš„å®ä¾‹å¯¹è±¡ï¼Œæœ¬æ–‡åˆ™ä¸»è¦æ¢ç©¶ Python ä¸­ int ç±»å‹çš„å®ç°ã€‚\nä¸åŒäº C å’Œ C++ ä¸­çš„ int ç±»å‹ï¼ŒPython ä¸­çš„ int ç±»å‹æœ€å¤§çš„ç‰¹ç‚¹æ˜¯å®ƒä¸€èˆ¬æ˜¯ä¸ä¼šæº¢å‡ºçš„ï¼Œå¯¹æ¯”ç”¨ C å’Œ Python åˆ†åˆ«è¾“å‡ºä¸¤ä¸ªä¸€ç™¾ä¸‡ç›¸ä¹˜çš„ç»“æœï¼š\n\u0026gt;\u0026gt;\u0026gt; x = 10000000000 \u0026gt;\u0026gt;\u0026gt; print(x) 10000000000 åœ¨ C è¯­è¨€ä¸­ä¼šå‘ç”Ÿæº¢å‡ºï¼š\nprintf(\u0026#34;%d\\n\u0026#34;, 1000000 * 1000000); printf(\u0026#34;%u\\n\u0026#34;, 1000000 * 1000000); -727379968 3567587328 1 int ç±»å‹åœ¨å†…å­˜ä¸­çš„å­˜å‚¨æ–¹å¼ 1.1 å†…å­˜ç»“æ„ Python ä¸­çš„ int æ•´æ•°ç±»å‹å®é™…ä¸Šæ˜¯ä¸€ä¸ªåä¸º PyLongObject çš„ç»“æ„ä½“ï¼Œå®šä¹‰åœ¨ longintrepr.h æ–‡ä»¶ä¸­ï¼š\n// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base;  // Objects/longobject.","title":"Python æºç å­¦ä¹ ï¼ˆ2ï¼‰ï¼šint ç±»å‹"},{"content":"Python æºç å­¦ä¹ ï¼ˆ1ï¼‰ï¼šç±»å‹å’Œå¯¹è±¡ Python æ˜¯ä¸€é—¨è§£é‡Šå‹ï¼ŒåŠ¨æ€ç±»å‹ï¼Œå¤šèŒƒå¼çš„ç¼–ç¨‹è¯­è¨€ï¼Œå½“æˆ‘ä»¬ä» python.org ä¸‹è½½å¹¶å®‰è£…è¿è¡Œ Python çš„æŸä¸ªåˆ†å‘ç‰ˆæœ¬æ—¶ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ˜¯åœ¨è¿è¡Œç”± C è¯­è¨€ç¼–å†™çš„ CPythonï¼Œé™¤æ­¤ä¹‹å¤– Python çš„è¿è¡Œæ—¶è¿˜æœ‰ Jython, PyPy, Cython ç­‰ï¼›CPython çš„æºç ä¸­æœ‰ä¸€ç³»åˆ—çš„åº“ï¼Œç»„ä»¶å’Œå·¥å…·ï¼š\n$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc\t# æ–‡æ¡£ |-- Grammar |-- Include # C å¤´æ–‡ä»¶ |-- Lib\t# ç”¨ Python å†™çš„åº“æ–‡ä»¶ |-- Mac\t# ç”¨äºåœ¨ macOS ä¸Šæ„å»ºçš„æ–‡ä»¶ |-- Misc\t# æ‚é¡¹ |-- Modules\t# ç”¨ C å†™çš„åº“æ–‡ä»¶ |-- Objects # æ ¸å¿ƒç±»å‹ï¼Œä»¥åŠå¯¹è±¡æ¨¡å‹çš„å®šä¹‰ |-- PC\t# ç”¨äºåœ¨ Windows ä¸Šæ„å»ºçš„æ–‡ä»¶ |-- PCbuild # ç”¨äºåœ¨è€ç‰ˆæœ¬çš„ Windows ä¸Šæ„å»ºçš„æ–‡ä»¶ |-- Parser\t# Python è§£æå™¨æºç  |-- Programs\t# Python å¯æ‰§è¡Œæ–‡ä»¶å’Œå…¶ä»– |-- Python\t# CPython ç¼–è¯‘å™¨æºç  |-- Tools\t# æ„å»ºæ—¶çš„å·¥å…· `-- m4 16 directories æœ¬ç³»åˆ—ä¸»è¦ä»¥é˜…è¯»å’Œåˆ†æ CPython æºç çš„æ–¹å¼å­¦ä¹  Pythonã€‚\n1 å¯¹è±¡æ¨¡å‹ Python æ˜¯ä¸€é—¨é¢å‘å¯¹è±¡çš„è¯­è¨€ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Python ä¸­çš„ type() å‡½æ•°æŸ¥çœ‹ä¸€ä¸ªå¯¹è±¡æ‰€å±çš„ç±»ï¼š\n\u0026gt;\u0026gt;\u0026gt; type(1) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(True) \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; å¯ä»¥çœ‹åˆ°æ•´æ•°å¯¹è±¡å’Œå¸ƒå°”å€¼å¯¹è±¡çš„ç±»å‹åˆ†åˆ«æ˜¯ \u0026lt;class 'int'\u0026gt; å’Œ \u0026lt;class 'bool'\u0026gt;ï¼›\nè€Œå®é™…ä¸Šï¼Œåœ¨ Python ä¸­æ— è®ºæ˜¯æ•´æ•°ï¼Œå¸ƒå°”å€¼è¿˜æ˜¯åŸºæœ¬æ•°æ®ç±»å‹ï¼Œç”šè‡³è‡ªå®šä¹‰çš„ classï¼Œéƒ½æ˜¯å¯¹è±¡ï¼š\nclass Foo: pass print(type(int)) print(type(Foo)) \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; å¯ä»¥çœ‹åˆ° int ç±»å‹å’Œè‡ªå®šä¹‰ç±» Foo çš„ç±»å‹éƒ½æ˜¯ \u0026lt;class 'type'\u0026gt;ï¼Œå®ƒä»¬æ˜¯ type è¿™ä¸ªç±»çš„å®ä¾‹å¯¹è±¡ï¼›type ç±»å‹æ˜¯ä¸“é—¨ç”¨äºå®šä¹‰ç±»å‹çš„ç±»å‹ï¼Œä¹Ÿç§°ä¸ºå…ƒç±»å‹ï¼›å®é™…ä¸Šï¼Œ type è¿™ä¸ªç±»å‹æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒæ‰€å±çš„ç±»ä¹Ÿæ˜¯ typeï¼š\n\u0026gt;\u0026gt;\u0026gt; type(type) \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; åŒæ—¶ï¼ŒPython ä¸­çš„æ‰€æœ‰ç±»å‹ï¼Œæ— è®ºæ˜¯ int, type, è¿˜æ˜¯è‡ªå®šä¹‰ç±» Foo éƒ½æ˜¯ç»§æ‰¿è‡ªä¸€ä¸ªå« object çš„åŸºç±»ï¼Œè€Œ object åˆ™æ˜¯ç»§æ‰¿é“¾çš„ç»ˆç‚¹ï¼š\n\u0026gt;\u0026gt;\u0026gt; int.__base__ \u0026lt;class \u0026#39;object\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type.__base__ \u0026lt;class \u0026#39;object\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(Foo.__base__) \u0026lt;class \u0026#39;object\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(object.__base__) None è€Œ object åŸºç±»ä¹Ÿæ˜¯ä¸€ä¸ª type ç±»å‹çš„å¯¹è±¡ï¼š\n\u0026gt;\u0026gt;\u0026gt; type(object) \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; ä¸Šé¢çš„å…³ç³»ç”¨å›¾è¡¨è¾¾å‡ºæ¥åˆ™æ˜¯ï¼š\nå¯ä»¥çœ‹åˆ°ï¼Œæ‰€æœ‰ç±»å‹çš„åŸºç±»éƒ½æ˜¯ objectï¼Œæ‰€æœ‰ç±»å‹çš„ç±»å‹éƒ½æ˜¯ typeï¼Œè¿™å°±æ˜¯ Python çš„å¯¹è±¡æ¨¡å‹ï¼ˆobject modelï¼‰ï¼Œä¹Ÿæ˜¯ Objects/ ç›®å½•ä¸‹æºç æ‰€åŒ…å«çš„å†…å®¹ã€‚\n2 æ ¸å¿ƒç±»å‹ä¸å¯¹è±¡ è™½ç„¶åœ¨ Python çš„è¯­æ³•å±‚é¢æœ‰éå¸¸å¤šæ‰€è°“çš„ç±»å‹ï¼ˆåŒ…æ‹¬ int, type, Foo ç­‰ï¼‰ï¼Œä½†å®é™…ä¸Šå®ƒä»¬åœ¨æºç ï¼ˆC è¯­è¨€ï¼‰å±‚é¢ä¸Šéƒ½æ˜¯ç»“æ„ä½“å¯¹è±¡ã€‚\n2.1 å¯¹è±¡ PyObject Python ä¸­æ‰€æœ‰çš„ç±»å‹éƒ½ç”± PyObject ç»“æ„ä½“æ‰©å±•è€Œæ¥ï¼Œè¿™ä¸ªç»“æ„ä½“ä¸­æœ‰ä»¥ä¸‹å‡ ä¸ªæˆå‘˜å˜é‡ï¼š\n Py_ssize_t ob_refcnt ç”¨äºä¿å­˜å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼› PyTypeObject *ob_type æŒ‡å‘å¯¹è±¡çš„ç±»å‹å¯¹è±¡ï¼Œç”¨æ¥æ ‡è¯†å¯¹è±¡å±äºçš„ç±»å‹ï¼Œå¹¶å­˜å‚¨ç±»å‹çš„å…ƒæ•°æ®ï¼› _PyObject_HEAD_EXTRA å®ä»£è¡¨äº†ä¸¤ä¸ª PyObject* åŒå‘é“¾è¡¨çš„æŒ‡é’ˆï¼Œç”¨äºæŠŠå †ä¸Šçš„æ‰€æœ‰å¯¹è±¡é“¾æ¥èµ·æ¥ï¼Œåªä¼šåœ¨å¼€å¯äº† Py_TRACE_REFS å®çš„æ—¶å€™è¿›è¡Œæ„é€ ï¼Œæ–¹ä¾¿è°ƒè¯•ï¼›  // Include/object.h  /* Define pointers to support a doubly-linked list of all live heap objects. */ #define _PyObject_HEAD_EXTRA \\ struct _object *_ob_next; \\ struct _object *_ob_prev;  /* Nothing is actually declared to be a PyObject, but every pointer to * a Python object can be cast to a PyObject*. This is inheritance built * by hand. Similarly every pointer to a variable-size Python object can, * in addition, be cast to PyVarObject*. */ typedef struct _object { _PyObject_HEAD_EXTRA\t// åŒå‘é“¾è¡¨ï¼Œç”¨äºè¿½è¸ªå †ä¸­æ‰€æœ‰å¯¹è±¡ï¼Œåœ¨å¼€å¯äº† Py_TRACE_REFS å®çš„æ—¶å€™æœ‰ç”¨  Py_ssize_t ob_refcnt;\t// å¼•ç”¨è®¡æ•°ï¼Œç”¨äºåƒåœ¾å›æ”¶  PyTypeObject *ob_type;\t// æŒ‡é’ˆï¼ŒæŒ‡å‘å½“å‰å¯¹è±¡çš„ç±»å‹å¯¹è±¡ï¼Œç”¨äºæŸ¥è¯¢å¯¹è±¡çš„ç±»å‹ } PyObject; PyVarObject Python ä¸­æœ‰å¯ä»¥è‡ªç”±ä¿®æ”¹é•¿åº¦çš„ PyVarObject å˜é•¿å¯¹è±¡ï¼Œå®ƒç”±ä¸€ä¸ª PyObject å¯¹è±¡å’Œä¸€ä¸ªå­˜å‚¨å˜é•¿éƒ¨åˆ†çš„é•¿åº¦ï¼ˆå…ƒç´ ä¸ªæ•°ï¼‰çš„å˜é‡ ob_size ç»„æˆï¼š\ntypedef struct { PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part */ } PyVarObject; PyObject å’Œ PyVarObject ä¸€èˆ¬æ˜¯ä½œä¸ºå¤´éƒ¨è¢«åŒ…å«åœ¨ä¸€ä¸ªå˜é‡ç»“æ„ä½“ä¸­çš„ï¼Œæ ¹æ®è¯¥å˜é‡å¤§å°æ˜¯å¦å›ºå®šæ¥é€‰æ‹©ä½¿ç”¨å“ªä¸€ç§ï¼š\n// Include/object.h /* PyObject_HEAD defines the initial segment of every PyObject. */ #define PyObject_HEAD PyObject ob_base;  /* PyObject_VAR_HEAD defines the initial segment of all variable-size * container objects. These end with a declaration of an array with 1 * element, but enough space is malloc\u0026#39;ed so that the array actually * has room for ob_size elements. Note that ob_size is an element count, * not necessarily a byte count. */ #define PyObject_VAR_HEAD PyVarObject ob_base; Python ä¸­æœ€å…¸å‹çš„å˜é•¿å¯¹è±¡å°±æ˜¯åˆ—è¡¨ Listï¼Œå®ƒå’Œ std::vector æ¯”è¾ƒç±»ä¼¼ï¼Œåˆ—è¡¨å¯¹è±¡é‡Œæœ‰ä¸‰ä¸ªæˆå‘˜å˜é‡ï¼ŒåŒ…æ‹¬ï¼š\n åŸºç¡€çš„å˜é•¿å¯¹è±¡ PyVarObject ob_baseï¼Œå…¶ä¸­ ob_base.ob_size ç”¨äºè¡¨ç¤ºåˆ—è¡¨å½“å‰çš„å…ƒç´ ä¸ªæ•°ï¼› æŒ‡å‘åŠ¨æ€æ•°ç»„çš„æŒ‡é’ˆ PyObject **ob_itemï¼› åŠ¨æ€æ•°ç»„å½“å‰çš„å®¹é‡ Py_ssize_t allocatedï¼š  // Inlucde/cpython/listobject.h  typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for \u0026#39;allocated\u0026#39; elements. The number * currently in use is ob_size. * Invariants: * 0 \u0026lt;= ob_size \u0026lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated; } PyListObject; 2.2 ç±»å‹ PyTypeObject PyObject ç±»ä¸­çš„ PyTypeObject *ob_type æ˜¯ä¸€ä¸ªæŒ‡å‘å¯¹è±¡ç±»å‹çš„æŒ‡é’ˆï¼Œå®ƒæ˜¯ç±»åœ¨ Python ä¸­çš„è¡¨ç°å½¢å¼ï¼›PyTypeObject ä¸ä»…å†³å®šäº† PyObject å¯¹è±¡å±äºä»€ä¹ˆç±»å‹ï¼Œè¿˜åŒ…å«äº†éå¸¸å¤šçš„å…ƒæ•°æ®ï¼Œä¾‹å¦‚ï¼š\n PyObject_VAR_HEAD è¡¨ç¤º PyTypeObject æœ¬èº«æ˜¯ä¸€ä¸ªå˜é•¿å¯¹è±¡ï¼› const char *tp_name è¡¨ç¤ºç±»å‹çš„åå­—ï¼› struct _typeobject *tp_base æ˜¯æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆï¼Œä¿å­˜ç±»å‹çš„ç»§æ‰¿ä¿¡æ¯ï¼› Py_ssize_t tp_basicsize, tp_itemsize è¡¨ç¤ºåˆ›å»ºå®åŠ›å¯¹è±¡æ—¶åˆ†é…çš„å†…å­˜å¤§å°ï¼› setattrfunc tp_setattr è®¾ç½®å€¼ï¼Œgetattrfunc tp_getattr è·å–å€¼ï¼Œdestructor tp_dealloc ææ„ï¼Œhashfunc tp_hash å“ˆå¸Œç­‰å‡½æ•°æŒ‡é’ˆè¡¨ç¤ºè¯¥ç±»å‹æ‰€æ”¯æŒçš„æ ‡å‡†æ“ä½œï¼›  // Include/object.h  /* PyTypeObject structure is defined in cpython/object.h. In Py_LIMITED_API, PyTypeObject is an opaque structure. */ typedef struct _typeobject PyTypeObject; // Include/cpython/object.h struct _typeobject { PyObject_VAR_HEAD // å³ PyVarObject ob_base;  const char *tp_name; /* For printing, in format \u0026#34;\u0026lt;module\u0026gt;.\u0026lt;name\u0026gt;\u0026#34; */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ destructor tp_dealloc; Py_ssize_t tp_vectorcall_offset; getattrfunc tp_getattr; setattrfunc tp_setattr; PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2) or tp_reserved (Python 3) */ // Strong reference on a heap type, borrowed reference on a static type  struct _typeobject *tp_base; /* More standard operations (here for binary compatibility) */ // ... }; Python ä¸­çš„æ¯ä¸€ç§ç±»å‹å¯¹è±¡éƒ½æ˜¯å…¨å±€å”¯ä¸€çš„ï¼Œä»–ä»¬åœ¨æºç ä¸­ä»¥å…¨å±€å˜é‡çš„å½¢å¼å­˜åœ¨ï¼Œä¾‹å¦‚ int ç±»å‹ï¼š\n// Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) \u0026#34;int\u0026#34;, /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ 0, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ long_to_decimal_string, /* tp_repr */ \u0026amp;long_as_number, /* tp_as_number */ // ... }; PyVarObject_HEAD_INIT å®ç”¨äºåˆå§‹åŒ– PyVarObject ä¸­çš„ ob_refcnt, ob_type å’Œ ob_sizeï¼š\n#define PyObject_HEAD_INIT(type) \\ { 1, type },  #define PyVarObject_HEAD_INIT(type, size) \\ { PyObject_HEAD_INIT(type) size },  å¯ä»¥çœ‹åˆ°åœ¨ PyLong_Type ä¸­ï¼Œob_type è¢«åˆå§‹åŒ–ä¸º \u0026amp;PyType_Typeï¼Œå®ƒæ˜¯ä¸“é—¨ç”¨äºå®šä¹‰ç±»å‹å¯¹è±¡çš„ç±»å‹ï¼ŒæŠ‘æˆ–å«åšç±»å‹çš„ç±»å‹æˆ–åŸç±»å‹ã€‚\nPyType_Type åœ¨å‰é¢å·²ç»äº†è§£åˆ°ï¼Œtype ç±»å‹å¯¹è±¡æ‰€å±çš„ç±»ä¹Ÿæ˜¯ typeï¼Œé‚£ä¹ˆç±»å‹å¯¹è±¡ PyTypeObject æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªç±»å¯¹è±¡ï¼Œå®ƒä¹Ÿæ‹¥æœ‰æŒ‡å‘å…¶ç±»å‹å¯¹è±¡çš„æŒ‡é’ˆ PyTypeObject *ob_typeï¼›å¯¹äºç±»å‹å¯¹è±¡æœ¬èº«æ¥è¯´ï¼Œå®ƒçš„ç±»å‹å¯¹è±¡éƒ½åŸºäºä¸€ä¸ªå«åš PyType_Typeï¼ˆå³å…ƒç±»å‹ï¼‰çš„ PyTypeObject ç±»å¯¹è±¡ï¼š\n// Objects/typeobject.c PyTypeObject PyType_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0)\t// PyType_Type åœ¨åˆå§‹åŒ–çš„æ—¶å€™å°†æŒ‡å‘è‡ªèº«çš„æŒ‡é’ˆä¼ é€’å¹¶ç”¨äºæ„é€ äº†ä¸€ä¸ª PyVarObject ç±»å‹çš„å¯¹è±¡ ob_baseï¼Œå…¶ä¸­ ob_base-\u0026gt;ob_type = \u0026amp;PyType_Typeï¼Œå‚è€ƒé™„å½• 1  \u0026#34;type\u0026#34;, /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ (destructor)type_dealloc, /* tp_dealloc */ offsetof(PyTypeObject, tp_vectorcall), /* tp_vectorcall_offset */ // ... }; Python ä¸­ç±»å‹å¯¹è±¡éƒ½å®šä¹‰åœ¨äº† Objects/ ç›®å½•ä¸‹ï¼Œä¾‹å¦‚ bool ç±»å‹ï¼š\n// Objects/boolobject.c  /* The type object for bool. Note that this cannot be subclassed! */ PyTypeObject PyBool_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0)\t// åŒ PyType_Typeï¼Œob_base-\u0026gt;ob_type = \u0026amp;PyType_Type  \u0026#34;bool\u0026#34;,\t// tp_name = \u0026#34;bool\u0026#34;  sizeof(struct _longobject),\t/* tp_basicsize */ 0,\t/* tp_itemsize */ 0, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ bool_repr, /* tp_repr */ \u0026amp;bool_as_number, /* tp_as_number */ // ...  0, /* tp_base */ // ... }; åœ¨ Python ä¸­ï¼Œæ— è®ºæ˜¯å†…å»ºç±»å‹ï¼ˆint, bool ç­‰ï¼‰ï¼Œè¿˜æ˜¯è‡ªå®šä¹‰ç±»å‹ï¼ˆFooï¼‰ï¼Œéƒ½æ˜¯é€šè¿‡ PyTypeObject è¿™ä¸ªç»“æ„ä½“æ„é€ çš„ï¼Œä¸”ä¸€å®šæ»¡è¶³ ob_base-\u0026gt;ob_type = \u0026amp;PyType_Typeã€‚\nå‰æ–‡æåˆ° tp_base æ˜¯æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆï¼Œä¿å­˜ç±»å‹çš„ç»§æ‰¿ä¿¡æ¯ï¼Œä½†å®é™…ä¸Šåœ¨å®šä¹‰ PyBool_Type çš„æ—¶å€™å¯ä»¥çœ‹åˆ° tp_base = 0ï¼Œå®é™…ä¸Šè¿™ä¸ª tp_base æ˜¯åœ¨ PyType_Ready å‡½æ•°ä¸­è¢«èµ‹å€¼ä¸º PyBaseObject_Type çš„ï¼š\n// Objects/typeobject.c  int PyType_Ready(PyTypeObject *type) { PyTypeObject *base; // ... \t/* Initialize tp_base (defaults to BaseObject unless that\u0026#39;s us) */ base = type-\u0026gt;tp_base; if (base == NULL \u0026amp;\u0026amp; type != \u0026amp;PyBaseObject_Type) { base = \u0026amp;PyBaseObject_Type; if (type-\u0026gt;tp_flags \u0026amp; Py_TPFLAGS_HEAPTYPE) { type-\u0026gt;tp_base = (PyTypeObject*)Py_NewRef((PyObject*)base); } else { type-\u0026gt;tp_base = base; } } // ... } è¿™é‡Œ PyTypeObject *base è¢«èµ‹å€¼ä¸ºçš„ PyBaseObject_Type å°±æ˜¯å‰æ–‡æåˆ°çš„åŸºç±»å‹ã€‚\nPyBaseObject_Type PyBaseObject_Type å®šä¹‰åœ¨ typeobject.c æ–‡ä»¶ä¸­ï¼š\n// Objects/typeobject.c PyTypeObject PyBaseObject_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0)\t// åŒ PyType_Typeï¼Œob_base-\u0026gt;ob_type = \u0026amp;PyType_Type  \u0026#34;object\u0026#34;, /* tp_name */ sizeof(PyObject), /* tp_basicsize */ 0, /* tp_itemsize */ object_dealloc, /* tp_dealloc */ // ...  object_repr, /* tp_repr */ // ...  0, /* tp_base */ // ... }; å¯ä»¥çœ‹åˆ°æ— è®ºæ˜¯ PyBool_Typeï¼ŒPyType_Type è¿˜æ˜¯ PyBaseObject_Typeï¼Œéƒ½æœ‰ä¸¤ä¸ªå…±åŒç‚¹ï¼š\n å®ƒä»¬æ˜¯ä»¥åŒæ ·çš„æ–¹å¼ PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) å®šä¹‰å…¶ç±»å‹çš„ï¼Œå› æ­¤å®ƒä»¬çš„ç±»å‹éƒ½æ˜¯ PyTypeObjectï¼› å®ƒä»¬æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆ tp_base åˆå§‹åŒ–æ—¶éƒ½æ˜¯ NULLï¼›  ä¸åŒçš„åœ°æ–¹æ˜¯ï¼Œåœ¨ä½¿ç”¨ PyType_Ready å‡½æ•°ä¸ºå®ƒä»¬çš„åŸºç±»æŒ‡é’ˆ tp_base èµ‹å€¼æ—¶ï¼Œåªæœ‰ PyBaseObject_Type.tp_base ä¸ä¼šè¢«èµ‹å€¼ï¼Œå…¶ä»–çš„ tp_base åˆ™éƒ½ä¼šè¢«èµ‹å€¼ä¸º PyBaseObject_Typeï¼Œè¿™ä¹Ÿå°è¯äº† PyBaseObject_Type æ˜¯ç»§æ‰¿é“¾çš„ç»ˆç‚¹ã€‚\næˆ‘ä»¬å¯ä»¥å°†ä¸Šé¢çš„å…³ç³»æ•´ç†ä¸ºä¸€ä¸ªå›¾ï¼š\né™„å½• 1 PyType_Type æ„é€  struct Bar; struct Foo { Bar* p_b; int ref_count; }; struct Bar { Foo f; const char* name; }; Bar b { Foo{ \u0026amp;b, 1 }, \u0026#34;ClassBar\u0026#34; }; int main() { printf(\u0026#34;%s\\n\u0026#34;, b.f.p_b-\u0026gt;name); return 0; } $ ./test ClassBar ","permalink":"http://zintrulcre.github.io/posts/python/source-code-1/","summary":"Python æºç å­¦ä¹ ï¼ˆ1ï¼‰ï¼šç±»å‹å’Œå¯¹è±¡ Python æ˜¯ä¸€é—¨è§£é‡Šå‹ï¼ŒåŠ¨æ€ç±»å‹ï¼Œå¤šèŒƒå¼çš„ç¼–ç¨‹è¯­è¨€ï¼Œå½“æˆ‘ä»¬ä» python.org ä¸‹è½½å¹¶å®‰è£…è¿è¡Œ Python çš„æŸä¸ªåˆ†å‘ç‰ˆæœ¬æ—¶ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ˜¯åœ¨è¿è¡Œç”± C è¯­è¨€ç¼–å†™çš„ CPythonï¼Œé™¤æ­¤ä¹‹å¤– Python çš„è¿è¡Œæ—¶è¿˜æœ‰ Jython, PyPy, Cython ç­‰ï¼›CPython çš„æºç ä¸­æœ‰ä¸€ç³»åˆ—çš„åº“ï¼Œç»„ä»¶å’Œå·¥å…·ï¼š\n$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc\t# æ–‡æ¡£ |-- Grammar |-- Include # C å¤´æ–‡ä»¶ |-- Lib\t# ç”¨ Python å†™çš„åº“æ–‡ä»¶ |-- Mac\t# ç”¨äºåœ¨ macOS ä¸Šæ„å»ºçš„æ–‡ä»¶ |-- Misc\t# æ‚é¡¹ |-- Modules\t# ç”¨ C å†™çš„åº“æ–‡ä»¶ |-- Objects # æ ¸å¿ƒç±»å‹ï¼Œä»¥åŠå¯¹è±¡æ¨¡å‹çš„å®šä¹‰ |-- PC\t# ç”¨äºåœ¨ Windows ä¸Šæ„å»ºçš„æ–‡ä»¶ |-- PCbuild # ç”¨äºåœ¨è€ç‰ˆæœ¬çš„ Windows ä¸Šæ„å»ºçš„æ–‡ä»¶ |-- Parser\t# Python è§£æå™¨æºç  |-- Programs\t# Python å¯æ‰§è¡Œæ–‡ä»¶å’Œå…¶ä»– |-- Python\t# CPython ç¼–è¯‘å™¨æºç  |-- Tools\t# æ„å»ºæ—¶çš„å·¥å…· `-- m4 16 directories æœ¬ç³»åˆ—ä¸»è¦ä»¥é˜…è¯»å’Œåˆ†æ CPython æºç çš„æ–¹å¼å­¦ä¹  Pythonã€‚","title":"Python æºç å­¦ä¹ ï¼ˆ1ï¼‰ï¼šç±»å‹å’Œå¯¹è±¡"},{"content":"C++ æ™ºèƒ½æŒ‡é’ˆçš„ç®€å•å®ç° 1 std::auto_ptr C++ ä¸­ç»å¸¸ä¼šå‡ºç°å› ä¸ºæ²¡æœ‰ delete æŒ‡é’ˆè€Œé€ æˆçš„å†…å­˜æ³„æ¼ï¼Œä¾‹å¦‚æœ‰ä¸€ä¸ª Object æ¨¡æ¿ç±»ï¼š\ntemplate\u0026lt;typename T\u0026gt; class Object { public: // constructor  Object() : t_() { cout \u0026lt;\u0026lt; \u0026#34;Object::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } Object(T t) : t_(t) { cout \u0026lt;\u0026lt; \u0026#34;Object::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } // copy-ctor  Object(const Object \u0026amp;other) { cout \u0026lt;\u0026lt; \u0026#34;Object::Copy-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } // destructor  ~Object() { cout \u0026lt;\u0026lt; \u0026#34;Object::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } void Set(T t) { t_ = t; } void Print() { cout \u0026lt;\u0026lt; t_ \u0026lt;\u0026lt; endl; } private: T t_; }; å¦‚æœåœ¨å †ä¸Šä¸ºç±»å¯¹è±¡åˆ†é…äº†å†…å­˜ï¼Œåœ¨ç¦»å¼€å…¶ä½œç”¨åŸŸçš„æ—¶å€™åˆæ²¡å°†å…¶é‡Šæ”¾ï¼Œåˆ™ä¼šé€ æˆå†…å­˜æ³„æ¼ï¼š\nvoid AutoPointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); o-\u0026gt;Print(); } $ ./bin/smart-pointer Object::Constructor 0x7b7058 # o 1 ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒC++ 98 åœ¨æ ‡å‡†ä¸­å¢åŠ äº†æœ€åŸå§‹çš„æ™ºèƒ½æŒ‡é’ˆ std::auto_ptrï¼Œå®ƒåˆ©ç”¨ RAII çš„æœºåˆ¶æä¾›äº†è‡ªåŠ¨å†…å­˜ç®¡ç†çš„åŠŸèƒ½ï¼Œå³åˆ©ç”¨æ ˆä¸Šå¯¹è±¡æ¥ç®¡ç†å †ä¸Šå†…å­˜ï¼Œå½“æ™ºèƒ½æŒ‡é’ˆå¯¹è±¡ç¦»å¼€å…¶ä½œç”¨åŸŸæ—¶ï¼Œé»˜è®¤åœ¨å…¶ææ„å‡½æ•°ä¸­é‡Šæ”¾å…¶ç®¡ç†çš„å †ä¸Šå˜é‡ï¼›å®ƒèƒ½å¤Ÿåœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡å°‘å†…å­˜æ³„éœ²çš„å‘ç”Ÿï¼Œä»¥ä¸‹æ˜¯å‚è€ƒ GCC ä¸­çš„ std::auto_ptr å®ç°çš„ AutoPointer ç±»ï¼Œåšäº†ä¸€å®šç¨‹åº¦çš„ç®€åŒ–ï¼Œå¢åŠ äº†ä¸€äº›è¾“å‡ºæ–¹ä¾¿è¿½è¸ªèµ„æºåˆ†é…è¿‡ç¨‹ï¼š\ntemplate\u0026lt;typename T\u0026gt; class AutoPointer { public: // constructor  explicit AutoPointer(T* t = nullptr) noexcept : ptr_(t) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // copy-ctor  AutoPointer(AutoPointer\u0026lt;T\u0026gt;\u0026amp; other) noexcept : ptr_(other.Release()) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer::Copyctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // assignment operator  AutoPointer\u0026lt;T\u0026gt;\u0026amp; operator=(AutoPointer\u0026lt;T\u0026gt;\u0026amp; other) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer::Assignment \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; Reset(other.Release()); return *this; } // destructor  ~AutoPointer() noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; delete ptr_; } T\u0026amp; operator*() noexcept { return *ptr_; } T* operator-\u0026gt;() const noexcept { return ptr_; } T* Get() const noexcept { return ptr_; } T* Release() noexcept { T* ptr_ret = ptr_; ptr_ = nullptr; return ptr_ret; } void Reset(T* ptr_para) noexcept { if (ptr_ != ptr_para) { delete ptr_; ptr_ = ptr_para; } } private: T *ptr_; }; åœ¨åˆå§‹åŒ–æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨åœ¨å †ä¸Šåˆ†é…ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶å°†å…¶ä½œä¸ºå‚æ•°ä¼ å…¥ï¼›æ¥ä¸‹æ¥å°±å¯ä»¥å°†æ™ºèƒ½æŒ‡é’ˆå¯¹è±¡å½“ä½œæ™®é€šçš„æŒ‡é’ˆä½¿ç”¨äº†ï¼ŒåŒæ—¶ä¹Ÿå¹¶ä¸éœ€è¦å…³å¿ƒå…¶ç”Ÿå‘½å‘¨æœŸï¼Œå¹¶èƒ½å¤Ÿç”¨ä½¿ç”¨æ™®é€šæŒ‡é’ˆçš„æ–¹æ³•æ¥ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼š\nvoid AutoPointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; a(o); (*o).Set(2); (*o).Print(); o-\u0026gt;Set(3); o-\u0026gt;Print(); } $ ./bin/smart-pointer Object::Constructor 0x48f058 # o AutoPointer::Constructor 0xbee47668 # a 2 3 AutoPointer::Destructor 0xbee47668 # a Object::Destructor 0x48f058 # o ç±»ä¸­æœ€é‡è¦çš„ä¸¤ä¸ªå‡½æ•°æ˜¯ Release å’Œ Resetï¼Œå‰è€…ç”¨æ¥è§£é™¤å¯¹è±¡å½“å‰æ‰€ç®¡ç†çš„æŒ‡é’ˆå¯¹è±¡å¹¶è¿”å›ï¼Œåè€…ä¼šé‡Šæ”¾å¯¹è±¡å½“å‰æ‰€ç®¡ç†çš„æŒ‡é’ˆå¯¹è±¡ï¼Œå¹¶å°†ä¼ å…¥çš„æŒ‡é’ˆå¯¹è±¡ç½®ä¸ºæ–°çš„ç®¡ç†å¯¹è±¡ï¼Œä¸¤è€…æ­é…èµ·æ¥å®ç°äº†æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ“ä½œç¬¦ï¼›è€Œè¿™ä¸¤ä¸ªå‡½æ•°çš„å­˜åœ¨åˆ™å¸¦æ¥äº†ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œå³åœ¨è¿›è¡Œæ‹·è´æ„é€ æˆ–è€…èµ‹å€¼æ“ä½œçš„æ—¶å€™ï¼Œè¢«æ“ä½œçš„ AutoPointer å¯¹è±¡å¯èƒ½åœ¨æ— æ„è¯†çš„æƒ…å†µä¸‹å¤±å»å¯¹å…¶è‡ªèº«æ‰€ç®¡ç†å¯¹è±¡çš„æ‰€æœ‰æƒï¼Œä»è€Œå¯èƒ½é€ æˆ segmentation faultï¼š\nvoid Foo() { AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; p1(new Object\u0026lt;int\u0026gt;(6)); AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; p2(p1); cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34;; p2-\u0026gt;Print(); cout \u0026lt;\u0026lt; \u0026#34;p1: \u0026#34;; p1-\u0026gt;Print(); } $ ./bin/smart-pointer Object::Constructor 0x1cbd058 # o AutoPointer::Constructor 0xbed23668 # a1 AutoPointer::Copyctor 0xbed23664 # a2 a2: 1 Segmentation fault ç¬¬äºŒä¸ªé—®é¢˜æ˜¯ AutoPointer é»˜è®¤åªä¼šä½¿ç”¨ delete æ¥è¿›è¡Œåˆ é™¤æ“ä½œï¼Œå¦‚æœä¸€ä¸ª AutoPointer å¯¹è±¡ç®¡ç†äº†ä¸€ä¸ªæ•°ç»„ï¼Œåˆ™ä¼šåœ¨ç¦»å¼€å…¶ä½œç”¨åŸŸæ—¶å‘ç”Ÿå†…å­˜æ³„æ¼ï¼Œå¼€å¯ AddressSanitizer å¯ä»¥æ£€æŸ¥åˆ°ï¼š\nvoid AutoPointerFoo() { int *a = new int[1000000]; AutoPointer\u0026lt;int\u0026gt; p(a); } $ ./bin/smart-pointer AutoPointer::Constructor 0xbe9955e0 # new[] AutoPointer::Destructor 0xbe9955e0 # delete ================================================================= ==2543==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new [] vs operator delete) on 0xb412e800 # ... é™¤æ­¤ä¹‹å¤–ï¼Œå¦‚æœä½¿ç”¨åŒä¸€ä¸ª Object æŒ‡é’ˆå¯¹å¤šä¸ª AutoPointer å¯¹è±¡è¿›è¡Œåˆå§‹åŒ–ï¼Œé‚£ä¹ˆè¿™ä¸ª Object å¯¹è±¡ä¼šè¢«å¤šæ¬¡ deleteï¼Œåœ¨è¿è¡Œæ—¶é€ æˆ double free çš„æŠ¥é”™ï¼š\nvoid AutoPointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; a1(o); AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; a2(o); } $ ./bin/smart-pointer Object::Constructor 0x9c3058 # o AutoPointer::Constructor 0xbee80668 # a1 AutoPointer::Constructor 0xbee80664 # a2 AutoPointer::Destructor 0xbee80664 # a2 Object::Destructor 0x9c3058 # o AutoPointer::Destructor 0xbee80668 # a1 Object::Destructor 0x9c3058 # o free(): double free detected in tcache 2 Aborted 2 unique_ptr ä¸ºäº†è§£å†³ std::auto_ptr ä¸­å‡ºç°çš„é—®é¢˜ï¼ŒC++ 11 å‚è€ƒäº† boost::unique_ptr çš„è®¾è®¡ï¼Œå‘æ ‡å‡†åº“ä¸­å¼•å…¥äº† std::unique_ptrï¼Œä¸‹é¢æ˜¯å‚è€ƒå…¶å®ç°çš„ UniquePointer æ¨¡æ¿ç±»ï¼Œåšäº†ç›¸å½“ç¨‹åº¦çš„ç®€åŒ–ï¼š\ntemplate\u0026lt;typename ElementType, typename DeleterType = DefaultDeleter\u0026gt; class UniquePointer { public: // constructors  UniquePointer() noexcept : ptr_(nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } explicit UniquePointer(ElementType* p) noexcept : ptr_(p) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } UniquePointer(ElementType* p, DeleterType d) noexcept : ptr_(p), deleter_(d) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // move-ctor  UniquePointer(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp;\u0026amp; other) noexcept : ptr_(other.Release()), deleter_(std::move(other.deleter_)) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Move-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // move assignment operator  UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; operator=(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp;\u0026amp; other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::MoveAssignment \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; ptr_ = other.Release(); deleter_ = std::move(other.deleter_); return *this; } // copy-ctor  UniquePointer(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; other) noexcept = delete; // assignment operator  UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; operator=(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; other) = delete; // destructor  ~UniquePointer() noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; if (ptr_) { GetDeleter()(ptr_); ptr_ = nullptr; } } ElementType\u0026amp; operator*() noexcept { return *ptr_; } ElementType* operator-\u0026gt;() const noexcept { return ptr_; } ElementType* Get() const noexcept { return ptr_; } const DeleterType\u0026amp; GetDeleter() const noexcept { return deleter_; } ElementType* Release() noexcept { ElementType* ret = nullptr; std::swap(ptr_, ret); return ret; } void Reset(ElementType* p) noexcept { if (ptr_ != p) { delete ptr_; ptr_ = p; } } private: ElementType* ptr_; DeleterType deleter_; }; ç›¸è¾ƒäº AutoPointerï¼ŒUniquePointer åšå‡ºçš„æ”¹å˜ä¸»è¦æœ‰ä¸¤ç‚¹ï¼šç¬¬ä¸€ç‚¹æ˜¯ UniquePointer å¯¹å…¶ç®¡ç†çš„æŒ‡é’ˆæ‹¥æœ‰ç‹¬å æ‰€æœ‰æƒï¼Œé€šè¿‡ç¦ç”¨æ‹·è´æ„é€ å’Œèµ‹å€¼æ“ä½œçš„æ–¹å¼é˜²æ­¢äº†æ‰€æœ‰æƒè½¬ç§»çš„å‘ç”Ÿï¼š\nvoid UniquePointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u1(o); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u2{ u1 }; // error: use of deleted function â€˜UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;::UniquePointer(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp;) [with ElementType = Object\u0026lt;int\u0026gt;; DeleterType = DefaultDeleter]â€™ } åŒæ—¶åˆå¢åŠ äº†ç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼æ“ä½œï¼Œé€šè¿‡ move è¯­ä¹‰æ¥è®©æˆ‘ä»¬å¯ä»¥åœ¨ç‰¹å®šæƒ…å†µä¸‹æ˜¾å¼åœ°è½¬ç§»æŒ‡é’ˆï¼š\nvoid UniquePointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u1(o); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u2(std::move(u1)); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u3; u3 = std::move(u2); } $ ./bin/smart-pointer Object::Constructor 0x3af058\t# o UniquePointer::Constructor 0xbec29664\t# u1 UniquePointer::Move-ctor 0xbec2965c\t# u2 UniquePointer::Constructor 0xbec29654\t# u3 UniquePointer::MoveAssignment 0xbec29654\t# u3 UniquePointer::Destructor 0xbec29654\t# u3 Object::Destructor 0x3af058\t# o UniquePointer::Destructor 0xbec2965c\t# u2 UniquePointer::Destructor 0xbec29664\t# u1 ç¬¬äºŒç‚¹æ˜¯åœ¨æ¨¡æ¿å‚æ•°ä¸­å¢åŠ äº†è‡ªå®šä¹‰åˆ é™¤å™¨ï¼Œåˆ é™¤å™¨æ˜¯ä¸€ä¸ª functorï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å…¶ operator() æ“ä½œç¬¦ä¸­è‡ªå®šä¹‰ UniquePointer åœ¨ææ„æ—¶å¯¹å…¶ç®¡ç†çš„æŒ‡é’ˆè¿›è¡Œçš„æ“ä½œï¼Œä¾‹å¦‚ä½¿ç”¨ delete[] æ¥é‡Šæ”¾å†…å­˜ï¼Œæˆ–æ˜¯å…³é—­ç›¸å…³çš„ Socket ç­‰ï¼š\nstruct ArrayDeleter { template\u0026lt;typename T\u0026gt; void operator()(T* p) const { static_assert(sizeof(p) \u0026gt; 0, \u0026#34;can\u0026#39;t delete pointer to incomplete type\u0026#34;); delete[] p; } }; void UniquePointerFoo() { int* int_arr = new int[1000000]; ArrayDeleter array_deleter; UniquePointer\u0026lt;int, ArrayDeleter\u0026gt; u(int_arr, array_deleter); } $ ./bin/smart-pointer UniquePointer::Constructor 0xbe9ad660 UniquePointer::Destructor 0xbe9ad660 æ­£å› ä¸º UniquePointer å¯¹èµ„æºå…·æœ‰ç‹¬å æ‰€æœ‰æƒï¼Œä¸èƒ½åŒæ—¶æœ‰å¤šä¸ª UniquePointer æ‹¥æœ‰ç›¸åŒçš„èµ„æºï¼Œå› æ­¤ AutoPointer ä¸­çš„ç¬¬ä¸‰ä¸ªé—®é¢˜å¹¶ä¸èƒ½é€šè¿‡ä½¿ç”¨ UniquePointer æ¥è§£å†³ã€‚\n3 shared_ptr std::shared_ptr çš„åº”ç”¨åœºæ™¯åœ¨äºå½“æˆ‘ä»¬éœ€è¦è®©å¤šä¸ªæ™ºèƒ½æŒ‡é’ˆå¯¹è±¡åŒæ—¶æ‹¥æœ‰åŒä¸€ä¸ªæŒ‡é’ˆï¼Œè€Œåˆå¸Œæœ›åœ¨è¿™äº›å¯¹è±¡éƒ½é€€å‡ºå…¶ä½œç”¨åŸŸçš„æ—¶å€™å»é”€æ¯æŒ‡é’ˆã€‚å®ƒä½¿ç”¨äº†ä¸€ä¸ªå¼•ç”¨è®¡æ•°å™¨æ¥è®°å½•æŒ‡é’ˆåœ¨åŒä¸€æ—¶é—´è¢«å‡ ä¸ªæ™ºèƒ½æŒ‡é’ˆå¯¹è±¡æ‰€å…±äº«ï¼Œå½“è¿™ä¸ªå¼•ç”¨è®¡æ•°å‡å°‘ä¸º 0 æ—¶ï¼Œè¯´æ˜å·²ç»ä¸å†æœ‰å¯¹è±¡æ‹¥æœ‰è¿™ä¸ªæŒ‡é’ˆï¼Œæ­¤æ—¶åˆ™éœ€è¦è¿›è¡Œèµ„æºçš„é”€æ¯ã€‚\n// A smart pointer with reference-counted copy semantics. The // object pointed to is deleted when the last shared_ptr pointing to // it is destroyed or reset. template\u0026lt;typename _Tp, _Lock_policy _Lp\u0026gt; class __shared_ptr // ... ç”± std::shared_ptr ç®¡ç†çš„æŒ‡é’ˆå¯¹è±¡ï¼ˆä»¥åŠå¼•ç”¨è®¡æ•°å™¨ï¼‰å­˜æ”¾åœ¨å †ä¸Šï¼Œå¦‚æœåœ¨åŒä¸€æ—¶é—´æœ‰ä¸¤ä¸ªæŒæœ‰ç›¸åŒèµ„æºä½†ä½äºä¸åŒçº¿ç¨‹ä¸­çš„æ™ºèƒ½æŒ‡é’ˆåŒæ—¶è®¿é—®ä»–ä»¬æ‰€æŒæœ‰çš„èµ„æºï¼Œåˆ™å¯èƒ½ä¼šå¯¼è‡´çº¿ç¨‹å®‰å…¨é—®é¢˜ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦ä½¿ç”¨ä¸€å®šçš„æœºåˆ¶æ¥é˜²æ­¢çº¿ç¨‹å®‰å…¨é—®é¢˜çš„å‘ç”Ÿï¼›ä¸€èˆ¬æ¥è¯´å¯¹å¼•ç”¨è®¡æ•°å™¨çš„åŠ å‡ä¿®æ”¹æ˜¯åŸå­çš„ï¼Œä½†å¯¹äºå…±äº«èµ„æºçš„è®¿é—®åˆ™éœ€è¦ä½¿ç”¨äº’æ–¥é”ç­‰æœºåˆ¶ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚\nä»¥ä¸‹æ˜¯å‚è€ƒ std::shared_ptr å®ç°çš„ SharedPointer ç±»ï¼š\ntemplate\u0026lt;typename ElementType, typename DeleterType = DefaultDeleter\u0026gt; class SharedPointer { public: // constructors  SharedPointer() noexcept : ptr_(nullptr), ref_count_(nullptr), deleter_(nullptr), mutex_(nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } explicit SharedPointer(ElementType* p) noexcept : ptr_(p), ref_count_(new int(1)), deleter_(new DeleterType()), mutex_(new mutex()) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } SharedPointer(ElementType* p, DeleterType *d) noexcept : ptr_(p), ref_count_(new int(1)), deleter_(d), mutex_(new mutex()) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } explicit SharedPointer(const WeakPointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; wp) noexcept : ptr_(wp.ptr_), ref_count_(wp.ref_count_), deleter_(wp.deleter_), mutex_(wp.mutex_) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; IncreaseReferenceCount(); } // copy-ctor  SharedPointer(const SharedPointer\u0026lt;ElementType\u0026gt;\u0026amp; other) noexcept : ptr_(other.ptr_), ref_count_(other.ref_count_), deleter_(other.deleter_), mutex_(other.mutex_) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Copy-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; IncreaseReferenceCount(); } // assignment operator  SharedPointer\u0026amp; operator=(SharedPointer\u0026lt;ElementType\u0026gt;\u0026amp; other) { if (ptr_ != other.ptr_) { Release(); ptr_ = other.ptr_; ref_count_ = other.ref_count_; mutex_ = other.mutex_; deleter_ = other.deleter_; IncreaseReferenceCount(); } return *this; } // destructor  ~SharedPointer() noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; Release(); } void Swap(SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; other) { std::swap(ptr_, other.ptr_); std::swap(ref_count_, other.ref_count_); std::swap(deleter_, other.deleter_); std::swap(mutex_, other.mutex_); } void Reset() { SharedPointer().Swap(*this); } void Reset(ElementType* p, DeleterType* d = nullptr) { SharedPointer(p, d).Swap(*this); } int UseCount() { return ref_count_ ? *ref_count_ : 0; } ElementType\u0026amp; operator*() noexcept { return *ptr_; } ElementType* operator-\u0026gt;() const noexcept { return ptr_; } ElementType* Get() const noexcept { return ptr_; } const DeleterType\u0026amp; GetDeleter() const noexcept { return *deleter_; } void Release() { if (!ptr_) return; bool delete_flag = false; mutex_-\u0026gt;lock(); if (--(*ref_count_) == 0) { GetDeleter()(ptr_); delete ref_count_; delete deleter_; delete_flag = true; } mutex_-\u0026gt;unlock(); if (delete_flag) { delete mutex_; } } void IncreaseReferenceCount() { if (!ptr_) return; mutex_-\u0026gt;lock(); ++(*ref_count_); mutex_-\u0026gt;unlock(); } ElementType* ptr_; int *ref_count_; DeleterType* deleter_; mutex* mutex_; }; ç°åœ¨å¯ä»¥æ­£ç¡®åœ°è®©ä¸€ä¸ªæŒ‡é’ˆè¢«å¤šä¸ªæ™ºèƒ½æŒ‡é’ˆå¯¹è±¡æ‰€æŒæœ‰äº†ï¼š\nvoid SharedPointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); SharedPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; s1(o); SharedPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; s2(s1); s1.Reset(nullptr); s2.Reset(nullptr); } $ ./bin/smart-pointer Object::Constructor 0x1ac7058 # o1 SharedPointer::Constructor 0xbe89c65c # p1 SharedPointer::Copy-ctor 0xbe89c64c # p2 SharedPointer::Constructor 0xbe89c630 # p1.Reset SharedPointer::Destructor 0xbe89c630 # p1.Reset SharedPointer::Constructor 0xbe89c630 # p2.Reset SharedPointer::Destructor 0xbe89c630 # p2.Reset Object::Destructor 0x1ac7058 # o1 SharedPointer::Destructor 0xbe89c64c # p2 SharedPointer::Destructor 0xbe89c65c # p1 ä½†åˆå‡ºç°äº†å¾ªç¯å¼•ç”¨çš„é—®é¢˜ï¼Œä¾‹å¦‚ï¼š\nvoid SharedPointerFoo() { struct Node { int i_; SharedPointer\u0026lt;Node\u0026gt; prev_; SharedPointer\u0026lt;Node\u0026gt; next_; Node(int i) : i_(i) { std::cout \u0026lt;\u0026lt; \u0026#34;Node::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } ~Node() { std::cout \u0026lt;\u0026lt; \u0026#34;Node::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } }; Node *n1 = new Node(1), *n2 = new Node(2); SharedPointer\u0026lt;Node\u0026gt; s1(n1), s2(n2); cout \u0026lt;\u0026lt; s1.UseCount() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s2.UseCount() \u0026lt;\u0026lt; endl; s1-\u0026gt;next_ = s2; s2-\u0026gt;prev_ = s1; cout \u0026lt;\u0026lt; s1.UseCount() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s2.UseCount() \u0026lt;\u0026lt; endl; } $ ./bin/smart-pointer SharedPointer::Constructor 0x3f905c # n1-\u0026gt;prev_ SharedPointer::Constructor 0x3f906c # n1-\u0026gt;next_ Node::Constructor 0x3f9058 # n1 SharedPointer::Constructor 0x3f948c # n2-\u0026gt;prev_ SharedPointer::Constructor 0x3f949c # n2-\u0026gt;next_ Node::Constructor 0x3f9488 # n2 SharedPointer::Constructor 0xbeca0658 # s1 SharedPointer::Constructor 0xbeca0648 # s2 1 1 2 2 SharedPointer::Destructor 0xbeca0648 # s2 SharedPointer::Destructor 0xbeca0658 # s1 è¿™é‡Œè™½ç„¶ s1 å’Œ s2 ä¸¤ä¸ª SharedPointer\u0026lt;Node\u0026gt; åœ¨å‡½æ•°é€€å‡ºæ—¶è¢«æˆåŠŸåœ°é”€æ¯äº†ï¼Œä½†å®ƒä»¬æ‰€æŒæœ‰çš„ n1 å’Œ n2 ä¸¤ä¸ªå¯¹è±¡å´æ²¡æœ‰ï¼Œå› ä¸º s1 å’Œ s2 çš„å¼•ç”¨è®¡æ•°éƒ½æ²¡æœ‰å‡å°‘ä¸º 0ï¼Œåªæœ‰å½“ s1-\u0026gt;next_ ä¸å†æŒ‡å‘ s2ï¼Œä¸” s2-\u0026gt;prev_ ä¸å†æŒ‡å‘ s1 æ—¶ï¼Œä¸¤è€…çš„å¼•ç”¨è®¡æ•°æ‰èƒ½å¤Ÿæ­£ç¡®çš„å‡å°‘ä¸º 0ã€‚\n4 weak_ptr std::weak_ptr æ˜¯ä¸€ç§å¼±å¼•ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒå’Œ std::shared_ptr çš„å”¯ä¸€åŒºåˆ«æ˜¯å®ƒå¿…é¡»ç”± std::shared_ptr æˆ– std::weak_ptr æ˜¾å¼è½¬æ¢è€Œæ¥ï¼Œè€Œä¸èƒ½ç”±ä½¿ç”¨ new åˆ›å»ºçš„å¯¹è±¡è¿›è¡Œæ„é€ ï¼Œå› æ­¤å…¶ç®¡ç†çš„èµ„æºå®é™…ä¸Šæ˜¯è¢«å¦ä¸€ä¸ª std::shared_ptr æ‰€æŒæœ‰çš„ï¼Œè€Œå…¶æœ¬èº«åˆ™åªæ˜¯æä¾›äº†å¯¹è¢«ç®¡ç†èµ„æºçš„è®¿é—®èƒ½åŠ›ï¼ŒåŒæ—¶ä¹Ÿä¸å¯¹è¢«ç®¡ç†èµ„æºçš„ç”Ÿå‘½å‘¨æœŸé€ æˆå½±å“ï¼Œå³ä¸ä¼šä¿®æ”¹ std::shared_ptr çš„å¼•ç”¨è®¡æ•°ã€‚\nä¸‹é¢æ˜¯å‚è€ƒ std::weak_ptr å®ç°çš„ WeakPointer ç±»ï¼š\ntemplate\u0026lt;typename ElementType, typename DeleterType\u0026gt; class SharedPointer; template\u0026lt;typename ElementType, typename DeleterType = DefaultDeleter\u0026gt; class WeakPointer { public: // constructors  WeakPointer() noexcept : ptr_(nullptr), ref_count_(nullptr), deleter_(nullptr), mutex_(nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;WeakPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } explicit WeakPointer(SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; sp) noexcept : ptr_(sp.ptr_), ref_count_(sp.ref_count_), deleter_(sp.deleter_), mutex_(sp.mutex_) { std::cout \u0026lt;\u0026lt; \u0026#34;WeakPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // copy-ctor  WeakPointer(WeakPointer\u0026lt;ElementType\u0026gt;\u0026amp; other) noexcept : ptr_(other.ptr_), ref_count_(other.ref_count_), deleter_(other.deleter_), mutex_(other.mutex_) { std::cout \u0026lt;\u0026lt; \u0026#34;WeakPointer::Copy-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // assignment operator  WeakPointer\u0026amp; operator=(SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; sp) { ptr_ = sp.ptr_; ref_count_ = sp.ref_count_; mutex_ = sp.mutex_; deleter_ = sp.deleter_; return *this; } // destructor  ~WeakPointer() noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;WeakPointer::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } void Swap(WeakPointer\u0026amp; other) { std::swap(ptr_, other.ptr_); std::swap(ref_count_, other.ref_count_); std::swap(deleter_, other.deleter_); std::swap(mutex_, other.mutex_); } void Reset() { WeakPointer().Swap(*this); } SharedPointer\u0026lt;ElementType, DeleterType\u0026gt; Lock() const { return Expired() ? SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;() : SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;(*this); } int UseCount() { return *ref_count_; } const DeleterType\u0026amp; GetDeleter() const noexcept { return *deleter_; } bool Expired() const { return *ref_count_ == 0; } ElementType* ptr_; int *ref_count_; DeleterType* deleter_; mutex* mutex_; }; std::weak_ptr ä¸èƒ½æ§åˆ¶è¢«ç®¡ç†èµ„æºçš„ç”Ÿå‘½å‘¨æœŸï¼Œå› æ­¤æˆ‘ä»¬åœ¨ä½¿ç”¨çš„æ—¶å€™éœ€è¦å…ˆåˆ¤æ–­è¢«ç®¡ç†èµ„æºæ˜¯å¦å­˜åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å€ŸåŠ© std::weak_ptr::lock è·å–ä¸€ä¸ªæ–°çš„ std::shared_ptr å¯¹è±¡ä»¥è¾¾åˆ°å®‰å…¨è®¿é—®èµ„æºçš„ç›®çš„ï¼š\nvoid WeakPointerFoo() { Object\u0026lt;string\u0026gt; *o = new Object\u0026lt;string\u0026gt;(\u0026#34;test\u0026#34;); SharedPointer\u0026lt;Object\u0026lt;string\u0026gt;\u0026gt; s(o); WeakPointer\u0026lt;Object\u0026lt;string\u0026gt;\u0026gt; w(s); s.Reset(); auto p = w.Lock().Get(); cout \u0026lt;\u0026lt; w.Expired() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; static_cast\u0026lt;void*\u0026gt;(p) \u0026lt;\u0026lt; endl; } $ ./bin/smart-pointer Object::Constructor 0xf8c058 # o SharedPointer::Constructor 0xbe97a630 # s WeakPointer::Constructor 0xbe97a620 # w SharedPointer::Constructor 0xbe97a608 # temporary variable in s.Reset() SharedPointer::Destructor 0xbe97a608 # temporary variable in s.Reset() Object::Destructor 0xf8c058 # o SharedPointer::Constructor 0xbe97a65c # temporary variable in w.Lock() SharedPointer::Destructor 0xbe97a65c # temporary variable in w.Lock() 1 # w.Expired() 0 # p WeakPointer::Destructor 0xbe97a620 # w SharedPointer::Destructor 0xbe97a630 # s å¦‚æœæŠŠä¸Šé¢çš„ s.Reset() å»æ‰ï¼Œé‚£ä¹ˆ w.Lock() åˆ™ä¼šè¿”å›ä¸€ä¸ªåŒ…å«æœ‰ Object\u0026lt;string\u0026gt; å¯¹è±¡çš„ SharedPointerï¼Œä¸Šé¢çš„ *o ä¹Ÿä¸ä¼šåœ¨ s.Reset() ä¹‹åææ„æ‰ï¼š\nvoid WeakPointerFoo() { Object\u0026lt;string\u0026gt; *o = new Object\u0026lt;string\u0026gt;(\u0026#34;test\u0026#34;); SharedPointer\u0026lt;Object\u0026lt;string\u0026gt;\u0026gt; s(o); WeakPointer\u0026lt;Object\u0026lt;string\u0026gt;\u0026gt; w(s); // s.Reset();  auto p = w.Lock().Get(); cout \u0026lt;\u0026lt; w.Expired() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; static_cast\u0026lt;void*\u0026gt;(p) \u0026lt;\u0026lt; endl; } $ ./bin/smart-pointer Object::Constructor 0xb5c058 # o SharedPointer::Constructor 0xbef4562c # s WeakPointer::Constructor 0xbef4561c # w SharedPointer::Constructor 0xbef45658 # temporary variable in s.Reset() SharedPointer::Destructor 0xbef45658 # temporary variable in s.Reset() 0 # w.Expired() 0xb5c058 # p WeakPointer::Destructor 0xbef4561c # temporary variable in w.Lock() SharedPointer::Destructor 0xbef4562c # # temporary variable in w.Lock() Object::Destructor 0xb5c058 # o å¯¹äºå¾ªç¯å¼•ç”¨çš„é—®é¢˜ï¼Œå°†éœ€è¦äº’ç›¸æŒ‡å‘çš„æ™ºèƒ½æŒ‡é’ˆæ”¹ä¸º WeakPointer åˆ™å¯ä»¥æˆåŠŸé¿å…æŒ‡é’ˆå¯¹è±¡ä¸èƒ½æ­£å¸¸ææ„çš„é—®é¢˜ï¼š\nvoid WeakPointerFoo() { struct Node { int i_; WeakPointer\u0026lt;Node\u0026gt; prev_; WeakPointer\u0026lt;Node\u0026gt; next_; Node(int i) : i_(i) { std::cout \u0026lt;\u0026lt; \u0026#34;Node::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } ~Node() { std::cout \u0026lt;\u0026lt; \u0026#34;Node::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } }; Node *n1 = new Node(1), *n2 = new Node(2); SharedPointer\u0026lt;Node\u0026gt; p1(n1), p2(n2); cout \u0026lt;\u0026lt; p1.UseCount() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p2.UseCount() \u0026lt;\u0026lt; endl; p1-\u0026gt;next_ = p2; p2-\u0026gt;prev_ = p1; cout \u0026lt;\u0026lt; p1.UseCount() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p2.UseCount() \u0026lt;\u0026lt; endl; } $ ./bin/smart-pointer WeakPointer::Constructor 0xb505c # n1-\u0026gt;prev_ WeakPointer::Constructor 0xb506c # n1-\u0026gt;next_ Node::Constructor 0xb5058 # n1 WeakPointer::Constructor 0xb548c # n2-\u0026gt;prev_ WeakPointer::Constructor 0xb549c # n2-\u0026gt;next_ Node::Constructor 0xb5488 # n2 SharedPointer::Constructor 0xbe904658 # s1 SharedPointer::Constructor 0xbe904648 # s2 1 1 1 1 SharedPointer::Destructor 0xbe904648 # s2 Node::Destructor 0xb5488 # n2 WeakPointer::Destructor 0xb549c # n2-\u0026gt;next_ WeakPointer::Destructor 0xb548c # n2-\u0026gt;prev_ SharedPointer::Destructor 0xbe904658 # s1 Node::Destructor 0xb5058 # n1 WeakPointer::Destructor 0xb506c # n1-\u0026gt;next_ WeakPointer::Destructor 0xb505c # n1-\u0026gt;prev_ ","permalink":"http://zintrulcre.github.io/posts/c++/smart-pointer/smart-pointer/","summary":"C++ æ™ºèƒ½æŒ‡é’ˆçš„ç®€å•å®ç° 1 std::auto_ptr C++ ä¸­ç»å¸¸ä¼šå‡ºç°å› ä¸ºæ²¡æœ‰ delete æŒ‡é’ˆè€Œé€ æˆçš„å†…å­˜æ³„æ¼ï¼Œä¾‹å¦‚æœ‰ä¸€ä¸ª Object æ¨¡æ¿ç±»ï¼š\ntemplate\u0026lt;typename T\u0026gt; class Object { public: // constructor  Object() : t_() { cout \u0026lt;\u0026lt; \u0026#34;Object::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } Object(T t) : t_(t) { cout \u0026lt;\u0026lt; \u0026#34;Object::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } // copy-ctor  Object(const Object \u0026amp;other) { cout \u0026lt;\u0026lt; \u0026#34;Object::Copy-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } // destructor  ~Object() { cout \u0026lt;\u0026lt; \u0026#34;Object::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } void Set(T t) { t_ = t; } void Print() { cout \u0026lt;\u0026lt; t_ \u0026lt;\u0026lt; endl; } private: T t_; }; å¦‚æœåœ¨å †ä¸Šä¸ºç±»å¯¹è±¡åˆ†é…äº†å†…å­˜ï¼Œåœ¨ç¦»å¼€å…¶ä½œç”¨åŸŸçš„æ—¶å€™åˆæ²¡å°†å…¶é‡Šæ”¾ï¼Œåˆ™ä¼šé€ æˆå†…å­˜æ³„æ¼ï¼š","title":"C++ æ™ºèƒ½æŒ‡é’ˆçš„ç®€å•å®ç°"},{"content":"å¯å‘å¼æœç´¢å’Œå¼ºåŒ–å­¦ä¹  The Pac-Man Projects æ˜¯ UC Berkeley CS 188 çš„è¯¾ç¨‹é¡¹ç›®ï¼Œæœ¬æ–‡ä»¥è¯¥é¡¹ç›®ä¸ºä¾‹ä»‹ç»å¯å‘å¼æœç´¢å’Œå¼ºåŒ–å­¦ä¹ ã€‚\n1 ç›²ç›®æœç´¢ ç›²ç›®æœç´¢ï¼ˆBlind Searchï¼‰æŒ‡ä¸åˆ©ç”¨ä»»ä½•é¢å¤–ä¿¡æ¯ï¼ˆè¾“å…¥æ•°æ®ï¼Œæˆ–è¾…åŠ©å‡½æ•°ï¼‰ï¼Œåªä¾èµ–äºç®—æ³•æœ¬èº«çš„æœç´¢ï¼Œä¾‹å¦‚ BFSï¼ŒDFSï¼ŒDijkstra ç­‰ï¼›\nDFS The Pac-Man Projects  å·²ç»å®ç°äº†åƒè±†äººæ¸¸æˆçš„åå°é€»è¾‘å’Œå›¾å½¢æ¸²æŸ“æ¡†æ¶ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨ search.py æ–‡ä»¶ä¸­å®ç°å…·ä½“çš„æœç´¢ç®—æ³•ï¼Œå¹¶æ ¹æ®æœç´¢ç®—æ³•ç”Ÿæˆå¯»è·¯è·¯å¾„ï¼Œå³å¯è®©åƒè±†äººç§»åŠ¨ï¼Œå…ˆæ¥å®ç°ä¸€ä¸ªç®€å•çš„ DFSï¼š\ndef DepthFirstSearch(problem): from util import Stack open_list = Stack() visited = [] open_list.push((problem.getStartState(), [])) while not open_list.isEmpty(): current_node, path = open_list.pop() if problem.isGoalState(current_node): return path if current_node in visited: continue visited.append(current_node) for next_node, action, cost in problem.getSuccessors(current_node): if next_node not in visited: open_list.push((next_node, path + [action])) dfs = DepthFirstSearch åœ¨åƒè±†äººæ¸¸æˆçš„æ¡†æ¶ä¸‹ï¼Œä¸ºå¯»è·¯å‡½æ•°ä¼ å…¥çš„ problem å‚æ•°å¯ä»¥ç†è§£ä¸ºä¸€ä¸ª class SearchProblem ç±»å‹çš„æŠ½è±¡åŸºç±»ï¼Œå®é™…çš„é—®é¢˜æœ‰ PositionSearchProblemï¼ˆæ‰¾åˆ°å•ä¸ªç»ˆç‚¹ï¼‰ï¼ŒFoodSearchProblemï¼ˆæ‰¾åˆ°æ‰€æœ‰é£Ÿç‰©ï¼‰ï¼ŒCapsuleSearchProblemï¼ˆæ‰¾åˆ°å¢ç›Šè¯ä¸¸å’Œæ‰€æœ‰é£Ÿç‰©ï¼‰ç­‰ï¼Œè¿™äº›å­ç±»éƒ½éœ€è¦å®ç°ä»¥ä¸‹å‡½æ•°ï¼š\n getStartState()ï¼šè·å–èµ·å§‹çŠ¶æ€ï¼› isGoalState(state)ï¼šåˆ¤æ–­ state èŠ‚ç‚¹æ˜¯å¦æ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼› getSuccessors(statu)ï¼šè·å– state èŠ‚ç‚¹çš„æ‰€æœ‰åç»­èŠ‚ç‚¹ï¼› getCostOfActions(actions)ï¼šactions æ˜¯ä¸€ä¸ªç”±ä¸Šä¸‹å·¦å³æ–¹å‘ç»„æˆçš„ä¸€ä¸ªåŠ¨ä½œåˆ—è¡¨ï¼Œå‡½æ•°è¿”å›è¿™ä¸ªåˆ—è¡¨çš„æ€»èŠ±è´¹ï¼ˆcostï¼‰ï¼›  è¿è¡Œä¸€ä¸‹çœ‹çœ‹ DFS çš„æ•ˆæœï¼š\n$ python pacman.py -l smallEmpty -z 0.8 -p SearchAgent -a fn=dfs [SearchAgent] using function dfs [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 56 in 0.002992 seconds Search nodes expanded: 56 Pacman emerges victorious! Score: 454 Average Score: 454.0 Scores: 454.0 Win Rate: 1/1 (1.00) Record: Win è¿è¡Œçš„å‚æ•°åˆ—è¡¨ä¸­æœ‰å‡ ä¸ªå‚æ•°ï¼š\n -l smallEmptyï¼šåœ¨åä¸º smallEmpty çš„åœ°å›¾ä¸Šè¿è¡Œï¼Œåœ°å›¾å®šä¹‰åœ¨ layouts ç›®å½•ä¸‹ï¼› -z 0.8ï¼šå®¢æˆ·ç«¯è¡¨ç°ç¼©æ”¾ä¸º 0.8 å€ -p SearchAgentï¼šæŒ‡å®šå®é™…çš„é—®é¢˜ï¼Œè¿™é‡Œçš„ SearchAgent æ˜¯ fn='depthFirstSearch', prob='PositionSearchProblem' çš„ç¼©å†™ï¼›  å®é™…è¿è¡Œæ•ˆæœå¦‚ä¸‹ï¼š\nå¯ä»¥çœ‹åˆ°åƒè±†äºº agent ç»•äº†å¾ˆè¿œçš„è·¯æ‰åˆ°è¾¾ç»ˆç‚¹ï¼Œå› ä¸º DFS åœ¨è®¡ç®—å¤æ‚æ€§ç†è®ºä¸­æ˜¯ä¸å®Œå¤‡ï¼ˆcompleteï¼‰ä¸”éæœ€ä¼˜ï¼ˆoptimalityï¼‰çš„ã€‚\nBFS def BreadthFirstSearch(problem): from util import Queue open_list = Queue() visited = set() open_list.push((problem.getStartState(), [])) while not open_list.isEmpty(): current_node, path = open_list.pop() if problem.isGoalState(current_node): return path if current_node in visited: continue visited.add(current_node) for next_node, action, cost in problem.getSuccessors(current_node): if next_node not in visited: open_list.push((next_node, path + [action])) bfs = BreadthFirstSearch BFS çš„è¿è¡Œæ•ˆæœå¦‚ä¸‹ï¼š\n$ python pacman.py -l smallEmpty -z 0.8 -p SearchAgent -a fn=bfs [SearchAgent] using function bfs [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 14 in 0.001995 seconds Search nodes expanded: 63 Pacman emerges victorious! Score: 496 Average Score: 496.0 Scores: 496.0 Win Rate: 1/1 (1.00) Record: Win å¯ä»¥çœ‹åˆ°ä½¿ç”¨ BFS çš„ agent é€šè¿‡æœ€çŸ­è·¯å¾„åˆ°è¾¾äº†ç»ˆç‚¹ï¼Œå› ä¸º BFS æ˜¯å®Œå¤‡ä¸”æœ€ä¼˜çš„ã€‚\nIterative Deepening Search IDS çš„æ€è·¯æ˜¯é‡å¤è¿›è¡Œé™åˆ¶å±‚æ•°çš„ DFS æ¥æ‰¾åˆ°æœ€ä¼˜è§£ï¼Œå®ƒç»¼åˆäº† DFS çš„ä¼˜ç‚¹ï¼ˆç©ºé—´å¤æ‚åº¦ï¼‰å’Œ BFS çš„ä¼˜ç‚¹ï¼ˆå®Œå¤‡ä¸”æœ€ä¼˜ï¼‰ï¼Œä½†æ˜¯åœ¨æ—¶é—´å¤æ‚åº¦ä¸Šè¡¨ç°æ¯”è¾ƒå·®ï¼ˆå¯ä»¥å‚è€ƒè¾“å‡ºç»“æœä¸­çš„ Search nodes expandedï¼‰ï¼š\ndef IterativeDeepeningSearch(problem): import sys from util import Stack def depthLimitSearch(problem, depth): visited = [] open_list = Stack() open_list.push((problem.getStartState(), [], visited)) while not open_list.isEmpty(): current_node, path, visited = open_list.pop() if problem.isGoalState(current_node): return path if len(path) == depth or depth == 0: continue if current_node in visited: continue actions = problem.getSuccessors(current_node) for next_node, action, cost in actions: if next_node not in visited: open_list.push((next_node, path + [action], visited+[current_node])) for depth in range(sys.maxsize**10): path = depthLimitSearch(problem, depth) if path: return path ids = IterativeDeepeningSearch è¿™ä¸ªç®—æ³•å¯¹äºåªæœ‰å°é¢ç§¯å¯æœç´¢ç©ºé—´çš„åœ°å›¾æ•ˆæœæ¯”è¾ƒå¥½ï¼š\n$ python pacman.py -l smallMaze -z 0.8 -p SearchAgent -a fn=ids [SearchAgent] using function ids [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 19 in 0.008976 seconds Search nodes expanded: 923 Pacman emerges victorious! Score: 491 Average Score: 491.0 Scores: 491.0 Win Rate: 1/1 (1.00) Record: Win ä½†æ˜¯å¯¹äºæ‹¥æœ‰å¤§é¢ç§¯å¯æœç´¢ç©ºé—´çš„åœ°å›¾ï¼Œæœç´¢æ—¶é—´ä¼šéå¸¸é•¿ï¼š\n$ python pacman.py -l smallEmpty -z 0.8 -p SearchAgent -a fn=ids [SearchAgent] using function ids [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 14 in 0.710854 seconds Search nodes expanded: 94552 Pacman emerges victorious! Score: 496 Average Score: 496.0 Scores: 496.0 Win Rate: 1/1 (1.00) Record: Win Uniform Cost Search UCS å’Œ Dijkstra ç±»ä¼¼ï¼Œç”¨ä¸€ä¸ªå°æ ¹å †ä¿å­˜å½“å‰èŠ‚ç‚¹åˆ°èµ·å§‹èŠ‚ç‚¹çš„è·ç¦»ï¼Œä¾æ¬¡å±•å¼€è·¯å¾„èŠ±è´¹æœ€å°çš„èŠ‚ç‚¹ï¼Œç›´åˆ°æ‰¾åˆ°ç»ˆç‚¹ä¸ºæ­¢ï¼Œè€Œä¸€èˆ¬æ¥è¯´ Dijkstra æ²¡æœ‰ä¸€ä¸ªå›ºå®šçš„ç»ˆç‚¹ï¼š\ndef UniformCostSearch(problem): from util import PriorityQueue frontier = PriorityQueue() visited = [] frontier.push((problem.getStartState(), [], 0), 0) while not frontier.isEmpty(): current_node, path, current_cost = frontier.pop() if problem.isGoalState(current_node): return path if current_node in visited: continue visited.append(current_node) for next_node, action, cost in problem.getSuccessors(current_node): if next_node not in visited: frontier.push((next_node, path + [action], current_cost + cost), current_cost + cost) ucs = UniformCostSearch $ python pacman.py -l smallEmpty -z 0.8 -p SearchAgent -a fn=ucs [SearchAgent] using function ucs [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 14 in 0.002992 seconds Search nodes expanded: 63 Pacman emerges victorious! Score: 496 Average Score: 496.0 Scores: 496.0 Win Rate: 1/1 (1.00) Record: Win 2 å¯å‘å¼æœç´¢ ä¼ ç»Ÿçš„ç›²ç›®æœç´¢ç®—æ³•å› ä¸ºå—åˆ¶äºå®Œå¤‡æ€§ã€æœ€ä¼˜æ€§ã€æ—¶é—´ã€ç©ºé—´å¤æ‚åº¦ç­‰å› ç´ ï¼Œåœ¨å®é™…çš„åº”ç”¨ä¸­å¾ˆå°‘è¢«ä½¿ç”¨ï¼›è€Œåœ¨è·¯å¾„è§„åˆ’ï¼Œæœ€ä¼˜åŒ–ç®—æ³•å’Œäººå·¥æ™ºèƒ½é¢†åŸŸï¼Œä½¿ç”¨å¯å‘å¼æœç´¢ï¼ˆHeuristic Searchï¼‰èƒ½å¤Ÿæ›´å¥½åœ°åœ¨å‡†ç¡®æ€§å’Œè®¡ç®—é€Ÿåº¦ä¹‹é—´å–å¾—å¹³è¡¡ã€‚\nå¯å‘å¼æœç´¢ Heuristic Search åˆå«åšæœ‰ä¿¡æ¯æœç´¢ Informed Searchï¼Œå¯å‘å¼æœç´¢ä¸åŒäºç›²ç›®æœç´¢çš„åœ°æ–¹æœ‰ä¸¤ç‚¹ï¼šä¸€æ˜¯å¯å‘å¼æœç´¢ä¾èµ–äºå¯å‘å‡½æ•°ï¼Œå¯å‘å‡½æ•° Heuristic Function æ˜¯ç”¨äºä¼°è®¡å½“å‰èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹è·ç¦»çš„ä¸€ç±»å‡½æ•°ï¼›äºŒæ˜¯å®ƒéœ€è¦åˆ©ç”¨è¾“å…¥æ•°æ®å¹¶å°†å…¶ä½œä¸ºå¯å‘å‡½æ•°çš„å‚æ•°ï¼Œä»¥è¡¡é‡å½“å‰ä½ç½®åˆ°ç›®æ ‡ä½ç½®çš„è·ç¦»å…³ç³»ã€‚\nå¯å‘å¼æœç´¢é€šè¿‡è¡¡é‡å½“å‰ä½ç½®åˆ°ç›®æ ‡ä½ç½®çš„è·ç¦»å…³ç³»ï¼Œä½¿å¾—æœç´¢è¿‡ç¨‹çš„ç§»åŠ¨æ–¹å‘ä¼˜å…ˆæœå‘ç›®æ ‡ä½ç½®æ›´è¿‘çš„æ–¹å‘å‰è¿›ï¼Œä»¥æé«˜æœç´¢æ•ˆç‡ã€‚\nå¯å‘å‡½æ•° å¯å‘å‡½æ•° h(n) ç”¨äºç»™å‡ºä»ç‰¹å®šèŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·ç¦»çš„ä¼°è®¡å€¼ï¼ˆè€Œä¸æ˜¯çœŸå®å€¼ï¼‰ï¼›è®¸å¤šå¯»è·¯é—®é¢˜éƒ½æ˜¯ NP å®Œå¤‡ï¼ˆNP-completenessï¼‰çš„ï¼Œå› æ­¤åœ¨æœ€åæƒ…å†µä¸‹å®ƒä»¬çš„ç®—æ³•æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯æŒ‡æ•°çº§çš„ï¼›æ‰¾åˆ°ä¸€ä¸ªå¥½çš„å¯å‘å‡½æ•°å¯ä»¥æ›´é«˜æ•ˆåœ°å¾—åˆ°ä¸€ä¸ªæ›´ä¼˜çš„è§£ï¼›å¯å‘å‡½æ•°ç®—æ³•çš„ä¼˜åŠ£ç›´æ¥å†³å®šäº†å¯å‘å¼æœç´¢çš„æ•ˆç‡ã€‚\næœ€ç®€å•çš„å¯å‘å‡½æ•°æœ‰ï¼š\n null heuristicï¼šä¼°è®¡å€¼å§‹ç»ˆç­‰äº 0ï¼Œç›¸å½“äºé€€åŒ–æˆäº† UCSï¼ˆåªè®¡ç®—å½“å‰èŠ‚ç‚¹åˆ°èµ·å§‹èŠ‚ç‚¹çš„è·ç¦»ï¼‰ï¼› æ›¼å“ˆé¡¿è·ç¦»ï¼šä¸¤ç‚¹åœ¨å—åŒ—æ–¹å‘ä¸Šçš„è·ç¦»åŠ ä¸Šåœ¨ä¸œè¥¿æ–¹å‘ä¸Šçš„è·ç¦»ï¼Œå³ abs(a âˆ’ x) + abs(b âˆ’ y)ï¼› æ¬§å‡ é‡Œå¾—è·ç¦»ï¼šä¸¤ç‚¹åœ¨æ¬§æ°ç©ºé—´ä¸­çš„ç›´çº¿è·ç¦»ï¼Œå³ sqrt((a - x) ^ 2 + (b - y) ^ 2)ï¼›  A* A* æ˜¯ä¸€ç§åº”ç”¨å¾ˆå¹¿æ³›çš„å¯å‘å¼æœç´¢ç®—æ³•ï¼Œå…¶ä¸»è¦æ€è·¯ä¸ Dijkstra å’Œ UCS ç±»ä¼¼ï¼Œéƒ½æ˜¯åˆ©ç”¨ä¸€ä¸ªå°æ ¹å †ï¼Œä¸æ–­åœ°å–å‡ºå †é¡¶èŠ‚ç‚¹å¹¶åˆ¤æ–­å…¶æ˜¯å¦æ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼Œä¸åŒçš„æ˜¯å®ƒä¼šä¸ºæ¯ä¸€ä¸ªå·²çŸ¥èŠ‚ç‚¹è®¡ç®—å‡ºä»èµ·ç‚¹å’Œç»ˆç‚¹çš„è·ç¦»ä¹‹å’Œ f(x) = g(x) + h(x)ï¼Œå…¶ä¸­ g(x) æ˜¯ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„å®é™…è·ç¦»ï¼Œh(x) æ˜¯ä½¿ç”¨å¯å‘å‡½æ•°è®¡ç®—å¾—åˆ°çš„ä»å½“å‰èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„ä¼°è®¡è·ç¦»ï¼š\ndef AStarSearch(problem, heuristic=nullHeuristic): from util import PriorityQueueWithFunction def AStarHeuristic(item): state, _, cost = item h = heuristic(state, problem=problem) g = cost return g + h frontier = PriorityQueueWithFunction(AStarHeuristic) visited = [] frontier.push((problem.getStartState(),[], 0)) while not frontier.isEmpty(): currentNode, path, currentCost = frontier.pop() if problem.isGoalState(currentNode): return path if currentNode not in visited: visited.append(currentNode) for nextNode, action, cost in problem.getSuccessors(currentNode): if nextNode not in visited: frontier.push((nextNode, path + [action], currentCost + cost)) astar = AStarSearch å¯¹äºå¤šèŠ‚ç‚¹çš„æœç´¢é—®é¢˜ï¼Œéœ€è¦ç»¼åˆè€ƒè™‘æ‰€æœ‰ç›®æ ‡èŠ‚ç‚¹å¯¹äºå½“å‰èŠ‚ç‚¹çš„å½±å“ï¼›æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è´ªå¿ƒçš„æ€æƒ³ï¼Œè®©åƒè±†äººä¼˜å…ˆé è¿‘è·ç¦»è¾ƒè¿‘çš„è±†å­ï¼Œä¹Ÿå°±æ˜¯ä½¿å¾—è·ç¦»å½“å‰èŠ‚ç‚¹æ›´è¿‘çš„ç›®æ ‡èŠ‚ç‚¹çš„å¯å‘å‡½æ•°å€¼æ›´å°ï¼Œè¿™æ ·è·ç¦»åƒè±†äººæ›´è¿‘çš„è±†å­å°±ä¼šæ›´æœ‰å¯èƒ½å…·æœ‰æ›´å°çš„ f(x) å€¼ï¼›åœ¨ä¸ºå¯å‘å‡½æ•°ä¼ å…¥çš„å‚æ•°ä¸­ï¼Œ state æ˜¯ä¸€ä¸ªåŒ…å«å½“å‰ä½ç½® position å’Œæ‰€æœ‰ç›®æ ‡ç‚¹ä¿¡æ¯ç»“æ„ grid çš„äºŒå…ƒç»„ï¼Œå¯ä»¥ä½¿ç”¨ grid.asList() å°†æ‰€æœ‰ç›®æ ‡ç‚¹è½¬æ¢ä¸ºä¸€ä¸ªæ•°ç»„ï¼š\ndef FoodHeuristic(state, problem): position, food_grid = state food_gridList = food_grid if isinstance(food_grid, list) else food_grid.asList() from util import manhattanDistance minx, miny = position maxx, maxy = position for food in food_gridList: foodx, foody = food minx = min(foodx,minx) maxx = max(foodx,maxx) miny = min(foody,miny) maxy = max(foody,maxy) return abs(minx-maxx) + abs(miny-maxy) $ python pacman.py -l tinySearch -p SearchAgent -a fn=astar,prob=FoodSearchProblem,heuristic=FoodHeuristic [SearchAgent] using function astar and heuristic foodHeuristic [SearchAgent] using problem type FoodSearchProblem Path found with total cost of 27 in 0.294214 seconds Search nodes expanded: 1544 Pacman emerges victorious! Score: 573 Average Score: 573.0 Scores: 573.0 Win Rate: 1/1 (1.00) Record: Win æ¢ä¸ªåœ°å›¾çœ‹çœ‹æ•ˆæœï¼š\n$ python pacman.py -l mediumDottedMaze -p SearchAgent -a fn=astar,prob=FoodSearchProblem,heuristic=FoodHeuristic [SearchAgent] using function astar and heuristic foodHeuristic [SearchAgent] using problem type FoodSearchProblem Path found with total cost of 74 in 0.091756 seconds Search nodes expanded: 389 Pacman emerges victorious! Score: 646 Average Score: 646.0 Scores: 646.0 Win Rate: 1/1 (1.00) Record: Win ç›¸æ¯”ä¹‹ä¸‹ï¼Œå¦‚æœä½¿ç”¨ nullHeuristicï¼ˆé€€åŒ–ä¸º UCSï¼‰çš„è¯æœç´¢èŠ±è´¹çš„æ—¶é—´åˆ™ä¼šé•¿å¾ˆå¤šï¼š\n$ python pacman.py -l tinySearch -p SearchAgent -a fn=ucs,prob=FoodSearchProblem [SearchAgent] using function ucs [SearchAgent] using problem type FoodSearchProblem Path found with total cost of 27 in 2.880744 seconds Search nodes expanded: 5057 Pacman emerges victorious! Score: 573 Average Score: 573.0 Scores: 573.0 Win Rate: 1/1 (1.00) Record: Win 3 å¼ºåŒ–å­¦ä¹  å¼ºåŒ–å­¦ä¹  å¼ºåŒ–å­¦ä¹ æ˜¯æŒ‡é€šè¿‡ä¸ç¯å¢ƒè¿›è¡Œäº¤äº’å’Œåé¦ˆæ¥å­¦ä¹ ä¸€ç§ç­–ç•¥çš„è¿‡ç¨‹ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œä¸€ä¸ªå¼ºåŒ–å­¦ä¹ çš„å®ä½“ agent é€šè¿‡ä¸ç¯å¢ƒ Environment è¿›è¡Œäº¤äº’å¹¶é‡‡å–ä¸€ç³»åˆ—è¡Œä¸º Action æ¥è·å¾—ä¸€å®šçš„æ”¶ç›Š Rewardï¼Œä»è€Œæ›´æ–°é‡‡å–ç›¸åº”è¡Œä¸ºçš„æƒé‡ã€‚\nå¼ºåŒ–å­¦ä¹ çš„ç›®æ ‡æ˜¯é€šè¿‡å­¦ä¹ å¾—åˆ°æŸä¸ªç­–ç•¥ Policyï¼Œä½¿å¾— agent ä» environment ä¸­è·å¾—çš„é•¿æœŸæ”¶ç›Šæœ€å¤§åŒ–ï¼Œå› æ­¤åœ¨ä¸€èˆ¬çš„é—®é¢˜ä¸­ï¼Œåœ¨æ²¡æœ‰è¾¾åˆ°æœ€ç»ˆçš„ç›®çš„å‰ï¼Œreward é€šå¸¸éƒ½æ˜¯è´Ÿæ•°ï¼ˆéšæ—¶é—´çš„å¢åŠ è€Œå‡å°‘ï¼‰ï¼Œè€Œä»…åœ¨è¾¾åˆ°æœ€ç»ˆçš„ç›®çš„æ—¶è·å¾—è¾ƒå¤§çš„æ­£åé¦ˆï¼Œè¿™æ ·çš„å­¦ä¹ ä»»åŠ¡é€šå¸¸ç§°ä¸º episodic taskï¼ˆä¾‹å¦‚åƒè±†äººæ¸¸æˆä¸­çš„å•èŠ‚ç‚¹æœç´¢é—®é¢˜ï¼‰ï¼›åœ¨å¦ä¸€ç±»é—®é¢˜ä¸­ï¼Œå¯èƒ½éœ€è¦å®Œæˆå¤šä¸ªç›®æ ‡æ‰èƒ½åˆ°è¾¾æœ€ç»ˆçŠ¶æ€ï¼Œå…¶ reward ç¦»æ•£åœ°åˆ†å¸ƒåœ¨ä¸€ä¸ªè¿ç»­çš„ç©ºé—´ä¸­ï¼Œè¿™ä¸€ç±»ä»»åŠ¡ç§°ä¸º continuing taskï¼ˆä¾‹å¦‚åƒè±†äººæ¸¸æˆä¸­çš„å¤šèŠ‚ç‚¹æœç´¢é—®é¢˜ï¼‰ï¼Œå¯¹äº continuing taskï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰å…¶ reward ä¸ºï¼š\nå…¶ä¸­ Î³ æ˜¯è¡°å‡ç‡ï¼ˆdiscount factorï¼‰ï¼Œè¡°å‡ç‡å¯ä»¥ä½¿å¾—æˆ‘ä»¬æ›´åŠ åå¥½è¿‘æœŸæ”¶ç›Šï¼›å¼•å…¥è¡°å‡ç³»æ•°çš„ç†ç”±æœ‰å¾ˆå¤šï¼Œä¾‹å¦‚é¿å…é™·å…¥æ— é™å¾ªç¯ï¼Œé™ä½è¿œæœŸåˆ©ç›Šçš„ä¸ç¡®å®šæ€§ï¼Œæœ€å¤§åŒ–è¿‘æœŸåˆ©ç›Šï¼Œåˆ©ç”¨è¿‘æœŸåˆ©ç›Šäº§ç”Ÿæ–°çš„åˆ©ç›Šå› è€Œå…¶æ›´æœ‰ä»·å€¼ç­‰ç­‰ã€‚\nè€Œå¼ºåŒ–å­¦ä¹ çš„ç»“æœæ˜¯å°±æ˜¯ Gtï¼Œé€šè¿‡ argmax å–å¾—çš„å€¼èƒ½å¤Ÿç»™å‡ºåœ¨æ¯ä¸ªçŠ¶æ€ä¸‹æˆ‘ä»¬åº”è¯¥é‡‡å–çš„è¡ŒåŠ¨ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ªç­–ç•¥è®°åš Ï€(a|s)ï¼Œå®ƒè¡¨ç¤ºåœ¨çŠ¶æ€ s ä¸‹é‡‡å–è¡ŒåŠ¨ a çš„æ¦‚ç‡ã€‚\né©¬å°”ç§‘å¤«å†³ç­–è¿‡ç¨‹ é©¬å°”ç§‘å¤«å†³ç­–è¿‡ç¨‹ï¼ˆMarkov Decision Process, MDPï¼‰æ˜¯æŒ‡åœ¨æ¯ä¸ªçŠ¶æ€ä¸‹ï¼Œagent å¯¹äºè¡ŒåŠ¨ a çš„é€‰å–åªä¾èµ–äºå½“å‰çš„çŠ¶æ€ï¼Œä¸ä»»ä½•ä¹‹å‰çš„è¡Œä¸ºéƒ½æ²¡æœ‰å…³ç³»ï¼›å‡ ä¹æ‰€æœ‰çš„å¼ºåŒ–å­¦ä¹ é—®é¢˜éƒ½å¯ä»¥ä½¿ç”¨ MDP è§£å†³ï¼Œä¸€ä¸ªæ ‡å‡†çš„é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹ç”±ä¸€ä¸ªå››å…ƒç»„ç»„æˆï¼š\n Sï¼šStateï¼ŒçŠ¶æ€ç©ºé—´çš„é›†åˆï¼ŒS0 è¡¨ç¤ºåˆå§‹çŠ¶æ€ï¼› Aï¼šActionï¼Œè¡Œä¸ºç©ºé—´çš„é›†åˆï¼ŒåŒ…å«æ¯ä¸ªçŠ¶æ€å¯ä»¥è¿›è¡Œçš„åŠ¨ä½œï¼› r(s' | s, a)ï¼šRewardï¼Œåœ¨ s çŠ¶æ€ä¸‹ï¼Œè¿›è¡Œ a æ“ä½œå¹¶è½¬ç§»åˆ° sâ€˜ çŠ¶æ€ä¸‹çš„å¥–åŠ±ï¼› P(s' | s, a)ï¼šProbabilityï¼Œåœ¨ s çŠ¶æ€ä¸‹ï¼Œè¿›è¡Œ a æ“ä½œå¹¶è½¬ç§»åˆ° sâ€˜ çŠ¶æ€ä¸‹çš„æ¦‚ç‡ï¼›  æ±‚è§£ MDP é—®é¢˜çš„å¸¸è§æ–¹æ³•æœ‰ Value iterationï¼ŒPolicy iterationï¼ŒQ-Learningï¼ŒDeep Q-Learning Network ç­‰ç­‰ã€‚\nValue Iteration Value Iteration æ˜¯ä¸€ç§åŸºäºæ¨¡å‹çš„ï¼ˆmodel-basedï¼‰ç®—æ³•ï¼Œä½¿ç”¨ Value Iteration æ¥è§£å†³ MDP é—®é¢˜çš„å‰ææ˜¯æˆ‘ä»¬çŸ¥é“å…³äºæ¨¡å‹çš„æ‰€æœ‰ä¿¡æ¯ï¼Œå³ MDP å››å…ƒç»„çš„æ‰€æœ‰å†…å®¹ã€‚\nå‡è®¾ç°åœ¨æœ‰ä¸€ä¸ª 3*4 å«åš GridWorld çš„åœ°å›¾å¦‚å›¾æ‰€ç¤ºï¼Œä»¥å·¦ä¸‹è§’æ ¼å­ä¸º (0, 0) åŸç‚¹ï¼Œå…¶ä¸­ (1, 1) ä¸ºä¸å¯é€šè¿‡çš„å¢™ï¼Œ(2, 3) ä¸ºå¥–åŠ±ä¸º +1 çš„ç»ˆç‚¹ï¼Œ(1, 3) ä¸º -1 çš„ç»ˆç‚¹ï¼›æˆ‘ä»¬å®šä¹‰æ¯ä¸€ä¸ªä½ç½®çš„ä»·å€¼ä¸º V(state)ï¼Œå³å¯¹äº state(x, y)ï¼ŒV(state) è¡¨ç¤ºå…¶èƒ½è·å–çš„æœ€å¤§ä»·å€¼ï¼›æ¯ä¸€ä¸ªä½ç½®åˆå§‹åŒ–æ—¶å…¶ value å‡ä¸º 0ï¼š\nåœ¨è¿­ä»£è¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨è´å°”æ›¼æ–¹ç¨‹ï¼ˆBellman Equationï¼‰æ›´æ–°æ‰€æœ‰ä½ç½®çš„ valueï¼Œå®ƒæè¿°äº†æœ€ä½³ç­–ç•¥å¿…é¡»æ»¡è¶³çš„æ¡ä»¶ï¼Œå‰åŠéƒ¨åˆ† r(s, a, s') ä»£è¡¨é‡‡å–äº† a è¡Œä¸ºä¹‹åå¾—åˆ°çš„ rewardï¼ŒååŠéƒ¨åˆ†ï¼›æˆ‘ä»¬éœ€è¦åœ¨æ¯è½®è¿­ä»£ä¸­è®¡ç®—æ¯ä¸ªçŠ¶æ€çš„ä»·å€¼å³ V(s)ï¼Œç›´åˆ°ä¸¤æ¬¡è¿­ä»£ç»“æœçš„å·®å€¼å°äºç»™å®šçš„é˜ˆå€¼æ‰èƒ½è®¤ä¸ºå…¶æ”¶æ•›äº†ï¼Œè¿™é‡Œçš„ V(s) ä¹Ÿå«åš q-valueï¼š\nç»è¿‡å‰ä¸‰æ¬¡è¿­ä»£åˆ†åˆ«å¾—åˆ°ï¼š\næ”¶æ•›é€Ÿåº¦æ˜¯æŒ‡æ•°çº§ï¼Œå¹¶ä¸”éšç€è¿­ä»£çš„ä¸æ–­è¿›è¡Œï¼Œç»ˆå°†å¾—åˆ°æœ€ä¼˜çš„ V(s)ï¼›æˆ–è€…è¯´å½“è¿­ä»£æ¬¡æ•°è¶‹è¿‘äºæ— ç©·å¤§çš„æ—¶å€™ï¼Œå°†å¾—åˆ° V(s) çš„æœ€ä¼˜è§£ï¼›ç»è¿‡ 100 æ¬¡è¿­ä»£åå°†å¾—åˆ°ï¼š\nå– argmax å³å¯å¾—åˆ°æœ€ä¼˜çš„ç­–ç•¥ï¼ˆå³ä¸Šå›¾ä¸­çš„å°ç®­å¤´ï¼‰ï¼›ä¹Ÿå¯ä»¥çœ‹åˆ°é‡‡å–æ¯ä¸€ç§è¡ŒåŠ¨å¯¹åº”çš„ Probailityï¼š\nè¿›è¡Œ Value Iteration çš„æµç¨‹ä¸»è¦å¯¹åº” runValueIteration å’Œ computeQValueFromValues ä¸¤ä¸ªå‡½æ•°ï¼Œè¿­ä»£ç»“æŸåé€‰æ‹©ç­–ç•¥åˆ™å¯¹åº” computeActionFromValues å‡½æ•°ï¼š\n# valueIterationAgents.py class ValueIterationAgent(ValueEstimationAgent): \u0026#34;\u0026#34;\u0026#34; A ValueIterationAgent takes a Markov decision process (see mdp.py) on initialization and runs value iteration for a given number of iterations using the supplied discount factor. \u0026#34;\u0026#34;\u0026#34; def __init__(self, mdp, discount = 0.9, iterations = 100): \u0026#34;\u0026#34;\u0026#34; Some useful mdp methods you will use: mdp.getStates() mdp.getPossibleActions(state) mdp.getTransitionStatesAndProbs(state, action) mdp.getReward(state, action, nextState) mdp.isTerminal(state) \u0026#34;\u0026#34;\u0026#34; self.mdp = mdp self.discount = discount self.iterations = iterations self.values = util.Counter() # A Counter is a dict with default 0 self.runValueIteration() def runValueIteration(self): for _ in np.arange(0, self.iterations): next_values = util.Counter() for state in self.mdp.getStates(): if self.mdp.isTerminal(state): continue q_values = util.Counter() for action in self.mdp.getPossibleActions(state): q_values[action] = self.computeQValueFromValues(state, action) key_max_value = q_values.argMax() next_values[state] = q_values[key_max_value] self.values = next_values def getValue(self, state): return self.values[state] def computeQValueFromValues(self, state, action): \u0026#34;\u0026#34;\u0026#34; Compute the Q-value of action in state from the value function stored in self.values. \u0026#34;\u0026#34;\u0026#34; next_states_probs = self.mdp.getTransitionStatesAndProbs(state, action) q_value = 0 for (next_state, next_state_prob) in next_states_probs: q_value += next_state_prob * (self.mdp.getReward(state, action, next_state) + self.discount * self.values[next_state]) return q_value def computeActionFromValues(self, state): \u0026#34;\u0026#34;\u0026#34; The policy is the best action in the given state according to the values currently stored in self.values. You may break ties any way you see fit. Note that if there are no legal actions, which is the case at the terminal state, you should return None. \u0026#34;\u0026#34;\u0026#34; if self.mdp.isTerminal(state): return None actions = self.mdp.getPossibleActions(state) values = util.Counter() for action in actions: values[action] = self.computeQValueFromValues(state, action) policy = values.argMax() return policy def getPolicy(self, state): return self.computeActionFromValues(state) def getAction(self, state): \u0026#34;Returns the policy at the state (no exploration).\u0026#34; return self.computeActionFromValues(state) def getQValue(self, state, action): return self.computeQValueFromValues(state, action) Q-Learning Q-Learning çš„æ€è·¯ä¸ Value Iteration æœ‰ä¸€äº›ç±»ä¼¼ï¼Œä½†å®ƒæ˜¯ä¸€ç§æ¨¡å‹æ— å…³çš„ï¼ˆmodel-freeï¼‰ç®—æ³•ï¼Œä½¿ç”¨ Q-Learning çš„æ—¶å€™æˆ‘ä»¬çš„ agent æ— éœ€äº‹å…ˆçŸ¥é“å½“å‰ç¯å¢ƒä¸­çš„ Stateï¼ŒAction ç­‰ MDP å››å…ƒç»„å†…å®¹ï¼Œ\nåœ¨ä½¿ç”¨ Value Ietration çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ¯ä¸€ä¸ª episode å¯¹æ‰€æœ‰çš„ State å’Œ Action è¿›è¡Œæ›´æ–°ï¼Œä½†åœ¨å®é™…é—®é¢˜ä¸­ State çš„æ•°é‡å¯èƒ½éå¸¸å¤šä»¥è‡´äºæˆ‘ä»¬ä¸å¯èƒ½éå†å®Œæ‰€æœ‰çš„çŠ¶æ€ï¼Œè¿™æ—¶å€™æˆ‘ä»¬å¯ä»¥å€ŸåŠ© Q-Learningï¼Œåœ¨å¯¹äºç¯å¢ƒæœªçŸ¥çš„å‰æä¸‹ï¼Œä¸æ–­åœ°ä¸ç¯å¢ƒè¿›è¡Œäº¤äº’å’Œæ¢ç´¢ï¼Œè®¡ç®—å‡ºæœ‰é™çš„ç¯å¢ƒæ ·æœ¬ä¸­ Q-Valueï¼Œå¹¶ç»´æŠ¤ä¸€ä¸ª Q-Tableï¼š\n   S r(s' | s, action 1) r(s' | s, action 2) \u0026hellip;     S1 (0, 0) 3 -1    S2 (0, 1) -2 4    \u0026hellip;       åœ¨åˆšå¼€å§‹æ—¶ï¼Œagent å¯¹äºç¯å¢ƒä¸€æ— æ‰€çŸ¥ï¼Œå› æ­¤ Q-Table åº”è¯¥è¢«åˆå§‹åŒ–ä¸ºä¸€ä¸ªé›¶çŸ©é˜µï¼›å½“æˆ‘ä»¬å¤„äºæŸä¸ªçŠ¶æ€ s ï¼ˆä¾‹å¦‚è¡¨é‡Œçš„ S1ï¼‰æ—¶ï¼Œæ ¹æ® Q-Table ä¸­å½“å‰çš„æœ€ä¼˜å€¼å’Œä¸€å®šçš„ç­–ç•¥ï¼ˆMulti-armed bandit é—®é¢˜ï¼Œåˆ©ç”¨ Îµ-greedyï¼ŒUCB ç­‰è§£å†³ï¼‰é€‰æ‹©å¯¹åº”çš„åŠ¨ä½œ a ï¼ˆå‡è®¾é€‰æ‹©äº†è¡¨é‡Œçš„ action 1ï¼Œå¯¹åº” r = 3ï¼‰è¿›è¡Œæ¢ç´¢ï¼Œå¹¶æ ¹æ®è·å¾—çš„å³æ—¶å¥–åŠ± r æ¥æ›´æ–°å¥–åŠ±ï¼Œè¿™é‡Œçš„ r åªæ˜¯å³æ—¶è·å¾—çš„å¥–åŠ±ï¼ˆr = 3ï¼‰ï¼Œå› ä¸ºè¿˜è¦è€ƒè™‘æ‰€è½¬ç§»åˆ°çš„çŠ¶æ€ s' ï¼ˆè¡¨é‡Œçš„ S2ï¼‰åœ¨æœªæ¥å¯èƒ½ä¼šè·å–åˆ°çš„æœ€å¤§å¥–åŠ±ï¼ˆr' = 4ï¼‰ï¼›\nçœŸæ­£çš„å¥–åŠ± Q(St, At) ç”±å…¬å¼ä¸­çš„ä¸¤éƒ¨åˆ†ç»„æˆï¼Œå‰åŠéƒ¨åˆ† r æ˜¯é€šè¿‡åŠ¨ä½œ a å³æ—¶è·å¾—çš„å¥–åŠ±ï¼ˆr = 3ï¼‰ï¼ŒååŠéƒ¨åˆ† Î³ * max(a')Q(s', a') æ˜¯å¯¹æœªæ¥è¡Œä¸ºçš„æœ€å¤§æœŸæœ›å¥–åŠ±ï¼ˆr' = 4ï¼‰ï¼Œä¸”ååŠéƒ¨åˆ†å¾€å¾€æ˜¯ä¸ç¡®å®šçš„ï¼Œå› æ­¤éœ€è¦ä¹˜ä»¥è¡°å‡ç‡ Î³ï¼š\nåœ¨é€šè¿‡è®¡ç®—å¾—åˆ°å½“å‰è¡Œä¸ºæ‰€èƒ½è·å¾—çš„é¢„æœŸå¥–åŠ±åï¼Œå°†å…¶å‡å»è¡¨ä¸­å¯¹å½“å‰ç¯å¢ƒçš„ä¼°è®¡å¥–åŠ± Q(s,a)ï¼ˆr = 3ï¼‰ï¼Œå†ä¹˜ä»¥å­¦ä¹ ç‡ï¼Œå°±èƒ½ç”¨æ¥æ›´æ–° Q-Table ä¸­çš„å€¼äº†ã€‚\nagent ä¸æ–­åœ°ä¸ç¯å¢ƒè¿›è¡Œæ¢ç´¢å¹¶å‘ç”ŸçŠ¶æ€è½¬æ¢ï¼Œç›´åˆ°åˆ°è¾¾ç›®æ ‡ï¼›æˆ‘ä»¬å°† agent çš„æ¯ä¸€è½®æ¢ç´¢ï¼ˆä»ä»»æ„èµ·å§‹çŠ¶æ€å‡ºå‘ï¼Œç»å†è‹¥å¹²ä¸ª actionï¼Œç›´åˆ°åˆ°è¾¾ç›®æ ‡çŠ¶æ€ï¼‰ç§°ä¸ºä¸€ä¸ª episodeï¼›åœ¨è¿›è¡ŒæŒ‡å®š episode æ¬¡æ•°çš„è®­ç»ƒä¹‹åï¼Œå– argmax å¾—åˆ°çš„ç­–ç•¥å°±æ˜¯å½“å‰çš„æœ€ä¼˜è§£ã€‚\nç°åœ¨åˆ©ç”¨ epsilon-greedy ä½œä¸ºæ¢ç´¢ç­–ç•¥ï¼Œè®­ç»ƒ 10 ä¸ª episodeï¼š\n$ python gridworld.py -a q -k 10 --noise 0.0 -e 0.9 å¾—åˆ°ç»“æœä¹‹åï¼Œå¯¹æ¯ä¸€ä¸ªçŠ¶æ€ s çš„æ‰€æœ‰åŠ¨ä½œ a å– argmax å³å¯å¾—åˆ°åœ¨å½“å‰ epsilon å€¼å’Œ episode å€¼ä¸‹çš„æœ€ä¼˜è§£ï¼š\nQ-Learning çš„å®ç°å¤§è‡´å¦‚ä¸‹ï¼š\nclass QLearningAgent(ReinforcementAgent): def __init__(self, **args): ReinforcementAgent.__init__(self, **args) self.q_values = defaultdict(lambda: 0.0) def getQValue(self, state, action): \u0026#34;\u0026#34;\u0026#34; Returns Q(state,action) Should return 0.0 if we have never seen a state or the Q node value otherwise \u0026#34;\u0026#34;\u0026#34; return self.q_values[(state, action)] def computeValueFromQValues(self, state): \u0026#34;\u0026#34;\u0026#34; Returns max_action Q(state,action) where the max is over legal actions. Note that if there are no legal actions, which is the case at the terminal state, you should return a value of 0.0. \u0026#34;\u0026#34;\u0026#34; next_actions = self.getLegalActions(state) if not next_actions: return 0.0 else: q_value_actions = [(self.getQValue(state, action), action) for action in next_actions] # return the max in q_value_actions which is q_value return sorted(q_value_actions, key=lambda x: x[0])[-1][0] def computeActionFromQValues(self, state): \u0026#34;\u0026#34;\u0026#34; Compute the best action to take in a state. Note that if there are no legal actions, which is the case at the terminal state, you should return None. \u0026#34;\u0026#34;\u0026#34; next_actions = self.getLegalActions(state) if not next_actions: return None else: actions = [] max_q_value = self.getQValue(state, next_actions[0]) # find actions with max q value for action in next_actions: action_q_value = self.getQValue(state, action) if max_q_value \u0026lt; action_q_value: max_q_value = action_q_value actions = [action] elif max_q_value == action_q_value: actions.append(action) # break ties randomly for better behavior. The random.choice() function will help. return random.choice(actions) def getAction(self, state): \u0026#34;\u0026#34;\u0026#34; Compute the action to take in the current state. With probability self.epsilon, we should take a random action and take the best policy action otherwise. Note that if there are no legal actions, which is the case at the terminal state, you should choose None as the action. \u0026#34;\u0026#34;\u0026#34; # Pick Action legalActions = self.getLegalActions(state) action = None if legalActions: if util.flipCoin(self.epsilon): return random.choice(legalActions) else: action = self.getPolicy(state) return action def update(self, state, action, nextState, reward): \u0026#34;\u0026#34;\u0026#34; The parent class calls this to observe a state = action =\u0026gt; nextState and reward transition. You should do your Q-Value update here NOTE: You should never call this function, it will be called on your behalf \u0026#34;\u0026#34;\u0026#34; state_action_q_value = self.getQValue(state, action) self.q_values[(state, action)] = state_action_q_value + self.alpha * (reward + self.discount * self.getValue(nextState) - state_action_q_value) def getPolicy(self, state): return self.computeActionFromQValues(staã€te) def getValue(self, state): return self.computeValueFromQValues(state) DQN Q-Learning ä¾èµ–äº Q-Tableï¼Œå…¶å­˜åœ¨çš„é—®é¢˜æ˜¯å½“ Q-Table ä¸­çš„çŠ¶æ€éå¸¸å¤šï¼Œæˆ–çŠ¶æ€çš„ç»´åº¦éå¸¸å¤šçš„æ—¶å€™ï¼Œå†…å­˜å¯èƒ½æ— æ³•å­˜å‚¨æ‰€æœ‰çš„çŠ¶æ€ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ç¥ç»ç½‘ç»œæ¥æ‹Ÿåˆæ•´ä¸ª Q-Tableï¼Œå³ä½¿ç”¨ Deep Q-Learning Networkã€‚DQN ä¸»è¦ç”¨æ¥è§£å†³æ‹¥æœ‰è¿‘ä¹æ— é™çš„ Stateï¼Œä½† Action æœ‰é™çš„é—®é¢˜ï¼Œå®ƒå°†å½“å‰ State ä½œä¸ºè¾“å…¥ï¼Œè¾“å‡ºå„ä¸ª Action çš„ Q-Valueã€‚\nå¯å‘å¼æœç´¢å’Œå¼ºåŒ–å­¦ä¹ çš„å¯¹æ¯” ","permalink":"http://zintrulcre.github.io/posts/reinforcement-learning/heuristic-search-and-reinforcement-learning/","summary":"å¯å‘å¼æœç´¢å’Œå¼ºåŒ–å­¦ä¹  The Pac-Man Projects æ˜¯ UC Berkeley CS 188 çš„è¯¾ç¨‹é¡¹ç›®ï¼Œæœ¬æ–‡ä»¥è¯¥é¡¹ç›®ä¸ºä¾‹ä»‹ç»å¯å‘å¼æœç´¢å’Œå¼ºåŒ–å­¦ä¹ ã€‚\n1 ç›²ç›®æœç´¢ ç›²ç›®æœç´¢ï¼ˆBlind Searchï¼‰æŒ‡ä¸åˆ©ç”¨ä»»ä½•é¢å¤–ä¿¡æ¯ï¼ˆè¾“å…¥æ•°æ®ï¼Œæˆ–è¾…åŠ©å‡½æ•°ï¼‰ï¼Œåªä¾èµ–äºç®—æ³•æœ¬èº«çš„æœç´¢ï¼Œä¾‹å¦‚ BFSï¼ŒDFSï¼ŒDijkstra ç­‰ï¼›\nDFS The Pac-Man Projects  å·²ç»å®ç°äº†åƒè±†äººæ¸¸æˆçš„åå°é€»è¾‘å’Œå›¾å½¢æ¸²æŸ“æ¡†æ¶ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨ search.py æ–‡ä»¶ä¸­å®ç°å…·ä½“çš„æœç´¢ç®—æ³•ï¼Œå¹¶æ ¹æ®æœç´¢ç®—æ³•ç”Ÿæˆå¯»è·¯è·¯å¾„ï¼Œå³å¯è®©åƒè±†äººç§»åŠ¨ï¼Œå…ˆæ¥å®ç°ä¸€ä¸ªç®€å•çš„ DFSï¼š\ndef DepthFirstSearch(problem): from util import Stack open_list = Stack() visited = [] open_list.push((problem.getStartState(), [])) while not open_list.isEmpty(): current_node, path = open_list.pop() if problem.isGoalState(current_node): return path if current_node in visited: continue visited.append(current_node) for next_node, action, cost in problem.getSuccessors(current_node): if next_node not in visited: open_list.push((next_node, path + [action])) dfs = DepthFirstSearch åœ¨åƒè±†äººæ¸¸æˆçš„æ¡†æ¶ä¸‹ï¼Œä¸ºå¯»è·¯å‡½æ•°ä¼ å…¥çš„ problem å‚æ•°å¯ä»¥ç†è§£ä¸ºä¸€ä¸ª class SearchProblem ç±»å‹çš„æŠ½è±¡åŸºç±»ï¼Œå®é™…çš„é—®é¢˜æœ‰ PositionSearchProblemï¼ˆæ‰¾åˆ°å•ä¸ªç»ˆç‚¹ï¼‰ï¼ŒFoodSearchProblemï¼ˆæ‰¾åˆ°æ‰€æœ‰é£Ÿç‰©ï¼‰ï¼ŒCapsuleSearchProblemï¼ˆæ‰¾åˆ°å¢ç›Šè¯ä¸¸å’Œæ‰€æœ‰é£Ÿç‰©ï¼‰ç­‰ï¼Œè¿™äº›å­ç±»éƒ½éœ€è¦å®ç°ä»¥ä¸‹å‡½æ•°ï¼š","title":"å¯å‘å¼æœç´¢å’Œå¼ºåŒ–å­¦ä¹ "},{"content":"C++ é—­åŒ…å’ŒåŒ¿åå‡½æ•° æœ¬æ–‡ä¸»è¦ä»‹ç»äº† C++ ä¸­é—­åŒ…å’Œä»¿å‡½æ•°ï¼Œä»¥åŠåŒ¿åå‡½æ•°ç›¸å…³çš„æ¦‚å¿µã€‚\n1 é—­åŒ…å’Œä»¿å‡½æ•° é—­åŒ…ï¼ˆClosureï¼‰å¯ä»¥è¢«ç†è§£ä¸ºä¸€ä¸ªé™„å¸¦æ•°æ®çš„æ“ä½œï¼ŒWikiPedia å¯¹é—­åŒ…çš„å®šä¹‰æ˜¯ \u0026ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.\u0026quot;ï¼Œå…¶ä¸­æœ‰ä¸¤å±‚å«ä¹‰ï¼š\n è¯æ³•ä½œç”¨åŸŸï¼ˆlexically scopedï¼‰çš„åå­—ç»‘å®šï¼ˆname bindingï¼‰ï¼šåœ¨è¯æ³•ä½œç”¨åŸŸï¼ˆC++ çš„è¯æ³•ä½œç”¨åŸŸæ˜¯é™æ€ç»‘å®šçš„ï¼ŒåŒ…æ‹¬å—ã€å‡½æ•°ã€ç±»ã€å‘½åç©ºé—´ã€å…¨å±€ä½œç”¨åŸŸç­‰ï¼‰ä¸­ï¼Œå˜é‡åä¸å…¶è¯æ³•ä¸Šä¸‹æ–‡çš„æ ‡è¯†ç¬¦ç›¸å…³è”ï¼Œè€Œç‹¬ç«‹äºè¿è¡Œæ—¶çš„è°ƒç”¨æ ˆï¼› å‡½æ•°è¢«å½“ä½œå¤´ç­‰å…¬æ°‘ï¼ˆfirst-class citizenï¼‰ï¼šåœ¨è¿è¡Œæ—¶å¯ä»¥æ„é€ ä¸€ä¸ªå‡½æ•°å¯¹è±¡å¹¶å°†å…¶ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°ï¼›  æ˜¾ç„¶ C++ 98 å¹¶ä¸ç¬¦åˆè¿™ä¸¤ç‚¹å®šä¹‰ï¼Œå› æ­¤ C++ 98 ä¸­å¹¶æ²¡æœ‰ä¸¥æ ¼æ„ä¹‰ä¸Šçš„é—­åŒ…ï¼Œä½†æˆ‘ä»¬å¯ä»¥ç”¨ä»¿å‡½æ•°ï¼ˆFunctorï¼‰æ¥æ¨¡æ‹Ÿé—­åŒ…çš„è¡Œä¸ºï¼›ä»¿å‡½æ•°å³ä¸€ä¸ªé‡è½½äº†å°æ‹¬å·æ“ä½œç¬¦çš„ç±»ï¼Œè¿™ä¸ªç±»æ‹¥æœ‰ä¸å‡½æ•°ç›¸è¿‘çš„è¡Œä¸ºæ–¹å¼ï¼Œå®ƒæ‹¥æœ‰è‡ªå·±çš„ç§æœ‰æˆå‘˜å˜é‡ï¼Œä¾‹å¦‚ï¼š\nclass Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout \u0026lt;\u0026lt; adder(1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(3) \u0026lt;\u0026lt; endl; } $ g++ -std=c++98 -o adder adder.cpp $ ./adder 1 3 6 ç›¸æ¯”ä¹‹ä¸‹ golang ä¸­çœŸæ­£çš„é—­åŒ…æ˜¾å¾—ç®€æ´å¾ˆå¤šï¼š\nfunc adder() func(int) int { sum := 0 return func(num int) int { sum += num return sum } } func main() { numAdder := adder() fmt.Println(numAdder(1)) fmt.Println(numAdder(2)) fmt.Println(numAdder(3)) } $ go run main.go 1 3 6 C++ 98 çš„æ ‡å‡†åº“ä¸­æä¾›äº†å¾ˆå¤šå®ç”¨çš„å‡½æ•°ï¼Œä¾‹å¦‚ std::sortï¼Œå½“æˆ‘ä»¬éœ€è¦å®šåˆ¶å…¶æ’åºè§„åˆ™çš„æ—¶å€™ï¼Œä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ªç®€å•çš„ä»¿å‡½æ•°ï¼ˆæˆ–è€…æ™®é€šçš„å‡½æ•°ï¼‰ä½œä¸ºå‚æ•°ä¼ å…¥ ï¼Œæ³¨æ„å®šä¹‰æ’åºè§„åˆ™çš„æ—¶å€™è¦æ»¡è¶³ Strict Weak Orderingï¼š\nstruct Foo { int a_, b_; Foo(int a, int b) : a_(a), b_(b) {} }; struct FooComparatorGreater { bool operator()(const Foo f1, const Foo f2) { if (f1.a_ != f2.a_) return f1.a_ \u0026gt; f2.a_; return f1.b_ \u0026gt; f2.b_; } }; int main() { vector\u0026lt;Foo\u0026gt; foo{ Foo(3, 6), Foo(9, 2), Foo(9, 8) }; sort(foo.begin(), foo.end(), FooComparatorGreater()); for (const auto\u0026amp; f : foo) cout \u0026lt;\u0026lt; f.a_ \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; f.b_ \u0026lt;\u0026lt; endl; return 0; } $ g++ -std=c++11 -o sort-functor sort-functor.cpp $ ./sort-functor 9 8 9 2 3 6 2 åŒ¿åå‡½æ•° åŒ¿åå‡½æ•°ï¼ˆAnonymous Functionï¼‰èµ·æºäºç¬¬ä¸€ä¸ªå‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ Lispï¼ŒC++ 11 æ ‡å‡†ä¸­æ­£å¼å¼•å…¥äº†åŒ¿åå‡½æ•°ï¼Œä¹Ÿå«åš lambda è¡¨è¾¾å¼ï¼ˆLambda Expressionï¼‰ï¼›åŒ¿åå‡½æ•°æ˜¯ä¸€ç§æ²¡æœ‰è¢«ç»‘å®šæ ‡è¯†ç¬¦çš„å‡½æ•°ï¼Œå¯ä»¥ç”¨äºå¾ˆæ–¹ä¾¿åœ°å®šä¹‰ä¸€ä¸ªä¸´æ—¶çš„å‡½æ•°å¯¹è±¡ï¼Œæˆ–ä½œä¸ºä¸€ä¸ªå‡½æ•°å¯¹è±¡ä¼ é€’ç»™æ›´ä¸Šå±‚çš„å‡½æ•°ï¼ˆä¾‹å¦‚ std::for_eachï¼‰ï¼Œå…¶åœ¨ C++ 11 çš„è¯­æ³•ä¸Šè¡¨ç°å¾—éå¸¸è½»é‡çº§ï¼Œä¸éœ€è¦åƒæ™®é€šçš„å…·åå‡½æ•°ä¸€æ ·å•ç‹¬åœ¨å¤´æ–‡ä»¶ä¸­ä½œå‡ºå£°æ˜ï¼Œä¸”ç¬¦åˆé—­åŒ…çš„å®šä¹‰ã€‚\nåŒ¿åå‡½æ•°å¯ä»¥æ›¿ä»£æ‰å¤æ‚ä¸”å†—ä½™çš„ä»¿å‡½æ•°ï¼Œä½¿å¾—ä»£ç æ›´æ˜“äºç†è§£å’Œç»´æŠ¤ï¼š\nsort(foo.begin(), foo.end(), [](const Foo\u0026amp; f1, const Foo\u0026amp; f2) { return f1.a_ != f2.a_ ? f1.a_ \u0026gt; f2.a_ : f1.b_ \u0026gt; f2.b_; }); åŒ¿åå‡½æ•°ç”±ä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ†ç»„æˆï¼Œå…¶ä¸­åªæœ‰ 1, 2, 6 ä¸‰ä¸ªéƒ¨åˆ†æ˜¯å¿…é¡»çš„ï¼Œå…¶ä½™éƒ¨åˆ†å¯ä»¥çœç•¥ï¼š\n æ•è·å­å¥ capture clause / lambda introducer å‚æ•°åˆ—è¡¨ parameter list / lambda declarator å¯å˜è§„æ ¼ mutable specification  è¢« mutable ä¿®é¥°çš„åŒ¿åå‡½æ•°å¯ä»¥ä¿®æ”¹æŒ‰å€¼æ•è·çš„å˜é‡   å¼‚å¸¸è§„æ ¼ exception specification å°¾éšè¿”å›ç±»å‹ trailing-return-type åŒ¿åå‡½æ•°ä½“ lambda body  2.1 æ•è·å­å¥ æ•è·å­å¥ç”¨äºæ•è·å¤–éƒ¨å˜é‡ï¼Œä½¿å¾—åŒ¿åå‡½æ•°ä½“å¯ä»¥ä½¿ç”¨è¿™äº›å˜é‡ï¼Œæ•è·çš„æ–¹æ³•åˆ†ä¸ºå¼•ç”¨æ•è·å’Œå€¼ï¼ˆæ‹·è´ï¼‰æ•è·ä¸¤ç§ï¼Œä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š\n  [] ä¸æ•è·ä»»ä½•å˜é‡ï¼›\n  [\u0026amp;] æŒ‰å¼•ç”¨æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡ï¼›\n  [=] æŒ‰å€¼æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡\n  [\u0026amp;, var] é»˜è®¤æŒ‰å¼•ç”¨æ•è·ï¼Œä»…æŒ‰å€¼æ•è· varï¼›\n  [=, \u0026amp;var] é»˜è®¤æŒ‰å€¼æ•è·ï¼Œä»…æŒ‰å¼•ç”¨æ•è· varï¼›\n  [y, y] é‡å¤æŒ‰å€¼æ•è·åŒä¸€ä¸ªå˜é‡ï¼Œæ²¡æœ‰æ„ä¹‰ï¼Œä¼šæŠ¥ warningï¼›\n  [\u0026amp;, \u0026amp;var] é»˜è®¤æŒ‰å¼•ç”¨æ•è·ï¼Œå¹¶æŒ‰å¼•ç”¨æ•è· varï¼Œæ²¡æœ‰æ„ä¹‰ï¼Œä¼šæŠ¥ warningï¼›\n  [=, this] é»˜è®¤æŒ‰å€¼æ•è·ï¼Œå¹¶æŒ‰å€¼æ•è· this æŒ‡é’ˆï¼Œæ²¡æœ‰æ„ä¹‰ï¼ŒåŒæ ·ä¼šæŠ¥ warningï¼›\nstd::function\u0026lt;void()\u0026gt; AnonyFunc = [=, this]() -\u0026gt; void {};// warning: explicit by-copy capture of â€˜thisâ€™ redundant with by-copy capture default   [this] æŒ‰å€¼æ•è· this æŒ‡é’ˆï¼Œthis æŒ‡é’ˆè™½ç„¶ä¸èƒ½è¢«ä¿®æ”¹ï¼Œä½†å…¶æŒ‡å‘çš„å¯¹è±¡å¯ä»¥è¢«æ“ä½œå¹¶ä¿®æ”¹ï¼Œç›¸å½“äºæŒ‰å¼•ç”¨æ•è·äº† this æŒ‡å‘çš„å¯¹è±¡ï¼Œå³ [\u0026amp;(*this)]ï¼›\nclass Foo { public: void Func() { int y{ 0 }; std::function\u0026lt;void()\u0026gt; AnonyFunc = [this]() -\u0026gt; void { x_ = 2; // okï¼Œx_ æ˜¯ç±»çš„æˆå‘˜å˜é‡ï¼Œå¯ä»¥è¢«ä¿®æ”¹  y = 2; // error: â€˜yâ€™ is not capturedï¼Œå‡½æ•°çš„å±€éƒ¨å˜é‡å¹¶æ²¡æœ‰è¢«æ•è·  this = nullptr; // error: lvalue required as left operand of assignmentï¼Œè¿™é‡Œæ•è·çš„ this æŒ‡é’ˆæ˜¯ä¸€ä¸ªä¸´æ—¶å˜é‡å³å³å€¼ï¼Œä¸èƒ½è¢«ä¿®æ”¹  }; AnonyFunc(); } private: int x_ = 0; };   [*this] åœ¨ C++ 11 ä¸­ä¸èƒ½æŒ‰å€¼æ•è· this æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡ï¼›\nstd::function\u0026lt;void()\u0026gt; AnonyFunc = [*this]() -\u0026gt; void {}; // error: expected identifier before â€˜*â€™ token   åœ¨ä½¿ç”¨æ•è·å­å¥çš„æ—¶å€™ï¼Œéœ€è¦æ³¨æ„ä¸€äº›é—®é¢˜ï¼š\n  ä¸å»ºè®®ä½¿ç”¨ 2ï¼Œ3 è¿™ä¸¤ç§æ–¹å¼è¿›è¡Œæ•è·ï¼ˆå¯¹æ€§èƒ½å½±å“è¾ƒå¤§ï¼‰ï¼Œåº”è¯¥æ˜ç¡®åœ°æŒ‡å‡ºéœ€è¦æŒ‰å¼•ç”¨æ•è·çš„å˜é‡ï¼›\n  æŒ‰å€¼æ•è·çš„å˜é‡æ˜¯ read-only (const) çš„ï¼Œåªæœ‰å½“åŒ¿åå‡½æ•°çš„å¯å˜è§„æ ¼è¢«æ˜¾å¼å£°æ˜ä¸º mutable çš„æ—¶å€™æ‰å¯ä»¥ä¿®æ”¹æŒ‰å€¼æ•è·çš„å˜é‡ï¼›\nint x{ 0 }; auto AnonyFunc = [=]() -\u0026gt; void { x = 1; // error: assignment of read-only variable â€˜xâ€™ } auto AnonyFunc = [=]() mutable -\u0026gt; void { x = 1; // ok }   æŒ‰å€¼æ•è·çš„å˜é‡çš„å€¼åœ¨åŒ¿åå‡½æ•°ç”Ÿæˆçš„æ—¶å€™å°±å·²ç»ç¡®å®šäº†ï¼Œå¦‚æœåœ¨åŒ¿åå‡½æ•°ç”Ÿæˆåä¿®æ”¹å¤–éƒ¨å˜é‡çš„å€¼ï¼Œåˆ™ä¸ä¼šå½±å“åˆ°åŒ¿åå‡½æ•°å†…è¢«æ•è·çš„å˜é‡å€¼ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸¤ä¸ªä½œç”¨åŸŸä¸åŒçš„å˜é‡ï¼š\nint i{ 0 }; auto AnonyFunc = [i]() -\u0026gt; void { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;i \u0026lt;\u0026lt; endl; }; i = 1; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;i \u0026lt;\u0026lt; endl; AnonyFunc(); $ g++ -std=c++11 -o lambda-capture lambda-capture.cpp $ ./lambda-capture 1 0x7ffe31fced8c 0 0x7ffe31fced80   å¯¹äºæŒ‰å¼•ç”¨æ•è·çš„å˜é‡ï¼ˆæˆ–æŒ‰å€¼æ•è·çš„æŒ‡é’ˆï¼‰ï¼Œå¦‚æœè¯¥å¼•ç”¨å˜é‡ï¼ˆæˆ–æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡ï¼‰åœ¨å¤–éƒ¨è¢«ææ„ï¼Œé‚£ä¹ˆåŒ¿åå‡½æ•°ä¸­çš„å¼•ç”¨å˜é‡ï¼ˆæˆ–æŒ‡é’ˆï¼‰åˆ™ä¼šæˆä¸ºæ‚¬ç©ºå¼•ç”¨/æŒ‡é’ˆï¼ˆDangling Pointerï¼‰ï¼š\nint* x = new int[1000000]; x[0] = 0; auto AnonyFunc = [\u0026amp;x]() { x[0] = 1; // Segmentation fault }; delete[] x; AnonyFunc(); struct Foo { int x_[1000000]; }; int main() { Foo* f = new Foo(); f-\u0026gt;x_[0] = 0; auto AnonyFunc = [f]() -\u0026gt; void { f-\u0026gt;x_[0] = 1; // Segmentation fault  }; delete f; AnonyFunc(); }   2.2 åŒ¿åå‡½æ•°å’Œé—­åŒ… Scott Meyers å¯¹ lambda è¡¨è¾¾å¼ï¼ˆåŒ¿åå‡½æ•°ï¼‰ä¸é—­åŒ…ä¹‹é—´çš„å…³ç³»çš„è§£é‡Šæ˜¯ \u0026ldquo;The distinction between a lambda and the corresponding closure is precisely equivalent to the distinction between a class and an instance of the class. A class exists only in source code; it doesnâ€™t exist at runtime. What exists at runtime are objects of the class type. Closures are to lambdas as objects are to classes. This should not be a surprise, because each lambda expression causes a unique class to be generated (during compilation) and also causes an object of that class typeâ€“a closureâ€“to be created (at runtime).\u0026quot;ï¼›\nè¿™æ®µè§£é‡Šå¯ä»¥æ‹†åˆ†ä¸ºä¸¤æ®µï¼š\n åŒ¿åå‡½æ•°å’Œé—­åŒ…çš„å…³ç³»å°±å¦‚åŒç±»å’Œç±»å¯¹è±¡çš„å…³ç³»ï¼ŒåŒ¿åå‡½æ•°å’Œç±»çš„å®šä¹‰éƒ½åªå­˜åœ¨äºæºç ï¼ˆä»£ç æ®µï¼‰ä¸­ï¼Œè€Œé—­åŒ…å’Œç±»å¯¹è±¡åˆ™æ˜¯åœ¨è¿è¡Œæ—¶å ç”¨å†…å­˜ç©ºé—´çš„å®ä½“ï¼› å¯¹åŒ¿åå‡½æ•°çš„å®šä¹‰ä¼šç”Ÿæˆä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„ç±»ï¼Œå¹¶åœ¨è¿è¡Œæ—¶ç”Ÿæˆå…¶ç±»å¯¹è±¡ï¼›  å†ç»“åˆ C++ 11 çš„æ ‡å‡†è¯´æ˜ï¼š\n \u0026quot;[C++11: 5.1.2/3]: The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type â€” called the closure type\u0026hellip;\u0026quot;ï¼ŒC++ 11 ä¸­çš„åŒ¿åå‡½æ•°å®é™…ä¸Šä¹Ÿæ˜¯ç”¨ç±»ï¼ˆclosure typeï¼‰æ¥å®ç°çš„ï¼› â€œ[C++11: 5.1.2/5]: The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters and return type are described by the lambda-expressionâ€™s parameter-declaration-clause and trailing-return-type respectively. [..]â€ï¼ŒåŒ¿åå‡½æ•°ç”Ÿæˆçš„ç±»ä¸­ä¹Ÿé‡è½½äº† operator()ï¼Œå…¶å‚æ•°ä¸åŒ¿åå‡½æ•°çš„å‚æ•°åˆ—è¡¨ç›¸åŒï¼Œè¿”å›å€¼ä¸åŒ¿åå‡½æ•°çš„å°¾éšè¿”å›ç±»å‹ç›¸åŒï¼› \u0026quot;[C++11: 5.1.2/6]: The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure typeâ€™s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure typeâ€™s function call operator.\u0026quot;ï¼Œå¦‚æœåŒ¿åå‡½æ•°æ²¡æœ‰ä»»ä½•å‚æ•°ï¼Œé‚£ä¹ˆå°†ä¼šç”Ÿæˆä¸€ä¸ªæ™®é€šçš„å‡½æ•°ï¼Œè€Œä¸æ˜¯é—­åŒ…ç±»å‹ï¼›  å¯ä»¥çŸ¥é“å®é™…ä¸ŠåŒ¿åå‡½æ•°ä¹Ÿæ˜¯ç”¨ä»¿å‡½æ•°å®ç°çš„ï¼Œå®ƒå®é™…ä¸Šæ˜¯ C++ 11 åŠ å…¥çš„è¯­æ³•ç³–ï¼Œä¸è¿‡å…¶è¯­æ³•ç‰¹æ€§æ˜¯ç¬¦åˆé—­åŒ…å®šä¹‰çš„ã€‚\n3 åŒ¿åå‡½æ•°åœ¨ C++ 14 åŠä¹‹åçš„å˜åŒ– C++ 14 å¹¿ä¹‰æ•è· C++ 14 ä¸­å¼•å…¥äº†æ–°çš„å¹¿ä¹‰ lambda æ•è·ï¼ˆGeneralized Lambda Capturesï¼‰ï¼Œå³å¯ä»¥åœ¨æ•è·åˆ—è¡¨ä¸­ä»¥ä»»æ„æ–¹å¼åˆå§‹åŒ–åŒ¿åå‡½æ•°ä¸­çš„å˜é‡ï¼Œä½¿å¾—æŸäº›è¢«ç¦ç”¨äº†æ‹·è´æ„é€ å‡½æ•°çš„ç±»å‹å¯ä»¥é€šè¿‡ std::move çš„æ–¹å¼è¢«æ•è·åˆ°åŒ¿åå‡½æ•°ä¸­ï¼š\nauto ptr_0 = make_unique\u0026lt;int\u0026gt;( 0 ); auto AnonyFunc = [ptr_0 = move(ptr_0)]() { *ptr_0 = 1; cout \u0026lt;\u0026lt; *ptr_0 \u0026lt;\u0026lt; endl; }; AnonyFunc(); è¿™é‡Œæ•è·åˆ—è¡¨ä¸­å·¦è¾¹å’Œå³è¾¹çš„ ptr_0 ä¸æ˜¯åŒä¸€ä¸ªå˜é‡ï¼Œå®ƒä»¬çš„ä½œç”¨åŸŸåˆ†åˆ«æ˜¯åŒ¿åå‡½æ•°å†…å’ŒåŒ¿åå‡½æ•°å¤–ï¼›\né™¤æ­¤ä¹‹å¤–å¹¿ä¹‰ lambda æ•è·è¿˜å¯ä»¥ç”¨æ¥é—´æ¥åœ°æ•è· *thisï¼Œå³åœ¨ C++ 11 ä¸­æ— æ³•å®ç°çš„æŒ‰å€¼æ•è· this æŒ‡å‘çš„å¯¹è±¡ï¼š\nauto AnonyFunc = [this_copy = *this]() mutable { this_copy.x_ = 1; cout \u0026lt;\u0026lt; this_copy.x_ \u0026lt;\u0026lt; endl; }; AnonyFunc(); C++ 17 æ•è· *this åœ¨ C++ 17 ä¸­ï¼Œç»ˆäºå¯ä»¥ç›´æ¥æ•è· *this äº†ï¼Œææ¡ˆ P0018R3 æŒ‡å‡ºæ•è· *this å¯ä»¥ç”¨äºéœ€è¦è¿›è¡Œå¼‚æ­¥æ“ä½œçš„å¹¶å‘åº”ç”¨ï¼Œå› ä¸º this å¯èƒ½å¤±æ•ˆï¼š\nauto AnonyFunc = [*this]() mutable { x_ = 1; cout \u0026lt;\u0026lt; x_ \u0026lt;\u0026lt; endl; }; AnonyFunc(); cout \u0026lt;\u0026lt; x_ \u0026lt;\u0026lt; endl; $ g++ -std=c++17 -o lambda lambda.cpp $ ./lambda 1 0 ","permalink":"http://zintrulcre.github.io/posts/c++/closure-and-anonymous-function/","summary":"C++ é—­åŒ…å’ŒåŒ¿åå‡½æ•° æœ¬æ–‡ä¸»è¦ä»‹ç»äº† C++ ä¸­é—­åŒ…å’Œä»¿å‡½æ•°ï¼Œä»¥åŠåŒ¿åå‡½æ•°ç›¸å…³çš„æ¦‚å¿µã€‚\n1 é—­åŒ…å’Œä»¿å‡½æ•° é—­åŒ…ï¼ˆClosureï¼‰å¯ä»¥è¢«ç†è§£ä¸ºä¸€ä¸ªé™„å¸¦æ•°æ®çš„æ“ä½œï¼ŒWikiPedia å¯¹é—­åŒ…çš„å®šä¹‰æ˜¯ \u0026ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.\u0026quot;ï¼Œå…¶ä¸­æœ‰ä¸¤å±‚å«ä¹‰ï¼š\n è¯æ³•ä½œç”¨åŸŸï¼ˆlexically scopedï¼‰çš„åå­—ç»‘å®šï¼ˆname bindingï¼‰ï¼šåœ¨è¯æ³•ä½œç”¨åŸŸï¼ˆC++ çš„è¯æ³•ä½œç”¨åŸŸæ˜¯é™æ€ç»‘å®šçš„ï¼ŒåŒ…æ‹¬å—ã€å‡½æ•°ã€ç±»ã€å‘½åç©ºé—´ã€å…¨å±€ä½œç”¨åŸŸç­‰ï¼‰ä¸­ï¼Œå˜é‡åä¸å…¶è¯æ³•ä¸Šä¸‹æ–‡çš„æ ‡è¯†ç¬¦ç›¸å…³è”ï¼Œè€Œç‹¬ç«‹äºè¿è¡Œæ—¶çš„è°ƒç”¨æ ˆï¼› å‡½æ•°è¢«å½“ä½œå¤´ç­‰å…¬æ°‘ï¼ˆfirst-class citizenï¼‰ï¼šåœ¨è¿è¡Œæ—¶å¯ä»¥æ„é€ ä¸€ä¸ªå‡½æ•°å¯¹è±¡å¹¶å°†å…¶ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°ï¼›  æ˜¾ç„¶ C++ 98 å¹¶ä¸ç¬¦åˆè¿™ä¸¤ç‚¹å®šä¹‰ï¼Œå› æ­¤ C++ 98 ä¸­å¹¶æ²¡æœ‰ä¸¥æ ¼æ„ä¹‰ä¸Šçš„é—­åŒ…ï¼Œä½†æˆ‘ä»¬å¯ä»¥ç”¨ä»¿å‡½æ•°ï¼ˆFunctorï¼‰æ¥æ¨¡æ‹Ÿé—­åŒ…çš„è¡Œä¸ºï¼›ä»¿å‡½æ•°å³ä¸€ä¸ªé‡è½½äº†å°æ‹¬å·æ“ä½œç¬¦çš„ç±»ï¼Œè¿™ä¸ªç±»æ‹¥æœ‰ä¸å‡½æ•°ç›¸è¿‘çš„è¡Œä¸ºæ–¹å¼ï¼Œå®ƒæ‹¥æœ‰è‡ªå·±çš„ç§æœ‰æˆå‘˜å˜é‡ï¼Œä¾‹å¦‚ï¼š\nclass Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout \u0026lt;\u0026lt; adder(1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(3) \u0026lt;\u0026lt; endl; } $ g++ -std=c++98 -o adder adder.","title":"C++ é—­åŒ…å’ŒåŒ¿åå‡½æ•°"},{"content":"è´Ÿè½½å‡è¡¡å’Œä¸€è‡´æ€§å“ˆå¸Œ åå‘ä»£ç† reverse proxy æ˜¯æŒ‡ä»¥ä»£ç†æœåŠ¡å™¨æ¥æ¥æ”¶ç”±å®¢æˆ·ç«¯å‘é€æ¥çš„è¯·æ±‚ï¼Œå¹¶é€šè¿‡ä¸€å®šçš„ç­–ç•¥å°†å…¶è½¬å˜å‘ç»™å®é™…å¤„ç†è¯·æ±‚çš„åç«¯æœåŠ¡å™¨ï¼›ä¸»è¦åº”ç”¨äºè´Ÿè½½å‡è¡¡ã€åŠ¨æ€ç¼“å­˜ã€å®‰å…¨è®¤è¯ã€å†…ç½‘ç©¿é€ã€SSL åŠ å¯†ç­‰ï¼›è€Œè´Ÿè½½å‡è¡¡ load balancing æ˜¯æŒ‡åœ¨å¤šä¸ª slotï¼ˆæ§½ï¼Œä¸€èˆ¬æ˜¯æŸç§è®¡ç®—èµ„æºï¼‰ä¸­åˆ†é…è´Ÿè½½ï¼Œä»¥ä¼˜åŒ–èµ„æºåˆ©ç”¨ç‡å’Œé¿å…å•ç‚¹æ•…éšœé—®é¢˜çš„æ–¹æ³•ï¼Œæ˜¯é«˜å¯ç”¨æ€§åˆ†å¸ƒå¼ç³»ç»Ÿçš„å¿…å¤‡ä¸­é—´ä»¶ï¼›å¸¸ç”¨çš„å¼€æº load balancer æœ‰ nginxï¼ŒLVSï¼ŒHaproxy ç­‰ï¼›è´Ÿè½½å‡è¡¡å¯ä»¥è§†ä¸ºåå‘ä»£ç†çš„ä¸€ç§åº”ç”¨ï¼Œè´Ÿè½½å‡è¡¡çš„æ–¹æ³•å¤§è‡´å¯ä»¥åˆ†ä¸ºä¼ ç»Ÿè´Ÿè½½å‡è¡¡ç®—æ³•å’Œå“ˆå¸Œç®—æ³•ä¸¤ç§ï¼Œæœ¬æ–‡ç®€å•åœ°æ€»ç»“äº†è¿™äº›ç®—æ³•çš„åŸç†ã€‚\n1 ä¼ ç»Ÿè´Ÿè½½å‡è¡¡ç®—æ³•  éšæœº randomï¼šå°† key éšæœºåˆ†é…åˆ°æŸä¸€ä¸ª slot ä¸Šï¼Œæ ¹æ®æ¦‚ç‡è®ºå¯çŸ¥ï¼Œååé‡è¶Šå¤§ï¼Œéšæœºç®—æ³•çš„æ•ˆæœè¶Šå¥½ï¼› åŠ æƒéšæœº weighted randomï¼šä¸ºæ¯ä¸€ä¸ª slot åˆ†é…ä¸€ä¸ªæƒé‡ï¼Œåœ¨éšæœºçš„æ—¶å€™è€ƒè™‘æƒé‡çš„å½±å“ï¼›å¯ä»¥é€šè¿‡åœ¨æ‰€æœ‰ slot çš„æƒé‡æ€»å’Œä¸­éšæœºå‡ºä¸€ä¸ªæ•°å­— kï¼Œæ‰¾åˆ° k æ‰€åœ¨çš„ slot ä½ç½®æ¥å®ç°ï¼› è½®è¯¢ round robinï¼šæŒ‰é¡ºåºä¾æ¬¡å°† key åˆ†é…ç»™æ¯ä¸€ä¸ª slotï¼› åŠ æƒè½®è¯¢ weighted round robinï¼šä¸ºæ¯ä¸€ä¸ª slot åˆ†é…ä¸€ä¸ªæƒé‡ï¼Œåœ¨æŒ‰åºåˆ†é…æ—¶ä¸ºæƒé‡æ›´é«˜çš„ slot åˆ†é…æ›´å¤šçš„ keyï¼› å¹³æ»‘åŠ æƒè½®è¯¢ smooth weighted round robinï¼šä¸€ç§èƒ½å¤Ÿå‡åŒ€åœ°åˆ†æ•£è°ƒåº¦åºåˆ—çš„åŠ æƒè½®è¯¢æ–¹æ³•ï¼Œåˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š  é€‰å‡ºå½“å‰æƒé‡æœ€é«˜çš„ slotï¼Œå°† key åˆ†é…ç»™å®ƒï¼› å°†é€‰å‡ºçš„ slot çš„æƒé‡æ•°å€¼å‡å»å…¶åˆå§‹æƒé‡ï¼› å°†æ‰€æœ‰ slot çš„æƒé‡æ•°å€¼éƒ½åŠ ä¸Šå®ƒä»¬çš„åŸå§‹æƒé‡ï¼› é‡å¤ä»¥ä¸Šæ­¥éª¤ï¼›   æœ€å°‘è¿æ¥æ•° least connectionsï¼šå°† key åˆ†é…ç»™å½“å‰å…·æœ‰æœ€å°‘è¿æ¥æ•°é‡çš„ slotï¼›  2 Mod-N å“ˆå¸Œ åœ¨æœ‰äº›åœºæ™¯ä¸‹ï¼Œä¼ ç»Ÿè´Ÿè½½å‡è¡¡ç®—æ³•æ— æ³•æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ï¼Œä¾‹å¦‚ï¼š\n å½“æˆ‘ä»¬éœ€è¦å……åˆ†åˆ©ç”¨åˆ° slot çš„ç¼“å­˜ï¼Œåœ¨ä»»ä½•æ—¶å€™éƒ½å¸Œæœ›å°†åŒä¸€ä¸ª key æ˜ å°„åˆ°å›ºå®šçš„ slot ä¸Šï¼Œè€Œä¸æ˜¯è®©å…¶è¢«ä»»æ„åœ°åˆ†é…åˆ°ä¸€ä¸ªè´Ÿè½½è¾ƒä½çš„ slot ä¸Šï¼› å½“æˆ‘ä»¬å¸Œæœ›æŠŠæ•°æ®åˆ†é…åˆ°ä¸€äº›å…·æœ‰é”®å€¼å­˜å‚¨åŠŸèƒ½ï¼ˆå¯ä»¥æ˜¯ memcache, redis, mysql ç­‰ï¼‰çš„ slot ä¸Šè¿›è¡Œæœ‰çŠ¶æ€æœåŠ¡ï¼Œè€Œåˆä¸ä½¿ç”¨ä¸€ä¸ªå…¨å±€çš„æ•°æ®åº“ï¼›  å¯¹äºä»¥ä¸Šä¸¤ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆä½¿ç”¨å“ˆå¸Œå‡½æ•°ï¼ˆå¦‚ md5, sha1 ç­‰ï¼Œéœ€è¦ä¿è¯å“ˆå¸Œåçš„åˆ†å¸ƒå¹³å‡ï¼‰å°† key æ˜ å°„ä¸ºä¸€ä¸ª uint32 çš„å€¼ï¼ˆkey æœ¬èº«å¯èƒ½æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²æˆ–å…¶ä»–å€¼ï¼‰ï¼Œå†ç”¨è¯¥å€¼å¯¹ Nï¼ˆslot çš„æ•°é‡ï¼‰è¿›è¡Œå–æ¨¡è¿ç®—æ¥æ˜ å°„å‡ºä¸€ä¸ªå€¼ï¼Œ å³ value = hash(key) mod nï¼Œè¿™ç§æ–¹æ³•å¯ä»¥ç§°ä¸º Mod-N å“ˆå¸Œï¼›è¿™é‡Œåšäº†ä¸¤æ¬¡å“ˆå¸Œï¼Œç¬¬ä¸€æ¬¡æ˜¯å¯¹ key åšæ˜ å°„ï¼Œç¬¬äºŒæ¬¡æ˜¯è¿›è¡Œå–æ¨¡è¿ç®—ã€‚\nä¸€èˆ¬æ¥è¯´å¥½çš„å“ˆå¸Œå‡½æ•°åº”è¯¥æ»¡è¶³ä¸€äº›æ¡ä»¶ï¼š\n ä»å“ˆå¸Œå€¼ä¸å¯åå‘æ¨å¯¼å‡º keyï¼› å‘ç”Ÿå“ˆå¸Œå†²çªçš„æ¦‚ç‡å°½å¯èƒ½å°ï¼› æ•ˆç‡é«˜ï¼›  å“ˆå¸Œå†²çª/ç¢°æ’ Hash Collision å½“æˆ‘ä»¬æŠŠè¾ƒå¤§çš„å€¼ç©ºé—´æ˜ å°„åˆ°è¾ƒå°çš„å€¼ç©ºé—´æ—¶ï¼Œå†²çªæ˜¯ä¸å¯é¿å…çš„ï¼›å¦‚æœä¸¤ä¸ª key é€šè¿‡å“ˆå¸Œæ–¹æ³•è¢«æ˜ å°„ä¸ºäº†åŒä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆå°±ç§°ä¸ºå‘ç”Ÿäº† hash collisionï¼Œä¸€èˆ¬æ¥è¯´å…¶è§£å†³æ–¹æ¡ˆæœ‰ï¼š\n(1) å•é“¾è¡¨æ³• separate chaining ä¹Ÿç§°ä½œ open hashingï¼›å¯¹äºæ¯ä¸€ä¸ªé€šè¿‡å“ˆå¸Œæ–¹æ³•æ˜ å°„å‡ºçš„å€¼ï¼Œæˆ‘ä»¬å°†å…¶ä½œä¸ºä¸€ä¸ª bucketï¼›å½“æœ‰ key è¢«æ˜ å°„åˆ° bucket ä¸Šæ—¶ï¼Œå¦‚æœ bucket ä¸ºç©ºï¼Œåˆ™ä¸ºå…¶æ–°åˆ†é…ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹ï¼Œå¦åˆ™éå†è¿™ä¸ªé“¾è¡¨ï¼Œåœ¨è¿™ä¸ªé“¾è¡¨çš„å°¾éƒ¨ä¸ºå…¶åˆ†é…æ–°çš„é“¾è¡¨èŠ‚ç‚¹ï¼›\n(2) å¼€æ”¾å¯»å€æ³• open addressing ä¹Ÿç§°ä½œ closed hashingï¼›ä¸»è¦æ€è·¯æ˜¯é€šè¿‡æœç´¢å“ˆå¸Œè¡¨ä¸­çš„å…¶ä»–ç©ºçš„ slotï¼ˆæ¢æµ‹åºåˆ— probe sequenceï¼‰æ¥è¿›è¡Œ key çš„æ’å…¥ï¼Œè¿›è¡ŒæŸ¥æ‰¾æ—¶åº”è¯¥é‡‡ç”¨ä¸æ’å…¥æ—¶ç›¸åŒçš„çº¿æ€§æ¢æµ‹è§„åˆ™ï¼›è·å– probe sequence çš„æ–¹æ³•ä¸€èˆ¬æœ‰ï¼š\n  çº¿æ€§æ¢æµ‹ linear probingï¼šæŸ¥æ‰¾å“ˆå¸Œè¡¨ä¸­ç¦»å†²çªä½ç½®æœ€è¿‘çš„ç©ºçš„ slotï¼Œå³ value = (hash(key) + k) mod n, k = 1, 2, 3, 4...\n  äºŒæ¬¡æ¢æµ‹ quadratic probingï¼šå¯¹å“ˆå¸Œç»“æœæ·»åŠ ä¸€ä¸ªäºŒæ¬¡å¤šé¡¹å¼ç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªç©ºçš„ slotï¼Œå³ value = (hash(key) + k^2) mod n, k^2 = 1, 4, 9, 16...\n  åŒé‡å“ˆå¸Œ double hashingï¼šå€ŸåŠ©å¦ä¸€ä¸ªå“ˆå¸Œå‡½æ•° hash' çš„ç»“æœï¼Œä½œä¸ºåç§»é‡è·å–å€¼ï¼Œå³ value = hash'(key) mod nï¼›\n  3 ä¸€è‡´æ€§å“ˆå¸Œ Consistent Hashing åœ¨æ•°æ®é‡è¾ƒå¤§çš„åœºæ™¯ä¸‹ï¼Œå‡è®¾æˆ‘ä»¬å› ä¸ºæŸäº›åŸå› éœ€è¦å°†åŸæœ¬çš„ n ä¸ª slot æ‰©å®¹ä¸º m ä¸ª slotï¼Œå¦‚æœä»ç„¶ä½¿ç”¨ Mod-N å“ˆå¸Œï¼Œå°†ä¼šæœ‰ n/m ä»½ç¼“å­˜ä¸èƒ½æ­£ç¡®å‘½ä¸­ï¼Œä»è€Œäº§ç”Ÿå¤§é‡çš„æ•°æ®åº“è¯·æ±‚ï¼Œå¯èƒ½å¯¼è‡´ç¼“å­˜é›ªå´©ã€‚\nå¯¹äºä¼ ç»Ÿçš„å“ˆå¸Œæ˜ å°„ï¼Œæ·»åŠ æˆ–è€…åˆ é™¤ä¸€ä¸ª slotï¼Œä¼šé€ æˆå“ˆå¸Œè¡¨çš„å…¨é‡é‡æ–°æ˜ å°„ï¼›è€Œ**ä¸€è‡´æ€§å“ˆå¸Œ**çš„ç›®çš„æ˜¯è¾¾æˆå¢é‡å¼çš„é‡æ–°æ˜ å°„ï¼Œå³å½“ slot çš„æ•°é‡å‘ç”Ÿå˜åŒ–æ—¶ï¼Œé™ä½é‡æ–°æ˜ å°„çš„æ•°é‡ï¼Œå°½é‡æœ€å°åŒ–é‡æ–°æ˜ å°„ï¼ˆminimum disruptionï¼‰ã€‚\nä¸€è‡´æ€§å“ˆå¸Œç®—æ³•çš„è®¾è®¡å…³é”®æœ‰ 4 ç‚¹ï¼š\n å¹³è¡¡æ€§ balanceï¼šæ‰€æœ‰çš„ key èƒ½è¢«å‡åŒ€åœ°æ˜ å°„åˆ°å„ä¸ª slot ä¸Šï¼› å•è°ƒæ€§ monotonicityï¼šå¢åŠ æ–°çš„ slot åï¼ŒåŸæœ‰çš„ key åº”è¯¥è¢«æ˜ å°„åˆ°åŸæœ‰çš„ slotï¼Œæˆ–æ–°çš„ slot ä¸Šï¼Œè€Œä¸æ˜¯å…¶ä»–æ—§çš„ slot ï¼› åˆ†æ•£ spreadï¼šæœåŠ¡æ‰©å®¹æˆ–è€…ç¼©å®¹æ—¶ï¼Œå°½é‡å‡å°‘æ•°æ®çš„è¿ç§»ï¼› è´Ÿè½½ loadï¼šå°½é‡é™ä½ slot çš„è´Ÿè½½ï¼›  3.1 Ketama ketama ç®—æ³•æ˜¯æœ€å¸¸ç”¨çš„ä¸€ç§ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•ï¼Œä¹Ÿå«åšå“ˆå¸Œç¯æ³•ï¼ˆhash ringï¼‰ï¼Œ è¢«å¹¿æ³›çš„åº”ç”¨åœ¨æ•°æ®åº“ï¼Œç¼“å­˜ç³»ç»Ÿå’ŒæœåŠ¡æ¡†æ¶ä¸Šï¼ŒåŒ…æ‹¬ä½†ä¸é™äº memcache, redis, dubbo, nginx ç­‰ï¼Œå…¶æ­¥éª¤æ˜¯ï¼š\n å¯¹äºä¸€ä¸ª [0, uint32] çš„åŒºé—´ï¼Œå°†å…¶é¦–å°¾ç›¸è¿ï¼Œå½¢æˆé¡ºæ—¶é’ˆçš„ç¯ï¼› å¯¹ slot è¿›è¡Œå“ˆå¸Œï¼Œæ˜ å°„åˆ° [0, uint32] åŒºé—´ä¸Šï¼Œå¹¶å°†ç»“æœæ ‡è®°åˆ°ç¯ä¸Šï¼› å¯¹ key è¿›è¡Œå“ˆå¸Œï¼Œæ˜ å°„åˆ°åŒºé—´ä¸Šï¼Œæ²¿ç€ç¯é¡ºæ—¶é’ˆå¯»æ‰¾å¹¶å°†å…¶åˆ†é…åˆ°è·å…¶æœ€è¿‘çš„ slotï¼›  ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾ç°åœ¨æœ‰ N0, N1, N2 ä¸‰ä¸ª slot ä»¥åŠ a, b, c ä¸‰ä¸ª keyï¼Œå…¶ä¸­ a ä¼šè¢«åˆ†é… N1 ä¸Šï¼Œb å’Œ c éƒ½ä¼šè¢«åˆ†é…åˆ° N2 ä¸Šï¼›\nç°åœ¨æˆ‘ä»¬æ–°å¢ä¸€ä¸ª N3 slotï¼Œå¹¶å°†å…¶æ˜ å°„åˆ° [a, N1] ä¹‹é—´ï¼Œé‚£ä¹ˆ a å’Œæ‰€æœ‰åœ¨ [N0, N3] ä¹‹é—´çš„ key éƒ½ä¼šè¢«é‡æ–°åˆ†é…åˆ° N3 è¿™ä¸ª slot ä¸Šï¼Œé™¤æ­¤ä¹‹å¤–çš„å…¶ä»–æ‰€æœ‰ key åˆ™ä¸ä¼šè¢«é‡æ–°æ˜ å°„ï¼›\nå‡è®¾æˆ‘ä»¬ç§»é™¤ N2 slotï¼Œé‚£ä¹ˆæ‰€æœ‰åœ¨ [N1, N2] ä¹‹é—´çš„ key éƒ½ä¼šè¢«é‡æ–°æ˜ å°„åˆ° N0 ä¸Šï¼Œé™¤æ­¤ä¹‹å¤–çš„å…¶ä»–æ‰€æœ‰ key åˆ™ä¸ä¼šè¢«é‡æ–°æ˜ å°„ã€‚\nå¯ä»¥å‘ç°ï¼Œketama ç®—æ³•è¾¾æˆäº†åœ¨æ–°å¢æˆ–ç§»é™¤ slot åçš„å¢é‡å¼é‡æ–°æ˜ å°„ï¼ˆminimum disruptionï¼‰ï¼Œä¸ä¼šç ´åå¤§å¤šæ•° key çš„æ˜ å°„å…³ç³»ï¼›å› ä¸ºè¦æ„é€ å‡ºä¸€ä¸ªç¯æ¥å­˜å‚¨æ‰€æœ‰ slot çš„ key è¢«æ˜ å°„åˆ°çš„ä½ç½®ï¼Œæ‰€ä»¥å…¶ç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ï¼›ä¸ºäº†æ–¹ä¾¿åœ°è¿›è¡ŒæŸ¥æ‰¾ï¼Œå¯ä»¥å°†ç¯è½¬æ¢æˆä¸€ä¸ªæœ‰åºæ•°ç»„ï¼Œåœ¨å…¶ä¸­è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(logn)ã€‚\nè™šæ‹ŸèŠ‚ç‚¹ æœ‰æ—¶å€™æˆ‘ä»¬å¯èƒ½ä¼šå¯¹ä¸åŒçš„èŠ‚ç‚¹èµ‹äºˆä¸åŒçš„æƒé‡ï¼Œä¹Ÿå°±å¯¼è‡´äº†æ¯ä¸ªèŠ‚ç‚¹çš„åœ°ä½ä¸å¹³ç­‰ï¼Œä»è€Œä¸èƒ½ç›´æ¥å°†èŠ‚ç‚¹æ”¾åœ¨ç¯ä¸Šï¼Œè§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨ä¸åŒæ•°é‡çš„è™šæ‹ŸèŠ‚ç‚¹ï¼ˆvirtual nodeï¼‰æ¥ä»£è¡¨å®é™…çš„èŠ‚ç‚¹ï¼Œä¸€èˆ¬æ¥è¯´æ¯ä¸ªè™šæ‹ŸèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªå•ä½èŠ‚ç‚¹ï¼Œè™šæ‹ŸèŠ‚ç‚¹æ•°é‡ä¹‹å’Œç­‰äºå®é™…èŠ‚ç‚¹çš„æƒé‡ï¼›å³ä½¿ä¸åŒèŠ‚ç‚¹ä¹‹é—´çš„æƒé‡ç›¸åŒï¼Œä¹Ÿå»ºè®®å°†ä¸€ä¸ªå®é™…èŠ‚ç‚¹æ˜ å°„ä¸ºå¤šä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼Œå› ä¸ºèŠ‚ç‚¹è¶Šå¤šï¼Œå®ƒä»¬åœ¨ç¯ä¸Šçš„åˆ†å¸ƒå°±è¶Šå‡åŒ€ï¼Œå› æ­¤ä½¿ç”¨è™šæ‹ŸèŠ‚ç‚¹è¿˜å¯ä»¥é™ä½èŠ‚ç‚¹ä¹‹é—´çš„è´Ÿè½½å·®å¼‚ï¼›å‡è®¾ N0, N1, N2 ä¸‰ä¸ªèŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„æƒé‡ï¼Œé‚£ä¹ˆç”¨è™šæ‹ŸèŠ‚ç‚¹ä»£æ›¿ä¹‹ååˆ™å¤§è‡´å¦‚å›¾ï¼š\n3.2 Jump Consistent Hashing Jump Consistent Hashing è·³è·ƒä¸€è‡´æ€§å“ˆå¸Œæ˜¯ Google å‘è¡¨çš„ä¸€ä¸ªéå¸¸ç®€æ´çš„ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•ï¼Œå…¶ä¸»è¦æ€è·¯æ˜¯ï¼š\n å‡è®¾æœ‰ n ä¸ª slot å’Œ k ä¸ª keyï¼Œæ‰€æœ‰çš„ k ä¸ª key éƒ½è¢«å‡åŒ€åœ°æ˜ å°„åˆ°äº†è¿™ n ä¸ª slot ä¸Šï¼› ç°åœ¨å¢åŠ  1 ä¸ª slotï¼Œä¸ºäº†å°†åŸæœ‰çš„ k ä¸ª key å‡åŒ€åœ°æ˜ å°„åˆ° n + 1 ä¸ª slot ä¸Šï¼Œéœ€è¦å°†å…¶ä¸­ k / n + 1 ä¸ª key è¿›è¡Œé‡æ–°æ˜ å°„ï¼Œå³æ¯æ¬¡å¢åŠ  1 ä¸ª slot éƒ½éœ€è¦é‡æ–°æ˜ å°„ k / n + 1 ä¸ª keyï¼› ä½¿ç”¨**ä¼ªéšæœº**çš„æ–¹å¼ï¼ˆç»™å®šä¸€ä¸ªéšæœºç§å­ï¼Œç”Ÿæˆä¸€ä¸ªå›ºå®šçš„éšæœºåºåˆ—ï¼‰æ¥å†³å®šå“ª k / n ä¸ª key éœ€è¦è¢«é‡æ–°æ˜ å°„ï¼›  è¿™é‡Œä½¿ç”¨ä¼ªéšæœºçš„å«ä¹‰æ˜¯ï¼Œå¯¹äºæ¯ä¸€ä¸ª keyï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ª key æ¥ä½œä¸ºéšæœºç§å­ï¼Œç”Ÿæˆä¸€ä¸ªå›ºå®šçš„éšæœºåºåˆ— seqï¼Œäºæ˜¯ seq åœ¨å…¶ä¸‹æ ‡ä¸º [1, n] çš„åŒºé—´é‡Œçš„å€¼éƒ½æ˜¯å›ºå®šçš„ï¼›æ¥ä¸‹æ¥éå† seqï¼Œåœ¨æ¯ä¸€æ¬¡è¿­ä»£ i ä¸­ï¼Œå¦‚æœ seq[i] \u0026lt; 1/iï¼Œåˆ™å°†å…¶é‡æ–°åˆ†é…åˆ°ç¬¬ i ä¸ª slot ä¸Šï¼Œå¦åˆ™ä¿æŒä¸å˜ï¼›æ•´ä¸ªè¿‡ç¨‹åœ¨ç»™å®š key æ—¶å°±å·²ç»ç¡®å®šäº†ã€‚\nè¿™æ ·ä¸€æ¥å°±è¾¾æˆäº†ä¸€è‡´æ€§å“ˆå¸Œçš„å¹³è¡¡æ€§å’Œå•è°ƒæ€§ï¼Œæ²¡æœ‰ä½¿ç”¨é¢å¤–çš„å†…å­˜ï¼Œæ‰€ä»¥ç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ï¼›è€Œå› ä¸ºéå†äº† n ä¸ª slotï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œè¿˜å¯ä»¥ä»æ—¶é—´å¤æ‚åº¦çš„è§’åº¦ç»§ç»­ä¼˜åŒ–ï¼›åœ¨ seq[i] \u0026lt; 1 / i è¿™ä¸ªå…¬å¼ä¸­ï¼ˆå³è¢«é‡æ–°åˆ†é…è¿™ä¸ªå‡è®¾æˆç«‹ï¼‰ï¼Œ1 / i ä¼šéšç€ i çš„å¢å¤§è€Œå˜å¾—è¶Šæ¥è¶Šå°ï¼Œè€Œ seq[i] æ˜¯éšæœºæ•°ï¼Œå› æ­¤å¯ä»¥è®¤ä¸ºå…¬å¼æˆç«‹çš„æ¦‚ç‡ä¼šè¶Šæ¥è¶Šå°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®© i çš„æ­¥è¿›å¢å¤§ï¼Œæ¥å‡å°‘è¿­ä»£çš„æ¬¡æ•°ã€‚\nå‡è®¾å½“å‰ key æ‰€åœ¨çš„ slot æ˜¯ bï¼Œè¿­ä»£æ¬¡æ•°æ˜¯ b + 1 ï¼Œä¸‹ä¸€æ¬¡è¿­ä»£æŸä¸€ä¸ª key ä¼šè¢«é‡æ–°æ˜ å°„çš„æ¦‚ç‡æ˜¯ 1 / b + 2ï¼ˆä¸Šé¢æ€è·¯ç¬¬ 2 ç‚¹ï¼‰ï¼Œå³å…¶ä¸ä¼šè¢«é‡æ–°åˆ†é…åˆ°æ–° slot çš„æ¦‚ç‡ä¸º b + 1 / b + 2ï¼Œå†ä¸‹ä¸€æ¬¡çš„æ¦‚ç‡æ˜¯ b + 2 / b + 3ï¼Œç›´åˆ°ç¬¬ j æ¬¡çš„æ¦‚ç‡æ˜¯ j - 1 / jï¼Œå°†è¿™äº›æ¦‚ç‡ç›¸ä¹˜å¾—åˆ°åœ¨è¿™ j - b æ¬¡ä¹‹é—´ key ä¸ä¼šè¢«é‡æ–°åˆ†é…çš„æ¦‚ç‡æ˜¯ b + 1 / jï¼›å‡è®¾æŠŠ seq[i] ç”¨ r = random.next() æ¥è¡¨ç¤ºï¼Œè¦ä½¿å¾— r \u0026lt; (b + 1) / jï¼ˆå³è¢«é‡æ–°åˆ†é…è¿™ä¸ªå‡è®¾æˆç«‹ï¼‰ï¼Œå°±å¿…é¡»æœ‰ j \u0026lt; (b + 1) / rï¼Œé‚£ä¹ˆ key åœ¨æ­¥è¿›å¤§äºç­‰äº (b + 1) / r æ¬¡åä¸€å®šä¼šè¢«é‡æ–°åˆ†é…ã€‚\nè¿™æ ·ä¸€æ¥æ—¶é—´å¤æ‚åº¦å°±å‡å°‘åˆ°äº† O(ln(n))ï¼›ä½†å…¶å±€é™æ€§ä¹Ÿå¾ˆæ˜æ˜¾ï¼Œå› ä¸ºåªèƒ½é€šè¿‡æ­¥è¿›çš„æ–¹å¼æ¥é‡æ–°æ˜ å°„å’Œåˆ†é… slotï¼Œå¯¼è‡´å…¶åªèƒ½åœ¨å°¾éƒ¨å¢åˆ  slotï¼Œå¦åˆ™åœ¨ä¸­é—´è¿›è¡Œå¢åˆ çš„è¯ä¼šå¯¼è‡´å…¶åç»­çš„ slot ä¸‹æ ‡å’Œæ­¥è¿›å…³ç³»éƒ½å‘ç”Ÿå˜åŒ–ï¼Œ\nè®ºæ–‡ä¸­è¿˜å¯¹æ¯”äº†å…¶ä¸å“ˆå¸Œç¯æ³•çš„è¿è¡Œæ—¶é—´ã€‚\n3.3 Maglev Hashing Maglev æ˜¯ Google ç ”å‘çš„ä¸€ä¸ªè´Ÿè½½å‡è¡¡ç»„ä»¶ï¼Œä½¿ç”¨äº†å…¶è‡ªç ”çš„ä¸€è‡´æ€§å“ˆå¸Œç®—æ³• Maglev Hashingï¼Œå…¶ä¸»è¦æ€è·¯æ˜¯é€šè¿‡ç»´æŠ¤ä¸¤ä¸ª table æ¥å°† key æ˜ å°„åˆ° slot ä¸Šï¼›ä¸€ä¸ªè¡¨æ˜¯ lookup table æŸ¥æ‰¾è¡¨ï¼Œç”¨äºå°† key æ˜ å°„åˆ° slot ä¸Šï¼›å¦ä¸€ä¸ªè¡¨æ˜¯ permutation table æ’åˆ—è¡¨ï¼Œç”¨äºè®°å½•ä¸€ä¸ª slot åœ¨ lookup table ä¸­çš„ä½ç½®åºåˆ—ï¼š\nå¯¹äº n ä¸ª slot å’Œä¸€ä¸ªé•¿åº¦ä¸º m çš„æ˜ å°„åºåˆ—ï¼ˆå³ permutation table å’Œ lookup table çš„é•¿åº¦ï¼‰ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸ºæ¯ä¸€ä¸ªä¸‹æ ‡ä¸º i çš„ slot éƒ½è®¡ç®—å‡ºä¸€ä¸ªæ•°é‡ä¸º m çš„æ’åˆ—ï¼Œè®¡ç®—æ—¶éœ€è¦ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å“ˆå¸Œå‡½æ•° h1 å’Œ h2ï¼Œæ¥è®¡ç®— offset å’Œ skip ä¸¤ä¸ªå€¼ï¼ˆè¿™é‡Œéœ€è¦ä¿è¯æ¯ä¸€ä¸ª slot çš„ name éƒ½ä¸ç›¸åŒï¼‰ï¼š\nä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾ n = 3ï¼Œm = 7ï¼Œå¯¹äºä¸‹æ ‡ä¸º 0 çš„ slotï¼Œé€šè¿‡æŸä¸¤ä¸ªå“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºæ¥çš„ offset = 3ï¼Œskip = 4ï¼Œä¸ºå…¶ç”Ÿæˆä¸€ä¸ªé•¿åº¦ m = 7 çš„ permutationï¼š\npermutation[i][0] = (3 + 0 * 4) mod 7 = 3\rpermutation[i][1] = (3 + 1 * 4) mod 7 = 0\rpermutation[i][2] = (3 + 2 * 4) mod 7 = 4\rpermutation[i][3] = (3 + 3 * 4) mod 7 = 1\rpermutation[i][4] = (3 + 4 * 4) mod 7 = 5\rpermutation[i][5] = (3 + 5 * 4) mod 7 = 2\rpermutation[i][6] = (3 + 6 * 4) mod 7 = 6\rå†åŠ ä¸Šå¦å¤–ä¸¤ä¸ªè®¡ç®—å¥½ permutation çš„ä¸‹æ ‡ä¸º 1 å’Œ 2 çš„ slotï¼Œå¯¹åº”çš„ permutation tableï¼š\n   m s0 s1 s2     0 3 0 3   1 0 2 4   2 4 4 5   3 1 6 6   4 5 1 0   5 2 3 1   6 6 5 2    ç°åœ¨æˆ‘ä»¬è®© 3 ä¸ª slot è½®æµåœ°ä»å…¶ permutation ä¸­ï¼ŒæŒ‰é¡ºåºé€‰æ‹©ç¬¬ä¸€ä¸ªæ²¡æœ‰è¢«åˆ†é…çš„ keyï¼Œæ¥å¡«å……åˆ°ä¹‹åçš„ lookup table ä¸­ï¼Œæµç¨‹æ˜¯ï¼š\n s0 çš„ permutation ä¸­çš„ç¬¬ä¸€ä¸ªæ•°å­— 3 æ²¡æœ‰è¢«åˆ†é…ï¼Œé€‰æ‹© 3ï¼› s1 çš„ permutation ä¸­çš„ç¬¬ä¸€ä¸ªæ•°å­— 0 æ²¡æœ‰è¢«åˆ†é…ï¼Œé€‰æ‹© 0ï¼› s2 çš„ permutation ä¸­çš„ç¬¬ä¸€ä¸ªæ•°å­— 3 å·²ç»è¢«åˆ†é…äº†ï¼Œå¾€åéå†åˆ°æ•°å­— 4ï¼Œé€‰æ‹© 4ï¼› s0 åœ¨ permutation ä¸­å¾€åéå†ï¼Œ0 å’Œ 4 éƒ½å·²ç»è¢«åˆ†é…äº†ï¼Œé€‰æ‹© 1ï¼› s1 åœ¨ permutation ä¸­å¾€åéå†ï¼Œé€‰æ‹© 2ï¼› s2 åœ¨ permutation ä¸­å¾€åéå†ï¼Œ4 å·²ç»è¢«åˆ†é…äº†ï¼Œé€‰æ‹© 5ï¼› s0 åœ¨ permutation ä¸­å¾€åéå†ç›´åˆ°é€‰æ‹© 6ï¼›  äºæ˜¯å°±æœ‰äº† lookup tableï¼š\n   m slot     0 s1   1 s0   2 s1   3 s0   4 s2   5 s2   6 s0    è¿™ç§æ–¹æ³•ç±»ä¼¼äºå¼€æ”¾å¯»å€æ³•ä¸­çš„åŒé‡å“ˆå¸Œï¼Œé€šè¿‡ä½¿ç”¨ä¸¤ä¸ªæ— å…³çš„å“ˆå¸Œå‡½æ•°æ¥ç”Ÿæˆæ’åˆ—ï¼ˆä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–ç”Ÿæˆéšæœºæ’åˆ—çš„æ–¹æ³•ï¼Œä¾‹å¦‚ fisher-yates shuffleï¼Œå¿…é¡»ä¿è¯æ–¹æ³•çš„çš„éšæœºæ€§ï¼‰é™ä½äº†å“ˆå¸Œç¢°æ’çš„æ¦‚ç‡ï¼›åœ¨å¢åŠ æˆ–ç§»é™¤ slot æ—¶ï¼Œéœ€è¦ä¸ºæ–°çš„ slot ç”Ÿæˆ permutation tableï¼Œå†é‡æ–°ç”Ÿæˆ lookup tableï¼Œè¿™ä¼šå¯¼è‡´éƒ¨åˆ†é‡æ–°æ˜ å°„ï¼Œä¸æ»¡è¶³æœ€å°åŒ–é‡æ–°æ˜ å°„ï¼ˆminimum disruptionï¼‰ï¼›ç»´æŠ¤ä¸¤ä¸ªè¡¨çš„ç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ï¼ŒæŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(1)ï¼›å»ºç«‹è¡¨çš„å¤æ‚åº¦å¯ä»¥å‚è€ƒè®ºæ–‡çš„ç¬¬ 3.4 èŠ‚ã€‚\n4 æ€»ç»“ æœ¬æ–‡ä¸»è¦ä»‹ç»äº†è´Ÿè½½å‡è¡¡çš„æ¦‚å¿µï¼Œå¹¶ç®€å•åœ°é˜æ˜äº†ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•çš„åŸç†ï¼Œå…³äºä¸€è‡´æ€§å“ˆå¸Œç®—æ³•çš„ä¼˜ç¼ºç‚¹ã€è¾¹ç•Œæ¡ä»¶ã€å¤æ‚åº¦åˆ†æã€æ•ˆç‡å¯¹æ¯”ã€å®é™…åº”ç”¨ç­‰è¿˜éœ€è¦ç»“åˆè®ºæ–‡å’Œå¼€æºç»„ä»¶è¿›è¡Œæ›´æ·±å…¥çš„äº†è§£ã€‚\n","permalink":"http://zintrulcre.github.io/posts/service-governance/load-balancing/","summary":"è´Ÿè½½å‡è¡¡å’Œä¸€è‡´æ€§å“ˆå¸Œ åå‘ä»£ç† reverse proxy æ˜¯æŒ‡ä»¥ä»£ç†æœåŠ¡å™¨æ¥æ¥æ”¶ç”±å®¢æˆ·ç«¯å‘é€æ¥çš„è¯·æ±‚ï¼Œå¹¶é€šè¿‡ä¸€å®šçš„ç­–ç•¥å°†å…¶è½¬å˜å‘ç»™å®é™…å¤„ç†è¯·æ±‚çš„åç«¯æœåŠ¡å™¨ï¼›ä¸»è¦åº”ç”¨äºè´Ÿè½½å‡è¡¡ã€åŠ¨æ€ç¼“å­˜ã€å®‰å…¨è®¤è¯ã€å†…ç½‘ç©¿é€ã€SSL åŠ å¯†ç­‰ï¼›è€Œè´Ÿè½½å‡è¡¡ load balancing æ˜¯æŒ‡åœ¨å¤šä¸ª slotï¼ˆæ§½ï¼Œä¸€èˆ¬æ˜¯æŸç§è®¡ç®—èµ„æºï¼‰ä¸­åˆ†é…è´Ÿè½½ï¼Œä»¥ä¼˜åŒ–èµ„æºåˆ©ç”¨ç‡å’Œé¿å…å•ç‚¹æ•…éšœé—®é¢˜çš„æ–¹æ³•ï¼Œæ˜¯é«˜å¯ç”¨æ€§åˆ†å¸ƒå¼ç³»ç»Ÿçš„å¿…å¤‡ä¸­é—´ä»¶ï¼›å¸¸ç”¨çš„å¼€æº load balancer æœ‰ nginxï¼ŒLVSï¼ŒHaproxy ç­‰ï¼›è´Ÿè½½å‡è¡¡å¯ä»¥è§†ä¸ºåå‘ä»£ç†çš„ä¸€ç§åº”ç”¨ï¼Œè´Ÿè½½å‡è¡¡çš„æ–¹æ³•å¤§è‡´å¯ä»¥åˆ†ä¸ºä¼ ç»Ÿè´Ÿè½½å‡è¡¡ç®—æ³•å’Œå“ˆå¸Œç®—æ³•ä¸¤ç§ï¼Œæœ¬æ–‡ç®€å•åœ°æ€»ç»“äº†è¿™äº›ç®—æ³•çš„åŸç†ã€‚\n1 ä¼ ç»Ÿè´Ÿè½½å‡è¡¡ç®—æ³•  éšæœº randomï¼šå°† key éšæœºåˆ†é…åˆ°æŸä¸€ä¸ª slot ä¸Šï¼Œæ ¹æ®æ¦‚ç‡è®ºå¯çŸ¥ï¼Œååé‡è¶Šå¤§ï¼Œéšæœºç®—æ³•çš„æ•ˆæœè¶Šå¥½ï¼› åŠ æƒéšæœº weighted randomï¼šä¸ºæ¯ä¸€ä¸ª slot åˆ†é…ä¸€ä¸ªæƒé‡ï¼Œåœ¨éšæœºçš„æ—¶å€™è€ƒè™‘æƒé‡çš„å½±å“ï¼›å¯ä»¥é€šè¿‡åœ¨æ‰€æœ‰ slot çš„æƒé‡æ€»å’Œä¸­éšæœºå‡ºä¸€ä¸ªæ•°å­— kï¼Œæ‰¾åˆ° k æ‰€åœ¨çš„ slot ä½ç½®æ¥å®ç°ï¼› è½®è¯¢ round robinï¼šæŒ‰é¡ºåºä¾æ¬¡å°† key åˆ†é…ç»™æ¯ä¸€ä¸ª slotï¼› åŠ æƒè½®è¯¢ weighted round robinï¼šä¸ºæ¯ä¸€ä¸ª slot åˆ†é…ä¸€ä¸ªæƒé‡ï¼Œåœ¨æŒ‰åºåˆ†é…æ—¶ä¸ºæƒé‡æ›´é«˜çš„ slot åˆ†é…æ›´å¤šçš„ keyï¼› å¹³æ»‘åŠ æƒè½®è¯¢ smooth weighted round robinï¼šä¸€ç§èƒ½å¤Ÿå‡åŒ€åœ°åˆ†æ•£è°ƒåº¦åºåˆ—çš„åŠ æƒè½®è¯¢æ–¹æ³•ï¼Œåˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š  é€‰å‡ºå½“å‰æƒé‡æœ€é«˜çš„ slotï¼Œå°† key åˆ†é…ç»™å®ƒï¼› å°†é€‰å‡ºçš„ slot çš„æƒé‡æ•°å€¼å‡å»å…¶åˆå§‹æƒé‡ï¼› å°†æ‰€æœ‰ slot çš„æƒé‡æ•°å€¼éƒ½åŠ ä¸Šå®ƒä»¬çš„åŸå§‹æƒé‡ï¼› é‡å¤ä»¥ä¸Šæ­¥éª¤ï¼›   æœ€å°‘è¿æ¥æ•° least connectionsï¼šå°† key åˆ†é…ç»™å½“å‰å…·æœ‰æœ€å°‘è¿æ¥æ•°é‡çš„ slotï¼›  2 Mod-N å“ˆå¸Œ åœ¨æœ‰äº›åœºæ™¯ä¸‹ï¼Œä¼ ç»Ÿè´Ÿè½½å‡è¡¡ç®—æ³•æ— æ³•æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ï¼Œä¾‹å¦‚ï¼š","title":"è´Ÿè½½å‡è¡¡å’Œä¸€è‡´æ€§å“ˆå¸Œ"},{"content":"C++ å¹¶å‘å…¥é—¨ï¼šä»¥ LeetCode 1114 ä¸ºä¾‹ é¢˜ç›® ç›´æ¥åšé¢˜ï¼š1114 æŒ‰åºæ‰“å°\nè§£æ³• 1. std::mutex å¦‚æœä½ å¯¹ c++ 11 ç•¥ä¸ºç†Ÿæ‚‰çš„è¯ï¼Œåº”è¯¥èƒ½å¤Ÿæƒ³åˆ°ç”¨ std::mutex æ¥è§£è¿™é“é¢˜ï¼Œåœ¨å‡½æ•°æ„é€ æ—¶ï¼ˆä¸»çº¿ç¨‹ï¼‰å¯¹ std::mutex è¿›è¡Œ lockï¼Œç„¶ååœ¨å„ä¸ªçº¿ç¨‹è°ƒç”¨çš„å‡½æ•°ä¸­ä¾æ¬¡å¯¹ std::mutex å¯¹è±¡è¿›è¡Œ unlockï¼š\nclass Foo { mutex mtx1, mtx2; public: Foo() { mtx1.lock(), mtx2.lock(); } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); mtx1.unlock(); } void second(function\u0026lt;void()\u0026gt; printSecond) { mtx1.lock(); printSecond(); mtx1.unlock(); mtx2.unlock(); } void third(function\u0026lt;void()\u0026gt; printThird) { mtx2.lock(); printThird(); mtx2.unlock(); } }; Mutex å³ mutual exclusionï¼Œæ˜¯ç”¨æ¥é˜²æ­¢å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«èµ„æºå¯¹è±¡çš„æœºåˆ¶ï¼Œåœ¨åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æ‹¥æœ‰ä¸€ä¸ª mutex å¯¹è±¡ï¼Œå…¶ä»–çº¿ç¨‹è°ƒç”¨ std::mutex::lock å‡½æ•°æ—¶ä¼šé˜»å¡ç›´åˆ°å…¶è·å–é”èµ„æºã€‚\nè¿™æ®µä»£ç èƒ½å¤Ÿ acï¼Œä½†å®é™…ä¸Šè¿™ç§ä½¿ç”¨ mutex çš„æ–¹æ³•æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºæ ¹æ® c++ æ ‡å‡†ï¼Œåœ¨ä¸€ä¸ªçº¿ç¨‹å°è¯•å¯¹ä¸€ä¸ª mutex å¯¹è±¡è¿›è¡Œ unlock æ“ä½œæ—¶ï¼Œmutex å¯¹è±¡çš„æ‰€æœ‰æƒå¿…é¡»åœ¨è¿™ä¸ªçº¿ç¨‹ä¸Šï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œåº”è¯¥ç”±åŒä¸€ä¸ªçº¿ç¨‹æ¥å¯¹ä¸€ä¸ª mutex å¯¹è±¡è¿›è¡Œ lock å’Œ unlock æ“ä½œï¼Œå¦åˆ™ä¼šäº§ç”Ÿæœªå®šä¹‰è¡Œä¸ºã€‚é¢˜ç›®ä¸­æåˆ°äº† first, second, third ä¸‰ä¸ªå‡½æ•°åˆ†åˆ«æ˜¯ç”±ä¸‰ä¸ªä¸åŒçš„çº¿ç¨‹æ¥è°ƒç”¨çš„ï¼Œä½†æˆ‘ä»¬æ˜¯åœ¨ Foo å¯¹è±¡æ„é€ æ—¶ï¼ˆå¯ä»¥æ˜¯åœ¨ create è¿™å‡ ä¸ªçº¿ç¨‹çš„ä¸»çº¿ç¨‹ä¸­ï¼Œä¹Ÿå¯ä»¥æ˜¯åœ¨ä¸‰ä¸ªçº¿ç¨‹ä¸­çš„ä»»æ„ä¸€ä¸ªï¼‰å¯¹ä¸¤ä¸ª mutex å¯¹è±¡è¿›è¡Œ lock æ“ä½œçš„ï¼Œå› æ­¤ï¼Œè°ƒç”¨ first å’Œ second å‡½æ•°çš„ä¸¤ä¸ªçº¿ç¨‹ä¸­è‡³å°‘æœ‰ä¸€ä¸ªåœ¨å°è¯•è·å–å…¶ä»–çº¿ç¨‹æ‰€æ‹¥æœ‰çš„ mutex å¯¹è±¡çš„æ‰€æœ‰æƒã€‚\nå¦å¤–ï¼Œå¦‚æœéè¦è®¨è®ºè¿™ä¸ªè§£æ³•æœ‰ä»€ä¹ˆä¼˜åŒ–çš„ä½™åœ°çš„è¯ï¼Œå› ä¸º mutex å¯¹è±¡æœ¬èº«æ˜¯ä¸ä¿æŠ¤ä»»ä½•æ•°æ®çš„ï¼Œæˆ‘ä»¬åªæ˜¯é€šè¿‡ mutex çš„æœºåˆ¶æ¥ä¿æŠ¤æ•°æ®è¢«åŒæ—¶è®¿é—®ï¼Œæ‰€ä»¥æœ€å¥½ä½¿ç”¨ lock_guard æˆ–è€… unique_lock æä¾›çš„ RAII æœºåˆ¶æ¥ç®¡ç† mutex å¯¹è±¡ï¼Œè€Œä¸æ˜¯ç›´æ¥æ“ä½œ mutex å¯¹è±¡ï¼›å…¶ä¸­ lock_guard åªæ‹¥æœ‰æ„é€ å’Œææ„å‡½æ•°ï¼Œç”¨æ¥å®ç° RAII æœºåˆ¶ï¼Œè€Œ unique_lock æ˜¯ä¸€ä¸ªå®Œæ•´çš„ mutex æ‰€æœ‰æƒåŒ…è£…å™¨ï¼Œå°è£…äº†æ‰€æœ‰ mutex çš„å‡½æ•°ï¼š\nclass Foo { mutex mtx_1, mtx_2; unique_lock\u0026lt;mutex\u0026gt; lock_1, lock_2; public: Foo() : lock_1(mtx_1, try_to_lock), lock_2(mtx_2, try_to_lock) { } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); lock_1.unlock(); } void second(function\u0026lt;void()\u0026gt; printSecond) { lock_guard\u0026lt;mutex\u0026gt; guard(mtx_1); printSecond(); lock_2.unlock(); } void third(function\u0026lt;void()\u0026gt; printThird) { lock_guard\u0026lt;mutex\u0026gt; guard(mtx_2); printThird(); } }; 2. std::condition_variable std::condition_variable æ˜¯ä¸€ç§ç”¨æ¥åŒæ—¶é˜»å¡å¤šä¸ªçº¿ç¨‹çš„åŒæ­¥åŸè¯­ï¼ˆsynchronization primitiveï¼‰ï¼Œstd::condition_variable å¿…é¡»å’Œ std::unique_lock æ­é…ä½¿ç”¨ï¼š\nclass Foo { condition_variable cv; mutex mtx; int k = 0; public: void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); k = 1; cv.notify_all();\t// é€šçŸ¥å…¶ä»–æ‰€æœ‰åœ¨ç­‰å¾…å”¤é†’é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹  } void second(function\u0026lt;void()\u0026gt; printSecond) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx);\t// lock mtx  cv.wait(lock, [this](){ return k == 1; });\t// unlock mtxï¼Œå¹¶é˜»å¡ç­‰å¾…å”¤é†’é€šçŸ¥ï¼Œéœ€è¦æ»¡è¶³ k == 1 æ‰èƒ½ç»§ç»­è¿è¡Œ  printSecond(); k = 2; cv.notify_one();\t// éšæœºé€šçŸ¥ä¸€ä¸ªï¼ˆunspecifiedï¼‰åœ¨ç­‰å¾…å”¤é†’é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹  } void third(function\u0026lt;void()\u0026gt; printThird) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx);\t// lock mtx  cv.wait(lock, [this](){ return k == 2; });\t// unlock mtxï¼Œå¹¶é˜»å¡ç­‰å¾…å”¤é†’é€šçŸ¥ï¼Œéœ€è¦æ»¡è¶³ k == 2 æ‰èƒ½ç»§ç»­è¿è¡Œ  printThird(); } }; std::condition_variable::wait å‡½æ•°ä¼šæ‰§è¡Œä¸‰ä¸ªæ“ä½œï¼šå…ˆå°†å½“å‰çº¿ç¨‹åŠ å…¥åˆ°ç­‰å¾…å”¤é†’é˜Ÿåˆ—ï¼Œç„¶å unlock mutex å¯¹è±¡ï¼Œæœ€åé˜»å¡å½“å‰çº¿ç¨‹ï¼›å®ƒæœ‰ä¸¤ç§é‡è½½å½¢å¼ï¼Œç¬¬ä¸€ç§åªæ¥æ”¶ä¸€ä¸ª std::mutex å¯¹è±¡ï¼Œæ­¤æ—¶çº¿ç¨‹ä¸€æ—¦æ¥å—åˆ°å”¤é†’ä¿¡å·ï¼ˆé€šè¿‡ std::condition_variable::notify_one æˆ– std::condition_variable::notify_all è¿›è¡Œå”¤é†’ï¼‰ï¼Œåˆ™æ— æ¡ä»¶ç«‹å³è¢«å”¤é†’ï¼Œå¹¶é‡æ–° lock mutexï¼›ç¬¬äºŒç§é‡è½½å½¢å¼è¿˜ä¼šæ¥æ”¶ä¸€ä¸ªæ¡ä»¶ï¼ˆä¸€èˆ¬æ˜¯ variable æˆ–è€… std::functionï¼‰ï¼Œå³åªæœ‰å½“æ»¡è¶³è¿™ä¸ªæ¡ä»¶æ—¶ï¼Œå½“å‰çº¿ç¨‹æ‰èƒ½è¢«å”¤é†’ï¼Œå®ƒåœ¨ gcc ä¸­çš„å®ç°ä¹Ÿå¾ˆç®€å•ï¼Œåªæ˜¯åœ¨ç¬¬ä¸€ç§é‡è½½å½¢å¼ä¹‹å¤–åŠ äº†ä¸€ä¸ª while å¾ªç¯æ¥ä¿è¯åªæœ‰åœ¨æ»¡è¶³ç»™å®šæ¡ä»¶åæ‰è¢«å”¤é†’ï¼Œå¦åˆ™é‡æ–°è°ƒç”¨ wait å‡½æ•°ï¼š\ntemplate\u0026lt;typename _Predicate\u0026gt; void wait(unique_lock\u0026lt;mutex\u0026gt;\u0026amp; __lock, _Predicate __p) { while (!__p()) wait(__lock); } æ¡ä»¶å˜é‡ std::condition_variable çš„æœºåˆ¶å’Œä¿¡å·é‡ semaphore æ¯”è¾ƒç±»ä¼¼ï¼Œå®ƒä»¬éƒ½æ˜¯å»ºç«‹åœ¨ mutex çš„åŸºç¡€ä¹‹ä¸Šï¼Œç”¨äºå®ç°å¯¹å…±äº«èµ„æºçš„åŒæ­¥è®¿é—®ï¼Œç„¶è€Œå¯æƒœçš„æ˜¯ c++ æ ‡å‡†åº“ä¸­å¹¶æ²¡æœ‰ä¿¡å·é‡çš„å®ç°å’Œå°è£…ï¼Œä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥ä½¿ç”¨ c è¯­è¨€æä¾›çš„ \u0026lt;sempahore.h\u0026gt; åº“æ¥è§£é¢˜ ï¼š\n#include \u0026lt;semaphore.h\u0026gt; class Foo { private: sem_t sem_1, sem_2; public: Foo() { sem_init(\u0026amp;sem_1, 0, 0), sem_init(\u0026amp;sem_2, 0, 0); } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); sem_post(\u0026amp;sem_1); } void second(function\u0026lt;void()\u0026gt; printSecond) { sem_wait(\u0026amp;sem_1); printSecond(); sem_post(\u0026amp;sem_2); } void third(function\u0026lt;void()\u0026gt; printThird) { sem_wait(\u0026amp;sem_2); printThird(); } }; 3. std::future std::future æ˜¯ç”¨æ¥è·å–å¼‚æ­¥æ“ä½œç»“æœçš„æ¨¡æ¿ç±»ï¼›std::packaged_task, std::promise, std::async éƒ½å¯ä»¥è¿›è¡Œå¼‚æ­¥æ“ä½œï¼Œå¹¶æ‹¥æœ‰ä¸€ä¸ª std::future å¯¹è±¡ï¼Œç”¨æ¥å­˜å‚¨å®ƒä»¬æ‰€è¿›è¡Œçš„å¼‚æ­¥æ“ä½œè¿”å›æˆ–è®¾ç½®çš„å€¼ï¼ˆæˆ–å¼‚å¸¸ï¼‰ï¼Œè¿™ä¸ªå€¼ä¼šåœ¨å°†æ¥çš„æŸä¸€ä¸ªæ—¶é—´ç‚¹ï¼Œé€šè¿‡æŸç§æœºåˆ¶è¢«ä¿®æ”¹åï¼Œä¿å­˜åœ¨å…¶å¯¹åº”çš„ std::future å¯¹è±¡ä¸­ï¼š\nå¯¹äº std::promiseï¼Œå¯ä»¥é€šè¿‡è°ƒç”¨ std::promise::set_value æ¥è®¾ç½®å€¼å¹¶é€šçŸ¥ std::future å¯¹è±¡ï¼š\nclass Foo { promise\u0026lt;void\u0026gt; pro1, pro2; public: void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); pro1.set_value(); } void second(function\u0026lt;void()\u0026gt; printSecond) { pro1.get_future().wait(); printSecond(); pro2.set_value(); } void third(function\u0026lt;void()\u0026gt; printThird) { pro2.get_future().wait(); printThird(); } }; std::future\u0026lt;T\u0026gt;::wait å’Œ std::future\u0026lt;T\u0026gt;::get éƒ½ä¼šé˜»å¡åœ°ç­‰å¾…æ‹¥æœ‰å®ƒçš„ promise å¯¹è±¡è¿”å›å…¶æ‰€å­˜å‚¨çš„å€¼ï¼Œåè€…è¿˜ä¼šè·å– T ç±»å‹çš„å¯¹è±¡ï¼›è¿™é“é¢˜åªéœ€è¦åˆ©ç”¨åˆ°å¼‚æ­¥é€šä¿¡çš„æœºåˆ¶ï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰è¿”å›ä»»ä½•å®é™…çš„å€¼ã€‚\nstd::packaged_task æ˜¯ä¸€ä¸ªæ‹¥æœ‰ std::future å¯¹è±¡çš„ functorï¼Œå°†ä¸€ç³»åˆ—æ“ä½œè¿›è¡Œäº†å°è£…ï¼Œåœ¨è¿è¡Œç»“æŸä¹‹åä¼šå°†è¿”å›å€¼ä¿å­˜åœ¨å…¶æ‰€æ‹¥æœ‰çš„ std::future\u0026lt;T\u0026gt; å¯¹è±¡ä¸­ï¼›åŒæ ·åœ°ï¼Œåœ¨è¿™é“é¢˜ä¸­åªéœ€è¦åˆ©ç”¨åˆ°å…¶å‡½æ•°è¿è¡Œç»“æŸä¹‹åé€šçŸ¥ std::future å¯¹è±¡çš„æœºåˆ¶ï¼š\nclass Foo { function\u0026lt;void()\u0026gt; task = []() {}; packaged_task\u0026lt;void()\u0026gt; pt_1{ task }, pt_2{ task }; public: void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); pt_1(); } void second(function\u0026lt;void()\u0026gt; printSecond) { pt_1.get_future().wait(); printSecond(); pt_2(); } void third(function\u0026lt;void()\u0026gt; printThird) { pt_2.get_future().wait(); printThird(); } }; 4. std::atomic æˆ‘ä»¬å¹³æ—¶è¿›è¡Œçš„æ•°æ®ä¿®æ”¹éƒ½æ˜¯éåŸå­æ“ä½œï¼Œå¦‚æœå¤šä¸ªçº¿ç¨‹åŒæ—¶ä»¥éåŸå­æ“ä½œçš„æ–¹å¼ä¿®æ”¹åŒä¸€ä¸ªå¯¹è±¡å¯èƒ½ä¼šå‘ç”Ÿæ•°æ®äº‰ç”¨ï¼Œä»è€Œå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼›è€ŒåŸå­æ“ä½œèƒ½å¤Ÿä¿è¯å¤šä¸ªçº¿ç¨‹é¡ºåºè®¿é—®ï¼Œä¸ä¼šå¯¼è‡´æ•°æ®äº‰ç”¨ï¼Œå…¶æ‰§è¡Œæ—¶æ²¡æœ‰ä»»ä½•å…¶å®ƒçº¿ç¨‹èƒ½å¤Ÿä¿®æ”¹ç›¸åŒçš„åŸå­å¯¹è±¡ã€‚c++ 11 æä¾›äº† std::atomic\u0026lt;T\u0026gt; æ¨¡æ¿ç±»æ¥æ„é€ åŸå­å¯¹è±¡ï¼š\nclass Foo { std::atomic\u0026lt;bool\u0026gt; a{ false }; std::atomic\u0026lt;bool\u0026gt; b{ false }; public: void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); a = true; } void second(function\u0026lt;void()\u0026gt; printSecond) { while (!a) this_thread::sleep_for(chrono::milliseconds(1)); printSecond(); b = true; } void third(function\u0026lt;void()\u0026gt; printThird) { while (!b) this_thread::sleep_for(chrono::milliseconds(1)); printThird(); } }; å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒåŸå­æ“ä½œçš„å®ç°è·Ÿå¤„ç†å™¨å’Œæ“ä½œç³»ç»Ÿå†…æ ¸ç›¸å…³ï¼Œå› æ­¤ c++ æ ‡å‡†å¹¶æ²¡æœ‰è§„å®š atomic çš„å®ç°æ˜¯å¦æ˜¯æ— é”çš„ï¼ˆlock-freeï¼‰ï¼Œåªè§„å®šäº†éœ€è¦æä¾›ä¸€ä¸ª is_lock_free() æ¥æŸ¥è¯¢å½“å‰ç¼–è¯‘å™¨å¯¹ atomic çš„å®ç°æ˜¯å¦æ˜¯æ— é”çš„ã€‚\n","permalink":"http://zintrulcre.github.io/posts/c++/concurrency/introduction-to-concurrency/","summary":"C++ å¹¶å‘å…¥é—¨ï¼šä»¥ LeetCode 1114 ä¸ºä¾‹ é¢˜ç›® ç›´æ¥åšé¢˜ï¼š1114 æŒ‰åºæ‰“å°\nè§£æ³• 1. std::mutex å¦‚æœä½ å¯¹ c++ 11 ç•¥ä¸ºç†Ÿæ‚‰çš„è¯ï¼Œåº”è¯¥èƒ½å¤Ÿæƒ³åˆ°ç”¨ std::mutex æ¥è§£è¿™é“é¢˜ï¼Œåœ¨å‡½æ•°æ„é€ æ—¶ï¼ˆä¸»çº¿ç¨‹ï¼‰å¯¹ std::mutex è¿›è¡Œ lockï¼Œç„¶ååœ¨å„ä¸ªçº¿ç¨‹è°ƒç”¨çš„å‡½æ•°ä¸­ä¾æ¬¡å¯¹ std::mutex å¯¹è±¡è¿›è¡Œ unlockï¼š\nclass Foo { mutex mtx1, mtx2; public: Foo() { mtx1.lock(), mtx2.lock(); } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); mtx1.unlock(); } void second(function\u0026lt;void()\u0026gt; printSecond) { mtx1.lock(); printSecond(); mtx1.unlock(); mtx2.unlock(); } void third(function\u0026lt;void()\u0026gt; printThird) { mtx2.lock(); printThird(); mtx2.unlock(); } }; Mutex å³ mutual exclusionï¼Œæ˜¯ç”¨æ¥é˜²æ­¢å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«èµ„æºå¯¹è±¡çš„æœºåˆ¶ï¼Œåœ¨åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æ‹¥æœ‰ä¸€ä¸ª mutex å¯¹è±¡ï¼Œå…¶ä»–çº¿ç¨‹è°ƒç”¨ std::mutex::lock å‡½æ•°æ—¶ä¼šé˜»å¡ç›´åˆ°å…¶è·å–é”èµ„æºã€‚\nè¿™æ®µä»£ç èƒ½å¤Ÿ acï¼Œä½†å®é™…ä¸Šè¿™ç§ä½¿ç”¨ mutex çš„æ–¹æ³•æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºæ ¹æ® c++ æ ‡å‡†ï¼Œåœ¨ä¸€ä¸ªçº¿ç¨‹å°è¯•å¯¹ä¸€ä¸ª mutex å¯¹è±¡è¿›è¡Œ unlock æ“ä½œæ—¶ï¼Œmutex å¯¹è±¡çš„æ‰€æœ‰æƒå¿…é¡»åœ¨è¿™ä¸ªçº¿ç¨‹ä¸Šï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œåº”è¯¥ç”±åŒä¸€ä¸ªçº¿ç¨‹æ¥å¯¹ä¸€ä¸ª mutex å¯¹è±¡è¿›è¡Œ lock å’Œ unlock æ“ä½œï¼Œå¦åˆ™ä¼šäº§ç”Ÿæœªå®šä¹‰è¡Œä¸ºã€‚é¢˜ç›®ä¸­æåˆ°äº† first, second, third ä¸‰ä¸ªå‡½æ•°åˆ†åˆ«æ˜¯ç”±ä¸‰ä¸ªä¸åŒçš„çº¿ç¨‹æ¥è°ƒç”¨çš„ï¼Œä½†æˆ‘ä»¬æ˜¯åœ¨ Foo å¯¹è±¡æ„é€ æ—¶ï¼ˆå¯ä»¥æ˜¯åœ¨ create è¿™å‡ ä¸ªçº¿ç¨‹çš„ä¸»çº¿ç¨‹ä¸­ï¼Œä¹Ÿå¯ä»¥æ˜¯åœ¨ä¸‰ä¸ªçº¿ç¨‹ä¸­çš„ä»»æ„ä¸€ä¸ªï¼‰å¯¹ä¸¤ä¸ª mutex å¯¹è±¡è¿›è¡Œ lock æ“ä½œçš„ï¼Œå› æ­¤ï¼Œè°ƒç”¨ first å’Œ second å‡½æ•°çš„ä¸¤ä¸ªçº¿ç¨‹ä¸­è‡³å°‘æœ‰ä¸€ä¸ªåœ¨å°è¯•è·å–å…¶ä»–çº¿ç¨‹æ‰€æ‹¥æœ‰çš„ mutex å¯¹è±¡çš„æ‰€æœ‰æƒã€‚","title":"C++ å¹¶å‘å…¥é—¨ï¼šä»¥ LeetCode 1114 ä¸ºä¾‹"},{"content":"Effective C++ ç¬”è®° 0 å¯¼è¨€ 1 æ„é€ å‡½æ•° default æ„é€ å‡½æ•°ï¼šå¯è¢«è°ƒç”¨è€Œä¸å¸¦ä»»ä½•å®å‚çš„æ„é€ å‡½æ•°ï¼Œè¿™æ ·çš„æ„é€ å‡½æ•°è¦ä¹ˆæ²¡æœ‰å‚æ•°ï¼Œè¦ä¹ˆæ¯ä¸ªå‚æ•°éƒ½å¸¦æœ‰é»˜è®¤å€¼ï¼Œä¾‹å¦‚\nclass Bar { public: // explicit Bar(); // æ˜¯ default æ„é€ å‡½æ•°  // explicit Bar(int x = 0) // ä¸æ˜¯ default æ„é€ å‡½æ•°  explicit Bar(int x = 0, bool b = true); // æ˜¯ default æ„é€ å‡½æ•° private: int x; bool b; }; explicit å…³é”®å­—ï¼šé˜»æ­¢æ‰§è¡Œéšå¼ç±»å‹è½¬æ¢ï¼Œå…¶ä¼˜ç‚¹æ˜¯ç¦æ­¢äº†ç¼–è¯‘å™¨æ‰§è¡Œéé¢„æœŸçš„ç±»å‹è½¬æ¢ï¼Œä¾‹å¦‚\nvoid Foo(Bar obj); // Foo å‡½æ•°çš„å‚æ•°æ˜¯ä¸€ä¸ªç±»å‹ä¸º Bar çš„å¯¹è±¡  Bar obj_1; // æ„é€ ä¸€ä¸ª Bar ç±»å‹çš„å¯¹è±¡ Foo (obj_1); // æ²¡é—®é¢˜ï¼Œä¼ é€’ä¸€ä¸ª Bar ç±»å‹çš„å¯¹è±¡ç»™ Foo å‡½æ•° Foo (Bar()); // æ²¡é—®é¢˜ï¼Œæ„é€ ä¸€ä¸ª Bar ç±»å‹çš„å¯¹è±¡ï¼Œå¹¶ä¼ é€’ç»™ Foo å‡½æ•° Foo (2); // å¦‚æœ Bar çš„æ„é€ å‡½æ•°æ²¡æœ‰è¢«å£°æ˜ä¸º explicitï¼Œé‚£ä¹ˆä¼šè°ƒç”¨ Bar çš„æ„é€ å‡½æ•°æ„é€ ä¸€ä¸ªæˆå‘˜å˜é‡ x = 2 çš„å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯è¯´å‘ç”Ÿäº†éšå¼ç±»å‹è½¬æ¢ï¼›å¦‚æœå…¶æ„é€ å‡½æ•°è¢«å£°æ˜ä¸º explicitï¼Œé‚£ä¹ˆå°±ä¸ä¼šæ„é€ å‡º Bar ç±»å‹çš„å¯¹è±¡ copy æ„é€ å‡½æ•°ï¼šç”¨åŒç±»å‹çš„å¯¹è±¡åˆå§‹åŒ–æ–°çš„å¯¹è±¡ï¼Œå®ƒå®šä¹‰äº†ä¸€ä¸ªå¯¹è±¡å¦‚ä½• pass by referenceã€‚\ncopy assignmentï¼šæ‹·è´å¦ä¸€ä¸ªåŒç±»å‹å¯¹è±¡çš„å€¼åˆ°è‡ªèº«ï¼ŒåŒæ—¶ \u0026ldquo;=\u0026rdquo; ä¹Ÿå¯ä»¥ç”¨æ¥è°ƒç”¨ copy æ„é€ å‡½æ•°ï¼Œä¾‹å¦‚\nclass Bar { public: Bar(); // default æ„é€ å‡½æ•°  Bar(const Bar \u0026amp;rhs); // copy æ„é€ å‡½æ•°  Bar\u0026amp; operator=(const Bar \u0026amp;rhs); // copy assignment }; Bar b1; // è°ƒç”¨ default æ„é€ å‡½æ•° Bar b2(b1); // è°ƒç”¨ copy æ„é€ å‡½æ•° b1 = b2; // è°ƒç”¨ copy assignment Bar b3 = b2; // è°ƒç”¨ copy æ„é€ å‡½æ•° 0.2 æœªå®šä¹‰è¡Œä¸º int *p = nullptr; std::cout \u0026lt;\u0026lt; *p; // å¯¹ä¸€ä¸ªç©ºæŒ‡é’ˆè¿›è¡Œå–å€¼ï¼Œå¯¼è‡´ä¸ç¡®å®šè¡Œä¸º  char name[] = \u0026#34;Joel\u0026#34;; // name æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º 5 çš„ char ç±»å‹æ•°ç»„ char c = name[10]; // æŒ‡å‘ä¸€ä¸ªæ— æ•ˆçš„æ•°ç»„ç´¢å¼•ï¼Œå¯¼è‡´ä¸ç¡®å®šè¡Œä¸º 2. å°½é‡ä½¿ç”¨ const, enum, inline æ›¿æ¢#define ä½¿ç”¨ç¼–è¯‘å™¨æ›¿æ¢é¢„å¤„ç†å™¨ï¼›ä½¿ç”¨å®å®šä¹‰çš„å˜é‡åœ¨ç¼–è¯‘å™¨å¤„ç†æºç ä¹‹å‰å°±è¢«æ›¿æ¢äº†ï¼Œä»æœªè¿›å…¥è®°å·è¡¨ã€‚\n3. å°½å¯èƒ½ä½¿ç”¨ const 3.1 Iterator STL ä¸­çš„ iterator ç±»ä¼¼äºä¸€ä¸ª T* æŒ‡é’ˆï¼Œå¦‚æœå°† iterator å£°æ˜ä¸º const é‚£ä¹ˆå®é™…ä¸Šæ˜¯å£°æ˜äº†ä¸€ä¸ª T* constï¼Œå³ const pointer to Tï¼ŒæŒ‡é’ˆ T åˆå§‹åŒ–åä¸èƒ½å†æŒ‡å‘å…¶ä»–çš„å¯¹è±¡ï¼›è€Œ STL ä¸­çš„ const_iterator åˆ™æœ¬èº«å°±æ˜¯ä¸€ä¸ª const T*ï¼Œå³ pointer to const Tï¼ŒæŒ‡å‘ä¸€ä¸ª const T ç±»å‹çš„å¯¹è±¡ï¼Œå¯¹è±¡çš„å€¼ä¸èƒ½è¢«ä¿®æ”¹ï¼Œè€Œå…¶æŒ‡å‘æ˜¯å¯ä»¥è¢«ä¿®æ”¹ä¸ºå…¶ä»–å¯¹è±¡çš„ã€‚\nå¯¹äº const ç±»å‹çš„ STL å®¹å™¨ï¼Œåº”è¯¥ä½¿ç”¨ const_iterator æ¥è¿›è¡Œéå†ï¼›å¯¹äºé const ç±»å‹çš„ STL å®¹å™¨ï¼Œåº”è¯¥ä½¿ç”¨ iterator æ¥éå†ã€‚\niterator ä¸ç”¨ä½¿ç”¨ reference çš„å½¢å¼ç»‘å®šåˆ° STL::begin() ä¸Šï¼Œå› ä¸º STL::begin() è¿”å›çš„æ˜¯ä¸€ä¸ªä¸´æ—¶ pointer å˜é‡ï¼Œä¸”å¯¹äºå†…ç½®ç±»å‹å’Œ STL çš„è¿­ä»£å™¨å’Œå‡½æ•°å¯¹è±¡ï¼Œpass-by-value ä¼šæ¯” pass-by-reference æ›´é«˜æ•ˆã€‚\nä½¿ç”¨ auto éå†ä¸€ä¸ª STL å®¹å™¨æ—¶ï¼Œä¼šç›´æ¥éå†ï¼Œè€Œä¸æ˜¯ä½¿ç”¨ iterator æŒ‡é’ˆã€‚\n3.2 const å’Œ multable 4. ç¡®ä¿åœ¨ä½¿ç”¨å‰å…ˆåˆå§‹åŒ–æ•°æ® 4.1 æˆå‘˜å˜é‡åˆå§‹åŒ– å¯¹äºå†…ç½®ç±»å‹ï¼Œæ‰‹åŠ¨è¿›è¡Œåˆå§‹åŒ–ï¼Œå› ä¸º C++ ä¸ä¿è¯ä¼šåˆå§‹åŒ–å®ƒä»¬ã€‚\nå¯¹äºç±»ï¼Œåœ¨æ„é€ å‡½æ•°ä¸­å°†æ¯ä¸€ä¸ªæˆå‘˜å˜é‡åˆå§‹åŒ–ï¼Œæˆå‘˜å˜é‡çš„åˆå§‹åŒ–åŠ¨ä½œå‘ç”Ÿåœ¨è¿›å…¥æ„é€ å‡½æ•°æœ¬ä½“ä¹‹å‰ï¼Œä½¿ç”¨ member initialization list æ•ˆç‡è¾ƒé«˜ï¼Œä¸”ä¸ä¼šä¸ assignment æ··æ·†ï¼›åœ¨æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨ä¸­æ€»æ˜¯åˆ—å‡ºæ‰€æœ‰æˆå‘˜å˜é‡ï¼Œä¸”æ’åˆ—æ¬¡åºåº”è¯¥å’Œå£°æ˜æ¬¡åºç›¸åŒã€‚\n4.2 static å˜é‡ static å¯¹è±¡çš„å¯¿å‘½ä»è¢«æ„é€ å‡ºæ¥ç›´åˆ°ç¨‹åºç»“æŸä¸ºæ­¢ï¼›å†³å®š non-local static å¯¹è±¡çš„åˆå§‹åŒ–æ¬¡åºéå¸¸å›°éš¾ï¼Œå¸¸è§å½¢å¼æ˜¯ä½¿ç”¨ implicit template instantiations æ¨¡æ¿éšå¼å…·ç°åŒ–ï¼›æ¶ˆé™¤è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æ˜¯ä½¿ç”¨ local static å¯¹è±¡ï¼Œå› ä¸º local static å¯¹è±¡ä¼šåœ¨å‡½æ•°é¦–æ¬¡è¢«è°ƒç”¨æ—¶è¢«åˆå§‹åŒ–ã€‚\n5. C++ é»˜è®¤ç¼–å†™å’Œè°ƒç”¨çš„å‡½æ•° 5.1 ç±» ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ä¸ºç±»å£°æ˜ copy æ„é€ å‡½æ•°å’Œ copy assignmentï¼Œå®ƒä»¬åªå•çº¯åœ°å°†æ¥æºå¯¹è±¡çš„æ¯ä¸€ä¸ª non-static æˆå‘˜å˜é‡æ‹·è´åˆ°ç›®æ ‡å¯¹è±¡ï¼›\nç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å£°æ˜ non-virtual çš„ææ„å‡½æ•°ï¼›\nå½“æ²¡æœ‰ä»»ä½•æ„é€ å‡½æ•°æ—¶ï¼Œç¼–è¯‘å™¨ä¼šä¸ºç±»å£°æ˜ default æ„é€ å‡½æ•°ï¼›è¿™äº›å‡½æ•°éƒ½æ˜¯ inline public çš„ï¼Œå¹¶ä¸”åªæœ‰å½“è¿™äº›å‡½æ•°è¢«è°ƒç”¨çš„æ—¶å€™æ‰ä¼šè¢«ç¼–è¯‘å™¨åˆ›å»ºå‡ºæ¥ï¼Œå‰ææ˜¯ç”Ÿæˆçš„ä»£ç æ˜¯åˆæ³•çš„ï¼Œå³å¯¹äºå†…å« const æˆå‘˜çš„æˆ–åœ¨åŸºç±»ä¸­å°† copy assignment å£°æ˜ä¸º private çš„æ´¾ç”Ÿç±»æ˜¯æ— æ³•è‡ªåŠ¨ç”Ÿæˆå¯¹åº”çš„å‡½æ•°çš„ã€‚\n6. å¯¹äºä¸æƒ³ä½¿ç”¨çš„ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆçš„å‡½æ•°ï¼Œæ˜¾å¼åœ°æ‹’ç» å‡½æ•°çš„å‚æ•°åç§°ä¸ä¸€å®šéœ€è¦è¢«å†™å‡ºæ¥ã€‚\nå°† copy æ„é€ å‡½æ•°å’Œ copy assignment å£°æ˜ä¸º private å¹¶ä¸”ä¸å®ç°ï¼Œå¯ä»¥é˜²æ­¢ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆè¿™ä¸¤ä¸ªå‡½æ•°ï¼ŒåŒæ—¶é˜²æ­¢å®ƒä»¬åœ¨å¤–éƒ¨è¢«è°ƒç”¨ï¼›ä½†å¦‚æœåœ¨ member å‡½æ•°æˆ–è€… friend å‡½æ•°ä¸­è°ƒç”¨äº†ï¼Œé‚£ä¹ˆè¿æ¥å™¨ä¼šæŠ¥é”™ï¼›æˆ‘ä»¬åº”è¯¥å°½å¯èƒ½å°†è¿æ¥æœŸé”™è¯¯ç§»åŠ¨è‡³ç¼–è¯‘æœŸé”™è¯¯ï¼Œå°½æ—©æ£€æŸ¥å‡ºé”™è¯¯ã€‚\nå¯ä»¥è®¾è®¡ä¸€ä¸ªä¸“é—¨ä¸ºäº†é˜»æ­¢ copying åŠ¨ä½œä¸ºå­˜åœ¨çš„ base classï¼Œå› ä¸º base class çš„ copy å‡½æ•°å’Œ copy assignment æ˜¯ private çš„ï¼Œæ´¾ç”Ÿç±»æ— æ³•è°ƒç”¨åŸºç±»çš„ç§æœ‰æ–¹æ³•ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨ä¼šæ‹’ç»ä¸ºå­ç±»è‡ªåŠ¨ç”Ÿæˆè¿™ä¸¤ä¸ªå‡½æ•°å¹¶æŠ¥é”™\nclass Uncopyable { protected: Uncopyable(); ~Uncopyable(); private: Uncopyable(const Uncopyable \u0026amp;); Uncopyable \u0026amp; operator=(const Uncopyable \u0026amp;); } class Foo: private Uncopyable { ... } C++ 11 ä¸­å¼•å…¥äº† default å’Œ delete å…³é”®å­—ï¼Œå‰è€…å¯ä»¥è®©ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆå‡½æ•°ï¼Œåè€…å¯ä»¥ç›´æ¥ç¦æ­¢ä½¿ç”¨å‡½æ•°\nclass Foo: private Uncopyable { public: A() = default; A(const A \u0026amp;) = delete; } 7. ä¸ºå¤šæ€åŸºç±»å£°æ˜ virtual ææ„å‡½æ•° å½“æ´¾ç”Ÿç±»å¯¹è±¡ç»ç”±åŸºç±»æŒ‡é’ˆè¢«åˆ é™¤æ—¶ï¼Œå¦‚æœå…¶ææ„å‡½æ•°ä¸æ˜¯ virtual çš„ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¸ä¼šå»è™šè¡¨ä¸ŠæŸ¥æ‰¾åˆ°æ´¾ç”Ÿç±»çš„ææ„å‡½æ•°æ­£ç¡®åœ°è¿›è¡Œè°ƒç”¨ï¼Œè€Œæ˜¯åªæ‰§è¡ŒåŸºç±»çš„éƒ¨åˆ†ï¼Œé€ æˆå±€éƒ¨é”€æ¯çš„ç°è±¡ã€‚\nå½“ä¸æ„å›¾å°†ä¸€ä¸ªå‡½æ•°ä½œä¸ºåŸºç±»å®ç°å¤šæ€æ—¶ï¼Œä¸è¦å°†å®ƒçš„ææ„å‡½æ•°å£°æ˜ä¸º virtualï¼›åªæœ‰å½“ç±»ä¸­è‡³å°‘å«æœ‰ä¸€ä¸ª virtual å‡½æ•°æ—¶ï¼Œæ‰ä¸ºå…¶å£°æ˜ virtual ææ„å‡½æ•°ã€‚\næ‰€æœ‰ STL å®¹å™¨éƒ½æ²¡æœ‰ virtual ææ„å‡½æ•°ã€‚\nå¯¹äºæŠ½è±¡ç±»ï¼Œå°†å…¶ææ„å‡½æ•°å£°æ˜ä¸º pure virtualã€‚\nææ„å‡½æ•°çš„è¿ä½œæ–¹å¼æ˜¯ä»æœ€æ·±å±‚çš„æ´¾ç”Ÿç±»çš„ææ„å‡½æ•°ä¾æ¬¡è°ƒç”¨åˆ°åŸºç±»çš„ææ„å‡½æ•°ï¼Œå› æ­¤å¿…é¡»ä¸ºçº¯è™šå‡½æ•°çš„ virtual ææ„å‡½æ•°æä¾›ä¸€ä¸ªå®šä¹‰ã€‚\n8. ä¸è¦åœ¨ææ„å‡½æ•°ä¸­æŠ›å‡ºå¼‚å¸¸ åœ¨ C++ ä¸­ï¼Œå¦‚æœåŒæ—¶å­˜åœ¨ä¸¤ä¸ªå¼‚å¸¸ï¼Œç¨‹åºä¼šå‘ç”Ÿæœªå®šä¹‰è¡Œä¸ºï¼ˆæˆ–ç»“æŸæ‰§è¡Œï¼‰ã€‚\n9. ä¸è¦åœ¨æ„é€ å‡½æ•°å’Œææ„å‡½æ•°å†…è°ƒç”¨ virtual å‡½æ•° å¯¹äºä¸€ä¸ªæ´¾ç”Ÿç±»ï¼Œå…¶å¯¹è±¡åœ¨æ„é€ çš„æ—¶å€™ä¼šä»åŸºç±»çš„æ„é€ å‡½æ•°ä¸€ç›´è°ƒç”¨åˆ°æ´¾ç”Ÿç±»çš„æ„é€ å‡½æ•°ã€‚\n10. è®© oprator= è¿”å›ä¸€ä¸ª reference to *this class Foo { public: ... Foo \u0026amp;operator=(const Foo \u0026amp;rhs) { ... return *this; } } STL ä¸­çš„å®¹å™¨å‡ä½¿ç”¨è¿™ä¸ªåè®®ã€‚\n11. åœ¨ operator= ä¸­å¤„ç†è‡ªæˆ‘èµ‹å€¼ åœ¨ operator= çš„å¼€å¤´åŠ ä¸Š identity testï¼Œé˜²æ­¢å‘ç”Ÿå› ä¸ºè‡ªæˆ‘èµ‹å€¼äº§ç”Ÿçš„æŒ‡é’ˆæŒ‡å‘é—®é¢˜ï¼š\nFoo\u0026amp; Foo::operator=(const Foo \u0026amp;rhs) { if (this == \u0026amp;rhs) return *this; delete p_bm; p_bm = new Bitmap(*rhs.p_bm); return *this; } è¿™æ ·çš„å®ç°å¹¶ä¸å…·å¤‡å¼‚å¸¸å®‰å…¨æ€§ï¼Œå› ä¸º new Bitmap å¯èƒ½ä¼šå› ä¸ºå†…å­˜ä¸è¶³æˆ– copy æ„é€ å‡½æ•°å‡ºé”™å¯¼è‡´å¼‚å¸¸ã€‚\nFoo\u0026amp; Foo::operator=(const Foo \u0026amp;rhs) { Bitmap *p_bm_temp = p_bm; p_bm = new Bitmap(*rhs.p_bm); delete p_bm_temp; return *this; } 12. æ‹·è´å¯¹è±¡æ˜¯ç¡®ä¿å¤åˆ¶æ¯ä¸€ä¸ªæˆå‘˜ åœ¨ç¼–å†™ä¸€ä¸ª copyingï¼ˆåŒ…æ‹¬ copy æ„é€ å‡½æ•°å’Œ copy assignmentï¼‰å‡½æ•°æ—¶ï¼Œç¡®ä¿ï¼š1. å¤åˆ¶æ‰€æœ‰çš„ local æˆå‘˜å˜é‡ï¼›2. è°ƒç”¨æ‰€æœ‰åŸºç±»å¯¹åº”çš„ copying å‡½æ•°ã€‚\nå¦‚æœ copy æ„é€ å‡½æ•°å’Œ copy assignment æœ‰ç›¸ä¼¼çš„ä»£ç ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªæ–°çš„ private ç±»å‹çš„åˆå§‹åŒ–å‡½æ•°ä¾›å…¶å®ç”¨ã€‚\n13. ä»¥å¯¹è±¡ç®¡ç†èµ„æº è·å¾—èµ„æºåç«‹åˆ»æ”¾è¿›ç®¡ç†å¯¹è±¡ï¼Œå³èµ„æºå–å¾—æ—¶æœºä¾¿æ˜¯åˆå§‹åŒ–æ—¶æœºï¼ˆResource Acquisition Is Initialization, RAIIï¼‰ï¼Œæ€»æ˜¯åœ¨å–å¾—èµ„æºåé©¬ä¸Šç”¨å®ƒæ¥åˆå§‹åŒ–æŸä¸ªç®¡ç†å¯¹è±¡ï¼›ç®¡ç†å¯¹è±¡ä½¿ç”¨ææ„å‡½æ•°ç¡®ä¿èµ„æºè¢«é‡Šæ”¾ã€‚ä¾‹å¦‚ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆã€‚\n14. åœ¨èµ„æºç®¡ç†ç±»ä¸­å°å¿ƒ copying è¡Œä¸º 16. æˆå¯¹ä½¿ç”¨ new å’Œ delete çš„æ—¶å€™è¦é‡‡å–ç›¸åŒå½¢å¼ å•ä¸€å¯¹è±¡çš„å†…å­˜å¸ƒå±€ä¸åŒäºæ•°ç»„å¯¹è±¡çš„å†…å­˜å¸ƒå±€ï¼Œæ•°ç»„çš„å†…å­˜è¿˜åŒ…å«äº†æ•°ç»„å¤§å°çš„è®°å½•ï¼Œä»¥ä¾¿ delete çŸ¥é“éœ€è¦è°ƒç”¨å¤šå°‘æ¬¡ææ„å‡½æ•°ï¼›new[] å’Œ delete[] ä¸€å®šè¦æˆå¯¹å‡ºç°ã€‚\n4 è®¾è®¡å’Œå£°æ˜ 18. è®©æ¥å£å®¹æ˜“è¢«æ­£ç¡®ä½¿ç”¨ï¼Œä¸æ˜“è¢«è¯¯ç”¨ ä¸ä¸€è‡´æ€§å¯¹å¼€å‘äººå‘˜é€ æˆçš„å¿ƒç†å’Œç²¾ç¥ä¸Šçš„æ‘©æ“¦ä¸äº‰æ‰§ï¼Œæ²¡æœ‰ä»»ä½•ä¸€ä¸ª IDE å¯ä»¥å®Œå…¨æŠ¹é™¤ã€‚\r19. åƒè®¾è®¡ä¸€ä¸ªæ–°ç±»å‹ä¸€æ ·è®¾è®¡ class è®¾è®¡ä¸€ä¸ªæ–°çš„ class çš„æ—¶å€™éœ€è¦è€ƒè™‘çš„å› ç´ åŒ…æ‹¬ä½†ä¸é™äºï¼š\n ç±»çš„å¯¹è±¡åº”è¯¥å¦‚ä½•è¢«åˆ›å»ºå’Œé”€æ¯ - æ„é€ å‡½æ•°å’Œææ„å‡½æ•° åˆå§‹åŒ–å’Œèµ‹å€¼æœ‰ä»€ä¹ˆåŒºåˆ« - copy æ„é€ å‡½æ•°å’Œ copy assignment çš„åŒºåˆ« å¯¹è±¡è¢« pass by value æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆ - copy æ„é€ å‡½æ•°çš„è®¾è®¡ å“ªäº›æ“ä½œæ˜¯æœ‰æ•ˆçš„ - æˆå‘˜å‡½æ•°å¿…é¡»è¿›è¡Œé”™è¯¯æ£€æŸ¥ ç»§æ‰¿å›¾ç³» inheritance graph çš„çº¦æŸ - virtualï¼Œoverrideï¼Œfinalï¼Œææ„å‡½æ•°ç›¸å…³ ç±»å‹è½¬æ¢ - å®šä¹‰ç±»å‹è½¬æ¢å‡½æ•° æ“ä½œç¬¦çš„å®šä¹‰ public å’Œ private å‡½æ•°çš„åŒºåˆ† æœªå£°æ˜æ¥å£ undeclared interface æ³›å‹çš„è€ƒè™‘  20. ä½¿ç”¨ pass-by-reference-to-const æ›¿ä»£ pass-by-value å¯¹è±¡åˆ‡å‰² slicing ï¼šç”¨ä¸€ä¸ªæ´¾ç”Ÿç±»å®å‚å»åˆå§‹åŒ–ä¸€ä¸ªåŸºç±»å½¢å‚ï¼Œæ‰§è¡Œå…¶æ‹·è´æ„é€ å‡½æ•°ï¼Œå¯¼è‡´å‡½æ•°å†…çš„å‚æ•°å®é™…ä¸Šä¼šæ‰§è¡ŒåŸºç±»çš„è¡Œä¸ºã€‚\nä»¥ pass-by-reference-to-const çš„æ–¹å¼ä¼ é€’å‚æ•°å¯ä»¥é˜²æ­¢å¯¹è±¡çš„æ‹·è´æ„é€ ï¼›ä¹Ÿå¯ä»¥é¿å…å¯¹è±¡åˆ‡å‰²é—®é¢˜ï¼Œå› ä¸º pass-by-reference-to-const çš„æ–¹å¼å¯ä»¥é˜²æ­¢æ‹·è´æ„é€ çš„å‘ç”Ÿï¼Œä»è€Œæ­£ç¡®åœ°è¡¨ç°å¤šæ€ç‰¹æ€§ã€‚\nåœ¨ C++ çš„åº•å±‚ï¼Œreference ä¸€èˆ¬æ˜¯ä½¿ç”¨ pointer å®ç°çš„ï¼Œå› æ­¤ pass by reference å®é™…ä¸Šä¼ é€’çš„æ˜¯æŒ‡é’ˆï¼›å¯¹äºå†…ç½®ç±»å‹å’Œ STL çš„è¿­ä»£å™¨å’Œå‡½æ•°å¯¹è±¡ï¼Œpass-by-value ä¼šæ¯” pass-by-reference æ›´é«˜æ•ˆã€‚\n21*. å¿…é¡»è¿”å›å¯¹è±¡æ—¶ï¼Œä¸è¦è¿”å›å…¶ reference ä»»ä½•æ—¶å€™çœ‹åˆ°ä¸€ä¸ª reference å£°æ˜å¼ï¼Œä½ éƒ½åº”è¯¥ç«‹åˆ»é—®è‡ªå·±ï¼Œå®ƒçš„å¦ä¸€ä¸ªåç§°æ˜¯ä»€ä¹ˆï¼Ÿ\ræ— è®ºæ˜¯åœ¨å †è¿˜æ˜¯æ ˆä¸Šåˆ›å»ºçš„å¯¹è±¡ï¼Œä½¿ç”¨ reference è¿”å›éƒ½ä¼šé€ æˆé—®é¢˜ï¼Œå‰è€…ä¼šå‘ç”Ÿå†…å­˜æ³„æ¼ï¼Œåè€…ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚\nç»ä¸è¦è¿”å›ä¸€ä¸ªæŒ‡å‘ local stack çš„ pointer æˆ– referenceï¼Œæˆ–è¿”å› reference æŒ‡å‘ä¸€ä¸ª heap-allocated å¯¹è±¡ï¼Œæˆ–è¿”å›ä¸€ä¸ªæŒ‡å‘ local static çš„ pointer æˆ– referenceã€‚\r22*. å°†æˆå‘˜å˜é‡å£°æ˜ä¸º private å°†æˆå‘˜å˜é‡éšè—åœ¨å‡½æ•°æ¥å£çš„èƒŒåï¼Œå¯ä»¥ä¸ºâ€œæ‰€æœ‰å¯èƒ½çš„å®ç°â€æä¾›å¼¹æ€§ã€‚ä¾‹å¦‚è¿™å¯ä»¥ä½¿å¾—æˆå‘˜å˜é‡åœ¨è¢«è¯»æˆ–è¢«å†™æ—¶è½»æ¾é€šçŸ¥å…¶ä»–å¯¹è±¡ï¼Œå¯ä»¥éªŒè¯ class çš„çº¦æŸæ¡ä»¶ä»¥åŠå‡½æ•°çš„å‰æå’Œäº‹åçŠ¶æ€ï¼Œå¯ä»¥åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­æ‰§è¡ŒåŒæ­¥æ§åˆ¶ç­‰ç­‰ã€‚\rä»å°è£…çš„è§’åº¦å‡ºå‘ï¼Œåªæœ‰ä¸¤ç§è®¿é—®æƒé™ï¼šprivateï¼ˆæä¾›å°è£…ï¼‰å’Œå…¶ä»–ï¼ˆä¸æä¾›å°è£…ï¼‰ï¼›protected å¹¶ä¸æ¯” public æ›´æœ‰å°è£…æ€§ï¼Œå› ä¸ºæ— è®ºä¿®æ”¹ protected å˜é‡æˆ–æ˜¯ public å˜é‡ï¼Œéƒ½ä¼šæœ‰å¤§é‡ä»£ç å—åˆ°ç ´åã€‚\n23. å°½é‡ä½¿ç”¨ non-memberï¼Œnon-friend æ›¿æ¢ member å‡½æ•° å°†æ‰€æœ‰éå†å‡½æ•°æ”¾åœ¨å¤šä¸ªå¤´æ–‡ä»¶å†…ï¼Œä½†éš¶å±äºåŒä¸€ä¸ªå‘½åç©ºé—´ï¼Œæ„å‘³ç€å®¢æˆ·å¯ä»¥è½»æ¾æ‰©å±•è¿™ä¸€ç»„éå†å‡½æ•°ï¼Œä»–ä»¬éœ€è¦åšçš„å°±æ˜¯æ·»åŠ æ›´å¤š non-member non-friend å‡½æ•°åˆ°æ­¤å‘½åç©ºé—´ä¸­ã€‚\rå°½é‡ä½¿ç”¨ non-memberï¼Œnon-friend æ›¿æ¢ member å‡½æ•°ï¼Œå¯ä»¥å¢åŠ å°è£…æ€§ï¼ŒåŒ…è£¹å¼¹æ€§ packaging flexibilityï¼Œå’Œæœºèƒ½æ‰©å……æ€§ã€‚\n24. å¦‚æœæ‰€æœ‰å‚æ•°éƒ½éœ€è¦ç±»å‹è½¬æ¢ï¼Œé‚£ä¹ˆå°†è¿™ä¸ªå‡½æ•°è®¾ç½®ä¸º non-member 25. æ”¯æŒä¸€ä¸ªä¸æŠ›å‡ºå¼‚å¸¸çš„ swap å‡½æ•° æ‰€æœ‰ STL å®¹å™¨éƒ½æä¾› public swap å‡½æ•°å’Œ std::swap çš„ç‰¹åŒ–ç‰ˆæœ¬ã€‚\n5. å®ç° Implementation å¤ªå¿«å®šä¹‰å˜é‡å¯èƒ½é€ æˆæ•ˆç‡ä¸Šçš„æ‹–å»¶ï¼›è¿‡åº¦ä½¿ç”¨è½¬å‹ cast å¯èƒ½å¯¼è‡´ä»£ç å˜æ…¢åˆéš¾ç»´æŠ¤ï¼Œåˆæ‹›æ¥å¾®å¦™éš¾è§£çš„é”™è¯¯ï¼›è¿”å›å¯¹è±¡å†…éƒ¨æ•°æ®çš„å¥æŸ„ handle å¯èƒ½ä¼šç ´åå°è£…æ€§å¹¶ç•™ç»™å®¢æˆ·æ‚¬ç©ºå¥æŸ„ dangling handleï¼›æœªè€ƒè™‘å¼‚å¸¸å¸¦æ¥çš„å†²å‡»å¯èƒ½å¯¼è‡´èµ„æºæ³„æ¼å’Œæ•°æ®è…åï¼›è¿‡åº¦çƒ­å¿ƒåœ° inlining å¯èƒ½å¼•èµ·ä»£ç è†¨èƒ€ï¼›è¿‡åº¦è€¦åˆ coupling å¯èƒ½å¯¼è‡´å†—é•¿æ„å»ºæ—¶é—´ build timeã€‚\r26. å°½é‡å»¶åå˜é‡å®šä¹‰åœ°å‡ºç° å»¶åå˜é‡çš„å®šä¹‰ï¼Œç›´åˆ°ä¸å¾—ä¸ä½¿ç”¨å®ƒçš„å‰ä¸€åˆ»ä¸ºæ­¢ï¼Œå¦åˆ™éœ€è¦æ‰¿å—é¢å¤–çš„æ„é€ å’Œææ„æˆæœ¬ï¼Œä»¥åŠæ— æ„ä¹‰åœ° default æ„é€ è¡Œä¸ºã€‚\nå¯¹äºéœ€è¦åœ¨å¾ªç¯å†…åå¤ä½¿ç”¨çš„\n27. å°‘ä½¿ç”¨è½¬å‹ C++ é£æ ¼çš„ç±»å‹è½¬æ¢æœ‰å››ç§ï¼š\n const_castï¼šå°†å¯¹è±¡çš„å¸¸é‡æ€§ç§»é™¤ dynamic_castï¼šæ‰§è¡Œå®‰å…¨å‘ä¸‹è½¬å‹ safe downcastingï¼Œç”¨æ¥å†³å®šå¯¹è±¡æ˜¯å¦å½’å±ç»§æ‰¿ä½“ç³»ä¸­çš„æŸä¸ªç±»å‹ï¼›å®ƒæ— æ³•ç”± C é£æ ¼çš„ç±»å‹è½¬æ¢æ‰§è¡Œï¼Œä½†å¯èƒ½è€—è´¹å¾ˆå¤§æˆæœ¬ reinterpret_castï¼šæ‰§è¡Œä½çº§è½¬å‹ï¼Œå…¶åŠ¨ä½œå’Œç»“æœå¯èƒ½å–å†³äºç¼–è¯‘å™¨ static_castï¼šæ‰§è¡Œéšå¼è½¬æ¢ï¼Œä¾‹å¦‚å°† non-const è½¬ä¸º const å¯¹è±¡ï¼Œæˆ–å°† int è½¬ä¸º double  C++ é£æ ¼çš„ç±»å‹è½¬æ¢æ›´å¥½ï¼ŒåŸå› æ˜¯ï¼š\n æ›´å®¹æ˜“è¢«è¾¨è¯† æ¯ç§è½¬å‹åŠ¨ä½œæœ‰æ›´æ˜ç¡®çš„æ„ä¹‰ï¼Œæ˜“äºè°ƒè¯•  ä»»ä½•ä¸€ä¸ªç±»å‹è½¬æ¢éƒ½ä¼šè®©ç¼–è¯‘å™¨ç¼–è¯‘å‡ºè¿è¡ŒæœŸçš„æ‰§è¡Œç \n28. é¿å…è¿”å›æŒ‡å‘å¯¹è±¡å†…éƒ¨æˆå‘˜çš„ handle å¯¹è±¡çš„å†…éƒ¨ä¸åªæœ‰æˆå‘˜å˜é‡ï¼Œè¿˜æœ‰ä¸è¢«å…¬å¼€çš„æˆå‘˜å‡½æ•°ï¼Œç»ä¸åº”è¯¥è¿”å›ä¸€ä¸ªæŒ‡å‘â€œè®¿é—®çº§åˆ«è¾ƒä½â€çš„æˆå‘˜å‡½æ•°ã€‚\né¿å…è¿”å›æŒ‡å‘å¯¹è±¡å†…éƒ¨æˆå‘˜çš„ handleï¼Œå¯ä»¥å¢åŠ å°è£…æ€§ï¼Œä½¿å¾— const æˆå‘˜å‡½æ•°çš„è¡Œä¸ºæ˜¯çœŸæ­£çš„ constï¼Œä¹Ÿèƒ½é™ä½å‡ºç°æ‚¬ç©ºæŒ‡é’ˆçš„å¯èƒ½æ€§ã€‚\n29. åŠªåŠ›å†™å‡ºå¼‚å¸¸å®‰å…¨çš„ä»£ç  å½“å¼‚å¸¸è¢«æŠ›å‡ºæ—¶ï¼Œå¸¦æœ‰å¼‚å¸¸å®‰å…¨æ€§çš„å‡½æ•°ä¼šï¼š\n ä¸æ³„éœ²ä»»ä½•èµ„æºï¼Œå³ä¸å› ä¸ºæµç¨‹é˜»å¡è€Œå¯¼è‡´å…¶åçš„èµ„æºæœªè¢«é‡Šæ”¾ ä¸å…è®¸æ•°æ®è´¥åï¼Œå³ä¸å…è®¸æ‚¬ç©ºæŒ‡é’ˆçš„å‡ºç°  å¼‚å¸¸å®‰å…¨å‡½æ•°æä¾›ä»¥ä¸‹ä¸‰ä¸ªä¿è¯ä¹‹ä¸€ï¼š\n åŸºæœ¬ä¿è¯ï¼šå¼‚å¸¸æŠ›å‡ºæ—¶ï¼Œæ²¡æœ‰å¯¹è±¡æˆ–æ•°æ®ç»“æ„è¢«ç ´åï¼Œæ‰€æœ‰å¯¹è±¡éƒ½å¤„äºå‰åä¸€è‡´çš„çŠ¶æ€ å¼ºçƒˆä¿è¯ï¼šå¦‚æœæŠ›å‡ºå¼‚å¸¸ï¼Œç¨‹åºçŠ¶æ€ä¸æ”¹å˜ï¼›å¦‚æœç¨‹åºå¤±è´¥ï¼Œç¨‹åºä¼šæ¢å¤åˆ°è°ƒç”¨å‡½æ•°å‰çš„çŠ¶æ€ ä¸æŠ›å¼‚å¸¸ä¿è¯ï¼šç¨‹åºä¿è¯ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œå› ä¸ºå®ƒæ€»èƒ½å¤Ÿå®ŒæˆåŸå…ˆæ‰¿è¯ºçš„åŠŸèƒ½  30. ç†è§£ inlining åœ¨ä¸€å°å†…å­˜æœ‰é™çš„æœºå™¨ä¸Šï¼Œè¿‡åº¦çƒ­è¡·äº inlining ä¼šå¯¼è‡´ç¨‹åºä½“ç§¯è¿‡å¤§ï¼›å³ä½¿æ‹¥æœ‰è™šæ‹Ÿå†…å­˜ï¼Œinlining é€ æˆçš„ä»£ç è†¨èƒ€ä¹Ÿä¼šå¯¼è‡´é¢å¤–çš„æ¢é¡µ paging è¡Œä¸ºï¼Œé™ä½æŒ‡ä»¤é«˜é€Ÿç¼“å­˜è£…ç½®çš„å‡»ä¸­ç‡ instruction cache hit rateï¼Œä»¥åŠä¼´éšè€Œæ¥çš„æ•ˆç‡æŸå¤±\rinline å¯ä»¥éšå–»æå‡ºï¼Œä¾‹å¦‚å°†å‡½æ•°å®šä¹‰äº class çš„å®šä¹‰å†…éƒ¨ã€‚\ninline å‡½æ•°ä¸€èˆ¬è¢«æ”¾åœ¨å¤´æ–‡ä»¶å†…ï¼Œå› ä¸º inlining åœ¨å¤§å¤šæ•° C+ ç¨‹åºä¸­æ˜¯ç¼–è¯‘æœŸè¡Œä¸ºï¼Œè€Œç¼–è¯‘å™¨ä¸ºäº†å°†å‡½æ•°è°ƒç”¨æ›¿æ¢ä¸ºè¢«è°ƒç”¨å‡½æ•°çš„æœ¬ä½“ï¼Œç¼–è¯‘å™¨éœ€è¦çŸ¥é“å‡½æ•°çš„å…·ä½“å®ç°ã€‚template ä¹Ÿæ˜¯å¦‚æ­¤ã€‚\nå°†å¤§å¤šæ•° inlining é™åˆ¶åœ¨å°å‹ä¸”è¢«é¢‘ç¹è°ƒç”¨çš„å‡½æ•°ä¸Šï¼Œå¯ä»¥ä½¿å¾—è°ƒè¯•å’ŒäºŒè¿›åˆ¶å‡çº§æ›´å®¹æ˜“ï¼Œä¹Ÿå¯ä»¥ä½¿å¾—æ½œåœ¨çš„ä»£ç è†¨èƒ€é—®é¢˜æœ€å°åŒ–ï¼Œå¹¶æå‡ç¨‹åºè¿è¡Œé€Ÿåº¦ã€‚\n31. å°†æ–‡ä»¶é—´çš„ç¼–è¯‘ä¾å­˜å…³ç³»é™è‡³æœ€ä½ #include åœ¨å®šä¹‰æ–‡ä»¶å’ŒåŒ…å«æ–‡ä»¶ä¹‹é—´å½¢æˆäº†ç¼–è¯‘ä¾å­˜å…³ç³» compilation dependencyï¼Œå¦‚æœå¤´æ–‡ä»¶ä¸­çš„ä»»ä½•ä¸€ä¸ªè¢«æ”¹å˜ï¼Œæˆ–å¤´æ–‡ä»¶æ‰€ä¾èµ–çš„å…¶ä»–å¤´æ–‡ä»¶æœ‰æ”¹å˜ï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ªåŒ…å«æœ‰è¯¥å¤´æ–‡ä»¶çš„æ–‡ä»¶éƒ½ä¼šé‡æ–°ç¼–è¯‘ï¼Œä»»ä½•ä½¿ç”¨è¯¥æ–‡ä»¶ä¸­å®šä¹‰çš„ç±»å’Œå‡½æ•°çš„æ–‡ä»¶ä¹Ÿéœ€è¦é‡æ–°ç¼–è¯‘ï¼Œè¿™è¢«å«åšè¿ä¸²ç¼–è¯‘ä¾å­˜å…³ç³» cascading compilation dependenciesã€‚\nå½“ç¼–è¯‘å™¨çœ‹åˆ°å®šä¹‰æ—¶ï¼Œå®ƒå¿…é¡»çŸ¥é“è¦åˆ†é…å¤šå°‘å†…å­˜ã€‚\n6. ç»§æ‰¿å’Œé¢å‘å¯¹è±¡è®¾è®¡ 32. ç¡®ä¿ public ç»§æ‰¿æ˜¯ is-a å…³ç³» é€‚ç”¨äº base class çš„æ¯ä¸€ä¸ªå‡½æ•°å’Œå¯¹è±¡ä¹Ÿä¸€å®šé€‚ç”¨äº derived classã€‚\n33. é¿å…é®æŒ¡ç»§æ‰¿å¾—æ¥çš„åç§° å†…å±‚ä½œç”¨åŸŸçš„åç§°ä¼šé®æŒ¡å¤–éƒ¨ä½œç”¨åŸŸçš„åç§°ï¼Œå½“ç¼–è¯‘å™¨å¤„äºä¸€ä¸ªä½œç”¨åŸŸå†…çš„æ—¶å€™ï¼Œä¼šå…ˆåœ¨ local ä½œç”¨åŸŸå†…æŸ¥æ‰¾æ˜¯å¦æœ‰å¯¹åº”çš„å˜é‡åç§°ï¼Œå¦‚æœæ²¡æœ‰æ‰ä¼šå»å…¶ä»–ä½œç”¨åŸŸæ‰¾ã€‚\nå¯ä»¥ä½¿ç”¨ using å…³é”®å­—æ˜¾å¼åœ°å£°æ˜å…¶ä»–ä½œç”¨åŸŸçš„å˜é‡å’Œå‡½æ•°ï¼Œä½¿å¾—å®ƒä»¬åœ¨å½“å‰ä½œç”¨åŸŸå¯è§ã€‚\n34. åŒºåˆ†æ¥å£ç»§æ‰¿å’Œå®ç°ç»§æ‰¿ ä¸åŒç±»å‹æˆå‘˜å‡½æ•°çš„ç›®çš„ï¼š\n çº¯è™šå‡½æ•°ï¼šè®©æ´¾ç”Ÿç±»ç»§æ‰¿å‡½æ•°çš„æ¥å£ è™šå‡½æ•°ï¼šè®©æ´¾ç”Ÿç±»ç»§æ‰¿å‡½æ•°çš„æ¥å£å’Œé»˜è®¤å®ç° éè™šå‡½æ•°ï¼šè®©æ´¾ç”Ÿç±»ç»§æ‰¿å‡½æ•°çš„æ¥å£å’Œå¼ºåˆ¶æ€§å®ç°  å¦‚æœæˆå‘˜å‡½æ•°æ˜¯ä¸ªéè™šå‡½æ•°ï¼Œæ„å‘³ç€å®ƒå¹¶ä¸æ‰“ç®—åœ¨æ´¾ç”Ÿç±»ä¸­è¢« overrideï¼›éè™šå‡½æ•°ä»£è¡¨å…¶ä¸å˜æ€§ invariant å‡Œé©¾äºç‰¹å¼‚æ€§ specialization ä¹‹ä¸Šã€‚\nä¸€ä¸ªå…¸å‹çš„ç¨‹åºå‘˜æœ‰ 80% çš„æ‰§è¡Œæ—¶é—´èŠ±åœ¨ 20% çš„ä»£ç ä¸Šï¼›å®ƒæ„å‘³ç€ï¼Œå¹³å‡è€Œè¨€å‡½æ•°è°ƒç”¨ä¸­å¯ä»¥æœ‰ 80% æ˜¯ virtual è€Œä¸å†²å‡»ç¨‹åºçš„å¤§ä½“æ•ˆç‡ï¼Œæ‰€ä»¥åœ¨æ‹…å¿ƒ virtual å‡½æ•°çš„æˆæœ¬ä¹‹å‰ï¼Œå…ˆå°†å¿ƒåŠ›æ”¾åœ¨ 20% çš„ä»£ç ä¸Šã€‚\r35. è€ƒè™‘ virtual å‡½æ•°ä»¥å¤–çš„å…¶ä»–é€‰æ‹©  é€šè¿‡ non-virtual interface å®ç°æ¨¡æ¿æ–¹æ³•æ¨¡å¼  éè™šæ¥å£ non-virtual interface (NVI)ï¼šä½¿å®¢æˆ·é€šè¿‡ public non-virtual æˆå‘˜å‡½æ•°é—´æ¥è°ƒç”¨ private virtual å‡½æ•°ï¼Œå®ƒæ˜¯æ‰€è°“çš„æ¨¡æ¿æ–¹æ³•æ¨¡å¼çš„ä¸€ä¸ªç‹¬ç‰¹è¡¨ç°å½¢å¼ï¼ŒæŠŠè¿™ä¸ª public non-virtual å‡½æ•°ç§°ä¸º virtual å‡½æ•°çš„åŒ…è£…å™¨ wrapperã€‚\né€šè¿‡ function pointer å®ç°ç­–ç•¥æ¨¡å¼  36. ç»ä¸é‡æ–°å®šä¹‰é€šè¿‡ç»§æ‰¿å¾—æ¥çš„éè™šå‡½æ•° éè™šå‡½æ•°æ˜¯é™æ€ç»‘å®šçš„ï¼Œè¢«è°ƒç”¨å‡½æ•°ä¸æŒ‡é’ˆæœ¬èº«ç±»å‹å¯¹åº”ï¼›è™šå‡½æ•°æ˜¯åŠ¨æ€ç»‘å®šçš„ï¼Œè¢«è°ƒç”¨å‡½æ•°ä¸æŒ‡é’ˆæ‰€æŒ‡å¯¹è±¡ç±»å‹å¯¹åº”ã€‚\n37. ç»ä¸é‡æ–°å®šä¹‰é€šè¿‡ç»§æ‰¿å¾—æ¥çš„é»˜è®¤å‚æ•°å€¼  é™æ€ç±»å‹ï¼šåœ¨ç¨‹åºä¸­è¢«å£°æ˜æ—¶æ‰€é‡‡ç”¨çš„ç±»å‹ åŠ¨æ€ç±»å‹ï¼šæŒ‡é’ˆå®é™…æ‰€æŒ‡å‘çš„ç±»å‹ï¼›åŠ¨æ€ç±»å‹å¯ä»¥è¡¨ç°å‡ºä¸€ä¸ªå¯¹è±¡å°†æœ‰ä»€ä¹ˆè¡Œä¸ºï¼Œä¸”åŠ¨æ€ç±»å‹åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å¯ä»¥æ”¹å˜  Shape *p_s; Shape *p_c = new Circle(); Shape *p_r = new Rectangle(); æ­¤å¤„ p_sï¼Œp_cï¼Œp_r ä¸‰è€…çš„é™æ€ç±»å‹éƒ½æ˜¯ Shapeï¼Œè€Œå®ƒä»¬çš„åŠ¨æ€ç±»å‹åˆ†åˆ«æ˜¯ Shapeï¼ŒCircleï¼ŒRectangle\nåœ¨ç»§æ‰¿ä¸€ä¸ªå¸¦æœ‰é»˜è®¤å‚æ•°å€¼çš„è™šå‡½æ•°æ—¶ï¼Œä¸åº”é‡æ–°å®šä¹‰å…¶é»˜è®¤å‚æ•°ï¼Œå› ä¸ºè™šå‡½æ•°æ˜¯åŠ¨æ€ç»‘å®šçš„ï¼Œè€Œé»˜è®¤å‚æ•°æ˜¯é™æ€ç»‘å®šçš„ï¼Œé»˜è®¤å‚æ•°åªä¸é™æ€ç±»å‹æœ‰å…³ã€‚\n38. é€šè¿‡ç»„åˆ composition æ„å»ºå‡º has-a æˆ– ç”±å…¶å®ç° çš„å…³ç³» åœ¨åº”ç”¨åŸŸå†…ï¼Œå¤åˆæ„å‘³ç€ has-aï¼›åœ¨å®ç°åŸŸå†…ï¼Œå¤åˆæ„å‘³ç€ is-implemented-in-terms-ofã€‚\n39. æ˜æ™ºè€Œå®¡æ…åœ°ä½¿ç”¨ private ç»§æ‰¿ private ç»§æ‰¿æ„å‘³ç€ç”±å…¶å®ç° implemented-in-terms-ofï¼Œé€šè¿‡ private ç»§æ‰¿å¾—åˆ°çš„åŸºç±»ä¸­çš„ public å’Œ protected å‡½æ•°å’Œå¯¹è±¡éƒ½æ˜¯ private çš„ã€‚\nå°½å¯èƒ½ä½¿ç”¨ç»„åˆï¼Œå¿…è¦æ—¶æ‰ä½¿ç”¨ private ç»§æ‰¿ã€‚\n40. æ˜æ™ºè€Œå®¡æ…åœ°ä½¿ç”¨å¤šé‡ç»§æ‰¿ å¤šé‡ç»§æ‰¿ä¼šå¯¼è‡´æ¯”è¾ƒå¤šçš„æ­§ä¹‰ï¼Œä¾‹å¦‚\n å¤šé‡ç»§æ‰¿çš„ä¸¤ä¸ªåŸºç±»éƒ½æœ‰ç›¸åŒç­¾åçš„å‡½æ•°ï¼šä»–ä»¬å…·æœ‰ç›¸åŒçš„åŒ¹é…ç¨‹åº¦è€Œæ²¡æœ‰æœ€ä½³åŒ¹é…ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªèµ·ä¹‰ï¼Œå¿…é¡»æ˜ç¡®æŒ‡å‡ºè¦è°ƒç”¨çš„æ˜¯å“ªä¸€ä¸ªåŸºç±»çš„å‡½æ•° è±å½¢ç»§æ‰¿ï¼šæŸä¸ªåŸºç±»åˆ°æŸä¸ªæ´¾ç”Ÿç±»ä¹‹é—´æœ‰ä¸€æ¡ä»¥ä¸Šçš„é€šè·¯ï¼Œé‚£ä¹ˆæ´¾ç”Ÿç±»é»˜è®¤å¯¹å¤šä»½åŸºç±»æ•°æ®éƒ½æ‰§è¡Œæ‹·è´ï¼Œè€Œå¦‚æœä½¿ç”¨è™šç»§æ‰¿ï¼Œé‚£ä¹ˆæ´¾ç”Ÿç±»åªä¼šä¿ç•™ä¸€ä»½æ‹·è´ï¼›æ ‡å‡†åº“ä¸­çš„ basic_iosï¼Œbasic_istreamï¼Œbasic_ostream å’Œ basic_iostream ä¹Ÿæ˜¯è±å½¢ç»§æ‰¿ä½“ç³»ï¼Œå®ƒä»¬é‡‡ç”¨çš„æ˜¯è™šç»§æ‰¿  ä¸€èˆ¬æ¥è¯´ï¼Œpublic ç»§æ‰¿éƒ½åº”è¯¥æ˜¯ virtual ç»§æ‰¿\n7. æ¨¡æ¿å’Œæ³›å‹ç¼–ç¨‹ 41. äº†è§£éšå¼æ¥å£å’Œç¼–è¯‘å™¨å¤šæ€  é¢å‘å¯¹è±¡ç¼–ç¨‹æ€»æ˜¯ä»¥æ˜¾å¼æ¥å£ explicit interface å’Œè¿è¡ŒæœŸå¤šæ€ runtime polymorphism è§£å†³é—®é¢˜ï¼Œæ˜¾å¼æ¥å£ç”±å‡½æ•°çš„ç­¾åæ„æˆ template å‚æ•°å…·æœ‰éšå¼æ¥å£ implicit interfaceï¼Œéšå¼æ¥å£ç”±æœ‰æ•ˆè¡¨è¾¾å¼ç»„æˆï¼Œä¹Ÿå°±æ˜¯å¯¹äºæ¨¡æ¿å˜é‡æ¥è¯´ï¼Œå®ƒå¿…é¡»æä¾›æ‰€éœ€çš„æˆå‘˜å‡½æ•°å’Œæ“ä½œç¬¦ï¼›template çš„å¤šæ€æ˜¯é€šè¿‡å‡½æ•°é‡è½½è§£æåœ¨ç¼–è¯‘æœŸå®Œæˆçš„  42. äº†è§£ typename çš„åŒé‡æ„ä¹‰ åœ¨ä½¿ç”¨ template æ—¶ï¼Œtypename å’Œ class æ„ä¹‰å®Œå…¨ç›¸åŒã€‚\ntemplate ä¸­ï¼Œåœ¨å‚æ•° class å†…åµŒå¥—çš„å˜é‡ç§°ä¸ºåµŒå¥—ä»å±åç§° nested dependent nameï¼Œä¸ä¾èµ–ä»»ä½•å‚æ•°çš„å˜é‡å«åšéä»å±åç§° non-dependent nameã€‚\nåµŒå¥—ä»å±åç§°å¯èƒ½å¯¼è‡´è§£æå›°éš¾ï¼Œç¼–è¯‘å™¨åœ¨è§£ææ—¶ï¼Œå¦‚æœé‡åˆ° template ä¸­æœ‰ä¸€ä¸ªåµŒå¥—ä»å±åç§°ï¼Œä¼šä¾¿å‡è®¾è¿™ä¸ªåç§°ä¸æ˜¯ä¸€ä¸ªç±»å‹ï¼Œä¾‹å¦‚ï¼š\ntemplate \u0026lt;typename T\u0026gt; void Foo(const T \u0026amp;t) { T::const_iterator iter(t.begin()); // Warning: Missing \u0026#39;typename\u0026#39; prior to dependent type name \u0026#39;T::const_iterator\u0026#39; } ç¼–è¯‘å™¨ä¼šå‡è®¾ T::const_iterator ä¸æ˜¯ä¸€ä¸ªç±»å‹ï¼Œæ‰€ä»¥ä¼šå‘å‡º warningï¼Œåªéœ€è¦åœ¨å…¶å‰é¢åŠ ä¸Šå…³é”®å­— typename å³å¯ï¼›ä½† typename ä¸èƒ½å‡ºç°åœ¨åŸºç±»åˆ—è¡¨ä¸­ï¼Œä¹Ÿä¸èƒ½åœ¨æˆå‘˜åˆå§‹åˆ— member initialization list ä¸­ä½œä¸ºåŸºç±»ä¿®é¥°ç¬¦ï¼Œä¾‹å¦‚ï¼š\ntemplate \u0026lt;typename T\u0026gt; class Derived: public Base\u0026lt;T\u0026gt;::Nested { // åŸºç±»åˆ—è¡¨ä¸­ä¸å«©ä½¿ç”¨ typename public: explicit Derived(int x):Base\u0026lt;T\u0026gt;::Nested(x) { // æˆå‘˜åˆå§‹åˆ—ä¸­ä¸èƒ½ä½¿ç”¨ typename  typename Base\u0026lt;T\u0026gt;::Nested temp; // åœ¨æ™®é€šçš„åµŒå¥—ä»å±åç§°å‰å¯ä»¥ä½¿ç”¨ typename  } }; 43. å­¦ä¼šå¤„ç†æ¨¡æ¿åŒ–åŸºç±»å†…çš„åç§° 44. å°†ä¸å‚æ•°æ— å…³çš„ä»£ç æŠ½ç¦» templates 8. è‡ªå®šä¹‰ new å’Œ delete 49. äº†è§£ new çš„è¡Œä¸º å½“ operator new æ— æ³•æ»¡è¶³å†…å­˜åˆ†é…çš„éœ€æ±‚æ—¶ï¼Œå®ƒä¼šæŠ›å‡ºå¼‚å¸¸ï¼›\nåœ¨ operator new æŠ›å‡ºå¼‚å¸¸ä¹‹å‰ï¼Œå®ƒä¼šå…ˆè°ƒç”¨é”™è¯¯å¤„ç†å‡½æ•° new-handlerï¼Œå¯ä»¥ä½¿ç”¨ std::set_new_handler æ¥è®¾ç½®è¿™ä¸ªå‡½æ•°ã€‚\n   c++ 11 operator new     throwing (1) void* operator new (std::size_t size);   nothrow (2) void* operator new (std::size_t size, const std::nothrow_t\u0026amp; nothrow_value) noexcept;   placement (3) void* operator new (std::size_t size, void* ptr) noexcept;    ä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„ new-handler åº”è¯¥å®Œæˆï¼š\n å¯åˆ†é…æ›´å¤šå†…å­˜ï¼›å¦åˆ™è°ƒç”¨å¦ä¸€ä¸ª new-handlerï¼Œæˆ–æŠ›å‡ºå¼‚å¸¸ æ•è· bad_allocï¼Œè°ƒç”¨ abort æˆ– exit  50. äº†è§£ new å’Œ delete çš„åˆç†æ›¿æ¢æ—¶é—´ æ›¿æ¢é»˜è®¤ operator new å’Œ operator delete çš„ç†ç”±ï¼š\n æ£€æµ‹è¿è¡Œæ—¶é”™è¯¯ ä¼˜åŒ–æ€§èƒ½ï¼šæé«˜åˆ†é…å’Œå½’è¿˜çš„é€Ÿåº¦ï¼Œé™ä½é¢å¤–çš„ç©ºé—´å¼€é”€ï¼Œå¼¥è¡¥éæœ€ä½³å¯¹é½ï¼ˆsuboptimal alignmentï¼‰ ç»Ÿè®¡æ•°æ®  51. ç¼–å†™ new å’Œ delete çš„æ—¶å€™éœ€è¦éµå®ˆè§„çº¦ 9. æ‚é¡¹ Miscellany 53. å…³æ³¨ç¼–è¯‘å™¨è­¦å‘Š åœ¨ç¼–è¯‘æ—¶ä½¿ç”¨ -Wall -Wextra -Werrorã€‚\n54. ç†Ÿæ‚‰ TR1 å’Œæ ‡å‡†åº“å†…å®¹ tr1 æ˜¯ 2007 å¹´æå‡ºçš„å¯¹æ ‡å‡†åº“çš„è¡¥å……ï¼ŒåŒ…æ‹¬äº† shared_ptr, function, bind, unordered_map, unordered_set, regex, tuple, array, mem_fn, reference_wrapper ç­‰å‡½æ•°å’Œç±»ï¼Œä»¥åŠ type traits, result_of ç­‰æ¨¡æ¿ã€‚\n55. ç†Ÿæ‚‰ boost ","permalink":"http://zintrulcre.github.io/posts/c++/basics/effective-cpp/","summary":"Effective C++ ç¬”è®° 0 å¯¼è¨€ 1 æ„é€ å‡½æ•° default æ„é€ å‡½æ•°ï¼šå¯è¢«è°ƒç”¨è€Œä¸å¸¦ä»»ä½•å®å‚çš„æ„é€ å‡½æ•°ï¼Œè¿™æ ·çš„æ„é€ å‡½æ•°è¦ä¹ˆæ²¡æœ‰å‚æ•°ï¼Œè¦ä¹ˆæ¯ä¸ªå‚æ•°éƒ½å¸¦æœ‰é»˜è®¤å€¼ï¼Œä¾‹å¦‚\nclass Bar { public: // explicit Bar(); // æ˜¯ default æ„é€ å‡½æ•°  // explicit Bar(int x = 0) // ä¸æ˜¯ default æ„é€ å‡½æ•°  explicit Bar(int x = 0, bool b = true); // æ˜¯ default æ„é€ å‡½æ•° private: int x; bool b; }; explicit å…³é”®å­—ï¼šé˜»æ­¢æ‰§è¡Œéšå¼ç±»å‹è½¬æ¢ï¼Œå…¶ä¼˜ç‚¹æ˜¯ç¦æ­¢äº†ç¼–è¯‘å™¨æ‰§è¡Œéé¢„æœŸçš„ç±»å‹è½¬æ¢ï¼Œä¾‹å¦‚\nvoid Foo(Bar obj); // Foo å‡½æ•°çš„å‚æ•°æ˜¯ä¸€ä¸ªç±»å‹ä¸º Bar çš„å¯¹è±¡  Bar obj_1; // æ„é€ ä¸€ä¸ª Bar ç±»å‹çš„å¯¹è±¡ Foo (obj_1); // æ²¡é—®é¢˜ï¼Œä¼ é€’ä¸€ä¸ª Bar ç±»å‹çš„å¯¹è±¡ç»™ Foo å‡½æ•° Foo (Bar()); // æ²¡é—®é¢˜ï¼Œæ„é€ ä¸€ä¸ª Bar ç±»å‹çš„å¯¹è±¡ï¼Œå¹¶ä¼ é€’ç»™ Foo å‡½æ•° Foo (2); // å¦‚æœ Bar çš„æ„é€ å‡½æ•°æ²¡æœ‰è¢«å£°æ˜ä¸º explicitï¼Œé‚£ä¹ˆä¼šè°ƒç”¨ Bar çš„æ„é€ å‡½æ•°æ„é€ ä¸€ä¸ªæˆå‘˜å˜é‡ x = 2 çš„å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯è¯´å‘ç”Ÿäº†éšå¼ç±»å‹è½¬æ¢ï¼›å¦‚æœå…¶æ„é€ å‡½æ•°è¢«å£°æ˜ä¸º explicitï¼Œé‚£ä¹ˆå°±ä¸ä¼šæ„é€ å‡º Bar ç±»å‹çš„å¯¹è±¡ copy æ„é€ å‡½æ•°ï¼šç”¨åŒç±»å‹çš„å¯¹è±¡åˆå§‹åŒ–æ–°çš„å¯¹è±¡ï¼Œå®ƒå®šä¹‰äº†ä¸€ä¸ªå¯¹è±¡å¦‚ä½• pass by referenceã€‚","title":"Effective C++ notes"},{"content":"C++ å•ä¾‹æ¨¡å¼çš„æ¨¡æ¿å®ç° å•ä¾‹æ¨¡å¼æ˜¯ä¸€ç§åˆ›å»ºå‹çš„è®¾è®¡æ¨¡å¼ï¼ˆcreational design patternsï¼‰ï¼Œä½¿ç”¨å•ä¾‹æ¨¡å¼è¿›è¡Œè®¾è®¡çš„ç±»åœ¨ç¨‹åºä¸­åªæ‹¥æœ‰ä¸€ä¸ªå®ä¾‹ï¼ˆsingle instanceï¼‰ï¼Œè¿™ä¸ªç±»ç§°ä¸ºå•ä¾‹ç±»ï¼Œå®ƒä¼šæä¾›ä¸€ä¸ªå…¨å±€çš„è®¿é—®å…¥å£ï¼ˆglobal access pointï¼‰ï¼Œå…³äºå•ä¾‹æ¨¡å¼çš„è®¨è®ºå¯ä»¥å‚è€ƒSingleton revisitedï¼›åŸºäºè¿™ä¸¤ä¸ªç‰¹ç‚¹ï¼Œå•ä¾‹æ¨¡å¼å¯ä»¥æœ‰ä»¥ä¸‹å‡ ç§å®ç°ï¼š\nMeyerâ€™s Singleton Scott Meyers åœ¨ Effective C++ çš„ Item 4: Make sure that objects are initialized before they\u0026rsquo;re used é‡Œé¢æå‡ºäº†ä¸€ç§åˆ©ç”¨ C++ çš„ static å…³é”®å­—æ¥å®ç°çš„å•ä¾‹æ¨¡å¼ï¼Œè¿™ç§å®ç°éå¸¸ç®€æ´é«˜æ•ˆï¼Œå®ƒçš„ç‰¹ç‚¹æ˜¯ï¼š\n ä»…å½“ç¨‹åºç¬¬ä¸€æ¬¡æ‰§è¡Œåˆ° GetInstance å‡½æ•°æ—¶ï¼Œæ‰§è¡Œ instance å¯¹è±¡çš„åˆå§‹åŒ–ï¼› åœ¨ C++ 11 ä¹‹åï¼Œè¢« static ä¿®é¥°çš„å˜é‡å¯ä»¥ä¿è¯æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼›  template\u0026lt;typename T\u0026gt; class Singleton { public: static T\u0026amp; GetInstance() { static T instance; return instance; } Singleton(T\u0026amp;\u0026amp;) = delete; Singleton(const T\u0026amp;) = delete; void operator= (const T\u0026amp;) = delete; protected: Singleton() = default; virtual ~Singleton() = default; }; é€šè¿‡ç¦ç”¨å•ä¾‹ç±»çš„ copy constructorï¼Œmove constructor å’Œ operator= å¯ä»¥é˜²æ­¢ç±»çš„å”¯ä¸€å®ä¾‹è¢«æ‹·è´æˆ–ç§»åŠ¨ï¼›ä¸æš´éœ²å•ä¾‹ç±»çš„ constructor å’Œ destructor å¯ä»¥ä¿è¯å•ä¾‹ç±»ä¸ä¼šé€šè¿‡å…¶ä»–é€”å¾„è¢«å®ä¾‹åŒ–ï¼ŒåŒæ—¶å°†ä¸¤è€…å®šä¹‰ä¸º protected å¯ä»¥è®©å…¶è¢«å­ç±»ç»§æ‰¿å¹¶ä½¿ç”¨ã€‚\nLazy Singleton Lazy Singleton æ˜¯ä¸€ç§æ¯”è¾ƒä¼ ç»Ÿçš„å®ç°æ–¹æ³•ï¼Œé€šè¿‡å…¶åå­—å¯ä»¥çœ‹å‡ºæ¥å®ƒä¹Ÿå…·æœ‰ lazy-evaluation çš„ç‰¹ç‚¹ï¼Œä½†åœ¨å®ç°çš„æ—¶å€™éœ€è¦è€ƒè™‘çº¿ç¨‹å®‰å…¨çš„é—®é¢˜ï¼š\ntemplate\u0026lt;typename T, bool is_thread_safe = true\u0026gt; class LazySingleton { private: static unique_ptr\u0026lt;T\u0026gt; t_; static mutex mtx_; public: static T\u0026amp; GetInstance() { if (is_thread_safe == false) { if (t_ == nullptr) t_ = unique_ptr\u0026lt;T\u0026gt;(new T); return *t_; } if (t_ == nullptr) { unique_lock\u0026lt;mutex\u0026gt; unique_locker(mtx_); if (t_ == nullptr) t_ = unique_ptr\u0026lt;T\u0026gt;(new T); return *t_; } } LazySingleton(T\u0026amp;\u0026amp;) = delete; LazySingleton(const T\u0026amp;) = delete; void operator= (const T\u0026amp;) = delete; protected: LazySingleton() = default; virtual ~LazySingleton() = default; }; template\u0026lt;typename T, bool is_thread_safe\u0026gt; unique_ptr\u0026lt;T\u0026gt; LazySingleton\u0026lt;T, is_thread_safe\u0026gt;::t_; template\u0026lt;typename T, bool is_thread_safe\u0026gt; mutex LazySingleton\u0026lt;T, is_thread_safe\u0026gt;::mtx_; æˆ‘ä»¬é€šè¿‡æ¨¡æ¿å‚æ•° is_thread_safe æ¥æ§åˆ¶è¿™ä¸ªç±»æ˜¯å¦æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå› ä¸ºåœ¨æŸäº›åœºæ™¯ä¸‹æˆ‘ä»¬ä¼šå¸Œæœ›æ¯ä¸ªçº¿ç¨‹æ‹¥æœ‰ä¸€ä¸ªå®ä¾‹ï¼š\n å½“ is_thread_safe == falseï¼Œå³éçº¿ç¨‹å®‰å…¨æ—¶ï¼Œæˆ‘ä»¬åœ¨ GetInstance å‡½æ•°ä¸­ç›´æ¥åˆ¤æ–­ï¼Œåˆå§‹åŒ–å¹¶è¿”å›å•ä¾‹å¯¹è±¡ï¼›è¿™é‡Œä½¿ç”¨äº† unique_ptr é˜²æ­¢çº¿ç¨‹é”€æ¯æ—¶å‘ç”Ÿå†…å­˜æ³„æ¼ï¼Œä¹Ÿå¯ä»¥åœ¨ææ„å‡½æ•°ä¸­é”€æ¯æŒ‡é’ˆï¼› å½“ is_thread_safe == true æ—¶ï¼Œæˆ‘ä»¬é€šè¿‡ double-checked locking æ¥è¿›è¡Œæ£€æŸ¥å¹¶åŠ é”ï¼Œé˜²æ­¢å•ä¾‹ç±»åœ¨æ¯ä¸ªçº¿ç¨‹ä¸Šéƒ½è¢«å®ä¾‹åŒ–ã€‚  Eager Singleton å’Œ Lazy Singleton ç›¸åï¼ŒEager Singleton åˆ©ç”¨ static member variable çš„ç‰¹æ€§ï¼Œåœ¨ç¨‹åºè¿›å…¥ main å‡½æ•°ä¹‹å‰è¿›è¡Œåˆå§‹åŒ–ï¼Œè¿™æ ·å°±ç»•å¼€äº†çº¿ç¨‹å®‰å…¨çš„é—®é¢˜ï¼š\ntemplate\u0026lt;typename T\u0026gt; class EagerSingleton { private: static T* t_; public: static T\u0026amp; GetInstance() { return *t_; } EagerSingleton(T\u0026amp;\u0026amp;) = delete; EagerSingleton(const T\u0026amp;) = delete; void operator= (const T\u0026amp;) = delete; protected: EagerSingleton() = default; virtual ~EagerSingleton() = default; }; template\u0026lt;typename T\u0026gt; T* EagerSingleton\u0026lt;T\u0026gt;::t_ = new (std::nothrow) T; ä½†æ˜¯å®ƒä¹Ÿæœ‰ä¸¤ä¸ªé—®é¢˜ï¼š\n å³ä½¿å•ä¾‹å¯¹è±¡ä¸è¢«ä½¿ç”¨ï¼Œå•ä¾‹ç±»å¯¹è±¡ä¹Ÿä¼šè¿›è¡Œåˆå§‹åŒ–ï¼› static initialization order fiascoï¼Œå³ t_ å¯¹è±¡å’Œ GetInstance å‡½æ•°çš„åˆå§‹åŒ–å…ˆåé¡ºåºæ˜¯ä¸å›ºå®šçš„ï¼›  Testing å°†ä¸Šé¢å®ç°çš„å››ç§ Singleton åˆ†åˆ«ç»§æ‰¿ä¸‹æ¥ä½œä¸º functor ä¼ å…¥çº¿ç¨‹å¯¹è±¡è¿›è¡Œæµ‹è¯•ï¼š\nclass Foo : public Singleton\u0026lt;Foo\u0026gt; { public: void operator() () { cout \u0026lt;\u0026lt; \u0026amp;GetInstance() \u0026lt;\u0026lt; endl; } }; class LazyFoo : public LazySingleton\u0026lt;LazyFoo, false\u0026gt; { public: void operator() () { cout \u0026lt;\u0026lt; \u0026amp;GetInstance() \u0026lt;\u0026lt; endl; } }; class ThreadSafeLazyFoo : public LazySingleton\u0026lt;ThreadSafeLazyFoo\u0026gt; { public: void operator() () { cout \u0026lt;\u0026lt; \u0026amp;GetInstance() \u0026lt;\u0026lt; endl; } }; class EagerFoo : public EagerSingleton\u0026lt;EagerFoo\u0026gt; { public: void operator() () { cout \u0026lt;\u0026lt; \u0026amp;GetInstance() \u0026lt;\u0026lt; endl; } }; void SingletonTest() { thread t1((Foo())); thread t2((Foo())); t1.join(); t2.join(); this_thread::sleep_for(chrono::milliseconds(100)); t1 = thread((LazyFoo())); t2 = thread((LazyFoo())); t1.join(); t2.join(); this_thread::sleep_for(chrono::milliseconds(100)); t1 = thread((ThreadSafeLazyFoo())); t2 = thread((ThreadSafeLazyFoo())); t1.join(); t2.join(); this_thread::sleep_for(chrono::milliseconds(100)); t1 = thread((EagerFoo())); t2 = thread((EagerFoo())); t1.join(); t2.join(); } è¾“å‡ºç»“æœä¸ºï¼š\n0x60d110 0x60d110 0x7f92380008c0 0x7f92300008c0 0x7f92300008e0 0x7f92300008e0 0x1132010 0x1132010 å¯ä»¥çœ‹åˆ°åªæœ‰ç¬¬äºŒç»„éçº¿ç¨‹å®‰å…¨çš„ LazySingleton åœ¨ä¸¤ä¸ªçº¿ç¨‹ä¸­è¾“å‡ºçš„å®ä¾‹åœ°å€æ˜¯ä¸åŒçš„ï¼Œå…¶å®ƒçš„ Singleton å‡æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚\n","permalink":"http://zintrulcre.github.io/posts/design-pattern/c++-template-singleton/","summary":"C++ å•ä¾‹æ¨¡å¼çš„æ¨¡æ¿å®ç° å•ä¾‹æ¨¡å¼æ˜¯ä¸€ç§åˆ›å»ºå‹çš„è®¾è®¡æ¨¡å¼ï¼ˆcreational design patternsï¼‰ï¼Œä½¿ç”¨å•ä¾‹æ¨¡å¼è¿›è¡Œè®¾è®¡çš„ç±»åœ¨ç¨‹åºä¸­åªæ‹¥æœ‰ä¸€ä¸ªå®ä¾‹ï¼ˆsingle instanceï¼‰ï¼Œè¿™ä¸ªç±»ç§°ä¸ºå•ä¾‹ç±»ï¼Œå®ƒä¼šæä¾›ä¸€ä¸ªå…¨å±€çš„è®¿é—®å…¥å£ï¼ˆglobal access pointï¼‰ï¼Œå…³äºå•ä¾‹æ¨¡å¼çš„è®¨è®ºå¯ä»¥å‚è€ƒSingleton revisitedï¼›åŸºäºè¿™ä¸¤ä¸ªç‰¹ç‚¹ï¼Œå•ä¾‹æ¨¡å¼å¯ä»¥æœ‰ä»¥ä¸‹å‡ ç§å®ç°ï¼š\nMeyerâ€™s Singleton Scott Meyers åœ¨ Effective C++ çš„ Item 4: Make sure that objects are initialized before they\u0026rsquo;re used é‡Œé¢æå‡ºäº†ä¸€ç§åˆ©ç”¨ C++ çš„ static å…³é”®å­—æ¥å®ç°çš„å•ä¾‹æ¨¡å¼ï¼Œè¿™ç§å®ç°éå¸¸ç®€æ´é«˜æ•ˆï¼Œå®ƒçš„ç‰¹ç‚¹æ˜¯ï¼š\n ä»…å½“ç¨‹åºç¬¬ä¸€æ¬¡æ‰§è¡Œåˆ° GetInstance å‡½æ•°æ—¶ï¼Œæ‰§è¡Œ instance å¯¹è±¡çš„åˆå§‹åŒ–ï¼› åœ¨ C++ 11 ä¹‹åï¼Œè¢« static ä¿®é¥°çš„å˜é‡å¯ä»¥ä¿è¯æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼›  template\u0026lt;typename T\u0026gt; class Singleton { public: static T\u0026amp; GetInstance() { static T instance; return instance; } Singleton(T\u0026amp;\u0026amp;) = delete; Singleton(const T\u0026amp;) = delete; void operator= (const T\u0026amp;) = delete; protected: Singleton() = default; virtual ~Singleton() = default; }; é€šè¿‡ç¦ç”¨å•ä¾‹ç±»çš„ copy constructorï¼Œmove constructor å’Œ operator= å¯ä»¥é˜²æ­¢ç±»çš„å”¯ä¸€å®ä¾‹è¢«æ‹·è´æˆ–ç§»åŠ¨ï¼›ä¸æš´éœ²å•ä¾‹ç±»çš„ constructor å’Œ destructor å¯ä»¥ä¿è¯å•ä¾‹ç±»ä¸ä¼šé€šè¿‡å…¶ä»–é€”å¾„è¢«å®ä¾‹åŒ–ï¼ŒåŒæ—¶å°†ä¸¤è€…å®šä¹‰ä¸º protected å¯ä»¥è®©å…¶è¢«å­ç±»ç»§æ‰¿å¹¶ä½¿ç”¨ã€‚","title":"C++ å•ä¾‹æ¨¡å¼çš„æ¨¡æ¿å®ç°"},{"content":"å¹¶è¡Œè®¡ç®—å…¥é—¨ 1 æ¦‚è¿° 1.1 å¹¶è¡Œè®¡ç®— é«˜æ€§èƒ½è®¡ç®—ï¼ˆHigh Performance Computingï¼‰æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„ä¸€ä¸ªé¢†åŸŸï¼Œå…¶ç›®çš„å¯ä»¥æ¦‚æ‹¬ä¸ºä¼˜åŒ–æ€§èƒ½ï¼Œå®ƒåŒ…æ‹¬äº†ç¼“å­˜æŠ€æœ¯ã€æ•°æ®ç»“æ„å’Œç®—æ³•ã€IO ä¼˜åŒ–ã€æŒ‡ä»¤é‡ç»„ï¼ˆinstruction reorganizationï¼‰ã€ç¼–è¯‘å™¨ä¼˜åŒ–ç­‰ï¼›\nå¹¶è¡Œè®¡ç®—ï¼ˆParallel Computingï¼‰æ˜¯é«˜æ€§èƒ½è®¡ç®—ä¸‹çš„ä¸€ä¸ªç»†åˆ†é¢†åŸŸï¼Œå…¶ä¸»è¦æ€æƒ³æ˜¯å°†å¤æ‚é—®é¢˜åˆ†è§£æˆè‹¥å¹²ä¸ªéƒ¨åˆ†ï¼Œå°†æ¯ä¸€ä¸ªéƒ¨åˆ†äº¤ç»™ç‹¬ç«‹çš„å¤„ç†å™¨ï¼ˆè®¡ç®—èµ„æºï¼‰è¿›è¡Œè®¡ç®—ï¼Œä»¥æé«˜æ•ˆç‡ï¼›é’ˆå¯¹ä¸åŒçš„é—®é¢˜ï¼Œå¹¶è¡Œè®¡ç®—éœ€è¦ä¸“ç”¨çš„å¹¶è¡Œæ¶æ„ï¼Œæ¶æ„æ—¢å¯ä»¥æ˜¯ä¸“é—¨è®¾è®¡çš„ï¼Œå«æœ‰å¤šä¸ªå¤„ç†å™¨çš„å•ä¸€ç¡¬ä»¶æˆ–è¶…çº§è®¡ç®—æœºï¼Œä¹Ÿå¯ä»¥æ˜¯ä»¥æŸç§æ–¹å¼äº’è¿çš„è‹¥å¹²å°çš„ç‹¬ç«‹è®¡ç®—æœºæ„æˆçš„é›†ç¾¤ï¼›å¹¶æ²¡æœ‰ä¸€ä¸ªç»Ÿä¸€çš„å¹¶è¡Œè®¡ç®—æ¶æ„é€‚ç”¨äºæ¯ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœä½¿ç”¨äº†é”™è¯¯çš„æ¶æ„ï¼Œå¹¶è¡Œè®¡ç®—ç”šè‡³ä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚\n1.2 ç¡¬ä»¶æ¶æ„ ä¸­å¤®å¤„ç†å™¨ï¼ˆCentral Processing Unitï¼‰çš„ä¸»è¦åŠŸèƒ½æ˜¯è§£é‡Šè®¡ç®—æœºæŒ‡ä»¤ï¼Œå®ƒç”±æ§åˆ¶å•å…ƒï¼ˆControl Unitï¼‰ã€ç®—æœ¯é€»è¾‘å•å…ƒï¼ˆArithmetic Logic Unitï¼‰ã€ä¹±åºæ§åˆ¶å•å…ƒï¼ˆOut-of-Order Control Unitï¼‰ã€åˆ†æ”¯é¢„æµ‹å™¨ï¼ˆBranch Predictorï¼‰ã€æ•°æ®ç¼“å­˜ï¼ˆData Cacheï¼‰ç­‰éƒ¨ä»¶ç»„æˆï¼›CPU è¢«è®¾è®¡ä¸ºå¯ä»¥å¿«é€Ÿåœ°å¤„ç†å„ç§é€šç”¨è®¡ç®—ä»»åŠ¡å¹¶æœ€å°åŒ–å»¶è¿Ÿï¼Œä½†åœ¨å¹¶å‘æ€§ï¼ˆæ—¶é’Ÿé¢‘ç‡ï¼‰æ–¹é¢å—åˆ°é™åˆ¶ï¼›\nå›¾å½¢å¤„ç†å™¨ï¼ˆGraphics Processing Unit, GPUï¼‰æ˜¯è‹±ä¼Ÿè¾¾ï¼ˆNVIDIAï¼‰åœ¨ 1999 å¹´ 8 æœˆå‘å¸ƒ NVIDIA GeForce 256 æ—¶æå‡ºçš„æ¦‚å¿µï¼›ç°ä»£ GPU çš„æ¨¡å‹è®¾è®¡å¯ä»¥æ¦‚æ‹¬ä¸ºå‡ ä¸ªå…³é”®ç‚¹ï¼š\n  GPU çš„è®¾è®¡ç›®çš„æ˜¯æœ€å¤§åŒ–ååé‡ï¼ˆThroughputï¼‰\n  èƒ½å¤Ÿå°†ç¨‹åºä¸­æ•°æ®å¯å¹¶è¡Œçš„éƒ¨åˆ†ä» CPU è½¬ç§»åˆ° GPU\n  èƒ½å¤Ÿä½¿ç”¨å°½å¯èƒ½å¤šçš„çº¿ç¨‹è¿›è¡Œå¹¶è¡Œè®¡ç®—\n  GPU æ‹¥æœ‰çš„å†…æ ¸æ•°é‡ç›¸è¾ƒäº CPU å¤šå¾—å¤šï¼Œå¯ä»¥æœ‰æ•°åƒä¸ªåŒæ—¶è¿è¡Œçš„å†…æ ¸æ‰§è¡Œå¤§è§„æ¨¡å¹¶è¡Œè®¡ç®—ï¼Œå› æ­¤åœ¨æ—©æœŸä¸“é—¨åº”ç”¨äºå›¾å½¢æ•°æ®çš„å¤„ç†ï¼Œä½†éšç€è¿‘åå‡ å¹´çš„å‘å±•ï¼Œå…¶å¼ºå¤§çš„å¹¶è¡Œå¤„ç†èƒ½åŠ›ä¹Ÿä½¿å…¶å¯ä»¥å¤„ç†éå›¾å½¢æ•°æ®ï¼Œå°¤å…¶åœ¨æ·±åº¦å­¦ä¹ é¢†åŸŸéå¸¸å—æ¬¢è¿ï¼›\nåœ¨åˆ¶é€ å·¥è‰ºçš„é™åˆ¶ä¸‹ï¼ŒèŠ¯ç‰‡çš„å¯†åº¦å’Œæœ€å¤§é¢ç§¯éƒ½æ˜¯æœ‰é™çš„ï¼ˆæ‘©å°”å®šå¾‹ï¼‰ï¼Œå› æ­¤èŠ¯ç‰‡è®¾è®¡å®é™…ä¸Šæ˜¯åŠŸèƒ½å’Œå…ƒä»¶æ•°é‡çš„æƒè¡¡ï¼›å‡ºäºå¯¹é€šç”¨æ€§çš„è¦æ±‚ï¼ŒCPU çš„èŠ¯ç‰‡è®¾è®¡å¿…é¡»ä½¿ç”¨è¾ƒå¤šç§ç±»çš„åŸä»¶ä»¥å¢åŠ å…¶åŠŸèƒ½ï¼ŒåŒæ—¶æ”¾å¼ƒéƒ¨åˆ†å…·æœ‰å¤æ‚åŠŸèƒ½çš„å…ƒä»¶æ•°é‡ï¼Œè€Œ GPU çš„èŠ¯ç‰‡è®¾è®¡åˆ™æ˜¯é€šè¿‡ç§»é™¤éƒ¨åˆ†å…·æœ‰å¤æ‚åŠŸèƒ½çš„å…ƒä»¶æ¥æ¢å–æ›´å¤šçš„ç©ºé—´ï¼Œå¹¶é›†æˆæ›´å¤šçš„åŸºæœ¬åŠŸèƒ½å…ƒä»¶ï¼›\nGPU è®¾å¤‡ç”±å¤šä¸ªæµå¤šå¤„ç†å™¨ï¼ˆStreaming Multiprocessorï¼‰çš„å¤„ç†å™¨é›†ç¾¤ï¼ˆProcessor Clusterï¼‰ç»„æˆã€‚æ¯ä¸ªæµå¤šå¤„ç†å™¨éƒ½å…³è”ä¸€ä¸ªæ§åˆ¶å•å…ƒ å’Œ L1 Cacheï¼Œè¿™æ ·çš„è®¾è®¡ä½¿å¾—ä¸€ä¸ªèŠ¯ç‰‡å¯ä»¥åŒæ—¶æ”¯æŒä¸Šç™¾ä¸ªæŒ‡ä»¤æµçš„å¹¶è¡Œæ‰§è¡Œï¼›é€šå¸¸ä¸€ä¸ªæµå¤šå¤„ç†å™¨åœ¨ä¸å…¨å±€ GDDR-5 å†…å­˜äº¤æ¢æ•°æ®ä¹‹å‰éƒ½ä¼šåˆ©ç”¨ä¸ä¹‹å…³è” L1 Cache å’Œ L2 Cache æ¥å‡å°‘æ•°æ®ä¼ è¾“çš„å»¶è¿Ÿï¼›è€Œåˆå› ä¸º GPU é€šå¸¸æ‹¥æœ‰è¶³å¤Ÿå¤§çš„è®¡ç®—é‡ï¼Œä½¿å¾—å…¶ä¸éœ€è¦ä¸ CPU ä¸€æ ·éå¸¸é¢‘ç¹åœ°ä»å†…å­˜ä¸­è·å–æ•°æ®ï¼Œå› æ­¤ GPU çš„ç¼“å­˜å±‚ä¸€èˆ¬æ˜¯å°äº CPU çš„ã€‚\nä¸ CPU ç›¸æ¯”ï¼ŒGPU å¯ä»¥ä½¿ç”¨è¾ƒå°‘ä¸”ç›¸å¯¹è¾ƒå°çš„å†…å­˜ç¼“å­˜å±‚ã€‚åŸå› æ˜¯ GPU å…·æœ‰æ›´å¤šçš„ä¸“ç”¨äºè®¡ç®—çš„æ™¶ä½“ç®¡ï¼Œè¿™æ„å‘³ç€å®ƒæ— éœ€æ‹…å¿ƒä»å†…å­˜ä¸­è·å–æ•°æ®éœ€è¦å¤šé•¿æ—¶é—´ã€‚åªè¦ GPU æ‹¥æœ‰è¶³å¤Ÿçš„è®¡ç®—é‡ï¼Œå°±å¯ä»¥æ©ç›–æ½œåœ¨çš„å†…å­˜è®¿é—® â€œç­‰å¾…æ—¶é—´â€ï¼Œä»è€Œä½¿å…¶ä¿æŒç¹å¿™çŠ¶æ€ã€‚\n2 æ¦‚å¿µ 2.1 è®¿å­˜æ¨¡å‹ å…±äº«å†…å­˜æ¨¡å‹çš„çš„è®¡ç®—æœºä¸­é€šå¸¸æœ‰éå¸¸å¤šçš„å†…æ ¸ï¼Œæ¯ä¸ªå†…æ ¸éƒ½æœ‰æœ¬åœ°çš„å¤„ç†å™¨å’Œç¼“å­˜ï¼›ç›¸å¯¹çš„ï¼Œåœ¨äº’è”ç½‘ç»œä¸Šæˆ–å…¶å®ƒç»“ç‚¹ä¸­çš„å¤„ç†å™¨å’Œå­˜å‚¨ä¸€èˆ¬ç§°ä¸ºå…¨å±€çš„ï¼›æ ¹æ®ä¸åŒçš„äº’è”ç½‘ç»œå’Œè®¿é—®å­˜å‚¨å™¨çš„æ–¹å¼ï¼Œä¸€ä¸ªå…±äº«å†…å­˜æœºå™¨å¯ä»¥è¢«åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼š\n  Uniform Memory Access\nå‡åŒ€å­˜å‚¨è®¿é—®ï¼ˆUniform Memory Access, UMAï¼‰æ¨¡å‹çš„ç‰¹ç‚¹æ˜¯æ‰€æœ‰çš„å¤„ç†å™¨éƒ½æ‹¥æœ‰æœ¬åœ°çš„é«˜é€Ÿç¼“å­˜ï¼ˆL1 Cache, L2 Cacheï¼‰ï¼Œæ‰€æœ‰çš„å¤„ç†å™¨éƒ½å‡åŒ€åœ°å…±äº«ç‰©ç†å­˜å‚¨ï¼ˆMemoryï¼‰ï¼Œå¹¶ä¸”æ¯ä¸€ä¸ªå¤„ç†å™¨è®¿é—®ä»»ä½•å­˜å‚¨å­—éƒ½éœ€è¦ç›¸åŒçš„æ—¶é—´ã€‚\n  Non-Uniform Memory Access\néå‡åŒ€å­˜å‚¨è®¿é—®ï¼ˆNon-Uniform Memory Access, NUMAï¼‰æ¨¡å‹çš„å…±äº«å­˜å‚¨å™¨åœ¨ç‰©ç†ä¸Šæ˜¯åˆ†å¸ƒå¼çš„ï¼Œæ‰€æœ‰çš„æœ¬åœ°å­˜å‚¨å™¨æ„æˆäº†å…¨å±€åœ°å€ç©ºé—´ï¼›å¤„ç†å™¨åœ¨è®¿é—®æœ¬åœ°å­˜å‚¨å™¨æ—¶çš„é€Ÿåº¦æ¯”è®¿é—®å…¨å±€å­˜å‚¨å™¨ï¼ˆå…±äº«å­˜å‚¨å™¨ï¼Œæˆ–å…¶ä»–å¤„ç†å™¨çš„æœ¬åœ°å­˜å‚¨å™¨ï¼‰å¿«ï¼Œå¤„ç†å™¨è®¿é—®å†…å­˜çš„æ—¶é—´å–å†³äºå†…å­˜ç›¸å¯¹äºå¤„ç†å™¨çš„ä½ç½®ã€‚\nä¸åŒçš„å¤„ç†å™¨è®¿é—®å…±äº«å­˜å‚¨å™¨æ—¶ï¼Œä½ç½®çš„ä¸åŒä¼šå¯¼è‡´è®¿é—®å»¶è¿Ÿã€‚\n  Cache-Only Memory Architecture\né«˜é€Ÿç¼“å­˜å­˜å‚¨ç»“æ„ï¼ˆCache-Only Memory Architecture, COMAï¼‰æ˜¯å°† NUMA ä¸­çš„åˆ†å¸ƒå­˜å‚¨å™¨æ¢æˆäº†é«˜é€Ÿç¼“å­˜ï¼Œæ¯ä¸ªå¤„ç†å™¨ä¸Šæ²¡æœ‰å­˜å‚¨å±‚æ¬¡ç»“æ„ï¼Œæ‰€æœ‰çš„é«˜é€Ÿç¼“å­˜å…±åŒæ„æˆäº†å…¨å±€åœ°å€ç©ºé—´ã€‚\n  2.2 Flynn åˆ†ç±»æ³• Flynn åˆ†ç±»æ³•ï¼ˆFlynn\u0026rsquo;s Taxonomyï¼‰æ˜¯ä¸€ç§é«˜æ•ˆèƒ½è®¡ç®—æœºçš„åˆ†ç±»æ–¹å¼ï¼Œä»–æ ¹æ®æŒ‡ä»¤å’Œæ•°æ®çš„æ‰§è¡Œæ–¹å¼å°†è®¡ç®—æœºç³»ç»Ÿåˆ†æˆäº†å››ç±»ï¼š\n  å•æŒ‡ä»¤å•æ•°æ®æ¨¡å‹ï¼ˆSingle Instruction Single Data, SISDï¼‰\nä¸€èˆ¬æ¥è¯´å…·æœ‰å•æ ¸ CPU ï¼ˆä¸è®¨è®ºè¶…çº¿ç¨‹æŠ€æœ¯ï¼‰çš„è®¡ç®—æœºå°±æ˜¯åŸºäºå•æŒ‡ä»¤å•æ•°æ®æ¨¡å‹çš„ï¼Œå¯¹äºæ¯ä¸€ä¸ª CPU æ—¶é’Ÿï¼ŒCPU æŒ‰ç…§ Fetchï¼ˆä»å¯„å­˜å™¨ä¸­è·å–æ•°æ®ï¼‰ï¼ŒDecodeï¼ˆè§£ç ï¼‰ï¼ŒExecuteï¼ˆæ‰§è¡Œå¹¶å°†ç»“æœä¿å­˜åœ¨å¦ä¸€ä¸ªå¯„å­˜å™¨ä¸­ï¼‰çš„æ­¥éª¤é¡ºåºæ‰§è¡ŒæŒ‡ä»¤ï¼›ä¸Šä¸ªä¸–çºªçš„è®¡ç®—æœºå‡ ä¹éƒ½æ˜¯ SISD æ¨¡å‹çš„ã€‚\n  å•æŒ‡ä»¤å¤šæ•°æ®æ¨¡å‹ï¼ˆSingle Instruction Multi Data, SIMDï¼‰\nå•ä¸ªæ§åˆ¶å•å…ƒæ‹¥æœ‰å¤šä¸ªå¤„ç†å™¨ï¼Œè¿™äº›å¤„ç†å™¨ä¸Šè¿è¡Œçš„çº¿ç¨‹å…±äº«åŒä¸€ä¸ªæŒ‡ä»¤æµï¼Œå®ç°äº†æ—¶é—´ä¸Šçš„å¹¶è¡Œï¼›GPU å°±æ˜¯å…¸å‹çš„ SIMD æ¨¡å‹ã€‚\n  å¤šæŒ‡ä»¤å•æ•°æ®æ¨¡å‹ï¼ˆMulti Instruction Single Data, MISDï¼‰\nå¤šä¸ªå¤„ç†å™¨åˆ†åˆ«æ‹¥æœ‰è‡ªå·±çš„æ§åˆ¶å•å…ƒå¹¶å…±äº«åŒä¸€ä¸ªå†…å­˜å•å…ƒï¼Œåº”ç”¨åœºæ™¯è¾ƒå°‘ã€‚\n  å¤šæŒ‡ä»¤å¤šæ•°æ®æ¨¡å‹ï¼ˆMulti Instruction Multi Data, MIMDï¼‰\nå¤šä¸ªæ§åˆ¶å•å…ƒå¼‚æ­¥åœ°æ§åˆ¶å¤šä¸ªå¤„ç†å™¨ï¼ŒåŒæ—¶å¤„ç†å™¨å¯ä»¥åœ¨ä¸åŒçš„æ•°æ®ä¸Šè¿è¡Œä¸åŒçš„ç¨‹åºï¼Œä¸€èˆ¬é€šè¿‡çº¿ç¨‹æˆ–è¿›ç¨‹å±‚é¢çš„å¹¶è¡Œæ¥å®ç°ï¼Œä»è€Œå®ç°ç©ºé—´ä¸Šçš„å¹¶è¡Œã€‚\n  2.3 åŠ é€Ÿæ¯”   åŠ é€Ÿæ¯”\nåŠ é€Ÿæ¯”ï¼ˆSpeedupï¼‰ç”¨äºè¡¡é‡æˆ‘ä»¬ç°åœ¨ä½¿ç”¨çš„å¹¶è¡Œç®—æ³•æ¯”ä¸²è¡Œç®—æ³•å¿«äº†å¤šå°‘ï¼Œä¹Ÿå°±æ˜¯å°†ç¨‹åºå¹¶è¡ŒåŒ–ä¹‹åæå‡çš„æ•ˆç‡ï¼Œå…¶å…¬å¼æ˜¯ï¼š\nå…¶ä¸­ p ä»£è¡¨ CPU æ•°é‡ï¼ŒT_1 ä»£è¡¨ä½¿ç”¨ä¸²è¡Œç®—æ³•çš„æ‰§è¡Œæ—¶é—´ï¼ŒT_p ä»£è¡¨å½“æœ‰ p ä¸ªå¤„ç†å™¨æ—¶ä½¿ç”¨å¹¶è¡Œç®—æ³•çš„æ‰§è¡Œæ—¶é—´ï¼›å½“ S_p == p ï¼Œå³ T_1 == p * T_p æ—¶ï¼ŒS_p ç§°ä¸ºçº¿æ€§åŠ é€Ÿæ¯”ï¼ˆLinear Speedupï¼‰ã€‚\n  é˜¿å§†è¾¾å°”å®šå¾‹\né˜¿å§†è¾¾å°”å®šå¾‹ï¼ˆAmdahl\u0026rsquo;s lawï¼‰ç”¨äºä¼°è®¡ç¨‹åºå¯ä»¥è¾¾åˆ°çš„æœ€å¤§åŠ é€Ÿæ¯”ï¼ŒW_s å’Œ W_p åˆ†åˆ«è¡¨ç¤ºç¨‹åºä¸²è¡Œéƒ¨åˆ†å’Œå¹¶è¡Œéƒ¨åˆ†æ‰€å çš„ç™¾åˆ†æ¯”ï¼ŒW_s + W_p è¡¨ç¤ºç¨‹åºä¸²è¡Œæ‰§è¡Œçš„æ—¶é—´ï¼ˆæ­¤æ—¶å¹¶è¡Œéƒ¨åˆ† W_p ç›¸å½“äºè¢«å•ä¸ªå¤„ç†å™¨æ‰§è¡Œï¼‰ï¼ŒW_s + W_p/p è¡¨ç¤ºç¨‹åºä½¿ç”¨ p ä¸ªå¤„ç†å™¨æ‰§è¡Œçš„æ—¶é—´ï¼›å½“ p -\u0026gt; âˆ æ—¶ï¼Œå…¶ä¸Šé™æ˜¯ (W_s + W_p) / W_sã€‚\nfor (int i = 0; i \u0026lt; 1000000000; ++i) std::this_thread::sleep_for(std::chrono::seconds(1)); // sequential for (int i = 0; i \u0026lt; 1000000000; ++i) std::this_thread::sleep_for(std::chrono::seconds(1)); // parallel   å¤æ–¯å¡”å¤«æ£®å®šå¾‹\nå¤æ–¯å¡”å¤«æ£®å®šå¾‹ï¼ˆGustafson\u0026rsquo;s Lawï¼‰é€šè¿‡ä½¿ç”¨ æ¥æè¿°åŠ é€Ÿæ¯”ï¼Œp ä»£è¡¨å¤„ç†å™¨çš„æ•°é‡ï¼Œa ä»£è¡¨ç¨‹åºä¸²è¡ŒåŒ–çš„éƒ¨åˆ†ï¼›\né˜¿å§†è¾¾å°”å®šå¾‹æè¿°çš„æ˜¯å¢åŠ å¤„ç†èµ·çš„æ•°é‡å¹¶ä¸ä¸€å®šèƒ½æé«˜åŠ é€Ÿæ¯”ï¼Œåªæœ‰å¢åŠ ç¨‹åºå¹¶è¡Œéƒ¨åˆ†çš„æ¯”ä¾‹ï¼Œæ‰èƒ½æé«˜åŠ é€Ÿæ¯”ã€‚\nå¤æ–¯å¡”å¤«æ£®å®šå¾‹æè¿°çš„æ˜¯éšç€ç¨‹åºå¹¶è¡ŒåŒ–æ¯”ä¾‹çš„æé«˜ï¼ŒåŠ é€Ÿæ¯”ä¸å¤„ç†å™¨ä¸ªæ•°æˆæ­£æ¯”çš„æ¯”ä¾‹ï¼ˆæ–œç‡ï¼‰ä¹Ÿåœ¨å¢åŠ ã€‚\n  æ€§èƒ½\næ€§èƒ½ï¼ˆEfficiencyï¼‰æ˜¯ç”±åŠ é€Ÿæ¯”æ´¾ç”Ÿå‡ºçš„é‡åº¦æ€§èƒ½çš„æŒ‡æ ‡ï¼Œå®ƒå¯ä»¥è¡¨ç¤ºæ¯ä¸ªå¤„ç†å™¨çš„åŠ é€Ÿæ¯”ï¼Œå³æ¯ä¸ªå¤„ç†å™¨åœ¨è¿™ä¸ªç®—æ³•ä¸­çš„åˆ©ç”¨ç‡ï¼Œå…¶å…¬å¼æ˜¯ï¼š\n  æ—¶é’ŸåŠ é€Ÿæ¯”\nS(p) = t_s / t_p\næ—¶é’ŸåŠ é€Ÿæ¯”ï¼ˆSpeedup in Wall-Clock Timeï¼‰çš„å…¬å¼å¾ˆç®€å•ï¼Œç”¨ä½¿ç”¨ä¸²è¡Œç®—æ³•èŠ±è´¹çš„æ—¶é’Ÿæ—¶é—´é™¤ä»¥ä½¿ç”¨å¹¶è¡Œç®—æ³•èŠ±è´¹çš„æ—¶é’Ÿæ—¶é—´å³å¯ï¼Œä½†æ˜¯å› ä¸ºæ—¶é’Ÿæ—¶é—´åŒ…æ‹¬äº†ç½‘ç»œå»¶è¿Ÿï¼ŒIOï¼Œç¼“å­˜äº‰ç”¨ç­‰æ— å…³å› ç´ ï¼Œæ‰€ä»¥å®ƒä¸åŠ é€Ÿæ¯”å’Œç®—æ³•çš„å¤æ‚åº¦å¹¶ä¸ç›¸å…³ï¼Œåªèƒ½ç”¨äºç²—ç•¥åœ°è¡¡é‡åŠ é€Ÿæ¯”ã€‚\n  3 å¹¶è¡Œè®¡ç®—æ¡†æ¶ 3.1 OpenMP OpenMPï¼ˆOpen Multi-Processingï¼‰æ˜¯ä¸€å¥—é’ˆå¯¹å¤šå¤„ç†å™¨å…±äº«å†…å­˜æœºå™¨è¿›è¡Œå¤šçº¿ç¨‹å¹¶è¡Œç¼–ç¨‹çš„ APIï¼Œæ”¯æŒçš„è¯­è¨€æœ‰ Cï¼ŒC++ å’Œ Fortranï¼Œæ”¯æŒçš„ç¼–è¯‘å™¨æœ‰ç°åœ¨ä¸»æµçš„ GCC å’Œ Clang ç­‰ï¼›\nOpenMP æä¾›äº†ç”¨äºæè¿°å¹¶è¡Œç¼–ç¨‹çš„é«˜å±‚æŠ½è±¡ï¼Œä½¿ç”¨ OpenMP æœ€å¤§çš„å¥½å¤„åœ¨äºï¼Œå½“æˆ‘ä»¬æ²¡æœ‰åœ¨ç¼–è¯‘çš„æ—¶å€™åŠ ä¸Š OpenMP ç›¸å…³çš„é€‰é¡¹ï¼Œæˆ–å½“ç¼–è¯‘å™¨ä¸æ”¯æŒ OpenMp æ—¶ï¼Œç¨‹åºä»ç„¶å¯ä»¥å®Œæˆç¼–è¯‘ï¼Œå¹¶ä½¿ç”¨ä¸²è¡Œçš„æµç¨‹æ­£å¸¸åœ°è¿è¡Œï¼›è¿™åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šé™ä½äº†å¹¶è¡Œç¼–ç¨‹çš„éš¾åº¦ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥æŠŠæ›´å¤šçš„ç²¾åŠ›æŠ•å…¥åˆ°å¹¶è¡Œç®—æ³•æœ¬èº«ï¼Œè€Œéå…¶å®ç°ç»†èŠ‚ï¼›å°¤å…¶å¯¹åŸºäºæ•°æ®é›†è¿›è¡Œå¹¶è¡Œåˆ’åˆ†çš„ç¨‹åºï¼ŒOpenMPæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ã€‚\nDirective æ‰€æœ‰çš„ OpenMP ç¼–ç¨‹æ“ä½œéƒ½æ˜¯åŸºäº #pragma omp å®æŒ‡ä»¤ï¼ˆdirectiveï¼‰çš„ï¼Œæ¯ä¸ª directive éƒ½ä¼šè¢«è½¬æ¢ä¸ºä¸å…¶ç›¸åº”çš„ OpenMP åº“å‡½æ•°è°ƒç”¨ï¼Œè€Œ OpenMP ä¼šå¤„ç†ä¸çº¿ç¨‹çº¿ç¨‹è°ƒç”¨ç›¸å…³çš„æ“ä½œï¼ŒåŒ…æ‹¬çº¿ç¨‹çš„ fork, join, synchronizing ç­‰ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š\n#include \u0026lt;omp.h\u0026gt;#include \u0026lt;iostream\u0026gt; int main() { #pragma omp parallel  { int tid{ omp_get_thread_num() }; printf(\u0026#34;Hello world from thread %d\\n\u0026#34;, tid); int thread_num{ omp_get_num_threads() }; if (tid == thread_num - 1) { printf(\u0026#34;tid: %d, thread_num: %d\\n\u0026#34;, tid, thread_num); } } return 0; } æ³¨æ„é“¾æ¥çš„æ—¶å€™éœ€è¦åŠ ä¸Š -fopenmpï¼Œè¿™æ˜¯ä¸€ä¸ªé«˜å±‚çº§çš„æ ‡å¿—ï¼Œå…¶ä½œç”¨ä¸»è¦æ˜¯é“¾æ¥ gomp åº“ï¼ˆGCC çš„ OpenMP å®ç°ï¼Œå¦‚æœä½¿ç”¨ clang è¿›è¡Œç¼–è¯‘åˆ™ä¼šé“¾æ¥ llvm å¯¹åº”çš„å®ç°ï¼Œç±»ä¼¼äº libstdc++ å’Œ libc++ çš„åŒºåˆ«ï¼‰ï¼ŒOpenMP é€šå¸¸æ˜¯åŸºäº pthread å®ç°çš„ï¼Œæ‰€ä»¥ gomp åº“è¿˜ä¼šé“¾æ¥æ›´å¤šçš„åº“æ¥ä½¿ç”¨æ“ä½œç³»ç»Ÿçš„çº¿ç¨‹åŠŸèƒ½ï¼š\n[joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o openmp-case openmp-case.cpp -fopenmp [joelzychen@DevCloud ~/parallel-computing]$ ./openmp-case Hello world from thread 5 Hello world from thread 2 Hello world from thread 1 Hello world from thread 3 Hello world from thread 7 tid: 7, thread_num: 8 Hello world from thread 4 Hello world from thread 0 Hello world from thread 6 omp_get_thread_num() å’Œ omp_get_num_threads() ä¸¤ä¸ªå‡½æ•°çš„åç§°éå¸¸ç›´ç™½ï¼Œåˆ†åˆ«è·å–äº†å½“å‰çº¿ç¨‹çš„ IDï¼ˆè¿™ä¸ª ID æ˜¯ OpenMP ç®¡ç†çš„ï¼Œå¹¶ä¸æ˜¯ PIDï¼‰å’Œæ€»çš„çº¿ç¨‹æ•°ï¼›#pragma omp parallel æ˜¯æœ€åŸºæœ¬çš„ directiveï¼Œå®ƒå¯ä»¥å¯åŠ¨ä¸€ç»„çº¿ç¨‹å¹¶è®©ä»–ä»¬å¹¶è¡Œåœ°æ‰§è¡Œï¼Œå¦‚æœæˆ‘ä»¬æ²¡æœ‰åœ¨ä½¿ç”¨ #pragma omp parallel è¿™ä¸ª directive çš„æ—¶å€™æŒ‡å®šçº¿ç¨‹æ•°é‡ï¼Œé‚£ä¹ˆé»˜è®¤ä¼šå¯åŠ¨ç­‰åŒäº CPU æ ¸å¿ƒæ•°é‡çš„çº¿ç¨‹æ•°ï¼›å¹¶ä¸”ç”±äºç¨‹åºæ˜¯å¹¶è¡Œåœ°æ‰§è¡Œçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¹¶ä¸èƒ½ä¿è¯ç¨‹åºæ‰§è¡Œçš„é¡ºåºï¼›\nExample å†çœ‹ä¸€ä¸ªä¾‹å­ï¼š\n#include \u0026lt;omp.h\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt; constexpr int thread_num = 3; using namespace std; int main() { std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); #pragma omp parallel for schedule(static) num_threads(thread_num)  for (int i = 0; i \u0026lt; thread_num; ++i) std::this_thread::sleep_for(std::chrono::seconds(1)); std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; } [joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o openmp-case openmp-case.cpp -fopenmp [joelzychen@DevCloud ~/parallel-computing]$ ./openmp-case time: 1000 ms [joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o openmp-case openmp-case.cpp [joelzychen@DevCloud ~/parallel-computing]$ ./openmp-case time: 3000 ms å› ä¸ºæ—¶é—´ç²’åº¦åªç²¾ç¡®åˆ°äº†æ¯«ç§’çº§ï¼Œæ‰€ä»¥åªèƒ½å¤Ÿçœ‹åˆ°å¤§è‡´çš„è¿è¡Œæ—¶é—´æ˜¯ 1s å’Œ 3sï¼›num_threads(thread_num) ç”¨äºæŒ‡å®šçº¿ç¨‹æ•°é‡ï¼Œschedule(static) ç”¨äºæŒ‡å®šå°† for å¾ªç¯ä¸­çš„è¿­ä»£ä»¥é™æ€çš„æ–¹å¼åˆ†é…ç»™å¤šä¸ªçº¿ç¨‹ï¼Œå‡è®¾æœ‰ n æ¬¡å¾ªç¯è¿­ä»£ï¼Œt ä¸ªçº¿ç¨‹ï¼Œé‚£ä¹ˆå°†ç»™æ¯ä¸ªçº¿ç¨‹é™æ€åœ°åˆ†é… n/t æ¬¡è¿­ä»£è¿›è¡Œè¿ç®—ã€‚\nOpenMP è¿˜æä¾›äº† barrierï¼ˆç­‰å¾…æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œå®Œå‰é¢çš„æ‰€æœ‰è®¡ç®—ï¼‰ï¼Œatomicï¼ˆåŸå­æ“ä½œï¼‰ï¼Œflashï¼ˆå†™å…¥å†…å­˜ï¼‰ç­‰å„ç§æ“ä½œï¼›å…³äº OpenMP æ‰€æœ‰çš„å‡½æ•°å’Œ directive å¯ä»¥å‚è€ƒ OpenMP 4.5 API C/C++ Syntax Reference Guideã€‚\n3.2 OpenMPI OpenMPI (Open Message Passing Interface) æ˜¯åŸºäºæ¶ˆæ¯é˜Ÿåˆ—è¿›è¡Œè¿›ç¨‹é—´é€šä¿¡çš„å¹¶è¡Œç¼–ç¨‹åº“ï¼ŒMPI æ˜¯ä¸€ä¸ªè·¨è¯­è¨€çš„é€šä¿¡åè®®ï¼ŒOpenMPI åªæ˜¯éµå¾ªè¿™ç§åè®®çš„ä¸€ç§å®ç°ï¼›åœ¨åŸºäºæ¶ˆæ¯é˜Ÿåˆ—çš„å¹¶è¡Œç¼–ç¨‹æ¨¡å‹ä¸­ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸€ä¸ªç‹¬ç«‹çš„åœ°å€ç©ºé—´ï¼Œä¸€ä¸ªè¿›ç¨‹ä¸èƒ½ç›´æ¥è®¿é—®å…¶ä»–è¿›ç¨‹ä¸­çš„æ•°æ®ï¼Œè€Œåªèƒ½é€šè¿‡æ¶ˆæ¯ä¼ é€’çš„æ–¹å¼æ¥å®ç°è¿›ç¨‹é—´çš„é€šä¿¡ï¼Œæˆ‘ä»¬éœ€è¦æ˜¾å¼åœ°é€šè¿‡å‘é€å’Œæ¥å—æ¶ˆæ¯æ¥å®ç°å¤„ç†å™¨ä¹‹é—´çš„æ•°æ®äº¤æ¢ï¼›ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—è¿›è¡Œé€šä¿¡çš„å¼€é”€æ¯”å…±äº«å†…å­˜å¤§ï¼Œå› æ­¤å®ƒä¸»è¦ç”¨æ¥è¿›è¡Œå¤§ç²’åº¦å¹¶è¡Œç¼–ç¨‹çš„å¼€å‘ã€‚\nAPI MPI æœ‰å‡ ä¸ªæœ€åŸºç¡€çš„å‡½æ•°ï¼Œåœ¨æ¯ä¸€ä¸ª MPI å¹¶è¡Œç¨‹åºä¸­å‡ ä¹éƒ½ä¼šç”¨åˆ°è¿™å‡ ä¸ªå‡½æ•°ï¼š\n  int MPI_Init (int* argc ,char** argv[] )\nåˆå§‹åŒ– MPI ç¯å¢ƒï¼Œä¸€èˆ¬æ˜¯ç¬¬ä¸€ä¸ªè¢«è°ƒç”¨çš„ MPI å‡½æ•°ï¼›\n  int MPI_Finalize (void)\nç»ˆæ­¢ MPI ç¯å¢ƒï¼Œä¸€èˆ¬æ˜¯æœ€åä¸€ä¸ªè¢«è°ƒç”¨çš„ MPI å‡½æ•°ï¼›\n  int MPI_Comm_size (MPI_Comm comm ,int* size )\nè·å–é€šä¿¡ç»„è¿›ç¨‹çš„ä¸ªæ•°ï¼ŒMPI_Comm comm æ˜¯æŒ‡å®šçš„ communicatorï¼Œå…±äº«é€šä¿¡ç©ºé—´çš„ä¸€ç»„è¿›ç¨‹ç»„æˆäº†é€šä¿¡ç»„ï¼Œé€šä¿¡ç»„ä¸­çš„æ‰€æœ‰è¿›ç¨‹ç”± communicator ç®¡ç†ï¼›\n  int MPI_Comm_rank (MPI_Comm comm ,int* rank)\nè·å–å½“å‰è¿›ç¨‹åœ¨é€šä¿¡ç»„ä¸­çš„è¿›ç¨‹ IDï¼Œè¿™ä¸ª ID æ˜¯ç”± communicator ç®¡ç†çš„ï¼Œä¸æ˜¯ PIDï¼›\n  Example æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼Œå°è¯•ç”¨ OpenMPI è§£å†³ 0-1 èƒŒåŒ…é—®é¢˜ï¼Œå‡è®¾ç‰©å“çš„æ•°é‡æ˜¯ Nï¼ŒèƒŒåŒ…çš„å®¹é‡æ˜¯ Cï¼Œç¬¬ i ä¸ªç‰©å“çš„é‡é‡æ˜¯ weight[i]ï¼Œä»·å€¼ä¸º value[i]ï¼Œå…ˆç”¨å¸¸è§„çš„çº¿æ€§ DP è§£å†³ï¼š\n#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;fstream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;#include \u0026lt;omp.h\u0026gt; using namespace std; int main() { std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); fstream input_file(\u0026#34;input-knapsack.txt\u0026#34;); int N; int64_t Capacity; input_file \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Capacity; int64_t weight[N], value[N]; for (int i = 0; i \u0026lt; N; ++i) input_file \u0026gt;\u0026gt; weight[i] \u0026gt;\u0026gt; value[i]; vector\u0026lt;vector\u0026lt;int64_t\u0026gt;\u0026gt; dp(N + 1, vector\u0026lt;int64_t\u0026gt;(Capacity + 1)); for (int i = 0; i \u0026lt;= N; ++i) { #pragma omp parallel for  for (int64_t j = 0; j \u0026lt;= Capacity; ++j) { if (i == 0 || j == 0) dp[i][j] = 0; else if (j \u0026lt; weight[i - 1]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); } } cout \u0026lt;\u0026lt; \u0026#34;max value: \u0026#34; \u0026lt;\u0026lt; dp[N][Capacity] \u0026lt;\u0026lt; endl; std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count() \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } å…ˆç”¨èƒŒåŒ…æ•°æ®éšæœºç”Ÿæˆå™¨ï¼ˆè§é™„å½•ï¼‰ç”Ÿæˆæ•°æ®ï¼Œç„¶åç¼–è¯‘è¿è¡Œï¼Œå¯¹æ¯”ä¸€ä¸‹ä½¿ç”¨ OpenMPI å‰åçš„ç»“æœï¼š\n[joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o knapsack-generator knapsack-generator.cpp -lcrypto [joelzychen@DevCloud ~/parallel-computing]$ ./knapsack-generator 1000 8000 [joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o knapsack knapsack.cpp [joelzychen@DevCloud ~/parallel-computing]$ ./knapsack max value: 13093 time: 175 ms [joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o knapsack-openmp knapsack.cpp -fopenmp [joelzychen@DevCloud ~/parallel-computing]$ ./knapsack-openmp max value: 13093 time: 75 ç°åœ¨ä½¿ç”¨ OpenMPI æ¥æ”¹é€  0-1 èƒŒåŒ…é—®é¢˜çš„ DP è§£æ³•ï¼š\n#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;fstream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;chrono\u0026gt;#include \u0026lt;mpi.h\u0026gt; using namespace std; int main(int argc, char *argv[]) { std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); MPI_Init(\u0026amp;argc, \u0026amp;argv); MPI_Comm comm = MPI_COMM_WORLD; int rank, size; MPI_Comm_rank(comm, \u0026amp;rank); MPI_Comm_size(comm, \u0026amp;size); MPI_Status status; // MPI receive  MPI_Request request; // MPI send  fstream input_file(\u0026#34;input-knapsack.txt\u0026#34;); int N; int64_t Capacity; if (rank == 0) input_file \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Capacity; MPI_Bcast(\u0026amp;N, 1, MPI_INT, 0, comm); MPI_Bcast(\u0026amp;Capacity, 1, MPI_LONG, 0, comm); MPI_Barrier(comm); int64_t weight[N], value[N]; if (rank == 0) for (int i = 0; i \u0026lt; N; ++i) input_file \u0026gt;\u0026gt; weight[i] \u0026gt;\u0026gt; value[i]; MPI_Bcast(weight, N, MPI_LONG, 0, comm); MPI_Bcast(value, N, MPI_LONG, 0, comm); MPI_Barrier(comm); vector\u0026lt;vector\u0026lt;int64_t\u0026gt;\u0026gt; dp(N + 1, vector\u0026lt;int64_t\u0026gt;(Capacity + 1)); int64_t prev_max_value; // mpi send and receive variable  for (int i = 0; i \u0026lt;= N; ++i) // for each item from 0 to n  { for (int64_t j = rank; j \u0026lt;= Capacity; j += size) // for each capacity from 0 to Capacity, each thread computes its own rows  { if (i == 0 || j == 0) dp[i][j] = 0; else if (j \u0026lt; weight[i - 1]) dp[i][j] = dp[i - 1][j]; else { // int MPI_Recv(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status)  MPI_Recv(\u0026amp;prev_max_value, 1, MPI_LONG, (j - weight[i - 1]) % size, i - 1, comm, \u0026amp;status); dp[i][j] = max(dp[i - 1][j], prev_max_value + value[i - 1]); } // send dp[i][j] to the next nodes that may need this curr_max_value  if (i \u0026lt; N \u0026amp;\u0026amp; weight[i] + j \u0026lt;= Capacity) { // int MPI_Isend(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request)  MPI_Isend(\u0026amp;dp[i][j], 1, MPI_LONG, (j + weight[i]) % size, i, comm, \u0026amp;request); // asynchronous operation  } } MPI_Barrier(MPI_COMM_WORLD); } MPI_Barrier(MPI_COMM_WORLD); if (rank == Capacity % size) printf(\u0026#34;max value: %ld\\n\u0026#34;, dp[N][Capacity]); if (rank == 0) { std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); printf(\u0026#34;time: %ld ms\\n\u0026#34;, std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count()); } MPI_Finalize(); return EXIT_SUCCESS; } ç›¸æ¯”äº OpenMPï¼Œä½¿ç”¨ OpenMPI è§£å†³èƒŒåŒ…é—®é¢˜çš„è¿‡ç¨‹éå¸¸å¤æ‚ï¼Œé¦–å…ˆè¦ä½¿ç”¨ rank == 0 çš„çº¿ç¨‹å¤„ç†è¾“å…¥ï¼Œç„¶åå°†è¾“å…¥çš„ N, C å’Œ weight, value æ•°ç»„éƒ½å¹¿æ’­ç»™å…¶ä»–çº¿ç¨‹ï¼Œä¹‹åå¼€å§‹å¤„ç† dp æ•°ç»„ï¼ŒåŠ¨æ€è§„åˆ’çš„æ­¥éª¤åˆ†ä¸ºä»¥ä¸‹å‡ æ­¥ï¼š\n  å¯¹äºä» 0 åˆ° n çš„æ¯ä¸€ä»¶ç‰©å“ i ä¸²è¡Œæ‰§è¡Œï¼›\n  å¯¹äºç¬¬ j ä¸ªçº¿ç¨‹ï¼ˆj = rank, 0 \u0026lt;= j \u0026lt; sizeï¼‰ï¼Œä½¿å…¶å»å¤„ç†å¯¹åº”çš„ capacity (capacity == j)ï¼Œä¹‹åè®© j += size å¤„ç†ä¸‹ä¸€ä»¶ï¼›\n  i == 0 æˆ– j == 0 æ—¶åˆå§‹åŒ–è¾¹ç•Œä¸º 0ï¼›\n  å¦‚æœ j \u0026lt; weight[i - 1]ï¼Œæ­¤æ—¶èƒŒåŒ…å®¹é‡å°äº weight[i - 1]ï¼Œé‚£ä¹ˆ dp[i][j] = dp[i - 1][j]ï¼›\n  å¦‚æœ j \u0026lt;= weight[i - 1]ï¼Œæ­¤æ—¶èƒŒåŒ…å®¹é‡å¤§äºç­‰äº weight[i - 1]ï¼Œé‚£ä¹ˆæ­¤æ—¶ dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1])ï¼Œä½†æ˜¯ç”±äºå®¹é‡å¤§å°ä¸º j - weight[i - 1] æ—¶çš„ dp ç»“æœï¼ˆä¹Ÿå°±æ˜¯ dp[i - 1][j - weight[i - 1]]ï¼‰ä¸ä¸€å®šæ˜¯ç”±ç¬¬ j ä¸ªçº¿ç¨‹å¤„ç†çš„ï¼Œæ‰€ä»¥æœ¬åœ°çš„ dp[i - 1][j - weight[i - 1]] ä¸ä¸€å®šå«æœ‰æ­£ç¡®çš„å€¼ï¼Œæ‰€ä»¥éœ€è¦é€šè¿‡ mpi ä»ç¬¬ (j - weight[i - 1]) % size ä¸ªçº¿ç¨‹æ‹¿åˆ°å¯¹åº”çš„å€¼ï¼ˆä¹Ÿå°±æ˜¯ prev_max_valueï¼‰ä¹‹åå†åšå¤„ç†ï¼›\n  å¯¹äºä¸‹ä¸€ä»¶ç‰©å“ï¼Œå½“èƒŒåŒ…å®¹é‡ä¸º j + weight[i] æ—¶å¯èƒ½ä¼šç”¨åˆ°å½“å‰çš„ dp ç»“æœï¼Œå› æ­¤éœ€è¦å°† dp[i][j] å‘é€ç»™å¤„ç†å®¹é‡ä¸º j + weight[i] çš„ç¬¬ (j + weight[i]) % size ä¸ªçº¿ç¨‹ï¼›\n  æœ€åå¤„ç†ç»“æœæ—¶åªéœ€è¦è®©å¤„ç†äº† dp[N][Capacity] çš„ç¬¬ rank = Capacity % size ä¸ªçº¿ç¨‹è¾“å‡ºå³å¯ï¼›æ³¨æ„è¿™ä¸ªåšæ³•ä¼šæœ‰ bugï¼Œå¦‚æœè¾“å…¥ä¸­çš„ç¬¬ i ä¸ªç‰©å“çš„ weight[i] == 0ï¼Œé‚£ä¹ˆçº¿ç¨‹åœ¨ç­‰å¾… recv çš„æ—¶å€™ä¼šä»è‡ªå·±è¿™ä¸ªçº¿ç¨‹æ¥æ”¶ä¸€ä¸ªå€¼ï¼Œä»è€Œå¯¼è‡´ç»“æœä¸å¯¹ï¼›\nä½¿ç”¨ OpenMPI å‰å…ˆè¦ä»å®˜æ–¹ç½‘ç«™ä¸‹è½½æºç å¹¶å®‰è£…ï¼ˆæˆ–è€…é€šè¿‡ yum å®‰è£…ï¼‰ï¼Œç„¶åä½¿ç”¨ mpic++ è¿›è¡Œç¼–è¯‘ï¼Œä½¿ç”¨ mpirun è¿è¡Œï¼š\n[joelzychen@DevCloud ~/parallel-computing/openmpi]$ sudo find / -name \u0026#34;mpic++\u0026#34; /usr/lib64/openmpi/bin/mpic++ /usr/lib64/mpich/bin/mpic++ [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpic++ -g -std=c++11 -o knapsack-openmpi knapsack-openmpi.cpp [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpirun -n 1 ./knapsack-openmpi max value: 13093 time: 6694 ms [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpirun -n 2 ./knapsack-openmpi max value: 13093 time: 4863 ms [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpirun -n 4 ./knapsack-openmpi max value: 13093 time: 3674 ms [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpirun -n 8 ./knapsack-openmpi max value: 13093 time: 2487 ms æ¨ªå‘æ¯”è¾ƒ OpenMPI å’Œ ä¸²è¡Œç®—æ³•ï¼Œåœ¨ä½¿ç”¨ OpenMPI åš DP çš„æ—¶å€™å› ä¸ºåœ¨æ¶ˆæ¯ä¼ è¾“ä¸­æµªè´¹äº†å¾ˆå¤šæ—¶é—´ï¼Œå…¶æ•ˆç‡ç”šè‡³ä¸å¦‚ä¸²è¡Œç®—æ³•ï¼›ä½†å¦‚æœä½¿ç”¨ç©·ä¸¾ç®—æ³•è§£ 0-1 èƒŒåŒ…ï¼ˆåœ¨ OJ é‡Œä¼šè¶…æ—¶çš„é‚£ç§ï¼‰ï¼Œå†ç”¨ OpenMPI ä¼˜åŒ–çš„è¯ï¼Œæ•ˆç‡ä¼šæœ‰éå¸¸å¤§çš„æå‡ï¼Œæœ‰å…´è¶£çš„åŒå­¦å¯ä»¥è‡ªå·±äº†è§£ä¸€ä¸‹ï¼›çºµå‘æ¯”è¾ƒå¼€å¯ä¸åŒçº¿ç¨‹æ•°é‡çš„ OpenMPI ç®—æ³•ï¼Œæˆ‘ä»¬åœ¨æ”¶å‘æ¶ˆæ¯æ•°é‡ä¸å˜çš„æƒ…å†µä¸‹æå‡äº†åŒæ—¶è¿›è¡Œè¿ç®—çš„çº¿ç¨‹æ•°é‡ï¼Œå› æ­¤æ˜æ˜¾åœ°æé«˜äº†æ•ˆç‡ï¼›å…³äº OpenMPI çš„æ‰€æœ‰å‡½æ•°å¯ä»¥æŸ¥é˜… Open MPI v4.0.4 documentationã€‚\n3.3 CUDA CUDA çš„å…¨ç§°æ˜¯ Compute Unified Device Architectureï¼Œå®ƒæ˜¯ä¸€ä¸ªç”¨äºå¹¶è¡Œè®¡ç®—çš„å¹³å°å’Œ APIï¼Œå®ƒå…è®¸å¼€å‘äººå‘˜ä½¿ç”¨æ”¯æŒ CUDA çš„ GPU è¿›è¡Œå¹¶è¡Œç¼–ç¨‹ï¼›GPU å¹¶ä¸èƒ½ç‹¬ç«‹è¿›è¡Œè¿ç®—ï¼Œå®ƒéœ€è¦ä¸ CPU é€šè¿‡ PCIe æ€»çº¿è¿æ¥åˆ°ä¸€èµ·ååŒè¿›è¡Œå·¥ä½œï¼Œä½¿ç”¨ GPU è¿›è¡Œçš„å¹¶è¡Œè®¡ç®—å¯ä»¥è¢«è§†ä¸ºæ˜¯ CPU å’Œ GPU çš„å¼‚æ„è®¡ç®—æ¶æ„ï¼ŒCPU è´Ÿè´£å¤„ç†é€»è¾‘å¤æ‚çš„ä¸²è¡Œéƒ¨åˆ†ï¼ŒGPU è´Ÿè´£å¤„ç†æ•°æ®å¯†é›†çš„å¹¶è¡Œéƒ¨åˆ†ï¼Œå…¶ä¸­ CPU é€šå¸¸è¢«ç§°ä¸º host ä¸»æœºç«¯ï¼ŒGPU é€šå¸¸è¢«ç§°ä¸º device è®¾å¤‡ç«¯ï¼›\nKernel CUDA ä¸­çš„ kernel æ ¸å‡½æ•°æ˜¯åœ¨ GPU ç«¯å¹¶è¡Œæ‰§è¡Œçš„å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°åªåŒ…å«ç¨‹åºçš„å¹¶è¡Œéƒ¨åˆ†ï¼Œå®ƒä¼šè¢« GPU ä¸Šçš„è¯¸å¤šçº¿ç¨‹å¹¶è¡Œæ‰§è¡Œï¼›ç›¸æ¯”äº CPU ä¸Šçš„çº¿ç¨‹ï¼ŒGPU ä¸Šçš„çº¿ç¨‹æ›´åŠ è½»é‡çº§ï¼Œåˆ›å»ºçš„æˆæœ¬æ›´å°ï¼Œçº¿ç¨‹åˆ‡æ¢æ›´çµæ´»ï¼Œè¿›å…¥ CUDA æ ¸å‡½æ•°æ—¶ç¨‹åºå¯ä»¥å®šä¹‰éå¸¸å¤šçš„è™šæ‹Ÿçº¿ç¨‹ï¼Œä½†èƒ½å¤Ÿå¹¶è¡Œæ‰§è¡Œçš„ç¡¬ä»¶çº¿ç¨‹æ•°ä¹Ÿæ˜¯æœ‰é™çš„ï¼›ä¸€èˆ¬æ¥è¯´åŸºäº CUDA ç¨‹åºçš„æ‰§è¡Œæµç¨‹å¦‚ä¸‹ï¼š\n host ç«¯è¿›è¡Œå†…å­˜åˆ†é…å’Œæ•°æ®åˆå§‹åŒ–ï¼Œæ‰§è¡Œç¨‹åºä¸²è¡Œéƒ¨åˆ† device ç«¯è¿›è¡Œå†…å­˜åˆ†é…ï¼Œå¹¶ä» host ç«¯æ‹·è´æ•°æ®åˆ° device ç«¯ device ç«¯è°ƒç”¨å¹¶æ‰§è¡Œæ ¸å‡½æ•°ï¼ŒåŒæ—¶ä½¿ç”¨ç¼“å­˜æå‡æ•ˆç‡ device ç«¯å°†è¿ç®—å¥½çš„ç»“æœæ‹·è´åˆ° host ç«¯ä¸Š device ç«¯é‡Šæ”¾å†…å­˜ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡æ ¸å‡½æ•°è°ƒç”¨  Thread Hierarchy CUDA æ‰§è¡Œæ ¸å‡½æ•°çš„æ—¶å€™å¼€å¯çš„çº¿ç¨‹æ‹¥æœ‰ä¸‰å±‚çš„å±‚çº§ç»“æ„ï¼š\n  grid\ngrid æ˜¯ä¸€ä¸ªé€»è¾‘å®ä½“ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå·¥ä½œåŒºï¼Œå®ƒè¿è¡Œåœ¨æ•´ä¸ª GPU ä¸Šï¼ŒåŒä¸€ä¸ª grid é‡Œçš„æ‰€æœ‰ thread å…±äº«å…¨å±€å†…å­˜ç©ºé—´ï¼›\n  thread block\nthread block æ˜¯ä¸€ç»„å¹¶è¡Œæ‰§è¡Œçš„çº¿ç¨‹ï¼Œä¸€ä¸ª block åœ¨å•ä¸ª streaming multi-processor ä¸­è¿è¡Œï¼Œå³ä¸€ä¸ª block ä¸­çš„æ‰€æœ‰ thread éƒ½åœ¨è¿™ä¸ªæµå¼å¤šå¤„ç†å™¨ä¸­è¿è¡Œï¼Œå®ƒä»¬å¯ä»¥é€šè¿‡å…±äº«å†…å­˜æˆ–åŒæ­¥åŸè¯­è¿›è¡Œé€šä¿¡ï¼Œä½äºä¸åŒçš„ block ä¸­çš„ thread ä¸€èˆ¬æ¥è¯´ä¸èƒ½äº’ç›¸é€šä¿¡å’Œåä½œï¼Œæ¯ä¸€ä¸ª block éƒ½åº”è¯¥èƒ½å¤Ÿç‹¬ç«‹è¿è¡Œï¼›\n  thread\nthread åœ¨ CUDA core ä¸Šæ‰§è¡Œï¼Œæ­£å¦‚å‰æ–‡æ‰€è¯´ï¼ŒGPU ä¸Šçš„çº¿ç¨‹éå¸¸è½»é‡çº§ï¼Œå¯ä»¥é€šè¿‡è¾ƒå¤§çš„å¯„å­˜å™¨æä¾›éå¸¸å¿«é€Ÿçš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼ˆCPU çš„çº¿ç¨‹å¥æŸ„å­˜åœ¨äºè¾ƒä½çš„å†…å­˜å±‚æ¬¡ç»“æ„ä¸­ï¼Œä¾‹å¦‚é«˜é€Ÿç¼“å­˜ï¼‰ï¼›\n  æˆ‘ä»¬åœ¨è°ƒç”¨æ ¸å‡½æ•°çš„æ—¶å€™éœ€è¦é€šè¿‡ \u0026lt;\u0026lt;\u0026lt;block, thread\u0026gt;\u0026gt;\u0026gt; çš„æ–¹å¼æ¥æŒ‡å®š block å’Œ thread çš„æ•°é‡å’Œç»´åº¦ã€‚\nExample æ¥çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œå…ˆä¸²è¡Œåœ°è¿›è¡Œå¤§çº¦ 10 äº¿æ¬¡åŠ æ³•è¿ç®—ï¼š\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;chrono\u0026gt;#include \u0026lt;thread\u0026gt; using namespace std; constexpr uint64_t magic_number = 12345; void Add(int n, uint64_t *x) { for (int i = 0; i \u0026lt; n; ++i) x[i] += x[i]; } int main(void) { int n = 1\u0026lt;\u0026lt;30; uint64_t *x = (uint64_t *)malloc(n * sizeof(uint64_t)); memset(x, magic_number, sizeof(x)); std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); Add(n, x); std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; free(x); return 0; } ä¸ºäº†æ–¹ä¾¿å¯¹æ¯”ï¼Œåœ¨ Windows PowerShell ä¸­ä½¿ç”¨ nvcc ç¼–è¯‘è¿è¡Œï¼š\nPS G:\\\u0026gt; nvcc -o add .\\add.cpp -ccbin \u0026#34;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\VC\\Tools\\MSVC\\14.16.27023\\bin\\Hostx64\\x64\u0026#34; add.cpp PS G:\\\u0026gt; .\\add.exe time: 4472 ms å¯ä»¥çœ‹åˆ° Add å‡½æ•°ä¸²è¡Œæ‰§è¡Œçš„æ—¶é—´å¤§çº¦æ˜¯ 4472 msï¼Œç°åœ¨æˆ‘ä»¬å°†å…¶ä¿®æ”¹ä¸ºä½¿ç”¨ CUDA çš„å¹¶è¡Œç¨‹åºï¼š\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;chrono\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;string\u0026gt; using namespace std; constexpr int magic_number = 12345; __global__ void Add(int n, int *x) { for (int i = 0; i \u0026lt; n; ++i) x[i] += x[i]; } int main(void) { int n = 1\u0026lt;\u0026lt;30; int64_t byte_size = n * sizeof(int); int *x; x = (int*)malloc(byte_size); for (int i = 0; i \u0026lt; n; ++i) x[i] = magic_number; int *cuda_x; cudaMalloc((void**)\u0026amp;cuda_x, byte_size); // copy from host to device  cudaMemcpy(cuda_x, x, byte_size, cudaMemcpyHostToDevice); std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); Add\u0026lt;\u0026lt;\u0026lt;1, 1\u0026gt;\u0026gt;\u0026gt;(n, cuda_x); cudaDeviceSynchronize(); std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); // copy from device to host  cudaMemcpy(x, cuda_x, byte_size, cudaMemcpyDeviceToHost); // check result  bool result{ true }; for (uint32_t i = 0; i \u0026lt; n; ++i) result = (result \u0026amp;\u0026amp; (x[i] == magic_number + magic_number)); string result_str = (result ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;result: \u0026#34; \u0026lt;\u0026lt; result_str \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; free(x); cudaFree(cuda_x); return 0; } PS G:\\\u0026gt; nvcc -o cuda-add .\\cuda-add.cu -ccbin \u0026#34;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\VC\\Tools\\MSVC\\14.16.27023\\bin\\Hostx64\\x64\u0026#34; cuda-add.cu Creating library cuda-add.lib and object cuda-add.exp PS G:\\\u0026gt; .\\cuda-add.exe result: true time: 21904 ms å¯ä»¥çœ‹åˆ° CUDA ç¨‹åºé‡Œæœ‰ä¸€äº›ç‰¹æ®Šçš„å…³é”®å­—å’Œ APIï¼š\n  __global__ æ˜¯æ ¸å‡½æ•°çš„æ ‡å¿—ï¼Œåªè¦åœ¨å‡½æ•°ç­¾åå‰åŠ ä¸Š __global__ å®ƒå°±å¯ä»¥è¢« CUDA ç¼–è¯‘å™¨åˆ†æä¸ºæ ¸å‡½æ•°ï¼›\n  å› ä¸º Add å‡½æ•°æ˜¯åœ¨ device ç«¯è¿è¡Œçš„ï¼Œæˆ‘ä»¬éœ€è¦å…ˆä½¿ç”¨ malloc å’Œ cudaMalloc åˆ†åˆ«ä¸º host å’Œ device ç«¯åˆ†é…å†…å­˜ï¼Œç„¶åä½¿ç”¨ cudaMemcpy å°†åœ¨ host ç«¯åˆå§‹åŒ–çš„æ•°æ®æ‹·è´åˆ° device ç«¯ï¼›\n  æˆ‘ä»¬éœ€è¦åœ¨ device ç«¯è°ƒç”¨ Add æ ¸å‡½æ•°ï¼Œè¿™ä¸ªæ“ä½œå¯¹äº host ç«¯æ¥è¯´æ˜¯å¼‚æ­¥çš„ï¼Œå®ƒä¸ä¼šç­‰å¾… device ç«¯çš„æ‰§è¡Œç»“æœï¼Œæˆ‘ä»¬éœ€è¦è°ƒç”¨ cudaDeviceSynchronize å‡½æ•°æ¥ç­‰å¾… device ç«¯æ‰§è¡Œå®Œæ¯•å¹¶è¿”å›ï¼›å¦‚æœæˆ‘ä»¬è¿ç»­è°ƒç”¨äº†å¤šä¸ªæ ¸å‡½æ•°ï¼Œåˆæ²¡æœ‰åœ¨ device ç«¯æŒ‡å®šæ§åˆ¶æµï¼Œé‚£ä¹ˆè¿™äº›æ ¸å‡½æ•°åªä¼šåœ¨ device ç«¯æŒ‰é¡ºåºæ‰§è¡Œï¼›\n  device ç«¯æ‰§è¡Œå®Œä¹‹åï¼Œä½¿ç”¨ cudaMemcpy å°†æ•°æ®ä» device ç«¯æ‹·è´å› host ç«¯è¿›è¡ŒéªŒè¯ï¼›\n  æœ€ååˆ†åˆ«è°ƒç”¨ free å’Œ cudaFree æ¥é‡Šæ”¾å†…å­˜ï¼›\n  æˆ‘ä»¬çš„ç¨‹åºè™½ç„¶è·‘åœ¨ GPU ä¸Šï¼Œä½†é€Ÿåº¦åè€Œæ¯”è·‘åœ¨ CPU ä¸Šçš„æ—¶å€™æ›´æ…¢äº†ï¼Œå› ä¸ºæˆ‘ä»¬åªä¸º kernel åˆ†é…äº† 1 ä¸ª block å’Œ 1 ä¸ª thread (Add\u0026lt;\u0026lt;\u0026lt;1,1\u0026gt;\u0026gt;\u0026gt;(n, x);)ï¼Œæ—¢æ²¡æœ‰å‘æŒ¥ GPU å¹¶è¡Œè®¡ç®—çš„ä¼˜åŠ¿ï¼Œåˆæµªè´¹äº†æ—¶é—´åœ¨ CPU å’Œ GPU çš„äº¤äº’ä¸Šï¼›ä¼˜åŒ–çš„æ–¹æ³•å’Œ OpenMPI ä¸­çš„ä¾‹å­ç±»ä¼¼ï¼Œåªéœ€è¦è®©æ¯ä¸ªçº¿ç¨‹å¤„ç†å¯¹åº”è‡ªå·±çš„æ•°æ®ï¼Œå¹¶åœ¨å¾ªç¯ä¸­æ¯æ¬¡è‡ªå¢ä¸€ä¸ªæ­¥é•¿ï¼š\n__global__ void Add(int n, int *cuda_x) { int index = blockIdx.x * blockDim.x + threadIdx.x; int stride = blockDim.x; for (int i = index; i \u0026lt; n; i += stride) cuda_x[i] += cuda_x[i]; } int main(void) { // ...  Add\u0026lt;\u0026lt;\u0026lt;4096, 256\u0026gt;\u0026gt;\u0026gt;(n, cuda_x); // ... } å…¶ä¸­ï¼š\n  blockIdx.x ä»£è¡¨ block çš„ IDï¼Œå³å½“å‰ block çš„ä¸‹æ ‡ï¼›\n  blockDim.x ä»£è¡¨ block çš„ç»´åº¦ï¼Œå³ä¸€ä¸ª block å†…å«æœ‰å¤šå°‘ä¸ª threadï¼›åŒæ—¶ä¹Ÿæ˜¯æ­¥é•¿ strideï¼›\n  ç±»ä¼¼çš„ï¼ŒthreadIdx.x ä»£è¡¨ thread çš„ IDï¼Œå³å½“å‰ block çš„ä¸‹æ ‡ï¼›\n  index æ˜¯å½“å‰éœ€è¦è¿›è¡Œè¿ç®—çš„æ•°æ®åœ¨å†…å­˜ä¸­çš„ä½ç½®\n  åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¼€å¯äº† 4096 ä¸ª block å’Œ 256 ä¸ª threadï¼Œå³ blockIdx.x \u0026lt; 4096, blockDim.x == 256, threadIdx.x \u0026lt; 256ï¼›\nå½“ç„¶å¦‚æœç”³è¯·è¿‡å¤šçš„ block å¹¶ä¸ä¼šæå‡è¿ç®—çš„æ•ˆç‡ï¼Œå› ä¸º cuda core ä¼šæµªè´¹è®¸å¤šæ—¶é—´æ¥è°ƒåº¦è¿™äº› blockï¼›æˆ‘ä»¬å¯ä»¥å¤šæ¬¡ä¿®æ”¹ \u0026lt;\u0026lt;\u0026lt;block, thread\u0026gt;\u0026gt;\u0026gt; æ¥å¯¹æ¯”åœ¨ä½¿ç”¨ä¸åŒæ•°é‡çš„ block å’Œ thread çš„æƒ…å†µä¸‹çš„æ€§èƒ½ï¼š\n# Add\u0026lt;\u0026lt;\u0026lt;4096, 256\u0026gt;\u0026gt;\u0026gt;(n, x); PS G:\\\u0026gt; nvcc -o cuda-add .\\cuda-add.cu -ccbin \u0026#34;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\VC\\Tools\\MSVC\\14.16.27023\\bin\\Hostx64\\x64\u0026#34; cuda-add.cu Creating library cuda-add.lib and object cuda-add.exp PS G:\\\u0026gt; .\\cuda-add.exe result: true time: 159454 ms # Add\u0026lt;\u0026lt;\u0026lt;1, 256\u0026gt;\u0026gt;\u0026gt;(n, x); PS G:\\\u0026gt; .\\cuda-add.exe result: true time: 1038 ms # Add\u0026lt;\u0026lt;\u0026lt;1, 1024\u0026gt;\u0026gt;\u0026gt;(n, x); PS G:\\\u0026gt; .\\cuda-add.exe result: true time: 299 ms å…³äº CUDA çš„æ›´å¤šä½¿ç”¨è¯´æ˜å¯ä»¥å‚è€ƒ CUDA Toolkit Documentationã€‚\n4 æ€»ç»“ æœ¬æ–‡ä¸»è¦è®²è§£äº†å¹¶è¡Œè®¡ç®—æ‰€ä¾é™„çš„ç¡¬ä»¶æ¶æ„åŠå…¶ç›¸å…³çš„ä¸€äº›æ¦‚å¿µï¼Œé€šè¿‡ OpenMP, OpenMPI å’Œ CUDA åˆ†åˆ«ç®€å•åœ°ä»‹ç»äº†åŸºäºå…±äº«å†…å­˜ï¼Œæ¶ˆæ¯ä¼ é€’å’Œ GPUï¼ˆå…¶å®ä¹Ÿæ˜¯ä¸€ç§å…±äº«å†…å­˜å¹¶è¡Œç¼–ç¨‹ï¼‰ä¸‰ç§æ–¹æ³•çš„å¹¶è¡Œç¼–ç¨‹ï¼Œå…³äºå¹¶è¡Œè®¡ç®—çš„æ›´å¤šå¼€å‘ç»éªŒè¿˜éœ€è¦åœ¨å®è·µä¸­ç§¯ç´¯ã€‚\næœ¬æ–‡æ‰€æœ‰ä»£ç å‡æ”¶å½•åœ¨ https://github.com/ZintrulCre/parallel-computing-demoã€‚\n5 é™„å½• 0-1 èƒŒåŒ…é—®é¢˜éšæœºæ•°æ®ç”Ÿæˆå™¨ // knapsack-generator.cpp #include \u0026lt;iostream\u0026gt;#include \u0026lt;fstream\u0026gt;#include \u0026lt;openssl/rand.h\u0026gt; using namespace std; int main (int argc, char *argv[]) { if (argc \u0026lt; 3) { fprintf(stderr, \u0026#34;usage: %s N C\\n\u0026#34;, argv[0]); exit(1); } int N = stoi (argv[1]); uint64_t C = stoi (argv[2]); int m = 4 * C / N; unsigned char buff[2 * N]; RAND_seed(\u0026amp;m, sizeof(m)); RAND_bytes(buff, sizeof(buff)); ofstream file_stream; file_stream.open(\u0026#34;input-knapsack.txt\u0026#34;); file_stream \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; C \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; N; i++) { file_stream \u0026lt;\u0026lt; buff[2 * i] % m \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; buff[2 * i + 1] % m \u0026lt;\u0026lt; endl;; } file_stream.close(); return 0; } å‚è€ƒæ–‡çŒ®   OpenMP 4.5 API C/C++ Syntax Reference Guide. (2020). Retrieved 10 August 2020, from https://www.openmp.org/wp-content/uploads/OpenMP-4.5-1115-CPP-web.pdf\n  Open MPI v4.0.4 documentation. (2020). Retrieved 10 August 2020, from https://www.open-mpi.org/doc/current/\n  Jiaoyun, Yang \u0026amp; Yun, Xu \u0026amp; Yi, Shang. (2010). An Efficient Parallel Algorithm for Longest Common Subsequence Problem on GPUs. Lecture Notes in Engineering and Computer Science. 1.\n  CUDA Toolkit Documentation. (2020). Retrieved 10 August 2020, from https://docs.nvidia.com/cuda/\n  Harwood, A., \u0026amp; Lanch, A. (2020). COMP90025 Parallel and Multicore. Retrieved 10 August 2020, from School of Computing and Information Systems The University of Melbourne\n  Zeller, C. (2011). CUDA C/C++ Basics Supercomputing. Retrieved 7 August 2020, from https://www.nvidia.com/docs/IO/116711/sc11-cuda-c-basics.pdf\n  Han, J., \u0026amp; Sharma, B. Learn CUDA programming.\n  Ruetsch, G., \u0026amp; Oster, B. (2020). Getting Started with CUDA. Retrieved 10 August 2020, from https://www.nvidia.com/content/cudazone/download/Getting_Started_w_CUDA_Training_NVISION08.pdf\n  Harris, M. (2017). An Even Easier Introduction to CUDA. Retrieved 10 August 2020, from https://developer.nvidia.com/blog/even-easier-introduction-cuda/\n  Modern Parallel Computing (Part 3) - Some Typical GPU Architectures Â· Infectious Waste. (2020). Retrieved 10 August 2020, from https://infectiouswaste.github.io/2019/02/20/typical-gpu-arch/\n  Cheng, J. (2014). Professional Cuda C programming. Indianapolis, IN: John Wiley and Sons, Inc.\n  Harris, M., Ebersole, M., \u0026amp; Sakharnykh, N. (2020). Unified Memory in CUDA 6 | NVIDIA Developer Blog. Retrieved 10 August 2020, from https://developer.nvidia.com/blog/unified-memory-in-cuda-6/\n  ","permalink":"http://zintrulcre.github.io/posts/parallel-computing/parallel-computing/","summary":"å¹¶è¡Œè®¡ç®—å…¥é—¨ 1 æ¦‚è¿° 1.1 å¹¶è¡Œè®¡ç®— é«˜æ€§èƒ½è®¡ç®—ï¼ˆHigh Performance Computingï¼‰æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„ä¸€ä¸ªé¢†åŸŸï¼Œå…¶ç›®çš„å¯ä»¥æ¦‚æ‹¬ä¸ºä¼˜åŒ–æ€§èƒ½ï¼Œå®ƒåŒ…æ‹¬äº†ç¼“å­˜æŠ€æœ¯ã€æ•°æ®ç»“æ„å’Œç®—æ³•ã€IO ä¼˜åŒ–ã€æŒ‡ä»¤é‡ç»„ï¼ˆinstruction reorganizationï¼‰ã€ç¼–è¯‘å™¨ä¼˜åŒ–ç­‰ï¼›\nå¹¶è¡Œè®¡ç®—ï¼ˆParallel Computingï¼‰æ˜¯é«˜æ€§èƒ½è®¡ç®—ä¸‹çš„ä¸€ä¸ªç»†åˆ†é¢†åŸŸï¼Œå…¶ä¸»è¦æ€æƒ³æ˜¯å°†å¤æ‚é—®é¢˜åˆ†è§£æˆè‹¥å¹²ä¸ªéƒ¨åˆ†ï¼Œå°†æ¯ä¸€ä¸ªéƒ¨åˆ†äº¤ç»™ç‹¬ç«‹çš„å¤„ç†å™¨ï¼ˆè®¡ç®—èµ„æºï¼‰è¿›è¡Œè®¡ç®—ï¼Œä»¥æé«˜æ•ˆç‡ï¼›é’ˆå¯¹ä¸åŒçš„é—®é¢˜ï¼Œå¹¶è¡Œè®¡ç®—éœ€è¦ä¸“ç”¨çš„å¹¶è¡Œæ¶æ„ï¼Œæ¶æ„æ—¢å¯ä»¥æ˜¯ä¸“é—¨è®¾è®¡çš„ï¼Œå«æœ‰å¤šä¸ªå¤„ç†å™¨çš„å•ä¸€ç¡¬ä»¶æˆ–è¶…çº§è®¡ç®—æœºï¼Œä¹Ÿå¯ä»¥æ˜¯ä»¥æŸç§æ–¹å¼äº’è¿çš„è‹¥å¹²å°çš„ç‹¬ç«‹è®¡ç®—æœºæ„æˆçš„é›†ç¾¤ï¼›å¹¶æ²¡æœ‰ä¸€ä¸ªç»Ÿä¸€çš„å¹¶è¡Œè®¡ç®—æ¶æ„é€‚ç”¨äºæ¯ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœä½¿ç”¨äº†é”™è¯¯çš„æ¶æ„ï¼Œå¹¶è¡Œè®¡ç®—ç”šè‡³ä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚\n1.2 ç¡¬ä»¶æ¶æ„ ä¸­å¤®å¤„ç†å™¨ï¼ˆCentral Processing Unitï¼‰çš„ä¸»è¦åŠŸèƒ½æ˜¯è§£é‡Šè®¡ç®—æœºæŒ‡ä»¤ï¼Œå®ƒç”±æ§åˆ¶å•å…ƒï¼ˆControl Unitï¼‰ã€ç®—æœ¯é€»è¾‘å•å…ƒï¼ˆArithmetic Logic Unitï¼‰ã€ä¹±åºæ§åˆ¶å•å…ƒï¼ˆOut-of-Order Control Unitï¼‰ã€åˆ†æ”¯é¢„æµ‹å™¨ï¼ˆBranch Predictorï¼‰ã€æ•°æ®ç¼“å­˜ï¼ˆData Cacheï¼‰ç­‰éƒ¨ä»¶ç»„æˆï¼›CPU è¢«è®¾è®¡ä¸ºå¯ä»¥å¿«é€Ÿåœ°å¤„ç†å„ç§é€šç”¨è®¡ç®—ä»»åŠ¡å¹¶æœ€å°åŒ–å»¶è¿Ÿï¼Œä½†åœ¨å¹¶å‘æ€§ï¼ˆæ—¶é’Ÿé¢‘ç‡ï¼‰æ–¹é¢å—åˆ°é™åˆ¶ï¼›\nå›¾å½¢å¤„ç†å™¨ï¼ˆGraphics Processing Unit, GPUï¼‰æ˜¯è‹±ä¼Ÿè¾¾ï¼ˆNVIDIAï¼‰åœ¨ 1999 å¹´ 8 æœˆå‘å¸ƒ NVIDIA GeForce 256 æ—¶æå‡ºçš„æ¦‚å¿µï¼›ç°ä»£ GPU çš„æ¨¡å‹è®¾è®¡å¯ä»¥æ¦‚æ‹¬ä¸ºå‡ ä¸ªå…³é”®ç‚¹ï¼š\n  GPU çš„è®¾è®¡ç›®çš„æ˜¯æœ€å¤§åŒ–ååé‡ï¼ˆThroughputï¼‰\n  èƒ½å¤Ÿå°†ç¨‹åºä¸­æ•°æ®å¯å¹¶è¡Œçš„éƒ¨åˆ†ä» CPU è½¬ç§»åˆ° GPU\n  èƒ½å¤Ÿä½¿ç”¨å°½å¯èƒ½å¤šçš„çº¿ç¨‹è¿›è¡Œå¹¶è¡Œè®¡ç®—\n  GPU æ‹¥æœ‰çš„å†…æ ¸æ•°é‡ç›¸è¾ƒäº CPU å¤šå¾—å¤šï¼Œå¯ä»¥æœ‰æ•°åƒä¸ªåŒæ—¶è¿è¡Œçš„å†…æ ¸æ‰§è¡Œå¤§è§„æ¨¡å¹¶è¡Œè®¡ç®—ï¼Œå› æ­¤åœ¨æ—©æœŸä¸“é—¨åº”ç”¨äºå›¾å½¢æ•°æ®çš„å¤„ç†ï¼Œä½†éšç€è¿‘åå‡ å¹´çš„å‘å±•ï¼Œå…¶å¼ºå¤§çš„å¹¶è¡Œå¤„ç†èƒ½åŠ›ä¹Ÿä½¿å…¶å¯ä»¥å¤„ç†éå›¾å½¢æ•°æ®ï¼Œå°¤å…¶åœ¨æ·±åº¦å­¦ä¹ é¢†åŸŸéå¸¸å—æ¬¢è¿ï¼›\nåœ¨åˆ¶é€ å·¥è‰ºçš„é™åˆ¶ä¸‹ï¼ŒèŠ¯ç‰‡çš„å¯†åº¦å’Œæœ€å¤§é¢ç§¯éƒ½æ˜¯æœ‰é™çš„ï¼ˆæ‘©å°”å®šå¾‹ï¼‰ï¼Œå› æ­¤èŠ¯ç‰‡è®¾è®¡å®é™…ä¸Šæ˜¯åŠŸèƒ½å’Œå…ƒä»¶æ•°é‡çš„æƒè¡¡ï¼›å‡ºäºå¯¹é€šç”¨æ€§çš„è¦æ±‚ï¼ŒCPU çš„èŠ¯ç‰‡è®¾è®¡å¿…é¡»ä½¿ç”¨è¾ƒå¤šç§ç±»çš„åŸä»¶ä»¥å¢åŠ å…¶åŠŸèƒ½ï¼ŒåŒæ—¶æ”¾å¼ƒéƒ¨åˆ†å…·æœ‰å¤æ‚åŠŸèƒ½çš„å…ƒä»¶æ•°é‡ï¼Œè€Œ GPU çš„èŠ¯ç‰‡è®¾è®¡åˆ™æ˜¯é€šè¿‡ç§»é™¤éƒ¨åˆ†å…·æœ‰å¤æ‚åŠŸèƒ½çš„å…ƒä»¶æ¥æ¢å–æ›´å¤šçš„ç©ºé—´ï¼Œå¹¶é›†æˆæ›´å¤šçš„åŸºæœ¬åŠŸèƒ½å…ƒä»¶ï¼›\nGPU è®¾å¤‡ç”±å¤šä¸ªæµå¤šå¤„ç†å™¨ï¼ˆStreaming Multiprocessorï¼‰çš„å¤„ç†å™¨é›†ç¾¤ï¼ˆProcessor Clusterï¼‰ç»„æˆã€‚æ¯ä¸ªæµå¤šå¤„ç†å™¨éƒ½å…³è”ä¸€ä¸ªæ§åˆ¶å•å…ƒ å’Œ L1 Cacheï¼Œè¿™æ ·çš„è®¾è®¡ä½¿å¾—ä¸€ä¸ªèŠ¯ç‰‡å¯ä»¥åŒæ—¶æ”¯æŒä¸Šç™¾ä¸ªæŒ‡ä»¤æµçš„å¹¶è¡Œæ‰§è¡Œï¼›é€šå¸¸ä¸€ä¸ªæµå¤šå¤„ç†å™¨åœ¨ä¸å…¨å±€ GDDR-5 å†…å­˜äº¤æ¢æ•°æ®ä¹‹å‰éƒ½ä¼šåˆ©ç”¨ä¸ä¹‹å…³è” L1 Cache å’Œ L2 Cache æ¥å‡å°‘æ•°æ®ä¼ è¾“çš„å»¶è¿Ÿï¼›è€Œåˆå› ä¸º GPU é€šå¸¸æ‹¥æœ‰è¶³å¤Ÿå¤§çš„è®¡ç®—é‡ï¼Œä½¿å¾—å…¶ä¸éœ€è¦ä¸ CPU ä¸€æ ·éå¸¸é¢‘ç¹åœ°ä»å†…å­˜ä¸­è·å–æ•°æ®ï¼Œå› æ­¤ GPU çš„ç¼“å­˜å±‚ä¸€èˆ¬æ˜¯å°äº CPU çš„ã€‚","title":"å¹¶è¡Œè®¡ç®—å…¥é—¨"},{"content":"boost::typeIndex çš„ç›¸å…³æ¢ç©¶ Effective Modern C++ çš„ Item 4: Know how to view deduced types. ä¸­æåˆ°äº† Boost::typeindex çš„ä½¿ç”¨ï¼Œä½†å¹¶æ²¡æœ‰è®²åˆ°å…¶å®ç°åŸç†ã€‚\n1. typeid æ“ä½œç¬¦ typeid æ˜¯ C++ ä¸­çš„ä¸€ä¸ªæ“ä½œç¬¦ï¼Œå¯ä»¥ç”¨äºè·å–ç±»å‹çš„ä¿¡æ¯ï¼Œå¸¸å¸¸ç”¨åœ¨å¿…é¡»çŸ¥é“å¤šæ€å¯¹è±¡çš„åŠ¨æ€ç±»å‹ï¼Œæˆ–æ˜¯è¯†åˆ«é™æ€ç±»å‹çš„åœ°æ–¹ã€‚\næˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªç®€å•çš„ demo ç”¨äºè·å–å¯¹è±¡ç±»å‹ç›¸å…³çš„ä¿¡æ¯ï¼Œéœ€è¦åŒ…å« tepyinfo å¤´æ–‡ä»¶ï¼š\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;typeinfo\u0026gt; using namespace std; class Foo {}; int main() { cout \u0026lt;\u0026lt; \u0026#34;1: \u0026#34; \u0026lt;\u0026lt; typeid(1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; typeid(int).name() \u0026lt;\u0026lt; endl; // å’Œ sizeof æ“ä½œç¬¦ç±»ä¼¼ï¼Œtypeid ä¹Ÿå¯ä»¥ç›´æ¥å¯¹æ•°æ®ç±»å‹ï¼ˆæ¯”å¦‚ intï¼‰è¿›è¡Œæ“ä½œ  cout \u0026lt;\u0026lt; \u0026#34;typeid: \u0026#34; \u0026lt;\u0026lt; typeid(typeid(int)).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;typeid: \u0026#34; \u0026lt;\u0026lt; typeid(const type_info \u0026amp;).name() \u0026lt;\u0026lt; endl; const Foo *foo = new Foo(); cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; typeid(foo).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;*foo: \u0026#34; \u0026lt;\u0026lt; typeid(*foo).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Foo: \u0026#34; \u0026lt;\u0026lt; typeid(Foo).name() \u0026lt;\u0026lt; endl; } [joelzychen@DevCloud ~/typeid]$ g++ -std=c++11 -otypeid_test typeid_test.cpp [joelzychen@DevCloud ~/typeid]$ ./typeid_test 1: i int: i typeid: N10__cxxabiv123__fundamental_type_infoE typeid: St9type_info foo: PK3Foo *foo: 3Foo Foo: 3Foo std::type_info::name() å‡½æ•°è¿”å›çš„å­—ç¬¦ä¸²ä¸­ï¼Œåœ¨ GCC å’Œ Clang çš„å®ç°é‡Œä¸€èˆ¬ i ä»£è¡¨ intï¼ŒP ä»£è¡¨ pointerï¼ŒK ä»£è¡¨ constï¼Œæ•°å­—ç”¨äºæ ‡è¯†å…¶åè·Ÿéšäº†å‡ ä¸ªå­—ç¬¦ï¼›æˆ‘ä»¬å¯ä»¥å°†è¿™æ®µä»£ç ä½¿ç”¨å¾®è½¯çš„ MSVC ç¼–è¯‘è¿è¡Œï¼Œå¾—åˆ°æ›´åŠ ç›´è§‚çš„è¾“å‡ºï¼š\n1: int int: int typeid: class type_info typeid: class type_info foo: class Foo const * *foo: class Foo Foo: class Foo å¯ä»¥çœ‹åˆ°å¤§å¤šæ•°ç»“æœéƒ½ä¸æˆ‘ä»¬çš„é¢„æœŸç›¸ç¬¦ï¼Œä½†åœ¨è°ƒç”¨ typeid(const type_info \u0026amp;).name() è¿”å›çš„ç»“æœå´ä¸æ˜¯æˆ‘ä»¬æ‰€æœŸæœ›çš„ const type_info \u0026amp;ï¼Œå…¶ä¸­çš„ const å’Œ reference ç‰¹æ€§å¹¶æ²¡æœ‰å¾—åˆ°ä¿ç•™ï¼›å†ä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;typeinfo\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; static void PrintType(const T \u0026amp;t) { std::cout \u0026lt;\u0026lt; \u0026#34;T: \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;t: \u0026#34; \u0026lt;\u0026lt; typeid(t).name() \u0026lt;\u0026lt; std::endl; } int main() { const int *p_i; PrintType(p_i); } [joelzychen@DevCloud ~/typeid]$ g++ -std=c++11 -otypeid_test typeid_test.cpp [joelzychen@DevCloud ~/typeid]$ ./typeid_test T: PKi t: PKi PrintType è¿™ä¸ªæ¨¡æ¿æ¥æ”¶åˆ°çš„ T çš„ç¡®æ˜¯ PKiï¼ˆconst int*ï¼‰ç±»å‹ï¼Œä½†å’Œä¹‹å‰çš„ä¾‹å­ç±»ä¼¼ï¼Œt çš„ const reference ç‰¹æ€§å¹¶æ²¡æœ‰å¾—åˆ°ä¿ç•™\n2. ä½¿ç”¨ boost::typeindex::type_id_with_cvr ä»£æ›¿ typeid boost åº“ä¸­æœ‰ä¸€ä¸ªç±»ä¼¼äº typeid æ“ä½œç¬¦çš„å‡½æ•° boost::typeindex::type_id_with_cvr å¯ä»¥ç”¨äºè·å–å¯¹è±¡ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸ªæ¨¡æ¿å‡½æ•°æ¥è·å–æ›´ç²¾ç¡®çš„ç±»å‹ï¼š\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;typeinfo\u0026gt;#include \u0026lt;boost/type_index.hpp\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; static void PrintType(const T \u0026amp;t) { cout \u0026lt;\u0026lt; \u0026#34;T: \u0026#34; \u0026lt;\u0026lt; boost::typeindex::type_id_with_cvr\u0026lt;T\u0026gt;().pretty_name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;t: \u0026#34; \u0026lt;\u0026lt; boost::typeindex::type_id_with_cvr\u0026lt;decltype(t)\u0026gt;().pretty_name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;typeid: \u0026#34; \u0026lt;\u0026lt; boost::typeindex::type_id_with_cvr\u0026lt;decltype(typeid(int))\u0026gt;().pretty_name() \u0026lt;\u0026lt; endl; } int main() { const int *p_i{ nullptr }; PrintType(p_i); } [joelzychen@DevCloud ~/typeid]$ g++ -std=c++11 -otypeid_test typeid_test.cpp -I/usr/include/boost-1.73.0/gcc-head/include [joelzychen@DevCloud ~/typeid]$ ./typeid_test T: int const* t: int const* const\u0026amp; typeid: std::type_info const\u0026amp; å¯ä»¥çœ‹åˆ° typeid çœŸæ­£çš„è¿”å›å€¼ç±»å‹æ˜¯ std::type_info const\u0026amp;ï¼Œboost::typeindex::type_id_with_cvr é€šè¿‡æŸç§æœºåˆ¶ä¿ç•™äº†å…¶ const å’Œ reference çš„ç‰¹æ€§å¹¶é€šè¿‡ pretty_name() å‡½æ•°å°†ç»“æœè½¬æ¢æˆäº†å­—ç¬¦ä¸²è¿›è¡Œè¾“å‡ºï¼›å’Œ typeid æ“ä½œç¬¦ä¸åŒçš„æ˜¯ï¼Œ type_id_with_cvr å‡½æ•°åªèƒ½æ¥æ”¶æ¨¡æ¿å‚æ•°ç±»å‹æˆ–é€šè¿‡ decltype æ¨å¯¼å‡ºçš„ç±»å‹ï¼Œè€Œä¸èƒ½æ¥æ”¶ä¸€ä¸ªå˜é‡ã€‚\n3 type_id_with_cvr() çš„å®ç° type_id_with_cvr è¿™ä¸ªæ¨¡æ¿å‡½æ•°å®šä¹‰åœ¨ boost/type_index.hpp ä¸­ï¼Œå®ƒå®é™…ä¸Šæ˜¯è°ƒç”¨äº† stl_type_index ç±»çš„é™æ€æ¨¡æ¿å‡½æ•° type_id_with_cvrï¼š\n// boost/type_index.hpp namespace boost { namespace typeindex { template \u0026lt;class T\u0026gt; inline type_index type_id_with_cvr() BOOST_NOEXCEPT { return type_index::type_id_with_cvr\u0026lt;T\u0026gt;(); } } // boost/type_index/stl_type_index.hpp namespace boost { class stl_type_index : public type_index_facade\u0026lt;stl_type_index, std::type_info\u0026gt; // çœç•¥äº† BOOST_NO_STD_TYPEINFO å®çš„åˆ¤æ–­ { public: typedef std::type_info type_info_t; // çœç•¥äº† BOOST_NO_STD_TYPEINFO å®çš„åˆ¤æ–­ private: const type_info_t* data_; public: inline stl_type_index(const type_info_t\u0026amp; data) BOOST_NOEXCEPT : data_(\u0026amp;data) // åˆ©ç”¨ typeid æ“ä½œç¬¦è¿”å›çš„ const type_info_t\u0026amp; å¯¹è±¡è¿›è¡Œæ„é€   {} template \u0026lt;class T\u0026gt; inline static stl_type_index type_id_with_cvr() BOOST_NOEXCEPT; } } boost::typeindex::type_id_with_cvr å‡½æ•°å°†å…¶ç¬¬äºŒä¸ªæ¨¡æ¿å‚æ•° detail::cvr_saver\u0026lt;T\u0026gt; ä½œä¸ºå®å‚è°ƒç”¨äº† typeid æ“ä½œç¬¦ï¼Œå¹¶åˆ©ç”¨è¿”å›çš„ const type_info_t\u0026amp; å¯¹è±¡æ„é€ äº† stl_type_index å¯¹è±¡ï¼›\ndetail::cvr_saver æ˜¯ä¸€ä¸ªç©ºçš„æ¨¡æ¿ç±»ï¼Œåªå¸¦æœ‰æ¨¡æ¿å‚æ•° \u0026lt;class T\u0026gt; çš„ä¿¡æ¯ï¼Œå¯ä»¥åˆ©ç”¨ typeid æ¥è·å–è¿™ä¸ªç‰¹ä¾‹åŒ–æ¨¡æ¿ç±»çš„ type_infoã€‚\n// boost/type_index/stl_type_index.hpp namespace boost { template \u0026lt;class T\u0026gt; inline stl_type_index stl_type_index::type_id_with_cvr() BOOST_NOEXCEPT { typedef BOOST_DEDUCED_TYPENAME boost::conditional\u0026lt; boost::is_reference\u0026lt;T\u0026gt;::value || boost::is_const\u0026lt;T\u0026gt;::value || boost::is_volatile\u0026lt;T\u0026gt;::value, detail::cvr_saver\u0026lt;T\u0026gt;, T \u0026gt;::type type; // ç­‰ä»·äº using type = boost::conditional\u0026lt;...\u0026gt;  return typeid(type); } } // boost/type_traits/conditional.hpp namespace detail { template \u0026lt;class T\u0026gt; class cvr_saver{}; } namespace boost { template \u0026lt;bool b, class T, class U\u0026gt; struct conditional { typedef T type; }; } 4 class stl_type_facade class type_index_facade æ˜¯ class stl_type_index çš„åŸºç±»ï¼Œå…¶æºç åœ¨ type_index_facade.hpp æ–‡ä»¶ä¸­ï¼Œä½¿ç”¨äº†é—¨é¢æ¨¡å¼çš„è®¾è®¡ï¼š\n// boost/type_index/stl_type_index.hpp // å°†æ´¾ç”Ÿç±» Derived ä½œä¸ºæ¨¡æ¿å‚æ•° template \u0026lt;class Derived, class TypeInfo\u0026gt; class type_index_facade { public: typedef TypeInfo type_info_t; // è°ƒç”¨å­ç±»çš„ raw_name()ï¼Œæ²¡æœ‰ä½¿ç”¨è™šå‡½æ•°çš„æ–¹å¼ï¼Œè€Œæ˜¯åˆ©ç”¨æ¨¡æ¿å®ç°äº†é™æ€å¤šæ€  inline const char* name() const BOOST_NOEXCEPT { return derived().raw_name(); } // è¿”å› human-readable çš„å­—ç¬¦ä¸²ï¼Œè°ƒç”¨å­ç±»çš„ name()  inline std::string pretty_name() const { return derived().name(); } // æ¯”è¾ƒæ´¾ç”Ÿç±»çš„ raw_name()ï¼Œéœ€è¦æ´¾ç”Ÿç±»å®ç° raw_name() å‡½æ•°  inline bool equal(const Derived\u0026amp; rhs) const BOOST_NOEXCEPT { const char* const left = derived().raw_name(); const char* const right = rhs.raw_name(); return left == right || !std::strcmp(left, right); } // æ¯”è¾ƒæ´¾ç”Ÿç±»çš„ raw_name()ï¼Œéœ€è¦æ´¾ç”Ÿç±»å®ç° raw_name() å‡½æ•°  inline bool before(const Derived\u0026amp; rhs) const BOOST_NOEXCEPT { const char* const left = derived().raw_name(); const char* const right = rhs.raw_name(); return left != right \u0026amp;\u0026amp; std::strcmp(left, right) \u0026lt; 0; } // è·å–ä¸€ä¸ªç±»å‹çš„å“ˆå¸Œå€¼ï¼Œé»˜è®¤å¯¹æ´¾ç”Ÿç±»çš„ raw_name() è¿›è¡Œå“ˆå¸Œ  inline std::size_t hash_code() const BOOST_NOEXCEPT { const char* const name_raw = derived().raw_name(); return boost::hash_range(name_raw, name_raw + std::strlen(name_raw)); } } é™¤æ­¤ä¹‹å¤–ï¼Œclass type_index_facade åŸºç±»è¿˜é‡è½½äº†å„ç±»å¯¹æ¯”æ“ä½œç¬¦ï¼Œè¾“å‡ºæµæ“ä½œç¬¦å’Œç±»çš„å“ˆå¸Œå€¼ç®—æ³•ï¼š\n// boost/type_index/stl_type_index.hpp // çœç•¥äº†å…¶å®ƒç±»å‹çš„å¯¹æ¯”æ“ä½œç¬¦ template \u0026lt;class Derived, class TypeInfo\u0026gt; inline bool operator == (const TypeInfo\u0026amp; lhs, const type_index_facade\u0026lt;Derived, TypeInfo\u0026gt;\u0026amp; rhs) BOOST_NOEXCEPT { return Derived(lhs) == rhs;\t// éœ€è¦æ´¾ç”Ÿç±»å®ç°ä»¥ const TypeInfo\u0026amp; ä½œä¸ºå‚æ•°çš„æ„é€ å‡½æ•° } // é‡è½½è¾“å‡ºæµæ“ä½œç¬¦ template \u0026lt;class CharT, class TriatT, class Derived, class TypeInfo\u0026gt; inline std::basic_ostream\u0026lt;CharT, TriatT\u0026gt;\u0026amp; operator\u0026lt;\u0026lt;( std::basic_ostream\u0026lt;CharT, TriatT\u0026gt;\u0026amp; ostr, const type_index_facade\u0026lt;Derived, TypeInfo\u0026gt;\u0026amp; ind) { ostr \u0026lt;\u0026lt; static_cast\u0026lt;Derived const\u0026amp;\u0026gt;(ind).pretty_name(); return ostr; } // ç±»çš„å“ˆå¸Œå€¼ç®—æ³• template \u0026lt;class Derived, class TypeInfo\u0026gt; inline std::size_t hash_value(const type_index_facade\u0026lt;Derived, TypeInfo\u0026gt;\u0026amp; lhs) BOOST_NOEXCEPT { return static_cast\u0026lt;Derived const\u0026amp;\u0026gt;(lhs).hash_code(); } å¦‚æœæƒ³è¦è¿›è¡Œ class type_index_facade åŸºç±»çš„å…¨éƒ¨æ“ä½œï¼Œè¿˜éœ€è¦æ´¾ç”Ÿç±»è‡³å°‘å®ç°è‡³å°‘ä»¥ä¸‹ä¸¤ä¸ªå‡½æ•°ï¼š\n raw_name()ï¼ŒåŸºç±»çš„å¾ˆå¤šå‡½æ•°éƒ½ä¾èµ–äºæ´¾ç”Ÿç±»çš„è¿™ä¸ªå‡½æ•° Derived(const TypeInfo\u0026amp;)ï¼Œå³ä»¥ const TypeInfo\u0026amp; ä½œä¸ºå‚æ•°çš„æ„é€ å‡½æ•°ï¼Œç”¨äºä¸ TypeInfo å¯¹è±¡è¿›è¡Œå¯¹æ¯”  5 class type_type_index stl_type_index æ˜¯ stl_type_facade çš„æ´¾ç”Ÿç±»ï¼Œå®ƒçš„ç§æœ‰æˆå‘˜å˜é‡çš„ç±»å‹ type_info_t æ˜¯é€šè¿‡ typedef å®šä¹‰å‡ºæ¥çš„ï¼ŒBOOST_NO_STD_TYPEINFO æ˜¯æ„ä¹‰æ˜¯ç¼–è¯‘å™¨çš„ namespace std ä¸‹æ²¡æœ‰ type_info è¿™ä¸ªç±»å‹ï¼Œè¿™æ—¶ä¼šå°†å…¨å±€å‘½åç©ºé—´çš„ type_info å®šä¹‰ä¸º type_info_t ã€‚\npublic: #ifdef BOOST_NO_STD_TYPEINFO  typedef type_info type_info_t; #else  typedef std::type_info type_info_t; #endif  private: const type_info_t* data_; ä¸ºäº†æ–¹ä¾¿ç†è§£æš‚æ—¶çœç•¥ BOOST_NO_STD_TYPEINFO å®çš„å®šä¹‰ï¼›æ´¾ç”Ÿç±» stl_type_index çš„å£°æ˜å¤§è‡´å¦‚ä¸‹ï¼š\nclass stl_type_index : public type_index_facade\u0026lt;stl_type_index, std::type_info\u0026gt; { public: typedef std::type_info type_info_t; private: const type_info_t* data_; // å”¯ä¸€çš„ç§æœ‰æˆå‘˜ const type_info_t*  public: inline stl_type_index() BOOST_NOEXCEPT : data_(\u0026amp;typeid(void)) {} inline stl_type_index(const type_info_t\u0026amp; data) BOOST_NOEXCEPT : data_(\u0026amp;data) // ä»¥ const TypeInfo\u0026amp; ä½œä¸ºå‚æ•°çš„æ„é€ å‡½æ•°ï¼Œå¯¹æ¯”æ“ä½œç¬¦å’Œ type_id_with_cvr() å‡½æ•°éƒ½ä¾èµ–äºè¿™ä¸ªæ„é€ å‡½æ•°  {} inline const type_info_t\u0026amp; type_info() const BOOST_NOEXCEPT; // è·å–ç§æœ‰æˆå‘˜æ•°æ®  inline const char* raw_name() const BOOST_NOEXCEPT; // raw_name() å‡½æ•°  inline const char* name() const BOOST_NOEXCEPT; inline std::string pretty_name() const; inline std::size_t hash_code() const BOOST_NOEXCEPT; inline bool equal(const stl_type_index\u0026amp; rhs) const BOOST_NOEXCEPT; inline bool before(const stl_type_index\u0026amp; rhs) const BOOST_NOEXCEPT; template \u0026lt;class T\u0026gt; inline static stl_type_index type_id() BOOST_NOEXCEPT; template \u0026lt;class T\u0026gt; inline static stl_type_index type_id_with_cvr() BOOST_NOEXCEPT; template \u0026lt;class T\u0026gt; inline static stl_type_index type_id_runtime(const T\u0026amp; value) BOOST_NOEXCEPT; }; æ´¾ç”Ÿç±» stl_type_index çš„ equal, before, hash_code çš„å®ç°éƒ½å’ŒåŸºç±»ç±»ä¼¼ï¼Œæ“ä½œçš„å¯¹è±¡éƒ½æ˜¯ raw_name()ï¼š\ninline std::size_t stl_type_index::hash_code() const BOOST_NOEXCEPT { #ifdef BOOST_TYPE_INDEX_STD_TYPE_INDEX_HAS_HASH_CODE  return data_-\u0026gt;hash_code(); #else  return boost::hash_range(raw_name(), raw_name() + std::strlen(raw_name())); #endif } inline bool stl_type_index::equal(const stl_type_index\u0026amp; rhs) const BOOST_NOEXCEPT { #ifdef BOOST_TYPE_INDEX_CLASSINFO_COMPARE_BY_NAMES  return raw_name() == rhs.raw_name() || !std::strcmp(raw_name(), rhs.raw_name()); #else  return !!(*data_ == *rhs.data_); #endif } inline bool stl_type_index::before(const stl_type_index\u0026amp; rhs) const BOOST_NOEXCEPT { #ifdef BOOST_TYPE_INDEX_CLASSINFO_COMPARE_BY_NAMES  return raw_name() != rhs.raw_name() \u0026amp;\u0026amp; std::strcmp(raw_name(), rhs.raw_name()) \u0026lt; 0; #else  return !!data_-\u0026gt;before(*rhs.data_); #endif } name() å’Œ raw_name() éƒ½è°ƒç”¨äº†ç§æœ‰æˆå‘˜çš„ name() å‡½æ•°ï¼Œå³ std::type_info::name()ï¼š\ninline const char* stl_type_index::raw_name() const BOOST_NOEXCEPT { #ifdef _MSC_VER // ä¸åŒç¼–è¯‘å™¨å¯¹ typeid çš„å®ç°ä¸åŒï¼Œå› æ­¤ boost åº“åœ¨è¿›è¡Œå°è£…æ—¶åŒæ—¶å®ç°äº† raw_name() å’Œ name() ä¸¤ä¸ªå‡½æ•°  return data_-\u0026gt;raw_name(); #else  return data_-\u0026gt;name(); #endif } inline const char* stl_type_index::name() const BOOST_NOEXCEPT { return data_-\u0026gt;name(); } åœ¨ç¬¬ 2 éƒ¨åˆ†ä¸­è°ƒç”¨çš„ pretty_name() å‡½æ•°åŸå‹å¦‚ä¸‹ï¼š\ninline std::string stl_type_index::pretty_name() const { static const char cvr_saver_name[] = \u0026#34;boost::typeindex::detail::cvr_saver\u0026lt;\u0026#34;; static BOOST_CONSTEXPR_OR_CONST std::string::size_type cvr_saver_name_len = sizeof(cvr_saver_name) - 1; // å¯¹äº GCC å’Œ Clangï¼Œdemangled_name å‡½æ•°ä¼šå»æ‰§è¡Œè§£ç æ“ä½œï¼›è€Œå¯¹äº MSVCï¼Œå› ä¸ºé€šè¿‡ std::type_info::name() è·å–çš„å°±æ˜¯å·²ç»è§£ç åçš„å­—ç¬¦ä¸²ï¼Œå› æ­¤å‡½æ•°é‡Œä¸å†è¿›è¡Œè§£ç   const boost::core::scoped_demangled_name demangled_name(data_-\u0026gt;name()); // begin æ˜¯é€šè¿‡ demangled_name.get() è·å–åˆ°çš„ svr_saver ç±»å‹å¯¹è±¡çš„å…¨æ–‡ï¼Œç”¨ GDB æ–­ç‚¹åˆ°æ­¤å¤„æ‰“å°å‡ºæ¥å¯ä»¥çœ‹åˆ°å…¶å­—ç¬¦ä¸²å†…å®¹  // (gdb) p begin \t// $1 = 0x605010 \u0026#34;boost::typeindex::detail::cvr_saver\u0026lt;int const\u0026gt; ()\u0026#34;  const char* begin = demangled_name.get(); if (!begin) { boost::throw_exception(std::runtime_error(\u0026#34;Type name demangling failed\u0026#34;)); } const std::string::size_type len = std::strlen(begin); const char* end = begin + len; // å­—ç¬¦ä¸²å¯¹æ¯”ï¼Œè£å‰ªä¸¤è¾¹å¤šä½™çš„å­—ç¬¦  if (len \u0026gt; cvr_saver_name_len) { const char* b = std::strstr(begin, cvr_saver_name); if (b) { b += cvr_saver_name_len; // Trim leading spaces  while (*b == \u0026#39; \u0026#39;) { // the string is zero terminated, we won\u0026#39;t exceed the buffer size  ++ b; } // Skip the closing angle bracket  const char* e = end - 1; while (e \u0026gt; b \u0026amp;\u0026amp; *e != \u0026#39;\u0026gt;\u0026#39;) { -- e; } // Trim trailing spaces  while (e \u0026gt; b \u0026amp;\u0026amp; *(e - 1) == \u0026#39; \u0026#39;) { -- e; } if (b \u0026lt; e) { // Parsing seems to have succeeded, the type name is not empty  begin = b; end = e; } } } return std::string(begin, end); } è‡³æ­¤å°±äº†è§£äº†é™¤äº† demangled_name å‡½æ•°ä»¥å¤–çš„æ‰€æœ‰å®ç°ç»†èŠ‚äº†ï¼Œä¸éš¾ç†è§£å…¶å® stl_type_index è¿™ä¸ªç±»å°±æ˜¯å¯¹ std::type_info ç±»çš„å°è£…ï¼Œtype_id_with_cvr å’Œ pretty_name ä¸¤ä¸ªå‡½æ•°åˆ†åˆ«ç»†åŒ–äº† typeid æ“ä½œç¬¦å’Œ std::type_info::name() å‡½æ•°ã€‚\n","permalink":"http://zintrulcre.github.io/posts/c++/boost/boost-typeindex/","summary":"boost::typeIndex çš„ç›¸å…³æ¢ç©¶ Effective Modern C++ çš„ Item 4: Know how to view deduced types. ä¸­æåˆ°äº† Boost::typeindex çš„ä½¿ç”¨ï¼Œä½†å¹¶æ²¡æœ‰è®²åˆ°å…¶å®ç°åŸç†ã€‚\n1. typeid æ“ä½œç¬¦ typeid æ˜¯ C++ ä¸­çš„ä¸€ä¸ªæ“ä½œç¬¦ï¼Œå¯ä»¥ç”¨äºè·å–ç±»å‹çš„ä¿¡æ¯ï¼Œå¸¸å¸¸ç”¨åœ¨å¿…é¡»çŸ¥é“å¤šæ€å¯¹è±¡çš„åŠ¨æ€ç±»å‹ï¼Œæˆ–æ˜¯è¯†åˆ«é™æ€ç±»å‹çš„åœ°æ–¹ã€‚\næˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªç®€å•çš„ demo ç”¨äºè·å–å¯¹è±¡ç±»å‹ç›¸å…³çš„ä¿¡æ¯ï¼Œéœ€è¦åŒ…å« tepyinfo å¤´æ–‡ä»¶ï¼š\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;typeinfo\u0026gt; using namespace std; class Foo {}; int main() { cout \u0026lt;\u0026lt; \u0026#34;1: \u0026#34; \u0026lt;\u0026lt; typeid(1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; typeid(int).name() \u0026lt;\u0026lt; endl; // å’Œ sizeof æ“ä½œç¬¦ç±»ä¼¼ï¼Œtypeid ä¹Ÿå¯ä»¥ç›´æ¥å¯¹æ•°æ®ç±»å‹ï¼ˆæ¯”å¦‚ intï¼‰è¿›è¡Œæ“ä½œ  cout \u0026lt;\u0026lt; \u0026#34;typeid: \u0026#34; \u0026lt;\u0026lt; typeid(typeid(int)).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;typeid: \u0026#34; \u0026lt;\u0026lt; typeid(const type_info \u0026amp;).","title":"boost::typeIndex çš„ç›¸å…³æ¢ç©¶"},{"content":"CMake å…¥é—¨ 0. åº CMake æ˜¯ä¸€ä¸ªè·¨å¹³å°çš„å¼€æºæ„å»ºå·¥å…·ï¼Œä½¿ç”¨ CMake èƒ½å¤Ÿæ–¹ä¾¿åœ°ç®¡ç†ä¾èµ–å¤šä¸ªåº“çš„ç›®å½•å±‚æ¬¡ç»“æ„å¹¶ç”Ÿæˆ makefile å’Œä½¿ç”¨ GNU make æ¥ç¼–è¯‘å’Œè¿æ¥ç¨‹åºã€‚\n1. æ„å»ºå•ä¸ªæ–‡ä»¶ 1.1 ä½¿ç”¨ GCC ç¼–è¯‘ å‡è®¾ç°åœ¨æˆ‘ä»¬å¸Œæœ›ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥å®ç°å®‰å…¨çš„ int ç±»å‹åŠ æ³•é˜²æ­¢æ•°æ®æº¢å‡ºï¼Œè¿™ä¸ªæºæ–‡ä»¶æ²¡æœ‰ä»»ä½•ä¾èµ–çš„æºç æˆ–é™æ€åº“ï¼š\n// safe_add.cpp #include \u0026lt;iostream\u0026gt;#include \u0026lt;memory\u0026gt;#define INT_MAX 2147483647 #define ERROR_DATA_OVERFLOW 2  int SafeIntAdd(std::unique_ptr\u0026lt;int\u0026gt; \u0026amp;sum, int a, int b) { if (a \u0026gt; INT_MAX - b) { *sum = INT_MAX; return ERROR_DATA_OVERFLOW; } *sum = a + b; return EXIT_SUCCESS; } int main() { int a, b; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; std::unique_ptr\u0026lt;int\u0026gt; sum(new int(1)); int res = SafeIntAdd(sum, a, b); std::cout \u0026lt;\u0026lt; *sum \u0026lt;\u0026lt; std::endl; return res; } æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ä¸€å¥ç®€å•çš„ gcc å‘½ä»¤æ¥ç¼–è¯‘è¿™ä¸ªæ–‡ä»¶å¹¶æ‰§è¡Œï¼š\n[joelzychen@DevCloud ~/cmake-tutorial]$ g++ main.cc -g -Wall -std=c++11 -o SafeIntAdd [joelzychen@DevCloud ~/cmake-tutorial]$ ./SafeIntAdd 2100000000 2100000000 2147483647 1.2 ä½¿ç”¨ cmake æ„å»º å¦‚æœè¦ä½¿ç”¨ cmake æ¥ç”Ÿæˆ makefile çš„è¯æˆ‘ä»¬éœ€è¦é¦–å…ˆæ–°å»ºä¸€ä¸ª CMakeLists.txt æ–‡ä»¶ï¼Œcmake çš„æ‰€æœ‰é…ç½®éƒ½åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­å®Œæˆï¼ŒCMakeLists.txt ä¸­çš„å†…å®¹å¤§è‡´å¦‚ä¸‹ï¼š\ncmake_minimum_required(VERSION 3.10)project(SafeIntAdd)set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)set(CMAKE_CXX_FLAGS -g -Wall)message(STATUS \u0026#34;CMAKE_CXX_FLAGS: \u0026#34; \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;)string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;)message(STATUS \u0026#34;CMAKE_CXX_FLAGS: \u0026#34; \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;)add_executable(SafeIntAdd main.cc)å…¶ä¸­æœ‰ä¸€äº›åŸºç¡€çš„ cmake æŒ‡ä»¤ï¼Œå®ƒä»¬çš„å«ä¹‰å¦‚ä¸‹ï¼š\n cmake_minimum_requiredï¼šcmake çš„æœ€ä½ç‰ˆæœ¬è¦æ±‚ projectï¼šæŒ‡å®šé¡¹ç›®çš„åç§° setï¼šè®¾ç½®æ™®é€šå˜é‡ï¼Œç¼“å­˜å˜é‡æˆ–ç¯å¢ƒå˜é‡ï¼Œä¸Šé¢ä¾‹å­ä¸­çš„ add_executableï¼šä½¿ç”¨åˆ—å‡ºçš„æºæ–‡ä»¶æ„å»ºå¯æ‰§è¡Œæ–‡ä»¶  æœ‰å‡ ä¸ªéœ€è¦æ³¨æ„çš„ç‚¹ï¼š\n  cmake çš„æŒ‡ä»¤æ˜¯ä¸åŒºåˆ†å¤§å°å†™çš„ï¼Œå†™ä½œ CMAKE_MINIMUM_REQUIRED æˆ– cmake_minimum_requiredï¼Œç”šè‡³æ˜¯ cmAkE_mInImUm_rEquIrEdï¼ˆä¸å»ºè®®ï¼‰éƒ½æ˜¯å¯ä»¥çš„\n  åœ¨ä½¿ç”¨ set æŒ‡ä»¤æŒ‡å®š CMAKE_CXX_FLAGS çš„æ—¶å€™é€šè¿‡ç©ºæ ¼æ¥åˆ†éš”å¤šä¸ªç¼–è¯‘é€‰é¡¹ï¼Œç”Ÿæˆçš„ CMAKE_CXX_FLAGS å­—ç¬¦ä¸²æ˜¯ \u0026ldquo;-g;-Wall\u0026rdquo;ï¼Œéœ€è¦ç”¨å­—ç¬¦ä¸²æ›¿æ¢å°†åˆ†å·æ›¿æ¢ä¸ºç©ºæ ¼\n  message å¯ä»¥åœ¨æ„å»ºçš„è¿‡ç¨‹ä¸­å‘ stdout è¾“å‡ºä¸€äº›ä¿¡æ¯ï¼Œä¸Šé¢ä¾‹å­ä¸­çš„è¾“å‡ºä¿¡æ¯ä¸ºï¼š\n-- CMAKE_CXX_FLAGS: -g;-Wall -- CMAKE_CXX_FLAGS: -g -Wall   ç±»ä¼¼äº bash è„šæœ¬ï¼Œåœ¨ CMakeLists.txt ä¸­è¾“å‡ºå˜é‡æ—¶è¦ä½¿ç”¨ \u0026ldquo;${CMAKE_CXX_FLAGS}\u0026rdquo; çš„å½¢å¼ï¼Œè€Œä¸èƒ½ç›´æ¥ä½¿ç”¨ CMAKE_CXX_FLAGS\n  ç¼–è¾‘å¥½ CMakeLists.txt ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥æ–°å»ºä¸€ä¸ª build ç›®å½•ï¼Œå¹¶åœ¨ build ç›®å½•ä¸‹ä½¿ç”¨ cmake æ¥è¿›è¡Œæ„å»ºï¼Œæ„å»ºæˆåŠŸçš„è¯å†ä½¿ç”¨ make æ¥è¿›è¡Œç¼–è¯‘å’Œé“¾æ¥ï¼Œæœ€ç»ˆå¾—åˆ° SafeAdd è¿™ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼š\n[joelzychen@DevCloud ~/cmake-tutorial]$ mkdir build/ [joelzychen@DevCloud ~/cmake-tutorial]$ cd build/ [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake .. -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- CMAKE_CXX_FLAGS: -g;-Wall -- CMAKE_CXX_FLAGS: -g -Wall -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target SafeIntAdd [ 50%] Building CXX object CMakeFiles/SafeIntAdd.dir/main.cc.o [100%] Linking CXX executable SafeIntAdd [100%] Built target SafeIntAdd [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./SafeIntAdd 2100000000 2100000000 2147483647 2. æ„å»ºå¤šä¸ªæ–‡ä»¶ 2.1 ä½¿ç”¨ GCC ç¼–è¯‘ å‡è®¾ç°åœ¨æˆ‘ä»¬å¸Œæœ›å°†åŠ æ³•å‡½æ•°æ”¾åˆ°å•ç‹¬çš„æ–‡ä»¶ä¸­å»ï¼Œå¹¶åœ¨ main å‡½æ•°æ‰€åœ¨çš„æºæ–‡ä»¶ä¸­åŒ…å«è¿™ä¸ªæ–‡ä»¶ï¼š\n// main.cc #include \u0026#34;math.h\u0026#34;#include \u0026#34;error_code.h\u0026#34;#include \u0026lt;iostream\u0026gt; int main() { int a{ 0 }, b{ 0 }, c{ 0 }; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; int sum{ 0 }; int ret_val = SafeAdd(sum, a, b, c); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return ret_val; } // util/math.h #ifndef UTIL_MATH_H #define UTIL_MATH_H  #include \u0026#34;error_code.h\u0026#34;#include \u0026lt;limits\u0026gt; template\u0026lt;typename ValueType\u0026gt; ValueType ValueTypeMax(ValueType) { return std::numeric_limits\u0026lt;ValueType\u0026gt;::max(); } template\u0026lt;typename ValueType\u0026gt; int SafeAdd(ValueType \u0026amp;sum) { return exit_success; } template\u0026lt;typename ValueType, typename ...ValueTypes\u0026gt; int SafeAdd(ValueType \u0026amp;sum, const ValueType \u0026amp;value, const ValueTypes \u0026amp;...other_values) { int ret_val = SafeAdd\u0026lt;ValueType\u0026gt;(sum, other_values...); if (ret_val != exit_success) { return ret_val; } if (sum \u0026gt; ValueTypeMax(value) - value) { sum = ValueTypeMax(value); return error_data_overflow; } sum += value; return exit_success; } #endif // definition/error_code.h #ifndef DEFINITION_ERROR_CODE_H #define DEFINITION_ERROR_CODE_H  constexpr int exit_success = 0; constexpr int exit_failure = 1; constexpr int error_data_overflow = 2; #endif æˆ‘ä»¬å¯ä»¥åœ¨ä½¿ç”¨ GCC ç¼–è¯‘çš„æ—¶å€™ä½¿ç”¨ -I å‚æ•°æŒ‡å®šå¤´æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•ï¼š\n[joelzychen@DevCloud ~/safe_add]$ g++ -g -Wall -std=c++11 -Ilib -Idefinition -o SafeAdd main.cc [joelzychen@DevCloud ~/safe_add]$ ./SafeAdd 20000 50000 80000 150000 2.2 ä½¿ç”¨ cmake æ„å»º cmake_minimum_required(VERSION 3.10)project(SafeIntAdd)set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)set(CMAKE_CXX_FLAGS -g -Wall)string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;)include_directories(lib/ definition/)aux_source_directory(./ SOURCE_DIR)add_executable(SafeIntAdd ${SOURCE_DIR})ç›¸æ¯”äºæ„å»ºå•ä¸ªæ–‡ä»¶ï¼Œæˆ‘ä»¬é¢å¤–ä½¿ç”¨äº†ä¸¤ä¸ªæŒ‡ä»¤ï¼š\n include_directoriesï¼šæ·»åŠ å¤šä¸ªå¤´æ–‡ä»¶æœç´¢è·¯å¾„ï¼Œè·¯å¾„ä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”ï¼›å¦‚æœå°† lib å’Œ definition ç›®å½•éƒ½æ·»åŠ åˆ°åˆ°æœç´¢è·¯å¾„çš„è¯ï¼Œåœ¨ include çš„æ—¶å€™å°±ä¸éœ€è¦ä½¿ç”¨ç›¸å¯¹è·¯å¾„äº† aux_source_directoryï¼šåœ¨ç›®å½•ä¸­æŸ¥æ‰¾æ‰€æœ‰æºæ–‡ä»¶ï¼Œå¹¶å°†è¿™äº›æºæ–‡ä»¶å­˜å‚¨åœ¨å˜é‡ SOURCE_DIR ä¸­ï¼›éœ€è¦æ³¨æ„è¿™ä¸ªæŒ‡ä»¤ä¸ä¼šé€’å½’åŒ…å«å­ç›®å½•  æ¥ä¸‹æ¥è¿›å…¥ build ç›®å½•è¿›è¡Œæ„å»ºï¼š\n[joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake .. -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target SafeIntAdd [ 50%] Building CXX object CMakeFiles/SafeIntAdd.dir/main.cc.o [100%] Linking CXX executable SafeIntAdd [100%] Built target SafeIntAdd [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./SafeIntAdd 2000000000 1900000000 2147483647 3. æ„å»ºä¾èµ–äºé™æ€åº“çš„é¡¹ç›® å…³äºé™æ€åº“å’ŒåŠ¨æ€åº“ç›¸å…³å†…å®¹å¯ä»¥å‚è€ƒæµ…è°ˆé™æ€åº“å’ŒåŠ¨æ€åº“ã€‚\n3.1 ä½¿ç”¨ GCC ç¼–è¯‘é™æ€åº“æ–‡ä»¶ å‡è®¾ç°åœ¨æˆ‘ä»¬å¸Œæœ›å°† exp2 å‡½æ•°å°è£…åˆ°ä¸€ä¸ªè®¡ç®—å™¨å•ä¾‹ç±»ä¸­ï¼Œå¹¶è®¡ç®— 2 çš„ n æ¬¡æ–¹ï¼Œå¹¶ä¸ºæ­¤ç¼–å†™äº†ä»¥ä¸‹è¿™äº›æ–‡ä»¶ï¼š\n// main.cc #include \u0026#34;util/calculator.h\u0026#34;#include \u0026#34;definition/error_code.h\u0026#34;#include \u0026lt;iostream\u0026gt; int main() { double a{ 0 }; std::cin \u0026gt;\u0026gt; a; double exp2{ 0 }; int ret_val = Calculator::GetInstance().Exp2(exp2, a); if (ret_val != exit_success) { return ret_val; } std::cout \u0026lt;\u0026lt; exp2 \u0026lt;\u0026lt; std::endl; return exit_success; } // util/singleton.h #ifndef UTIL_SINGLETON_H #define UTIL_SINGLETON_H  template \u0026lt;typename T\u0026gt; class Singleton { public: static T\u0026amp; GetInstance() { static T instance; return instance; } Singleton(Singleton const \u0026amp;) = delete; Singleton\u0026amp; operator=(Singleton const \u0026amp;) = delete; protected: Singleton() = default; ~Singleton() = default; }; #endif // definition/error_code.h #ifndef DEFINITION_ERROR_CODE_H #define DEFINITION_ERROR_CODE_H  constexpr int exit_success = 0; constexpr int exit_failure = 1; constexpr int error_data_overflow = 2; #endif // util/calculator.h #ifndef UTIL_CALCULATOR_H #define UTIL_CALCULATOR_H  #include \u0026#34;singleton.h\u0026#34;#include \u0026#34;../definition/error_code.h\u0026#34;#include \u0026lt;limits\u0026gt;#include \u0026lt;cmath\u0026gt; class Calculator : public Singleton\u0026lt;Calculator\u0026gt; { public: template\u0026lt;typename ValueType\u0026gt; ValueType ValueTypeMax(ValueType) { return std::numeric_limits\u0026lt;ValueType\u0026gt;::max(); } int Exp2(double \u0026amp;exp2, const double \u0026amp;val); }; #endif ä¸ºäº†æ–¹ä¾¿ç”Ÿæˆé™æ€åº“æ–‡ä»¶ï¼Œæˆ‘ä»¬å…ˆå°† calculator.cc è¿™ä¸ªæ–‡ä»¶æ”¾åˆ° archive ç›®å½•ä¸‹ï¼š\n// archive/calculator.cc #include \u0026#34;../util/calculator.h\u0026#34; int Calculator::Exp2(double \u0026amp;exp2, const double \u0026amp;val) { if (std::sqrt(ValueTypeMax(val)) \u0026lt; val) { exp2 = ValueTypeMax(val); return error_data_overflow; } exp2 = std::exp2(val); return exit_success; } å¯¹äº calculator.cc è¿™ä¸ªæºæ–‡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ -c å‚æ•°å°†å…¶ç¼–è¯‘ä¸º obj æ–‡ä»¶ï¼Œå†ä½¿ç”¨ ar å½’æ¡£å°±èƒ½å°†å…¶ç¼–è¯‘ä¸ºä¸€ä¸ª .a åº“æ–‡ä»¶äº†ï¼šï¼š\n[joelzychen@DevCloud ~/cmake-tutorial/archive]$ g++ calculator.cc -g -Wall -std=c++11 -c [joelzychen@DevCloud ~/cmake-tutorial/archive]$ ar -crv libcalculator.a calculator.o a - calculator.o 3.2 ä½¿ç”¨ GCC ç¼–è¯‘é¡¹ç›®å’Œé“¾æ¥é™æ€åº“ ç°åœ¨çš„ç›®å½•ç»“æ„å¦‚ä¸‹ï¼š\n[joelzychen@DevCloud ~/cmake-tutorial]$ tree . |-- archive | |-- calculator.cc | |-- calculator.o | `-- libcalculator.a |-- CMakeLists.txt |-- definition | `-- error_code.h |-- main.cc `-- util |-- calculator.h `-- singleton.h 3 directories, 8 files ä½¿ç”¨ GCC ç¼–è¯‘å’Œé“¾æ¥åˆ°å¯¹åº”çš„é™æ€åº“æ–‡ä»¶å³å¯å¾—åˆ°å¯æ‰§è¡Œæ–‡ä»¶ï¼š\n[joelzychen@DevCloud ~/cmake-tutorial]$ g++ main.cc -g -Wall -std=c++11 -o Exp2 -Larchive -lcalculator [joelzychen@DevCloud ~/cmake-tutorial]$ ll Exp2 32K -rwxrwxr-x 1 joelzychen joelzychen 31K Jun 21 14:38 Exp2 [joelzychen@DevCloud ~/cmake-tutorial]$ ./Exp2 8 256 éœ€è¦æ³¨æ„çš„ç‚¹æœ‰ï¼š\n -Llib ç”¨äºæŒ‡å®šåº“æ–‡ä»¶ç›®å½• -lsingleton ç”¨äºæŒ‡å®šåº“æ–‡ä»¶ -L å’Œ -l å‚æ•°ä¸€å®šè¦åœ¨ -o å‚æ•°ä¹‹å  3.3 ä½¿ç”¨ cmake æ„å»ºé¡¹ç›®å’Œé“¾æ¥é™æ€åº“ æˆ‘ä»¬åˆšæ‰å·²ç»ç”¨ GCC ç¼–è¯‘å¥½äº†é™æ€åº“æ–‡ä»¶ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥åœ¨ CMakeLists.txt é‡Œæ·»åŠ é“¾æ¥é™æ€åº“çš„æŒ‡ä»¤ï¼š\ncmake_minimum_required(VERSION 3.10)project(Exp2)set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)set(CMAKE_CXX_FLAGS -g -Wall)string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/)message(STATUS \u0026#34;source dir: \u0026#34; ${PROJECT_SOURCE_DIR})message(STATUS \u0026#34;binary dir: \u0026#34; ${PROJECT_BINARY_DIR})message(STATUS \u0026#34;output dir: \u0026#34; ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})include_directories(./)aux_source_directory(./ SOURCE_DIR)link_directories(archive/)add_executable(Exp2 ${SOURCE_DIR})target_link_libraries(Exp2 libcalculator.a)# target_link_libraries(Exp2 calculator) å’Œä¹‹å‰ç›¸æ¯”ï¼Œé¢å¤–ä½¿ç”¨çš„æŒ‡ä»¤æœ‰ï¼š\n link_directoriesï¼šæŒ‡å®šé™æ€åº“æˆ–åŠ¨æ€åº“çš„æœç´¢è·¯å¾„ target_link_librariesï¼šå°†æŒ‡å®šçš„é™æ€åº“è¿æ¥åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸Šï¼Œsingleton å’Œ libsingleton.a ä¸¤ç§å½¢å¼ç­‰ä»·  ç„¶åè¿›å…¥ build ç›®å½•è¿›è¡Œæ„å»ºï¼š\n[joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake ../ -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- source dir: /home/joelzychen/cmake-tutorial -- binary dir: /home/joelzychen/cmake-tutorial/build -- output dir: /home/joelzychen/cmake-tutorial/build/bin/ -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target Exp2 [ 50%] Building CXX object CMakeFiles/Exp2.dir/main.cc.o [100%] Linking CXX executable bin/Exp2 [100%] Built target Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll bin/Exp2 32K -rwxrwxr-x 1 joelzychen joelzychen 31K Jun 21 14:58 bin/Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./bin/Exp2 6 64 å¯ä»¥çœ‹åˆ°é€šè¿‡ cmake æ„å»ºå¾—åˆ°äºŒè¿›åˆ¶æ–‡ä»¶å¤§å°å’Œç›´æ¥é€šè¿‡ GCC ç¼–è¯‘å’Œé“¾æ¥å¾—åˆ°çš„äºŒè¿›åˆ¶æ–‡ä»¶å¤§å°æ˜¯ç›¸åŒçš„ã€‚è¿™æ¬¡ç”¨ set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/) å‘½ä»¤å°†ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶æ”¾åˆ°äº† bin ç›®å½•ä¸‹ï¼Œæ³¨æ„è¿™é‡Œçš„ bin ç›®å½•æ˜¯ä½¿ç”¨ cmake è¿›è¡Œæ„å»ºçš„ç›®å½•ï¼ˆPROJECT_BINARY_DIRï¼‰ï¼Œä¸æ˜¯ CMakeLists.txt æ‰€åœ¨çš„ç›®å½•ï¼ˆPROJECT_SOURCE_DIRï¼‰ã€‚\n3.4 ä½¿ç”¨ cmake æ„å»ºé™æ€åº“æ–‡ä»¶å’Œé¡¹ç›® é™¤äº†ç›´æ¥å¼•ç”¨å¤–éƒ¨çš„é™æ€åº“ï¼Œcmake è¿˜å¯ä»¥å…ˆå°†æºæ–‡ä»¶ç¼–è¯‘æˆé™æ€åº“ä¹‹ååœ¨è¿›è¡Œæ„å»ºï¼š\ncmake_minimum_required(VERSION 3.10)set(project_name Exp2)project(${project_name})set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)set(CMAKE_CXX_FLAGS -g -Wall)string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/)message(STATUS \u0026#34;source dir: \u0026#34; ${PROJECT_SOURCE_DIR})message(STATUS \u0026#34;binary dir: \u0026#34; ${PROJECT_BINARY_DIR})message(STATUS \u0026#34;output dir: \u0026#34; \u0026#34;${PROJECT_BINARY_DIR}/${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\u0026#34;)include_directories(./)aux_source_directory(./ SOURCE_DIR)set(static_lib_source_file archive/calculator.cc)add_library(calculator_static STATIC ${static_lib_source_file})add_executable(${project_name} ${SOURCE_DIR})target_link_libraries(${project_name} calculator_static)è¿™é‡Œç”¨åˆ°äº†ä¸€ä¸ªæ–°çš„æŒ‡ä»¤ add_library æ¥ä½¿ç”¨æŒ‡å®šçš„æºæ–‡ä»¶ç”Ÿæˆåº“æ–‡ä»¶ï¼Œå†ä½¿ç”¨ target_link_libraries å°†ç”Ÿæˆçš„åº“æ–‡ä»¶æ·»åŠ åˆ°é¡¹ç›®ä¸­ï¼›æ¥ä¸‹æ¥è¿›è¡Œæ„å»ºï¼š\n[joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake ../ -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- source dir: /home/joelzychen/cmake-tutorial -- binary dir: /home/joelzychen/cmake-tutorial/build -- output dir: /home/joelzychen/cmake-tutorial/build/bin/ -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target calculator_static [ 25%] Building CXX object CMakeFiles/calculator_static.dir/archive/calculator.cc.o [ 50%] Linking CXX static library libcalculator_static.a [ 50%] Built target calculator_static Scanning dependencies of target Exp2 [ 75%] Building CXX object CMakeFiles/Exp2.dir/main.cc.o [100%] Linking CXX executable bin/Exp2 [100%] Built target Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll | grep calculator 12K -rw-rw-r-- 1 joelzychen joelzychen 11K Jun 21 15:30 libcalculator_static.a [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./bin/Exp2 5 32 å¯ä»¥çœ‹åˆ°åœ¨ build ç›®å½•ä¸‹ç”Ÿæˆäº†ä¸€ä¸ªåä¸º libcalculator_static.a çš„é™æ€åº“æ–‡ä»¶ï¼Œè¿™ä¸ªåå­—æ˜¯ç”±ä½¿ç”¨ add_library æŒ‡ä»¤æ—¶çš„ç¬¬ä¸€ä¸ªå‚æ•°æŒ‡å®šçš„ã€‚\n4. æ„å»ºä¾èµ–äºåŠ¨æ€åº“çš„é¡¹ç›® 4.1 ä½¿ç”¨ GCC ç¼–è¯‘åŠ¨æ€åº“æ–‡ä»¶ ä»ç„¶ä½¿ç”¨ä¹‹å‰å·²æœ‰çš„æ–‡ä»¶ï¼Œåœ¨ archive ç›®å½•ä¸‹ç”ŸæˆåŠ¨æ€åº“æ–‡ä»¶ï¼š\n[joelzychen@DevCloud ~/cmake-tutorial/archive]$ rm calculator.o libcalculator.a [joelzychen@DevCloud ~/cmake-tutorial/archive]$ g++ calculator.cc -g -Wall -std=c++11 -c -fPIC [joelzychen@DevCloud ~/cmake-tutorial/archive]$ g++ calculator.o -g -Wall -std=c++11 -shared -o libcalculator.so åˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼š\n ä½¿ç”¨ -c å’Œ -fPIC å‚æ•°ç”Ÿæˆä½ç½®æ— å…³çš„ï¼ˆposition independent codeï¼‰æœºå™¨ç  .o æ–‡ä»¶ ä½¿ç”¨ -shared å‚æ•°ç”Ÿæˆ .so åŠ¨æ€åº“æ–‡ä»¶  ä¹Ÿå¯ä»¥åˆå¹¶ä¸ºä¸€ä¸ªæ­¥éª¤ï¼š\n[joelzychen@DevCloud ~/cmake-tutorial/archive]$ g++ calculator.cc -g -Wall -std=c++11 -shared -fPIC -o libcalculator.so è¿™æ ·å¯ä»¥ç›´æ¥ç”ŸæˆåŠ¨æ€åº“æ–‡ä»¶ï¼Œçœå»ç”Ÿæˆæœºå™¨ç æ–‡ä»¶çš„ä¸­é—´æ­¥éª¤ã€‚\n4.2 ä½¿ç”¨ GCC ç¼–è¯‘é¡¹ç›®å’Œé“¾æ¥åŠ¨æ€åº“ å’Œé“¾æ¥åˆ°é™æ€åº“ç±»ä¼¼ï¼Œåœ¨ç¼–è¯‘åé“¾æ¥åŠ¨æ€åº“å³å¯ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶ï¼š\n[joelzychen@DevCloud ~/cmake-tutorial]$ g++ main.cc -g -Wall -std=c++11 -o Exp2 -Larchive -lcalculator [joelzychen@DevCloud ~/cmake-tutorial]$ ./Exp2 ./Exp2: error while loading shared libraries: libcalculator.so: cannot open shared object file: No such file or directory æˆ‘ä»¬å‘ç°åœ¨è¿è¡ŒäºŒçº§åˆ¶æ–‡ä»¶æ—¶ä¼šå‡ºç°æ‰¾ä¸åˆ°åŠ¨æ€åº“çš„æŠ¥é”™ï¼Œè¿™æ˜¯å› ä¸ºåŠ¨æ€é“¾æ¥åº“ç¯å¢ƒå˜é‡çš„ç›®å½•ä¸‹æ²¡æœ‰æ‰¾åˆ°ç¼–è¯‘æ—¶æ‰€ç”¨åˆ°çš„åŠ¨æ€åº“ï¼Œæˆ‘ä»¬å¯ä»¥å°†å¯¹åº”çš„ç›®å½•æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ä¸‹ï¼Œæˆ–æ˜¯å°†åŠ¨æ€åº“æ‹·è´åˆ°ç¯å¢ƒå˜é‡çš„ç›®å½•ä¸‹ï¼š\n[joelzychen@DevCloud ~/cmake-tutorial]$ echo $LD_LIBRARY_PATH [joelzychen@DevCloud ~/cmake-tutorial]$ export LD_LIBRARY_PATH=\u0026#34;/usr/lib/\u0026#34; [joelzychen@DevCloud ~/cmake-tutorial]$ sudo cp archive/libcalculator.so /usr/lib/ æ¥ä¸‹æ¥å°±å¯ä»¥è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶äº†ï¼Œå¯ä»¥çœ‹åˆ°ä½¿ç”¨é“¾æ¥åŠ¨æ€åº“æ–¹å¼ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶çš„å¤§å°è¦å°äºä½¿ç”¨é“¾æ¥é™æ€åº“æ–¹å¼ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œä½¿ç”¨ ldd å‘½ä»¤ä¹Ÿèƒ½çœ‹åˆ°å¯æ‰§è¡Œæ–‡ä»¶æ˜¯æ­£ç¡®åœ°è°ƒç”¨äº†å¯¹åº”çš„åŠ¨æ€åº“æ–‡ä»¶ï¼š\n[joelzychen@DevCloud ~/cmake-tutorial]$ ./Exp2 9 512 [joelzychen@DevCloud ~/cmake-tutorial]$ ll Exp2 28K -rwxrwxr-x 1 joelzychen joelzychen 28K Jun 21 14:25 Exp2 [joelzychen@DevCloud ~/cmake-tutorial]$ ldd Exp2 | grep calculator libcalculator.so =\u0026gt; /usr/lib/libcalculator.so (0x00007fd2391f0000) 4.3 ä½¿ç”¨ cmake æ„å»ºé¡¹ç›®å’Œé“¾æ¥åŠ¨æ€åº“ å’Œæ„å»ºé™æ€åº“ç±»ä¼¼ï¼Œåªéœ€è¦å°† CMakeLists.txt ä¸­é“¾æ¥é™æ€åº“çš„æŒ‡ä»¤ä¿®æ”¹ä¸ºé“¾æ¥åŠ¨æ€åº“å³å¯è¿›è¡Œæ„å»ºï¼š\ncmake_minimum_required(VERSION 3.10)project(Exp2)set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)set(CMAKE_CXX_FLAGS -g -Wall)string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/)message(STATUS \u0026#34;source dir: \u0026#34; ${PROJECT_SOURCE_DIR})message(STATUS \u0026#34;binary dir: \u0026#34; ${PROJECT_BINARY_DIR})message(STATUS \u0026#34;output dir: \u0026#34; \u0026#34;${PROJECT_BINARY_DIR}/${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\u0026#34;)include_directories(./)aux_source_directory(./ SOURCE_DIR)link_directories(archive/)add_executable(Exp2 ${SOURCE_DIR})target_link_libraries(Exp2 libcalculator.so)[joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake ../ -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- source dir: /home/joelzychen/cmake-tutorial -- binary dir: /home/joelzychen/cmake-tutorial/build -- output dir: /home/joelzychen/cmake-tutorial/build/bin/ -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target Exp2 [ 50%] Building CXX object CMakeFiles/Exp2.dir/main.cc.o [100%] Linking CXX executable bin/Exp2 [100%] Built target Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll bin/Exp2 28K -rwxrwxr-x 1 joelzychen joelzychen 28K Jun 21 15:04 bin/Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ldd bin/Exp2 | grep calculator libcalculator.so =\u0026gt; /home/joelzychen/cmake-tutorial/archive/libcalculator.so (0x00007f4c87e35000) [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./bin/Exp2 6 64 å¯ä»¥çœ‹åˆ°é€šè¿‡ cmake æ„å»ºå¾—åˆ°äºŒè¿›åˆ¶æ–‡ä»¶å¤§å°å’Œç›´æ¥é€šè¿‡ GCC ç¼–è¯‘å’Œé“¾æ¥åŠ¨æ€åº“å¾—åˆ°çš„äºŒè¿›åˆ¶æ–‡ä»¶å¤§å°ä¹Ÿæ˜¯ç›¸åŒçš„ã€‚\n4.4 ä½¿ç”¨ cmake æ„å»ºåŠ¨æ€åº“æ–‡ä»¶å’Œé¡¹ç›® ä½¿ç”¨ cmake æ„å»ºåŠ¨æ€åº“çš„æ­¥éª¤å’Œæ„å»ºé™æ€åº“çš„æ­¥éª¤å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œåªéœ€è¦å°† add_library çš„ STATIC å‚æ•°æ”¹ä¸º SHARED å³å¯ï¼š\ncmake_minimum_required(VERSION 3.10)set(project_name Exp2)project(${project_name})set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)set(CMAKE_CXX_FLAGS -g -Wall)string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/)message(STATUS \u0026#34;source dir: \u0026#34; ${PROJECT_SOURCE_DIR})message(STATUS \u0026#34;binary dir: \u0026#34; ${PROJECT_BINARY_DIR})message(STATUS \u0026#34;output dir: \u0026#34; \u0026#34;${PROJECT_BINARY_DIR}/${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\u0026#34;)include_directories(./)aux_source_directory(./ SOURCE_DIR)set(shared_lib_source_file archive/calculator.cc)add_library(calculator_shared SHARED ${shared_lib_source_file})add_executable(${project_name} ${SOURCE_DIR})target_link_libraries(${project_name} calculator_shared)[joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake .. -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- source dir: /home/joelzychen/cmake-tutorial -- binary dir: /home/joelzychen/cmake-tutorial/build -- output dir: /home/joelzychen/cmake-tutorial/build/bin/ -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target calculator_shared [ 25%] Building CXX object CMakeFiles/calculator_shared.dir/archive/calculator.cc.o [ 50%] Linking CXX shared library libcalculator_shared.so [ 50%] Built target calculator_shared Scanning dependencies of target Exp2 [ 75%] Building CXX object CMakeFiles/Exp2.dir/main.cc.o [100%] Linking CXX executable bin/Exp2 [100%] Built target Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll | grep calculator 16K -rwxrwxr-x 1 joelzychen joelzychen 13K Jun 21 15:34 libcalculator_shared.so [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll bin/Exp2 28K -rwxrwxr-x 1 joelzychen joelzychen 28K Jun 21 15:34 bin/Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ldd bin/Exp2 | grep calculator libcalculator_shared.so =\u0026gt; /home/joelzychen/cmake-tutorial/build/libcalculator_shared.so (0x00007f1fa5aa5000) [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./bin/Exp2 7 128 å¯ä»¥çœ‹åˆ°å¾—åˆ°çš„äºŒè¿›åˆ¶æ–‡ä»¶çš„ç›¸å…³ä¿¡æ¯å’Œä½¿ç”¨å‰å‡ ç§æ–¹æ³•å¾—åˆ°çš„éƒ½æ˜¯ç›¸åŒçš„ã€‚\n5. å¸¸ç”¨å‘½ä»¤ 5.1 é¡¹ç›®ç›¸å…³  cmake_minimum_required(VERSION 3.10)ï¼šæŒ‡å®š cmake çš„æœ€ä½ç‰ˆæœ¬è¦æ±‚ project(project_name)ï¼šæŒ‡å®šé¡¹ç›®çš„åç§° set(CMAKE_CXX_FLAGS -g -Wall -pthread)ï¼šè®¾ç½®æ™®é€šå˜é‡ï¼Œç¼“å­˜å˜é‡æˆ–ç¯å¢ƒå˜é‡  5.2 ç¼–è¯‘ç›¸å…³  include_directoriesï¼šæŒ‡å®šå¤´æ–‡ä»¶çš„ç›®å½•ï¼Œç±»ä¼¼äº GCC ç¼–è¯‘æ—¶çš„ -I å‚æ•°ï¼›ç­‰ä»·äºå°†å¤´æ–‡ä»¶ç›®å½•æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ CPLUS_INCLUDE_PATH ä¸­ aux_source_directoryï¼šåœ¨ç›®å½•ä¸­ï¼ˆä¸å«å­ç›®å½•ï¼‰æŸ¥æ‰¾æ‰€æœ‰æºæ–‡ä»¶ï¼Œå¹¶å°†è¿™äº›æºæ–‡ä»¶å­˜å‚¨åœ¨å˜é‡ SOURCE_DIR ä¸­ add_executableï¼šä½¿ç”¨åˆ—å‡ºçš„æºæ–‡ä»¶æ„å»ºå¯æ‰§è¡Œæ–‡ä»¶ add_definitionsï¼šå®å®šä¹‰  5.3 é“¾æ¥ç›¸å…³  link_directoriesï¼šæŒ‡å®šåº“æ–‡ä»¶çš„ç›®å½•ï¼Œç±»ä¼¼äº GCC é“¾æ¥æ—¶çš„ -L å‚æ•°ï¼›ç­‰ä»·äºå°†åº“æ–‡ä»¶ç›®å½•æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ LD_LIBRARY_PATH ä¸­ target_link_librariesï¼šå°†æŒ‡å®šçš„é™æ€åº“è¿æ¥åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸Šï¼Œsingleton å’Œ libsingleton.a ä¸¤ç§å½¢å¼ç­‰ä»·  6. æ€»ç»“ æœ¬æ–‡é€šè¿‡å‡ ä¸ªç¤ºä¾‹ç¨‹åºå¯¹æ¯”äº†åœ¨ Linux ä¸‹ä½¿ç”¨ GCC å’Œ cmake æ¥ç¼–è¯‘å’Œæ„å»ºç¨‹åºçš„åŸºæœ¬æ­¥éª¤ï¼Œäº†è§£äº†ä¸€äº› cmake çš„åŸºç¡€æŒ‡ä»¤ã€‚å®é™…å¼€å‘ä¸­çš„é¡¹ç›®å¾€å¾€ä¼šéå¸¸å¤§ï¼Œä»¥è‡´äºä¸èƒ½å¤Ÿç›´æ¥ä½¿ç”¨ GCC æ¥ç¼–è¯‘æ•´ä¸ªé¡¹ç›®ï¼Œåœ¨è¿™ç§åœºæ™¯ä¸‹ä½¿ç”¨ cmake è¿›è¡Œæ„å»ºå¾€å¾€èƒ½å¤ŸèŠ‚çœæ—¶é—´å’Œæé«˜æ•ˆç‡ï¼Œè®©æˆ‘ä»¬èƒ½å¤Ÿä¸“æ³¨åœ¨é¡¹ç›®çš„å¼€å‘ä¸Šã€‚åœ¨å®é™…åº”ç”¨ä¸­ç¼–å†™ CMakeLists.txt çš„æ—¶å€™è¿˜ä¼šé‡åˆ°éå¸¸å¤šçš„é—®é¢˜ã€ä¸ç†Ÿæ‚‰çš„æŒ‡ä»¤å’Œå…¶ä»–çš„ä½¿ç”¨æŠ€å·§ï¼Œè¿™äº›éƒ½éœ€è¦ç»“åˆæ•™ç¨‹å’Œå®è·µæ¥è¿›ä¸€æ­¥å­¦ä¹ ã€‚\n","permalink":"http://zintrulcre.github.io/posts/c++/compilation/cmake/","summary":"CMake å…¥é—¨ 0. åº CMake æ˜¯ä¸€ä¸ªè·¨å¹³å°çš„å¼€æºæ„å»ºå·¥å…·ï¼Œä½¿ç”¨ CMake èƒ½å¤Ÿæ–¹ä¾¿åœ°ç®¡ç†ä¾èµ–å¤šä¸ªåº“çš„ç›®å½•å±‚æ¬¡ç»“æ„å¹¶ç”Ÿæˆ makefile å’Œä½¿ç”¨ GNU make æ¥ç¼–è¯‘å’Œè¿æ¥ç¨‹åºã€‚\n1. æ„å»ºå•ä¸ªæ–‡ä»¶ 1.1 ä½¿ç”¨ GCC ç¼–è¯‘ å‡è®¾ç°åœ¨æˆ‘ä»¬å¸Œæœ›ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥å®ç°å®‰å…¨çš„ int ç±»å‹åŠ æ³•é˜²æ­¢æ•°æ®æº¢å‡ºï¼Œè¿™ä¸ªæºæ–‡ä»¶æ²¡æœ‰ä»»ä½•ä¾èµ–çš„æºç æˆ–é™æ€åº“ï¼š\n// safe_add.cpp #include \u0026lt;iostream\u0026gt;#include \u0026lt;memory\u0026gt;#define INT_MAX 2147483647 #define ERROR_DATA_OVERFLOW 2  int SafeIntAdd(std::unique_ptr\u0026lt;int\u0026gt; \u0026amp;sum, int a, int b) { if (a \u0026gt; INT_MAX - b) { *sum = INT_MAX; return ERROR_DATA_OVERFLOW; } *sum = a + b; return EXIT_SUCCESS; } int main() { int a, b; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; std::unique_ptr\u0026lt;int\u0026gt; sum(new int(1)); int res = SafeIntAdd(sum, a, b); std::cout \u0026lt;\u0026lt; *sum \u0026lt;\u0026lt; std::endl; return res; } æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ä¸€å¥ç®€å•çš„ gcc å‘½ä»¤æ¥ç¼–è¯‘è¿™ä¸ªæ–‡ä»¶å¹¶æ‰§è¡Œï¼š","title":"CMake å…¥é—¨"},{"content":"GDB è°ƒè¯•å…¥é—¨ 0. åº è°ƒè¯•ç¨‹åºæ˜¯å¼€å‘è¿‡ç¨‹ä¸­å¿…ä¸å¯å°‘çš„ä¸€ç¯ï¼Œåœ¨ Windows æˆ– MacOS ä¸Šå¼€å‘æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ VS å’Œ CLion ç­‰ IDE ä¸Šè‡ªå¸¦çš„è°ƒè¯•åŠŸèƒ½æ¥æ‰“æ–­ç‚¹æˆ–æŸ¥çœ‹å˜é‡å’Œå †æ ˆï¼Œä½† Linux å¹¶æ²¡æœ‰å›¾å½¢åŒ–çš„æ“ä½œç•Œé¢ï¼Œè€Œå¦‚æœåªé€šè¿‡æ‰“ log çš„æ–¹å¼æ¥æŸ¥æ‰¾é—®é¢˜çš„è¯æ•ˆç‡å°†ä¼šéå¸¸ä½ä¸‹ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ GDB æ¥æå‡æˆ‘ä»¬çš„å¼€å‘æ•ˆç‡ã€‚\nGDB æ˜¯ GNU Debugger çš„ç®€å†™ï¼Œæ˜¯ GNU è½¯ä»¶ç³»ç»Ÿä¸­çš„æ ‡å‡†è°ƒè¯•å™¨ã€‚GDB å…·å¤‡å„ç§è°ƒè¯•åŠŸèƒ½ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºæ‰“æ–­ç‚¹ã€å•æ­¥æ‰§è¡Œã€æ‰“å°å˜é‡ã€æŸ¥çœ‹å¯„å­˜å™¨ã€æŸ¥çœ‹å‡½æ•°è°ƒç”¨å †æ ˆç­‰ï¼Œèƒ½å¤Ÿæœ‰æ•ˆåœ°é’ˆå¯¹å‡½æ•°çš„è¿è¡Œè¿›è¡Œè¿½è¸ªå’Œè­¦å‘Šï¼›ä½¿ç”¨ GDB è°ƒè¯•æ—¶ï¼Œå¯ä»¥ç›‘ç£å’Œä¿®æ”¹ç¨‹åºçš„å˜é‡ï¼Œå¹¶ä¸”è¿™äº›ä¿®æ”¹æ˜¯ç‹¬ç«‹äºä¸»ç¨‹åºä¹‹å¤–çš„ã€‚GDB ä¸»è¦ç”¨äºè°ƒè¯•ç¼–è¯‘å‹è¯­è¨€ï¼Œå¯¹ Cï¼ŒC++ï¼ŒGoï¼ŒFortran ç­‰è¯­è¨€æœ‰å†…ç½®çš„æ”¯æŒï¼Œä½†å®ƒä¸æ”¯æŒè§£é‡Šå‹è¯­è¨€ã€‚\n1. ç¯å¢ƒæ­å»º 1.1 ç¼–å†™ç¨‹åº ä¸ºäº†è¿›è¡Œè°ƒè¯•ï¼Œæˆ‘ä»¬éœ€è¦å‡†å¤‡ä¸€ä¸ªç®€å•çš„ C++ ç¨‹åºï¼š\n$ cat test.cpp #include \u0026lt;iostream\u0026gt; void Func(const char *s) { int *p = nullptr; int \u0026amp;r = static_cast\u0026lt;int\u0026amp;\u0026gt;(*p); int num = std::atoi(s); r = num; printf(\u0026#34;%d\\n\u0026#34;, r); } int main (int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;test [int]\\n\u0026#34;); return -1; } Func(argv[1]); return 0; } 1.2 ç¼–è¯‘ å¯¹äº C/C++ ç¨‹åºï¼Œåœ¨ä½¿ç”¨ gcc/clang ç¼–è¯‘çš„æ—¶å€™éœ€è¦åŠ ä¸Šå‚æ•° -gï¼Œæ‰èƒ½ç”Ÿæˆå®Œæ•´çš„è°ƒè¯•ä¿¡æ¯å¹¶åœ¨ GDB ä¸­è°ƒè¯•ï¼š\n$ clang++ -g -std=c++11 -m64 -o test test.cpp 2. è°ƒè¯•ç¤ºä¾‹ GDB æœ‰éå¸¸å¤šçš„åŠŸèƒ½ï¼Œå½“æˆ‘ä»¬å¿˜è®°å¦‚ä½•ä½¿ç”¨è¿™äº›åŠŸèƒ½æ—¶ï¼Œå¯ä»¥åœ¨ GDB äº¤äº’ç•Œé¢é‡Œè¾“å…¥ help æˆ– help all æ¥æŸ¥çœ‹æŒ‡ä»¤ï¼š\n(gdb) help\rList of classes of commands:\r...\r2.1 å¯åŠ¨ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ gdb [executable file] æ¥å¯åŠ¨è°ƒè¯•ï¼š\n$ gdb test.cpp\r...\rReading symbols from test...done.\r(gdb)\rä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ gdb æ¥è¿›å…¥äº¤äº’ç•Œé¢ï¼Œå†ä½¿ç”¨ file æ¥æŒ‡å®šè¦è°ƒè¯•çš„ç¨‹åºï¼š\n$ gdb\r...\r(gdb) file test\rReading symbols from test...done.\r2.2 è¿è¡Œ å¯¹äºå¸¦å‚æ•°çš„ç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ set args [arg] ... è®¾ç½®å‚æ•°ï¼Œå†ä½¿ç”¨ run æ¥è¿è¡Œï¼š\n(gdb) set args 1\r(gdb) run\rStarting program: test 1\r...\rå½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥åœ¨ run ååŠ ä¸Šå‚æ•°æ¥è¿è¡Œï¼š\n(gdb) run 1\rStarting program: test 1\rProgram received signal SIGSEGV, Segmentation fault.\r0x0000000000400749 in Func (s=0x7fffffffe167 \u0026quot;/data/home/joelzychen/test/test\u0026quot;) at test.cpp:8\r8 r = num;\ræˆ‘ä»¬å‘ç°ç¨‹åºå‡ºç°äº† Segmentation faultï¼Œæ­¤æ—¶å¯ä»¥é€šè¿‡æ‰“æ–­ç‚¹æ¥è°ƒè¯•ç¨‹åºã€‚\n2.3 æ–­ç‚¹ é€šè¿‡é”™è¯¯ä¿¡æ¯æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ˜¯å‡½æ•° Func ä¸­ï¼Œtest.cpp çš„ç¬¬ 8 è¡Œå‡ºç°äº†é”™è¯¯ï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥æ‰“ä¸Šä¸¤ä¸ªæ–­ç‚¹ï¼Œä¸€ä¸ªåœ¨è¿›å…¥ Func å‡½æ•°æ—¶ï¼Œä¸€ä¸ªåœ¨ test.cpp æ–‡ä»¶çš„ç¬¬ 8 è¡Œï¼Œå¹¶ä½¿ç”¨ info breakpoints æˆ– info b æ¥æŸ¥çœ‹æˆ‘ä»¬è®¾ç½®äº†å“ªäº›æ–­ç‚¹ï¼š\n(gdb) b test.cpp:8\rBreakpoint 1 at 0x400742: file test.cpp, line 8.\r(gdb) b Func\rBreakpoint 2 at 0x40071c: file test.cpp, line 4.\r(gdb) info b\rNum Type Disp Enb Address What\r1 breakpoint keep y 0x0000000000400742 in Func(char const*) at test.cpp:8\r2 breakpoint keep y 0x000000000040071c in Func(char const*) at test.cpp:4\r2.4 è°ƒè¯• è®¾ç½®å¥½æ–­ç‚¹ä¹‹åå°±å¯ä»¥ä½¿ç”¨ run å¼€å§‹è¿è¡Œäº†ï¼š\n(gdb) run\rStarting program: test 1\rBreakpoint 2, Func (s=0x7fffffffe167 \u0026quot;/data/home/joelzychen/test/test\u0026quot;) at test.cpp:4\r4 int *p = nullptr;\rå› ä¸ºæˆ‘ä»¬åœ¨ Func å‡½æ•°çš„å¼€å¤´è®¾ç½®äº†ä¸€ä¸ªæ–­ç‚¹ï¼Œæ‰€ä»¥ç¨‹åºåœ¨è¿›å…¥ Func å‡½æ•°æ—¶æš‚åœäº†ï¼›æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ list æˆ– l [function name] æ¥æŸ¥çœ‹å‡½æ•°çš„ä¸Šä¸‹æ–‡ï¼š\n(gdb) l Func\r1 #include \u0026lt;iostream\u0026gt;\r2\r3 void Func(const char *s) {\r4 int *p = nullptr;\r5 int \u0026amp;r = static_cast\u0026lt;int\u0026amp;\u0026gt;(*p);\r6\r7 int num = std::atoi(s);\r8 r = num;\r9 printf(\u0026quot;%d\\n\u0026quot;, r);\r10 }\ræ­¤æ—¶æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ print æˆ– p æ¥æŸ¥çœ‹å˜é‡ï¼š\n(gdb) p s\r$1 = 0x7fffffffe187 \u0026quot;1\u0026quot;\r(gdb) p *s\r$2 = 49 '1'\råˆ°ç›®å‰ä¸ºæ­¢è¿˜æ²¡æœ‰å‡ºç°é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ continue æˆ– c èµ°åˆ°ä¸‹ä¸€ä¸ªæ–­ç‚¹å¤„ï¼š\n(gdb) c\rContinuing.\rBreakpoint 2, Func (s=0x7fffffffe187 \u0026quot;1\u0026quot;) at test.cpp:8\r8 r = num;\ræŸ¥çœ‹ä¸€ä¸‹å½“å‰ä½œç”¨åŸŸçš„ä¸€äº›å˜é‡ï¼š\n(gdb) p s\r$8 = 0x7fffffffe187 \u0026quot;1\u0026quot;\r(gdb) p p\r$9 = (int *) 0x0\r(gdb) p *p\rCannot access memory at address 0x0\r(gdb) p r\r$10 = (int \u0026amp;) @0x0: \u0026lt;error reading variable\u0026gt;\r(gdb) p \u0026amp;r\r$11 = (int *) 0x0\r(gdb) p num\r$12 = 1\rä¼šå‘ç° r è¿™ä¸ª int\u0026amp; ç»‘å®šåˆ°äº†ä¸€ä¸ªè¢«è§£å¼•ç”¨çš„ç©ºæŒ‡é’ˆä¸Šï¼Œæ‰€ä»¥ \u0026amp;r == nullptrï¼Œå› æ­¤ä¸èƒ½è¯»å– r çš„å€¼ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ next æˆ– n æ¥è¿›è¡Œå•æ­¥æ‰§è¡Œï¼Œçœ‹çœ‹æ¥ä¸‹æ¥ä¼šå‘ç”Ÿä»€ä¹ˆï¼š\n(gdb) n\rProgram received signal SIGSEGV, Segmentation fault.\r0x0000000000400749 in Func (s=0x7fffffffe187 \u0026quot;1\u0026quot;) at test.cpp:8\r8 r = num;\ræœç„¶å‘ç”Ÿäº† Segmentation faultã€‚\n3. GDB å‘½ä»¤ æ ¹æ®åˆšæ‰çš„ç¤ºä¾‹ç¨‹åºï¼Œå¯ä»¥æ•´ç†å‡ºä¸€äº›å¸¸ç”¨çš„ GDB å‘½ä»¤ã€‚\n3.1 å¯åŠ¨   å°† GDB é“¾æ¥åˆ°ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶å¹¶å¯åŠ¨\ngdb [executable file]\rgdb\r(gdb) file [executable file]\r  å°† GDB é“¾æ¥åˆ°ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„è¿›ç¨‹å¹¶å¯åŠ¨\ngdb\r(gdb) attach [PID]\r  3.2 æ–­ç‚¹   å¢åŠ æ–­ç‚¹\n b [function name] b [file:line]    æŸ¥çœ‹æ–­ç‚¹\n info b    åˆ é™¤æ–­ç‚¹\ndelete [breakpoint number]\rd [breakpoint number]\rclear # åˆ é™¤å½“å‰è¡Œçš„æ–­ç‚¹\rclear [function name] # åˆ é™¤æŸä¸ªå‡½æ•°å¤„çš„æ–­ç‚¹\rclear [file:line] # åˆ é™¤æŸä¸€è¡Œçš„æ–­ç‚¹\r  ç¦ç”¨å’Œå¯ç”¨æ–­ç‚¹\ndisable # ç¦ç”¨æ‰€æœ‰æ–­ç‚¹\rdisable [breakpoint number] # ç¦ç”¨æŸä¸ªæ–­ç‚¹\renable # å¯ç”¨æ‰€æœ‰æ–­ç‚¹\renable [breakpoint number] # å¯ç”¨æŸä¸ªæ–­ç‚¹\r  3.3 è¿è¡Œ  ä»å¤´å¼€å§‹è¿è¡Œ  run   å•æ­¥æ‰§è¡Œ  next æˆ– n   è¿›å…¥å‡½æ•°å†…éƒ¨  step æˆ– s stepi æ‰§è¡Œä¸€æ¡æœºå™¨æŒ‡ä»¤    3.4 æŸ¥çœ‹   æŸ¥çœ‹ä»£ç \nlist # ä»å¤´å¼€å§‹ä¾æ¬¡æ‰“å°ï¼Œé»˜è®¤æ¯æ¬¡æ‰“å° 10 è¡Œ\rl # åŒä¸Š\rl [function name] # ä»å‡½æ•°å®šä¹‰å¼€å§‹æ‰“å°\rl [file:line] # ä»æŸä¸€è¡Œå¼€å§‹æ‰“å°\rset listsize 20 # ä¿®æ”¹æ¯æ¬¡æ‰“å°çš„è¡Œæ•°\r  æŸ¥çœ‹å˜é‡\nprint [expression] # æ‰“å°è¡¨è¾¾å¼\rp [expression] # åŒä¸Š\rptype [expression] # æ‰“å°è¡¨è¾¾å¼çš„ç±»å‹\rinfo args # æ‰“å°å‡½æ•°å‚æ•°\rinfo locals # æ‰“å°å±€éƒ¨å˜é‡\rinfo registers # æ‰“å°å¯„å­˜å™¨ä¿¡æ¯\r  3.5 ä¿®æ”¹   ä¿®æ”¹å˜é‡\nset variable i = 10 # å°†å˜é‡ i è®¾ç½®ä¸º 10\rset var i = 10 # åŒä¸Š\rp i = 10 # å°†å˜é‡ i è®¾ç½®ä¸º 10ï¼Œå¹¶æ‰“å°\r  3.6 è°ƒç”¨ä¿¡æ¯  æŸ¥çœ‹å‡½æ•°è°ƒç”¨æ ˆä¿¡æ¯  backtrace æˆ– bt where   æŸ¥çœ‹å½“å‰æ ˆå¸§  frame æˆ– f    4. corefile core dump / crash dump / memory dump / system dump éƒ½æ˜¯æŒ‡ä¸€ä¸ªç¨‹åºåœ¨ç‰¹å®šæ—¶é—´å´©æºƒï¼ˆcrashï¼‰æ—¶çš„å†…å­˜è®°å½•ï¼Œå®ƒåŒ…å«äº†å¾ˆå¤šå…³é”®ä¿¡æ¯ï¼Œæ¯”å¦‚å¯„å­˜å™¨ï¼ˆåŒ…æ‹¬ç¨‹åºè®¡æ•°å™¨å’Œå †æ ˆæŒ‡é’ˆï¼‰ï¼Œå†…å­˜ç®¡ç†ä¿¡æ¯ï¼Œæ“ä½œç³»ç»Ÿæ ‡å¿—ä¿¡æ¯ç­‰ã€‚corefile å°±æ˜¯è½¬å‚¨ï¼ˆdumpï¼‰æ—¶çš„å¿«ç…§ï¼Œcorefileå¯ä»¥è¢«é‡æ–°æ‰§è¡Œç”¨ä»¥è°ƒè¯•é”™è¯¯ä¿¡æ¯ã€‚\n4.1 ç”Ÿæˆ ä¸ºäº†è®©ç³»ç»Ÿèƒ½å¤Ÿç”Ÿæˆ corefileï¼Œéœ€è¦å…ˆæ£€æŸ¥é…ç½®ï¼š\n$ ulimit -c\runlimited\rå¦‚æœç»“æœæ˜¯ 0 åˆ™è¯´æ˜ç³»ç»Ÿç¦æ­¢äº† corefile çš„ç”Ÿæˆï¼Œéœ€è¦æ‰§è¡Œ ulimit -c unlimited æ¥è®© corefile èƒ½å¤Ÿæ­£å¸¸ç”Ÿæˆã€‚ä»¥åˆšæ‰çš„ç¤ºä¾‹ç¨‹åºä¸ºä¾‹ï¼Œå…ˆæ‰§è¡Œ test æ–‡ä»¶ï¼Œç”Ÿæˆä¸€ä¸ª corefileï¼š\n$ ./test 1\ræ®µé”™è¯¯ (core dumped)\r$ ll /data/corefile\r-rw------- 1 joelzychen dev 450560 4æœˆ 22 17:07 core_test_1587546447.28284\rèƒ½å¤Ÿçœ‹åˆ°ç³»ç»Ÿåœ¨ç‰¹å®šçš„ç›®å½•ä¸‹ï¼ˆå¯ä»¥ä¿®æ”¹ï¼‰ç”Ÿæˆäº†ä¸€ä¸ª corefile å«åš core_test_1587546447.28284ï¼Œæˆ‘ä»¬ä½¿ç”¨ gdb æ¥å¯¹è¿™ä¸ª corefile è¿›è¡Œè°ƒè¯•ã€‚\n4.2 è°ƒè¯• è¦æ‰§è¡Œ corefile è¿˜éœ€è¦å‡†å¤‡å¯¹åº”çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œè¿è¡Œ gdb [executable file] [corefile] å°±èƒ½å¼€å§‹è°ƒè¯•äº†ï¼š\n$ gdb test /data/corefile/core_test_1587546447.28284\r...\rCore was generated by `./test 1'.\rProgram terminated with signal 11, Segmentation fault.\r#0 0x0000000000400749 in Func (s=0x7ffed098c19e \u0026quot;1\u0026quot;) at test.cpp:8\r8 r = num;\rå› ä¸ºç¤ºä¾‹ç¨‹åºæ¯”è¾ƒç®€å•ï¼Œå› æ­¤å‡½æ•°è°ƒç”¨æ ˆä¹Ÿæ¯”è¾ƒå°‘ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆä½¿ç”¨ bt æ‰“å°å‡½æ•°è°ƒç”¨æ ˆä¿¡æ¯ï¼š\n(gdb) bt\r#0 0x0000000000400749 in Func (s=0x7ffed098c19e \u0026quot;1\u0026quot;) at test.cpp:8\r#1 0x00000000004007c0 in main (argc=2, argv=0x7ffed098afb8) at test.cpp:17\ræˆ‘ä»¬é€šè¿‡ frame 0 æˆ– f 0 è¿›å…¥ç¨‹åºå´©æºƒçš„æ ˆå¸§æ¥æŸ¥çœ‹ç›¸å…³ä¿¡æ¯ï¼š\n(gdb) f 0\r#0 0x0000000000400749 in Func (s=0x7ffed098c19e \u0026quot;1\u0026quot;) at test.cpp:8\r8 r = num;\r(gdb) info args\rs = 0x7ffed098c19e \u0026quot;1\u0026quot;\r(gdb) info locals\rp = 0x0\rr = @0x0: \u0026lt;error reading variable\u0026gt;\rnum = 1\r(gdb) ptype r\rtype = int \u0026amp;\r(gdb) ptype p\rtype = int *\ræŸ¥çœ‹ä¸€ä¸‹å½“å‰æ ˆå¸§çš„æ±‡ç¼–ä»£ç ï¼š\n(gdb) disas\rDump of assembler code for function Func(char const*):\r0x0000000000400710 \u0026lt;+0\u0026gt;: push %rbp\r0x0000000000400711 \u0026lt;+1\u0026gt;: mov %rsp,%rbp\r0x0000000000400714 \u0026lt;+4\u0026gt;: sub $0x20,%rsp\r0x0000000000400718 \u0026lt;+8\u0026gt;: mov %rdi,-0x8(%rbp)\r0x000000000040071c \u0026lt;+12\u0026gt;: movq $0x0,-0x10(%rbp)\r0x0000000000400724 \u0026lt;+20\u0026gt;: mov -0x10(%rbp),%rdi\r0x0000000000400728 \u0026lt;+24\u0026gt;: mov %rdi,-0x18(%rbp)\r0x000000000040072c \u0026lt;+28\u0026gt;: mov -0x8(%rbp),%rdi\r0x0000000000400730 \u0026lt;+32\u0026gt;: callq 0x4005a0 \u0026lt;atoi@plt\u0026gt;\r0x0000000000400735 \u0026lt;+37\u0026gt;: movabs $0x400860,%rdi\r0x000000000040073f \u0026lt;+47\u0026gt;: mov %eax,-0x1c(%rbp)\r0x0000000000400742 \u0026lt;+50\u0026gt;: mov -0x1c(%rbp),%eax\r0x0000000000400745 \u0026lt;+53\u0026gt;: mov -0x18(%rbp),%rcx\r=\u0026gt; 0x0000000000400749 \u0026lt;+57\u0026gt;: mov %eax,(%rcx)\r0x000000000040074b \u0026lt;+59\u0026gt;: mov -0x18(%rbp),%rcx\r0x000000000040074f \u0026lt;+63\u0026gt;: mov (%rcx),%esi\r0x0000000000400751 \u0026lt;+65\u0026gt;: mov $0x0,%al\r0x0000000000400753 \u0026lt;+67\u0026gt;: callq 0x400550 \u0026lt;printf@plt\u0026gt;\r0x0000000000400758 \u0026lt;+72\u0026gt;: mov %eax,-0x20(%rbp)\r0x000000000040075b \u0026lt;+75\u0026gt;: add $0x20,%rsp\r0x000000000040075f \u0026lt;+79\u0026gt;: pop %rbp\r0x0000000000400760 \u0026lt;+80\u0026gt;: retq\rEnd of assembler dump.\ræŸ¥çœ‹å¯„å­˜å™¨çŠ¶æ€ï¼š\n(gdb) i r\rrax 0x1 1\rrbx 0x0 0\rrcx 0x0 0\rrdx 0xa 10\rrsi 0x0 0\rrdi 0x400860 4196448\rrbp 0x7ffed098aea0 0x7ffed098aea0\rrsp 0x7ffed098ae80 0x7ffed098ae80\rr8 0x7f9c88bbf060 140310285643872\rr9 0x7ffed098c19f 140732398092703\rr10 0x1 1\rr11 0x0 0\rr12 0x40061c 4195868\rr13 0x7ffed098afb0 140732398088112\rr14 0x0 0\rr15 0x0 0\rrip 0x400749 0x400749 \u0026lt;Func(char const*)+57\u0026gt;\reflags 0x10206 [ PF IF RF ]\rcs 0x33 51\rss 0x2b 43\rds 0x0 0\res 0x0 0\rfs 0x0 0\rgs 0x0 0\r5. æ€»ç»“ æœ¬æ–‡ä¸»è¦é€šè¿‡ä¸€ä¸ªç¤ºä¾‹ç¨‹åºæ¼”ç¤ºäº†åœ¨ Linux ç¯å¢ƒä¸‹ GDB çš„åŸºæœ¬ä½¿ç”¨æ–¹æ³•ï¼Œæ•´ç†äº† GDB çš„å¸¸ç”¨æŒ‡ä»¤ï¼Œä»¥åŠè°ƒè¯• C/C++ ç¨‹åºå’Œ corefile çš„æ­¥éª¤ã€‚åœ¨å®é™…åº”ç”¨ä¸­ GDB èƒ½ä¸ªæå¤§ç¨‹åº¦åœ°æé«˜å¼€å‘å’Œè°ƒè¯•æ•ˆç‡ï¼Œæ›´å¤šçš„ä½¿ç”¨æŠ€å·§è¿˜éœ€è¦ç»“åˆå®è·µæ¥ç»ƒä¹ ã€‚\n","permalink":"http://zintrulcre.github.io/posts/c++/compilation/gdb/","summary":"GDB è°ƒè¯•å…¥é—¨ 0. åº è°ƒè¯•ç¨‹åºæ˜¯å¼€å‘è¿‡ç¨‹ä¸­å¿…ä¸å¯å°‘çš„ä¸€ç¯ï¼Œåœ¨ Windows æˆ– MacOS ä¸Šå¼€å‘æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ VS å’Œ CLion ç­‰ IDE ä¸Šè‡ªå¸¦çš„è°ƒè¯•åŠŸèƒ½æ¥æ‰“æ–­ç‚¹æˆ–æŸ¥çœ‹å˜é‡å’Œå †æ ˆï¼Œä½† Linux å¹¶æ²¡æœ‰å›¾å½¢åŒ–çš„æ“ä½œç•Œé¢ï¼Œè€Œå¦‚æœåªé€šè¿‡æ‰“ log çš„æ–¹å¼æ¥æŸ¥æ‰¾é—®é¢˜çš„è¯æ•ˆç‡å°†ä¼šéå¸¸ä½ä¸‹ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ GDB æ¥æå‡æˆ‘ä»¬çš„å¼€å‘æ•ˆç‡ã€‚\nGDB æ˜¯ GNU Debugger çš„ç®€å†™ï¼Œæ˜¯ GNU è½¯ä»¶ç³»ç»Ÿä¸­çš„æ ‡å‡†è°ƒè¯•å™¨ã€‚GDB å…·å¤‡å„ç§è°ƒè¯•åŠŸèƒ½ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºæ‰“æ–­ç‚¹ã€å•æ­¥æ‰§è¡Œã€æ‰“å°å˜é‡ã€æŸ¥çœ‹å¯„å­˜å™¨ã€æŸ¥çœ‹å‡½æ•°è°ƒç”¨å †æ ˆç­‰ï¼Œèƒ½å¤Ÿæœ‰æ•ˆåœ°é’ˆå¯¹å‡½æ•°çš„è¿è¡Œè¿›è¡Œè¿½è¸ªå’Œè­¦å‘Šï¼›ä½¿ç”¨ GDB è°ƒè¯•æ—¶ï¼Œå¯ä»¥ç›‘ç£å’Œä¿®æ”¹ç¨‹åºçš„å˜é‡ï¼Œå¹¶ä¸”è¿™äº›ä¿®æ”¹æ˜¯ç‹¬ç«‹äºä¸»ç¨‹åºä¹‹å¤–çš„ã€‚GDB ä¸»è¦ç”¨äºè°ƒè¯•ç¼–è¯‘å‹è¯­è¨€ï¼Œå¯¹ Cï¼ŒC++ï¼ŒGoï¼ŒFortran ç­‰è¯­è¨€æœ‰å†…ç½®çš„æ”¯æŒï¼Œä½†å®ƒä¸æ”¯æŒè§£é‡Šå‹è¯­è¨€ã€‚\n1. ç¯å¢ƒæ­å»º 1.1 ç¼–å†™ç¨‹åº ä¸ºäº†è¿›è¡Œè°ƒè¯•ï¼Œæˆ‘ä»¬éœ€è¦å‡†å¤‡ä¸€ä¸ªç®€å•çš„ C++ ç¨‹åºï¼š\n$ cat test.cpp #include \u0026lt;iostream\u0026gt; void Func(const char *s) { int *p = nullptr; int \u0026amp;r = static_cast\u0026lt;int\u0026amp;\u0026gt;(*p); int num = std::atoi(s); r = num; printf(\u0026#34;%d\\n\u0026#34;, r); } int main (int argc, char *argv[]) { if (argc !","title":"GDB è°ƒè¯•å…¥é—¨"},{"content":"coverity çš„ WRAPPER_ESCAPE å‘Šè­¦ const char* Foo() { std::string str_msg(\u0026#34;test\u0026#34;); return str_msg.c_str(); } int main() { const char *p_msg = Foo(); printf(\u0026#34;%s\\n\u0026#34;, p_msg); return 0; } // output:ï¼ˆä¸ºç©ºï¼Œæˆ–ä¹±ç ï¼‰ D? ä¸Šé¢ä»£ç ä¸­çš„ Foo å‡½æ•°ä¼šè¢« coverity æŠ¥å‘Š WRAPPER_ESCAPEï¼Œè¯¦ç»†è¯´æ˜æ˜¯ï¼š\nWrapper object use after free (WRAPPER_ESCAPE)\r1. escape: The internal representation of local strMsg escapes, but is destroyed when it exits scope\rå¤§æ„æ˜¯å±€éƒ¨å˜é‡ str_msg åœ¨ç¦»å¼€å‡½æ•° Foo çš„æ—¶å€™ä¼šè¢«é‡Šæ”¾ï¼ˆå› ä¸º str_msg æ˜¯åˆ†é…åœ¨æ ˆä¸Šçš„å˜é‡ï¼‰ï¼Œè€Œé€šè¿‡å‡½æ•° std::string::c_str() è·å–çš„æŒ‡å‘ str_msg å¤´éƒ¨çš„æŒ‡é’ˆä¼šå› æ­¤å˜ä¸ºä¸€ä¸ªæ‚¬ç©ºæŒ‡é’ˆï¼Œå°†è¿™ä¸ªæ‚¬ç©ºæŒ‡é’ˆè¿”å›ç»™å‡½æ•°è°ƒç”¨è€…ä½¿ç”¨å°†ä¼šå‘ç”Ÿä¸å¯é¢„çŸ¥çš„è¡Œä¸ºã€‚\nè€Œ c_str() æœ¬èº«è¿”å›çš„æ˜¯ä¸€ä¸ª const char *pï¼Œè™½ç„¶æˆ‘ä»¬æ— æ³•ç›´æ¥ä¿®æ”¹æŒ‡é’ˆ p æ‰€æŒ‡å‘çš„æ•°æ®ï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿®æ”¹ str_msg æ¥è¾¾åˆ°ä¿®æ”¹ p æ‰€æŒ‡å‘å†…å­˜çš„æ•ˆæœï¼Œä¾‹å¦‚å¦‚ä¸‹çš„ä»£ç ï¼š\nint main() { std::string str_msg(\u0026#34;test\u0026#34;); const char *p_msg = str_msg.c_str(); printf(\u0026#34;%s\\n\u0026#34;, p_msg); str_msg[2] = \u0026#39;x\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, p_msg); return 0; } // output: test text æƒ³è¦æ­£ç¡®åœ°ä½¿ç”¨è¿”å›çš„ const char*ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å †ä¸Šåˆ†é…ä¸€å—å†…ä»ï¼Œå°†è¦ä½¿ç”¨çš„å­—ç¬¦ä¸²æ‹·è´åˆ°å…¶ä¸­å¹¶è¿”å›ï¼š\nconst char* Foo() { std::string str_msg(\u0026#34;test\u0026#34;); uint32_t u32_msg_size = str_msg.size() + 1; char *p_return = new char[u32_msg_size]; strcpy_s(p_return, u32_msg_size, str_msg.c_str()); return p_return; } int main() { const char *p_msg = Foo(); printf(\u0026#34;%s\\n\u0026#34;, p_msg); return 0; } // output: test å½“ç„¶ï¼Œè°ƒç”¨è€…ä¹Ÿåº”è¯¥åˆ™é€‚å½“çš„æ—¶æœºå¯¹ p_msg è¿›è¡Œ delete æ“ä½œï¼Œå¦åˆ™å°†ä¼šé€ æˆå†…å­˜æ³„æ¼ã€‚\nåº”è¯¥è®°ä½çš„æ˜¯ï¼Œé™¤éä½ éœ€è¦ç«‹å³ä»¥ const char* çš„æ–¹å¼ä½¿ç”¨å­—ç¬¦ä¸²ï¼Œå¦åˆ™åº”è¯¥å°½é‡é¿å…ä½¿ç”¨ c_str()ï¼Œå°¤å…¶æ˜¯åœ¨å‘ç”Ÿå‡½æ•°è°ƒç”¨å’Œè¿”å›æ—¶ã€‚\n","permalink":"http://zintrulcre.github.io/posts/c++/basics/wrapper_escape-in-coverity/","summary":"coverity çš„ WRAPPER_ESCAPE å‘Šè­¦ const char* Foo() { std::string str_msg(\u0026#34;test\u0026#34;); return str_msg.c_str(); } int main() { const char *p_msg = Foo(); printf(\u0026#34;%s\\n\u0026#34;, p_msg); return 0; } // output:ï¼ˆä¸ºç©ºï¼Œæˆ–ä¹±ç ï¼‰ D? ä¸Šé¢ä»£ç ä¸­çš„ Foo å‡½æ•°ä¼šè¢« coverity æŠ¥å‘Š WRAPPER_ESCAPEï¼Œè¯¦ç»†è¯´æ˜æ˜¯ï¼š\nWrapper object use after free (WRAPPER_ESCAPE)\r1. escape: The internal representation of local strMsg escapes, but is destroyed when it exits scope\rå¤§æ„æ˜¯å±€éƒ¨å˜é‡ str_msg åœ¨ç¦»å¼€å‡½æ•° Foo çš„æ—¶å€™ä¼šè¢«é‡Šæ”¾ï¼ˆå› ä¸º str_msg æ˜¯åˆ†é…åœ¨æ ˆä¸Šçš„å˜é‡ï¼‰ï¼Œè€Œé€šè¿‡å‡½æ•° std::string::c_str() è·å–çš„æŒ‡å‘ str_msg å¤´éƒ¨çš„æŒ‡é’ˆä¼šå› æ­¤å˜ä¸ºä¸€ä¸ªæ‚¬ç©ºæŒ‡é’ˆï¼Œå°†è¿™ä¸ªæ‚¬ç©ºæŒ‡é’ˆè¿”å›ç»™å‡½æ•°è°ƒç”¨è€…ä½¿ç”¨å°†ä¼šå‘ç”Ÿä¸å¯é¢„çŸ¥çš„è¡Œä¸ºã€‚\nè€Œ c_str() æœ¬èº«è¿”å›çš„æ˜¯ä¸€ä¸ª const char *pï¼Œè™½ç„¶æˆ‘ä»¬æ— æ³•ç›´æ¥ä¿®æ”¹æŒ‡é’ˆ p æ‰€æŒ‡å‘çš„æ•°æ®ï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿®æ”¹ str_msg æ¥è¾¾åˆ°ä¿®æ”¹ p æ‰€æŒ‡å‘å†…å­˜çš„æ•ˆæœï¼Œä¾‹å¦‚å¦‚ä¸‹çš„ä»£ç ï¼š","title":"coverity çš„ WRAPPER_ESCAPE å‘Šè­¦"},{"content":"C++ åç¨‹ï¼ˆ1ï¼‰ï¼šå‡½æ•°å’Œåç¨‹ è¿™ç¯‡æ–‡ç« çš„ç›®çš„æ˜¯æ¢ç©¶ C++ ä¸­åç¨‹çš„æœºåˆ¶å’Œç”¨æ³•ï¼Œä»¥åŠæ€æ ·åˆ©ç”¨åç¨‹çš„ç‰¹æ€§æ¥æ„å»ºä¸Šå±‚çš„åº“å’Œåº”ç”¨ã€‚\n1. æ ˆå¸§å’Œå‡½æ•° æ ˆå¸§æ˜¯ä¸€ä¸ªå‡½æ•°æ‰§è¡Œçš„ç¯å¢ƒï¼ŒåŒ…æ‹¬å‡½æ•°å‚æ•°ã€å‡½æ•°è¿”å›åœ°å€ã€å±€éƒ¨å˜é‡ç­‰ä¿¡æ¯ã€‚æ“ä½œç³»ç»Ÿæ¯æ¬¡è°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œéƒ½ä¼šä¸ºå…¶åˆ†é…ä¸€ä¸ªæ–°çš„æ ˆå¸§ï¼Œç›¸å…³çš„æ¦‚å¿µæœ‰ï¼š\n ESPï¼šæ ˆæŒ‡é’ˆå¯„å­˜å™¨ï¼ˆExtended Stack Pointerï¼‰ï¼Œå…¶å†…å­˜ä¸­å­˜æ”¾ä¸€ä¸ªå§‹ç»ˆæŒ‡å‘ç³»ç»Ÿæ ˆæœ€é¡¶éƒ¨æ ˆå¸§æ ˆé¡¶çš„æŒ‡é’ˆ EBPï¼šåŸºå€æŒ‡é’ˆå¯„å­˜å™¨ï¼ˆExtended Base Pointerï¼‰ï¼Œå…¶å†…å­˜ä¸­å­˜æ”¾ä¸€ä¸ªå§‹ç»ˆæŒ‡å‘ç³»ç»Ÿæœ€é¡¶éƒ¨æ ˆå¸§æ ˆåº•çš„æŒ‡é’ˆ å‡½æ•°æ ˆå¸§ï¼šESPå’ŒEBPä¹‹é—´çš„å†…å­˜ç©ºé—´ä¸ºå½“å‰æ ˆå¸§ï¼ŒEBPæ ‡è¯†äº†å½“å‰æ ˆå¸§çš„åº•éƒ¨ï¼ŒESPæ ‡è¯†äº†å½“å‰æ ˆå¸§çš„é¡¶éƒ¨  å¯¹äºæ™®é€šçš„å‡½æ•°æ¥è¯´ï¼Œä¸€èˆ¬æˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡Œä¸¤ç§æ“ä½œï¼šcallï¼ˆè°ƒç”¨ï¼‰å’Œ returnï¼ˆè¿”å›ï¼‰ã€‚ä¸ºäº†æ–¹ä¾¿å¯¹æ¯”ï¼Œæ­¤å¤„ä¸è®¨è®º throw exception çš„æƒ…å†µã€‚åœ¨è¿è¡Œä¸€ä¸ª C++ ç¨‹åºæ—¶ï¼Œç¼–è¯‘å™¨ä¼šå…ˆæ‰§è¡Œ C++ runtimeï¼Œç„¶åä¼šè°ƒç”¨ main å‡½æ•°ï¼Œå†ç”± main å‡½æ•°è°ƒç”¨å…¶ä»–çš„å‡½æ•°ã€‚\ncall æ“ä½œä¸€èˆ¬åŒ…å«ä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š\n å‚æ•°å…¥æ ˆï¼šå‚æ•°ä»å³å‘å·¦ä¾æ¬¡å…¥æ ˆ è¿”å›åœ°å€å…¥æ ˆï¼šå°†å½“å‰ä»£ç åŒºçš„ä¸‹ä¸€æ¡å¾…æ‰§è¡Œçš„æŒ‡ä»¤å…¥æ ˆï¼Œä»¥ä¾¿åœ¨å‡½æ•° return ä¹‹åæ‰§è¡Œ ä»£ç åŒºè·³è½¬ï¼šå¤„ç†å™¨è·³è½¬åˆ°è¢«è°ƒå‡½æ•°çš„å…¥å£ æ ˆå¸§è°ƒæ•´ï¼ŒåŒ…æ‹¬ï¼š  ä¿å­˜å½“å‰æ ˆå¸§çŠ¶æ€å€¼ï¼ŒEBP å…¥æ ˆ ä»å½“å‰æ ˆå¸§åˆ‡æ¢åˆ°æ–°çš„æ ˆå¸§ï¼Œæ›´æ–° EBPï¼Œå°† EBP çš„å€¼è®¾ç½®ä¸º ESP çš„å€¼ ç»™æ–°çš„æ ˆå¸§åˆ†é…å†…å­˜ç©ºé—´ï¼Œæ›´æ–° ESPï¼Œå°† ESP çš„å€¼å‡å»æ‰€éœ€ç©ºé—´çš„å¤§å°    å½“ä¸€ä¸ªå‡½æ•°é€šè¿‡ return è¯­å¥è¿”å›æ—¶ï¼Œæ‰§è¡Œçš„æ­¥éª¤ä¸è°ƒç”¨æ—¶ç›¸åï¼š\n2. åç¨‹ åç¨‹ç”±ç¨‹åºæ‰€æ§åˆ¶ï¼Œå³åœ¨ç”¨æˆ·æ€æ‰§è¡Œï¼Œè€Œä¸æ˜¯åƒçº¿ç¨‹ä¸€æ ·ç”±æ“ä½œç³»ç»Ÿå†…æ ¸ç®¡ç†ï¼Œä½¿ç”¨åç¨‹æ—¶ï¼Œä¸éœ€è¦å¦‚çº¿ç¨‹ä¸€èˆ¬é¢‘ç¹åœ°è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œæ€§èƒ½èƒ½å¤Ÿå¾—åˆ°å¾ˆå¤§çš„æå‡ï¼Œå› æ­¤åç¨‹çš„å¼€é”€è¿œè¿œå°äºçº¿ç¨‹çš„å¼€é”€ã€‚ä¸€èˆ¬æ¥è¯´åç¨‹æœ‰ä¸‰ç§ç‰¹æ€§ï¼š\n suspend æ‚¬åœï¼šæš‚åœå½“å‰åç¨‹çš„æ‰§è¡Œï¼Œå°†æ‰§è¡Œæƒäº¤è¿˜ç»™è°ƒç”¨è€…ï¼Œä½†æ˜¯ä¿ç•™å½“å‰æ ˆå¸§ã€‚å’Œå‡½æ•°çš„ return ç±»ä¼¼ï¼Œåç¨‹çš„ suspend åªèƒ½ç”±åç¨‹è‡ªèº«å‘èµ· resume æ¢å¤ï¼šç»§ç»­æ‰§è¡Œå·²ç» suspend çš„åç¨‹ï¼Œé‡æ–°æ¿€æ´»åç¨‹çš„æ ˆå¸§ destroy é”€æ¯ï¼šé”€æ¯åç¨‹çš„æ ˆå¸§å’Œå…¶å¯¹åº”çš„å†…å­˜  å¯ä»¥çœ‹åˆ°ï¼Œåç¨‹å¯ä»¥åœ¨ä¸æ¸…é™¤æ ˆå¸§çš„æƒ…å†µä¸‹è¢«æŒ‚èµ·è€Œä¸è¢«é”€æ¯ï¼Œå› æ­¤æˆ‘ä»¬ä¸èƒ½å¤Ÿä½¿ç”¨è°ƒç”¨æ ˆè¿™æ ·çš„æ•°æ®ç»“æ„æ¥ä¸¥æ ¼ä¿è¯æ´»åŠ¨æ ˆå¸§çš„ç”Ÿå‘½å‘¨æœŸï¼Œæˆ‘ä»¬å¯ä»¥æŠŠåç¨‹å­˜å‚¨åœ¨å †ä¸­ã€‚æˆ‘ä»¬å¯ä»¥æŠŠåç¨‹çš„æ ˆå¸§åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ˜¯æ‰§è¡Œæ ˆå¸§ï¼Œè¿™éƒ¨åˆ†ä»…åœ¨å½“å‰åç¨‹æ‰§è¡ŒæœŸé—´å­˜åœ¨ï¼Œåœ¨æ‰§è¡Œç»“æŸï¼Œå³åç¨‹ suspend çš„æ—¶å€™è¢«é‡Šæ”¾ï¼›å¦ä¸€éƒ¨åˆ†æ˜¯æ•°æ®æ ˆå¸§ï¼Œè¿™éƒ¨åˆ†å³ä½¿åœ¨åç¨‹ suspend çš„æ—¶å€™ä¾ç„¶å­˜åœ¨ã€‚\n2.1 Suspend åç¨‹é€šè¿‡æŸäº›ç‰¹å®šçš„è¯­å¥æ¥æ‰§è¡Œ suspend æ“ä½œï¼Œåœ¨ C++ Coroutine TS ä¸­æœ‰ co_await å’Œ co_yieldã€‚åœ¨æ‰§è¡Œ suspend æ“ä½œçš„æ—¶å€™ï¼Œæˆ‘ä»¬åº”è¯¥ç¡®ä¿ä¸¤ç‚¹ï¼š\n å°†å½“å‰æ‰§è¡Œæ ˆå¸§ä¸­çš„æ•°æ®ä¿å­˜åˆ°æ•°æ®æ ˆå¸§ä¸­ å°†åç¨‹ suspend çš„ä½ç½®å†™å…¥æ•°æ®æ ˆå¸§ä¸­ï¼Œä»¥ä¾¿åç»­çš„ resume æ“ä½œçŸ¥é“ä»å“ªé‡Œç»§ç»­ï¼Œæˆ–è®© destroy æ“ä½œçŸ¥é“é”€æ¯å“ªä¸€éƒ¨åˆ†  æ¥ä¸‹æ¥ï¼Œåç¨‹å¯ä»¥å°†æ‰§è¡Œæƒè½¬äº¤ç»™è°ƒç”¨æ–¹ï¼Œè€Œæ‰§è¡Œæ ˆå¸§å°†è¢«é‡Šæ”¾ã€‚\n2.2. Resume æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ resume æ“ä½œæ¥æ¢å¤ä¸€ä¸ªå·²ç» suspend çš„åç¨‹ï¼Œå’Œå‡½æ•°çš„ call ç±»ä¼¼ï¼Œresume æ“ä½œå°†ä¼šåˆ†é…ä¸€ä¸ªæ–°çš„æ‰§è¡Œæ ˆå¸§æ¥å­˜å‚¨å·²ç»ä¿å­˜åœ¨æ•°æ®æ ˆå¸§ä¸­çš„æ•°æ®ï¼Œä»¥åŠè°ƒç”¨æ–¹çš„è¿”å›åœ°å€ç­‰ï¼Œä¹‹ååç¨‹å°†åŠ è½½ä¹‹å‰ suspend çš„ä½ç½®å¹¶ç»§ç»­æ‰§è¡Œã€‚\n2.3 Destroy Destroy æ“ä½œåªèƒ½åœ¨å·²ç» suspend çš„åç¨‹ä¸Šæ‰§è¡Œï¼Œå’Œ resume ç±»ä¼¼ï¼Œä»–ä¹Ÿä¼šå…ˆåˆ†é…æ‰§è¡Œæ ˆå¸§ï¼Œå°†è°ƒç”¨æ–¹çš„è¿”å›åœ°å€å­˜å…¥å…¶ä¸­ï¼Œä½†å®ƒå¹¶ä¸ä¼šç»§ç»­æ‰§è¡Œ suspend çš„ä½ç½®ä¹‹åçš„å‡½æ•°ä½“ï¼Œè€Œæ˜¯æ‰§è¡Œå½“å‰ä½œç”¨åŸŸå†…æ‰€æœ‰å±€éƒ¨å˜é‡çš„ææ„å‡½æ•°ï¼Œå¹¶é‡Šæ”¾è¿™äº›å†…å­˜ã€‚\n2.4 Call å’Œ Return åç¨‹çš„è°ƒç”¨å’Œæ™®é€šå‡½æ•°çš„ call æ“ä½œç±»ä¼¼ï¼Œè°ƒç”¨æ–¹ä¼šç»™å…¶åˆ†é…ä¸€ä¸ªæ´»åŠ¨æ ˆå¸§ï¼Œå°†å‚æ•°å’Œè¿”å›åœ°å€å…¥æ ˆï¼Œå¹¶å°†æ‰§è¡Œæƒäº¤ç»™åç¨‹ï¼Œè€Œåç¨‹ä¼šå…ˆåœ¨å †ä¸Šåˆ†é…ä¸€ä¸ªæ‰§è¡Œæ ˆå¸§ï¼Œå¹¶å°†å‚æ•°å¤åˆ¶åˆ°æ‰§è¡Œæ ˆå¸§ä¸Šï¼Œä»¥ä¾¿åç»­èƒ½å¤Ÿæ­£ç¡®åœ°åˆ é™¤è¿™äº›å‚æ•°ã€‚\nåç¨‹çš„ return æ“ä½œå’Œæ™®é€šå‡½æ•°çš„ç•¥æœ‰ä¸åŒï¼Œå½“åç¨‹æ‰§è¡Œ return æ“ä½œæ—¶ï¼Œä»–ä¼šå°†è¿”å›å€¼å­˜å‚¨åœ¨å¦ä¸€ä¸ªåœ°å€ï¼Œç„¶ååˆ é™¤æ‰€æœ‰å±€éƒ¨å˜é‡ï¼Œå¹¶å°†æ‰§è¡Œæƒè½¬äº¤ç»™è°ƒç”¨æ–¹ï¼Œ\n3. å‡½æ•°å’Œåç¨‹çš„æ‰§è¡Œè¿‡ç¨‹ å‡è®¾ func() æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä»–åœ¨å‡½æ•°ä½“å†…è°ƒç”¨äº†åç¨‹ co_func(int x)ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šåœ¨è°ƒç”¨æ ˆä¸Šåˆ›å»ºæ–°çš„æ´»åŠ¨æ ˆå¸§ï¼Œå°†å‚æ•°å’Œè¿”å›åœ°å€å…¥æ ˆï¼Œå¹¶å°† ESP ç§»åŠ¨åˆ°æ–°çš„æ´»åŠ¨æ ˆå¸§çš„æ ˆé¡¶ä½ç½®ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚\nStack Register Heap (Coroutine Manager)\r+----+\r+------------+ \u0026lt;---------- ESP\rfunc() +----+\r+------------+\r...\ræ¥ä¸‹æ¥åç¨‹ç®¡ç†å™¨ä¼šåœ¨å †ä¸Šç”³è¯·ä¸€å—æ–°çš„åŒºåŸŸä½œä¸ºåç¨‹çš„æ‰§è¡Œæ ˆå¸§ï¼Œæ­¤æ—¶ç¼–è¯‘å™¨ä¼šå°† EBP æŒ‡å‘æ‰§è¡Œæ ˆå¸§çš„é¡¶éƒ¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚\nStack Register Heap (Coroutine Manager)\r+------------+ \u0026lt;------- +------------+\rco_func() | -------\u0026gt; co_func()\rx = 68 | | x = 68\rret = func() + 0x789 | +----+ | +------------+\r+------------+ ---- ESP |\rfunc() +----+ |\r+------------+ EBP --------|\r... +----+\rå¦‚æœåœ¨ co_func æ‰§è¡Œçš„æŸä¸€æ—¶åˆ»è§¦å‘äº† suspendï¼Œé‚£ä¹ˆæ‰§è¡Œæ ˆå¸§ä¸­çš„æ•°æ®å°†è¢«ä¿å­˜åˆ°æ•°æ®æ ˆå¸§ä¸­ï¼Œä¸”æ”¹åç¨‹ä¼šè¿”å›ä¸€äº›è¿”å›å€¼ç»™è°ƒç”¨æ–¹ï¼Œè¿™äº›è¿”å›å€¼ä¸­é€šå¸¸å«æœ‰ suspend çš„ä½ç½®ï¼Œä»¥åŠåç¨‹æš‚æŒ‚çš„å¥æŸ„ï¼Œè¿™ä¸ªå¥æŸ„å¯ä»¥åœ¨æ¥ä¸‹æ¥ä½¿ç”¨ resume çš„æ—¶å€™æ¢å¤åç¨‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚\nStack Register Heap (Coroutine Manager)\r+----+ -------\u0026gt; +------------+\r+------------+ \u0026lt;---------- ESP | co_func()\rfunc() +----+ | x = 68\r+------------+ EBP | resume point = co_func() + 16\rhandle --------------- +----+ |\r... | |\r| |\r---------------------\rç°åœ¨å› ä¸ºæŸäº›åŸå› è§¦å‘äº†åç¨‹çš„ resumeï¼Œæ¢å¤åç¨‹çš„è°ƒç”¨æ–¹ä¼šè°ƒç”¨ void resume (handle) æ¥æ¢å¤è¿™ä¸ªåç¨‹ï¼Œæ­¤æ—¶ç¼–è¯‘å™¨ä¼šå†æ¬¡åˆ›å»ºæ–°çš„æ´»åŠ¨æ ˆå¸§ç”¨æ¥è®°å½•å‚æ•°å’Œè¿”å›åœ°å€ï¼ŒåŒæ—¶æ¿€æ´»æ‰§è¡Œæ ˆå¸§ï¼Œæ‰§è¡Œæ ˆå¸§ä»æ•°æ®æ ˆå¸§è¯»å–æ•°æ®ï¼Œæ¢å¤åç¨‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚\nStack Register Heap (Coroutine Manager)\r+------------+ \u0026lt;------- +------------+\rco_func() | -------\u0026gt; co_func()\rx = 68 | | x = 68\rret = func() + 0x789 | +----+ | +------------+\r+------------+ ---- ESP |\rfunc() +----+ |\r+------------+ EBP --------|\rhandle +----+\r... ","permalink":"http://zintrulcre.github.io/posts/c++/coroutine/c++-coroutine-function-and-coroutine/","summary":"C++ åç¨‹ï¼ˆ1ï¼‰ï¼šå‡½æ•°å’Œåç¨‹ è¿™ç¯‡æ–‡ç« çš„ç›®çš„æ˜¯æ¢ç©¶ C++ ä¸­åç¨‹çš„æœºåˆ¶å’Œç”¨æ³•ï¼Œä»¥åŠæ€æ ·åˆ©ç”¨åç¨‹çš„ç‰¹æ€§æ¥æ„å»ºä¸Šå±‚çš„åº“å’Œåº”ç”¨ã€‚\n1. æ ˆå¸§å’Œå‡½æ•° æ ˆå¸§æ˜¯ä¸€ä¸ªå‡½æ•°æ‰§è¡Œçš„ç¯å¢ƒï¼ŒåŒ…æ‹¬å‡½æ•°å‚æ•°ã€å‡½æ•°è¿”å›åœ°å€ã€å±€éƒ¨å˜é‡ç­‰ä¿¡æ¯ã€‚æ“ä½œç³»ç»Ÿæ¯æ¬¡è°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œéƒ½ä¼šä¸ºå…¶åˆ†é…ä¸€ä¸ªæ–°çš„æ ˆå¸§ï¼Œç›¸å…³çš„æ¦‚å¿µæœ‰ï¼š\n ESPï¼šæ ˆæŒ‡é’ˆå¯„å­˜å™¨ï¼ˆExtended Stack Pointerï¼‰ï¼Œå…¶å†…å­˜ä¸­å­˜æ”¾ä¸€ä¸ªå§‹ç»ˆæŒ‡å‘ç³»ç»Ÿæ ˆæœ€é¡¶éƒ¨æ ˆå¸§æ ˆé¡¶çš„æŒ‡é’ˆ EBPï¼šåŸºå€æŒ‡é’ˆå¯„å­˜å™¨ï¼ˆExtended Base Pointerï¼‰ï¼Œå…¶å†…å­˜ä¸­å­˜æ”¾ä¸€ä¸ªå§‹ç»ˆæŒ‡å‘ç³»ç»Ÿæœ€é¡¶éƒ¨æ ˆå¸§æ ˆåº•çš„æŒ‡é’ˆ å‡½æ•°æ ˆå¸§ï¼šESPå’ŒEBPä¹‹é—´çš„å†…å­˜ç©ºé—´ä¸ºå½“å‰æ ˆå¸§ï¼ŒEBPæ ‡è¯†äº†å½“å‰æ ˆå¸§çš„åº•éƒ¨ï¼ŒESPæ ‡è¯†äº†å½“å‰æ ˆå¸§çš„é¡¶éƒ¨  å¯¹äºæ™®é€šçš„å‡½æ•°æ¥è¯´ï¼Œä¸€èˆ¬æˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡Œä¸¤ç§æ“ä½œï¼šcallï¼ˆè°ƒç”¨ï¼‰å’Œ returnï¼ˆè¿”å›ï¼‰ã€‚ä¸ºäº†æ–¹ä¾¿å¯¹æ¯”ï¼Œæ­¤å¤„ä¸è®¨è®º throw exception çš„æƒ…å†µã€‚åœ¨è¿è¡Œä¸€ä¸ª C++ ç¨‹åºæ—¶ï¼Œç¼–è¯‘å™¨ä¼šå…ˆæ‰§è¡Œ C++ runtimeï¼Œç„¶åä¼šè°ƒç”¨ main å‡½æ•°ï¼Œå†ç”± main å‡½æ•°è°ƒç”¨å…¶ä»–çš„å‡½æ•°ã€‚\ncall æ“ä½œä¸€èˆ¬åŒ…å«ä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š\n å‚æ•°å…¥æ ˆï¼šå‚æ•°ä»å³å‘å·¦ä¾æ¬¡å…¥æ ˆ è¿”å›åœ°å€å…¥æ ˆï¼šå°†å½“å‰ä»£ç åŒºçš„ä¸‹ä¸€æ¡å¾…æ‰§è¡Œçš„æŒ‡ä»¤å…¥æ ˆï¼Œä»¥ä¾¿åœ¨å‡½æ•° return ä¹‹åæ‰§è¡Œ ä»£ç åŒºè·³è½¬ï¼šå¤„ç†å™¨è·³è½¬åˆ°è¢«è°ƒå‡½æ•°çš„å…¥å£ æ ˆå¸§è°ƒæ•´ï¼ŒåŒ…æ‹¬ï¼š  ä¿å­˜å½“å‰æ ˆå¸§çŠ¶æ€å€¼ï¼ŒEBP å…¥æ ˆ ä»å½“å‰æ ˆå¸§åˆ‡æ¢åˆ°æ–°çš„æ ˆå¸§ï¼Œæ›´æ–° EBPï¼Œå°† EBP çš„å€¼è®¾ç½®ä¸º ESP çš„å€¼ ç»™æ–°çš„æ ˆå¸§åˆ†é…å†…å­˜ç©ºé—´ï¼Œæ›´æ–° ESPï¼Œå°† ESP çš„å€¼å‡å»æ‰€éœ€ç©ºé—´çš„å¤§å°    å½“ä¸€ä¸ªå‡½æ•°é€šè¿‡ return è¯­å¥è¿”å›æ—¶ï¼Œæ‰§è¡Œçš„æ­¥éª¤ä¸è°ƒç”¨æ—¶ç›¸åï¼š\n2. åç¨‹ åç¨‹ç”±ç¨‹åºæ‰€æ§åˆ¶ï¼Œå³åœ¨ç”¨æˆ·æ€æ‰§è¡Œï¼Œè€Œä¸æ˜¯åƒçº¿ç¨‹ä¸€æ ·ç”±æ“ä½œç³»ç»Ÿå†…æ ¸ç®¡ç†ï¼Œä½¿ç”¨åç¨‹æ—¶ï¼Œä¸éœ€è¦å¦‚çº¿ç¨‹ä¸€èˆ¬é¢‘ç¹åœ°è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œæ€§èƒ½èƒ½å¤Ÿå¾—åˆ°å¾ˆå¤§çš„æå‡ï¼Œå› æ­¤åç¨‹çš„å¼€é”€è¿œè¿œå°äºçº¿ç¨‹çš„å¼€é”€ã€‚ä¸€èˆ¬æ¥è¯´åç¨‹æœ‰ä¸‰ç§ç‰¹æ€§ï¼š\n suspend æ‚¬åœï¼šæš‚åœå½“å‰åç¨‹çš„æ‰§è¡Œï¼Œå°†æ‰§è¡Œæƒäº¤è¿˜ç»™è°ƒç”¨è€…ï¼Œä½†æ˜¯ä¿ç•™å½“å‰æ ˆå¸§ã€‚å’Œå‡½æ•°çš„ return ç±»ä¼¼ï¼Œåç¨‹çš„ suspend åªèƒ½ç”±åç¨‹è‡ªèº«å‘èµ· resume æ¢å¤ï¼šç»§ç»­æ‰§è¡Œå·²ç» suspend çš„åç¨‹ï¼Œé‡æ–°æ¿€æ´»åç¨‹çš„æ ˆå¸§ destroy é”€æ¯ï¼šé”€æ¯åç¨‹çš„æ ˆå¸§å’Œå…¶å¯¹åº”çš„å†…å­˜  å¯ä»¥çœ‹åˆ°ï¼Œåç¨‹å¯ä»¥åœ¨ä¸æ¸…é™¤æ ˆå¸§çš„æƒ…å†µä¸‹è¢«æŒ‚èµ·è€Œä¸è¢«é”€æ¯ï¼Œå› æ­¤æˆ‘ä»¬ä¸èƒ½å¤Ÿä½¿ç”¨è°ƒç”¨æ ˆè¿™æ ·çš„æ•°æ®ç»“æ„æ¥ä¸¥æ ¼ä¿è¯æ´»åŠ¨æ ˆå¸§çš„ç”Ÿå‘½å‘¨æœŸï¼Œæˆ‘ä»¬å¯ä»¥æŠŠåç¨‹å­˜å‚¨åœ¨å †ä¸­ã€‚æˆ‘ä»¬å¯ä»¥æŠŠåç¨‹çš„æ ˆå¸§åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ˜¯æ‰§è¡Œæ ˆå¸§ï¼Œè¿™éƒ¨åˆ†ä»…åœ¨å½“å‰åç¨‹æ‰§è¡ŒæœŸé—´å­˜åœ¨ï¼Œåœ¨æ‰§è¡Œç»“æŸï¼Œå³åç¨‹ suspend çš„æ—¶å€™è¢«é‡Šæ”¾ï¼›å¦ä¸€éƒ¨åˆ†æ˜¯æ•°æ®æ ˆå¸§ï¼Œè¿™éƒ¨åˆ†å³ä½¿åœ¨åç¨‹ suspend çš„æ—¶å€™ä¾ç„¶å­˜åœ¨ã€‚","title":"C++ åç¨‹ï¼ˆ1ï¼‰ï¼šå‡½æ•°å’Œåç¨‹"},{"content":"LeetCode æ ‘ï¼ˆ3ï¼‰ é¢˜ç›® 4. é€’å½’æ±‚è§£ 617 åˆå¹¶äºŒå‰æ ‘ åˆå¹¶ä¸¤ä¸ªäºŒå‰æ ‘ã€‚\nåˆ¤æ–­å„ä¸ªèŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ï¼Œå…¨éƒ¨åˆå¹¶åˆ°ä¸€æ£µæ ‘ä¸Šå³å¯ã€‚\nclass Solution { public: TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) { if (!t1 \u0026amp;\u0026amp; !t2) return nullptr; else if (!t1) return t2; else if (!t2) return t1; t1-\u0026gt;val += t2-\u0026gt;val; t1-\u0026gt;left = mergeTrees(t1-\u0026gt;left, t2-\u0026gt;left); t1-\u0026gt;right = mergeTrees(t1-\u0026gt;right, t2-\u0026gt;right); return t1; } }; 226 ç¿»è½¬äºŒå‰æ ‘ ç¿»è½¬ä¸€ä¸ªäºŒå‰æ ‘ã€‚\nå…ˆå°†å·¦å³å­æ ‘åˆ†åˆ«ç¿»è½¬ï¼Œå†äº¤æ¢ä¸¤è€…çš„ä½ç½®ã€‚\nclass Solution { public: TreeNode *invertTree(TreeNode *root) { if (!root) return nullptr; TreeNode *left = invertTree(root-\u0026gt;left), *right = invertTree(root-\u0026gt;right); root-\u0026gt;right = left; root-\u0026gt;left = right; return root; } }; 104 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ æ‰¾å‡ºä¸€ä¸ªäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ã€‚\næ¯å±‚æ·±åº¦ä¸º 1ï¼ŒåŠ ä¸Šå·¦å³å­æ ‘ä¸­æ›´å¤§çš„æ·±åº¦å³ä¸ºæœ€å¤§æ·±åº¦ã€‚\nclass Solution { public: int maxDepth(TreeNode *root) { if (!root) return 0; return 1 + max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)); } }; 965 å•å€¼äºŒå‰æ ‘ åˆ¤æ–­ä¸€ä¸ªäºŒå‰æ ‘æ˜¯å¦æ˜¯ä¸€ä¸ªå•å€¼äºŒå‰æ ‘ã€‚\nåˆ¤æ–­æ¯ä¸ªèŠ‚ç‚¹ä¸å…¶å·¦å³èŠ‚ç‚¹çš„å€¼æ˜¯å¦ç›¸åŒå³å¯ã€‚\nclass Solution { public: bool isUnivalTree(TreeNode *root) { if (!root) return true; return (root-\u0026gt;left ? root-\u0026gt;val == root-\u0026gt;left-\u0026gt;val : true) \u0026amp;\u0026amp; (root-\u0026gt;right ? root-\u0026gt;val == root-\u0026gt;right-\u0026gt;val : true) \u0026amp;\u0026amp; isUnivalTree(root-\u0026gt;left) \u0026amp;\u0026amp; isUnivalTree(root-\u0026gt;right); } }; 559 Nå‰æ ‘çš„æœ€å¤§æ·±åº¦ æ‰¾åˆ°ä¸€ä¸ª N å‰æ ‘çš„æœ€å¤§æ·±åº¦ã€‚\næ¯å±‚æ·±åº¦ä¸º 1ï¼ŒåŠ ä¸Šå…¶æ‰€æœ‰å­æ ‘ä¸­æœ€å¤§çš„æ·±åº¦å³ä¸ºæœ€å¤§æ·±åº¦ã€‚\nclass Solution { public: int maxDepth(Node* root) { if (!root) return 0; int depth = 0; for (auto \u0026amp;c:root-\u0026gt;children) depth = max(depth, maxDepth(c)); return 1 + depth; } }; 563 äºŒå‰æ ‘çš„å¡åº¦ è®¡ç®—ä¸€ä¸ªäºŒå‰æ ‘çš„å¡åº¦ã€‚\nå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œè®¡ç®—å…¶å·¦å­æ ‘å’Œå³å­æ ‘çš„å’Œï¼Œå°†å…¶å·®çš„ç»å¯¹å€¼åŠ åˆ°æ€»çš„å¡åº¦ä¸Šï¼Œå†è¿”å›å·¦å­æ ‘ï¼Œå³å­æ ‘ï¼Œä¸è‡ªå·±çš„å€¼çš„å’Œï¼Œé€’å½’è°ƒç”¨å³å¯ã€‚\nclass Solution { int res; public: int findTilt(TreeNode *root) { res = 0; CalcTilt(root); return res; } int CalcTilt(TreeNode *node) { if (!node) return 0; int left = CalcTilt(node-\u0026gt;left); int right = CalcTilt(node-\u0026gt;right); res += abs(left - right); return node-\u0026gt;val + left + right; } }; 508 å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­æ ‘å…ƒç´ å’Œ æ‰¾å‡ºä¸€ä¸ªäºŒå‰æ ‘ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­æ ‘å…ƒç´ å’Œã€‚\nè®¡ç®—å‡ºä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘çš„å­æ ‘å…ƒç´ å’Œï¼ŒåŠ ä¸Šè‡ªèº«çš„å€¼å°±æ˜¯ä¸€ä¸ªå®Œæ•´çš„å­æ ‘å…ƒç´ å’Œï¼Œé€’å½’è°ƒç”¨è®¡ç®—æ‰€æœ‰çš„èŠ‚ç‚¹å¹¶è®¡æ•°å³å¯ã€‚\nclass Solution { unordered_map\u0026lt;int, int\u0026gt; count; public: vector\u0026lt;int\u0026gt; findFrequentTreeSum(TreeNode *root) { vector\u0026lt;int\u0026gt; res; count = unordered_map\u0026lt;int, int\u0026gt;(); Traverse(root); int n = 0; for (auto \u0026amp;c:count) { if (c.second \u0026gt; n) { n = c.second; res.clear(); res.push_back(c.first); } else if (c.second == n) res.push_back(c.first); } return res; } int Traverse(TreeNode *root) { if (!root) return 0; int val = Traverse(root-\u0026gt;left) + Traverse(root-\u0026gt;right) + root-\u0026gt;val; ++count[val]; return val; } }; 5. æ ˆæ±‚è§£ 623 åœ¨äºŒå‰æ ‘ä¸­å¢åŠ ä¸€è¡Œ ç»™ä¸€ä¸ªäºŒå‰æ ‘ï¼Œåœ¨ç¬¬ d å±‚è¿½åŠ ä¸€è¡Œå€¼ä¸º v çš„èŠ‚ç‚¹ã€‚\nç”¨ä¸€ä¸ªæ ˆä¿å­˜ä¸€å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œé€å±‚éå†å³å¯ã€‚æ³¨æ„ d = 1 æ—¶è¦å•ç‹¬å¤„ç†ã€‚\nclass Solution { public: TreeNode *addOneRow(TreeNode *root, int v, int d) { if (!root) return nullptr; if (d == 1) { TreeNode *new_root = new TreeNode(v); new_root-\u0026gt;left = root; return new_root; } queue\u0026lt;TreeNode *\u0026gt; q; q.push(root); int depth = 1, n = 1; while (!q.empty() \u0026amp;\u0026amp; depth \u0026lt; d) { for (int i = 0; i \u0026lt; n; ++i) { TreeNode *node = q.front(); q.pop(); if (depth == d - 1) { TreeNode *left = node-\u0026gt;left, *right = node-\u0026gt;right; node-\u0026gt;left = new TreeNode(v); node-\u0026gt;right = new TreeNode(v); node-\u0026gt;left-\u0026gt;left = left; node-\u0026gt;right-\u0026gt;right = right; } if (node-\u0026gt;left) q.push(node-\u0026gt;left); if (node-\u0026gt;right) q.push(node-\u0026gt;right); } ++depth; n = q.size(); } return root; } }; 6. æ‰¾èŠ‚ç‚¹ 1123. æœ€æ·±å¶èŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ æ‰¾åˆ°ä¸€ä¸ªäºŒå‰æ ‘æœ€æ·±çš„å¶èŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚\nå¯ä»¥å…ˆç”¨å±‚åºéå†æ‰¾åˆ°äºŒå‰æ ‘çš„æ·±åº¦ï¼Œå†é€šè¿‡ä¸€æ¬¡é€’å½’æ‰¾åˆ°æ‰€æœ‰å¶èŠ‚ç‚¹çš„å…¬å…±ç¥–å…ˆã€‚\nclass Solution { TreeNode *res; int lvl; public: TreeNode *lcaDeepestLeaves(TreeNode *root) { if (!root) return nullptr; res = nullptr; lvl = 0; queue\u0026lt;TreeNode *\u0026gt; nodes; nodes.push(root); int n = 1; while (!nodes.empty()) { for (int i = 0; i \u0026lt; n; ++i) { TreeNode *node = nodes.front(); nodes.pop(); if (node-\u0026gt;left) nodes.push(node-\u0026gt;left); if (node-\u0026gt;right) nodes.push(node-\u0026gt;right); } ++lvl; n = nodes.size(); } FindLCA(root, 1); return res; } bool FindLCA(TreeNode *root, int l) { if (root \u0026amp;\u0026amp; l == lvl) { res = root; return true; } else if (!root) return false; bool left = FindLCA(root-\u0026gt;left, l + 1), right = FindLCA(root-\u0026gt;right, l + 1); if (left \u0026amp;\u0026amp; right) res = root; return left || right; } }; ä½†å®é™…ä¸Šæˆ‘ä»¬å¹¶ä¸éœ€è¦çŸ¥é“è¿™æ£µæ ‘çš„æ·±åº¦ï¼Œåªéœ€è¦çŸ¥é“æœ€æ·±çš„èŠ‚ç‚¹å³æ˜¯å¶èŠ‚ç‚¹ï¼Œå¹¶ä¸”å¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘çš„æœ€æ·±èŠ‚ç‚¹çš„æ·±åº¦ç›¸åŒï¼Œé‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯ä»–ä»¬çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œè¿”å›è¿™ä¸ªèŠ‚ç‚¹å³å¯ã€‚\nclass Solution { public: TreeNode *lcaDeepestLeaves(TreeNode *root) { return FindLCA(root).first; } pair\u0026lt;TreeNode *, int\u0026gt; FindLCA(TreeNode *root) { if (!root) return pair\u0026lt;TreeNode *, int\u0026gt;(nullptr, 0); auto left = FindLCA(root-\u0026gt;left), right = FindLCA(root-\u0026gt;right); if (left.second \u0026gt; right.second) return pair\u0026lt;TreeNode *, int\u0026gt;(left.first, left.second + 1); if (left.second \u0026lt; right.second) return pair\u0026lt;TreeNode *, int\u0026gt;(right.first, right.second + 1); return pair\u0026lt;TreeNode *, int\u0026gt;(root, left.second + 1); } } ","permalink":"http://zintrulcre.github.io/posts/leetcode/tree-3/","summary":"LeetCode æ ‘ï¼ˆ3ï¼‰ é¢˜ç›® 4. é€’å½’æ±‚è§£ 617 åˆå¹¶äºŒå‰æ ‘ åˆå¹¶ä¸¤ä¸ªäºŒå‰æ ‘ã€‚\nåˆ¤æ–­å„ä¸ªèŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ï¼Œå…¨éƒ¨åˆå¹¶åˆ°ä¸€æ£µæ ‘ä¸Šå³å¯ã€‚\nclass Solution { public: TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) { if (!t1 \u0026amp;\u0026amp; !t2) return nullptr; else if (!t1) return t2; else if (!t2) return t1; t1-\u0026gt;val += t2-\u0026gt;val; t1-\u0026gt;left = mergeTrees(t1-\u0026gt;left, t2-\u0026gt;left); t1-\u0026gt;right = mergeTrees(t1-\u0026gt;right, t2-\u0026gt;right); return t1; } }; 226 ç¿»è½¬äºŒå‰æ ‘ ç¿»è½¬ä¸€ä¸ªäºŒå‰æ ‘ã€‚\nå…ˆå°†å·¦å³å­æ ‘åˆ†åˆ«ç¿»è½¬ï¼Œå†äº¤æ¢ä¸¤è€…çš„ä½ç½®ã€‚\nclass Solution { public: TreeNode *invertTree(TreeNode *root) { if (!root) return nullptr; TreeNode *left = invertTree(root-\u0026gt;left), *right = invertTree(root-\u0026gt;right); root-\u0026gt;right = left; root-\u0026gt;left = right; return root; } }; 104 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ æ‰¾å‡ºä¸€ä¸ªäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ã€‚","title":"LeetCode æ ‘ï¼ˆ3ï¼‰"},{"content":"LeetCode æ’åº é¢˜ç›® 56 åˆå¹¶åŒºé—´ æŒ‰ç…§é—´éš”çš„èµ·å§‹è¿›è¡Œæ’åºï¼Œåˆ¤æ–­ä¸‹ä¸€ä¸ªé—´éš”çš„èµ·å§‹æ˜¯å¦å¤§äºå‰ä¸€ä¸ªé—´éš”çš„æœ«å°¾ï¼Œå¦‚æœå¤§äºçš„è¯å°±æŠŠä¹‹å‰çš„é—´éš”åŠ å…¥ç»“æœæ•°ç»„ï¼Œå¦åˆ™ç»§ç»­æ‰©å±•å½“å‰çš„é—´éš”ã€‚\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;intervals) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; int n = intervals.size(); if (n == 0) return res; sort(intervals.begin(), intervals.end(), [](vector\u0026lt;int\u0026gt; const \u0026amp;v1, vector\u0026lt;int\u0026gt; const \u0026amp;v2) { return v1[0] \u0026lt; v2[0]; }); int start = intervals[0][0], end = intervals[0][1]; for (int i = 1; i \u0026lt; n; ++i) { if (intervals[i][0] \u0026gt; end) { res.push_back(vector\u0026lt;int\u0026gt;{start, end}); start = intervals[i][0]; } end = max(end, intervals[i][1]); } res.push_back(vector\u0026lt;int\u0026gt;{start, end}); return res; } }; 179 æœ€å¤§æ•° å…ˆæŠŠæ•°å­—è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åè‡ªå®šä¹‰ç±»ä¼¼äºå­—å…¸åºçš„æ’åºè§„åˆ™ s1 + s2 \u0026gt; s2 + s1 è¿›è¡Œæ’åºã€‚\nclass Solution { public: string largestNumber(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0, n = nums.size(); string res; vector\u0026lt;string\u0026gt; strs(n); for (i = 0; i \u0026lt; n; ++i) strs[i] = to_string(nums[i]); sort(strs.begin(), strs.end(), [](const string \u0026amp;s1, const string \u0026amp;s2) { return s1 + s2 \u0026gt; s2 + s1; }); for (i = 0; i \u0026lt; n; ++i) res += strs[i]; i = 0; while (i \u0026lt; res.size() - 1 \u0026amp;\u0026amp; res[i] == \u0026#39;0\u0026#39;) ++i; return res.substr(i); } }; 324 æ‘†åŠ¨æ’åº II å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åä»å°åˆ°å¤§åœ°å°†æ•°å­—é—´éš”ç€æ”¾åœ¨æ–°çš„æ•°ç»„ä¸­ï¼Œè¿™æ ·å¶æ•°ä½ä¸Šçš„æ•°å­—ä¸€å®šæ¯”å¥‡æ•°ä½ä¸Šçš„æ•°å­—å¤§ã€‚å¦‚æœæ•°ç»„é•¿åº¦ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆåˆå§‹ä½ç½®æ˜¯ n - 2ï¼ˆå€’æ•°ç¬¬äºŒä½ï¼‰ï¼Œå¦åˆ™æ˜¯ n - 1ï¼ˆæœ€åä¸€ä½ï¼‰ï¼Œä¸ä»ç¬¬ä¸€ä½å¼€å§‹æ˜¯å› ä¸ºæœ‰äº›ã€‚è¿™æ ·åšæ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogn)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: void wiggleSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(), i = n % 2 == 0 ? n - 2 : n - 1; vector\u0026lt;int\u0026gt; res(n); sort(nums.begin(), nums.end()); for (int j = 0; j \u0026lt; n; ++j) { res[i] = nums[j]; i -= 2; if (i \u0026lt; 0) i = n % 2 == 0 ? n - 1 : n - 2; } nums = res; } }; 524 é€šè¿‡åˆ é™¤å­—æ¯åŒ¹é…åˆ°å­—å…¸é‡Œæœ€é•¿å•è¯ ç”¨åŒæŒ‡é’ˆåˆ¤æ–­å­—å…¸é‡Œçš„æ¯ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ»¡è¶³è¦æ±‚ï¼Œå¹¶æ¯”è¾ƒæ»¡è¶³è¦æ±‚çš„å­—ç¬¦ä¸²ä¸ç»“æœå­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°é•¿åº¦æœ€é•¿ï¼Œå­—å…¸åºæœ€å°çš„è¿”å›å³å¯ã€‚\nclass Solution { public: string findLongestWord(string s, vector\u0026lt;string\u0026gt; \u0026amp;d) { string res; for (auto \u0026amp;ds:d) { int l = 0; for (int i = 0; i \u0026lt; s.size(); ++i) { if (s[i] == ds[l]) ++l; if (l == ds.size()) { if (ds.size() \u0026gt; res.size() || (ds.size() == res.size() \u0026amp;\u0026amp; ds \u0026lt; res)) res = ds; break; } } } return res; } }; 969 ç…é¥¼æ’åº æ¯æ¬¡æŠŠåœ¨ [0, j] å†…çš„æœ€å¤§çš„æ•°ç§»åŠ¨åˆ° A[j] çš„ä½ç½®ä¸Šå¹¶ \u0026ndash;jï¼Œæ¯æ¬¡éœ€è¦è¿›è¡Œä¸¤æ¬¡ç¿»è½¬ï¼Œä¸€æ¬¡æ˜¯æŠŠ [0, j] å†…æœ€å¤§çš„æ•°ç¿»è½¬åˆ° A[0]ä¸Šï¼Œä¸€æ¬¡æ˜¯æŠŠ A[0] ç¿»è½¬åˆ° A[j] ä¸Šï¼Œè¿™æ ·å°±èƒ½ä¿è¯æ¯æ¬¡éƒ½æŠŠæœ€å¤§çš„æ•°ç§»åŠ¨åˆ°äº† [0, j] çš„æœ«å°¾ï¼Œé‡å¤è¿™ä¸ªè¿‡ç¨‹ç›´åˆ° j å‡å°‘ä¸º 1ï¼Œæ­¤æ—¶åªå‰© 1 ä¸ªæ•°å­—ï¼Œç»“æŸå¾ªç¯å³å¯ã€‚å› ä¸ºåœ¨å¾ªç¯å†…åšäº†ç¿»è½¬æ“ä½œï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: vector\u0026lt;int\u0026gt; pancakeSort(vector\u0026lt;int\u0026gt; \u0026amp;A) { vector\u0026lt;int\u0026gt; res; int n = A.size(), j = n; while (j \u0026gt; 1) { int idx = 0; for (int i = 0; i \u0026lt; j; ++i) if (A[i] \u0026gt; A[idx]) idx = i; if (idx != j - 1) { if (idx != 0) { reverse(A.begin(), A.begin() + idx + 1); res.push_back(idx + 1); } reverse(A.begin(), A.begin() + j); res.push_back(j); } --j; } return res; } }; 1122 æ•°ç»„çš„ç›¸å¯¹æ’åº ç»™ arr2 ä¸­çš„æ•°å­—æŒ‰ç…§ä¸‹æ ‡èµ‹äºˆæƒåˆ¶ï¼ŒæŒ‰ç…§æƒåˆ¶æ•°ç»„è¿›è¡Œæ’åºå³å¯ã€‚\nclass Solution { public: vector\u0026lt;int\u0026gt; relativeSortArray(vector\u0026lt;int\u0026gt;\u0026amp; arr1, vector\u0026lt;int\u0026gt;\u0026amp; arr2) { vector\u0026lt;int\u0026gt; auth(1001); for (int i = 0; i \u0026lt;= 1000; ++i) auth[i] = 1001 + i; for (int i = 0; i \u0026lt; arr2.size(); ++i) auth[arr2[i]] = i; sort(arr1.begin(), arr1.end(), [\u0026amp;](const int \u0026amp;c1, const int \u0026amp;c2) { return auth[c1] \u0026lt; auth[c2]; }); return arr1; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/sort/","summary":"LeetCode æ’åº é¢˜ç›® 56 åˆå¹¶åŒºé—´ æŒ‰ç…§é—´éš”çš„èµ·å§‹è¿›è¡Œæ’åºï¼Œåˆ¤æ–­ä¸‹ä¸€ä¸ªé—´éš”çš„èµ·å§‹æ˜¯å¦å¤§äºå‰ä¸€ä¸ªé—´éš”çš„æœ«å°¾ï¼Œå¦‚æœå¤§äºçš„è¯å°±æŠŠä¹‹å‰çš„é—´éš”åŠ å…¥ç»“æœæ•°ç»„ï¼Œå¦åˆ™ç»§ç»­æ‰©å±•å½“å‰çš„é—´éš”ã€‚\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;intervals) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; int n = intervals.size(); if (n == 0) return res; sort(intervals.begin(), intervals.end(), [](vector\u0026lt;int\u0026gt; const \u0026amp;v1, vector\u0026lt;int\u0026gt; const \u0026amp;v2) { return v1[0] \u0026lt; v2[0]; }); int start = intervals[0][0], end = intervals[0][1]; for (int i = 1; i \u0026lt; n; ++i) { if (intervals[i][0] \u0026gt; end) { res.push_back(vector\u0026lt;int\u0026gt;{start, end}); start = intervals[i][0]; } end = max(end, intervals[i][1]); } res.","title":"LeetCode æ’åº"},{"content":"LeetCode å † é¢˜ç›® 215 æ•°ç»„ä¸­çš„ç¬¬ K ä¸ªæœ€å¤§å…ƒç´  æœ€ç®€å•çš„å †çš„åº”ç”¨ã€‚\nclass Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; heap; for (auto \u0026amp;m:nums) { if (heap.size() \u0026lt; k || m \u0026gt; heap.top()) heap.push(m); if (heap.size() \u0026gt; k) heap.pop(); } return heap.top(); } }; 347 å‰ K ä¸ªé«˜é¢‘å…ƒç´  å…ˆéå†ä¸€æ¬¡ç»Ÿè®¡å‡ºæ•°ç»„ä¸­å„ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œå†ç”¨ä¸€ä¸ªå¤§æ ¹å †å°†å‰ k ä¸ªé«˜é¢‘å…ƒç´ ä¿å­˜ä¸‹æ¥ï¼Œæœ€åå†å°†è¿™äº›å…ƒç´ ä¾æ¬¡ pop å‡ºæ¥å­˜å…¥ç»“æœæ•°ç»„ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; freq; unordered_map\u0026lt;int, int\u0026gt; count; vector\u0026lt;int\u0026gt; res(k, 0); for (auto \u0026amp;m:nums) ++count[m]; for (auto \u0026amp;c:count) { freq.push(pair\u0026lt;int, int\u0026gt;(c.second, c.first)); if (freq.size() \u0026gt; k) freq.pop(); } for (int i = 0; i \u0026lt; k; ++i) { pair\u0026lt;int, int\u0026gt; p = freq.top(); freq.pop(); res[i] = p.second; } return res; } }; 451 æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº ç”¨ä¸€ä¸ªå¤§æ ¹å †ä¿å­˜æ¯ä¸ªå­—ç¬¦å‡ºç°çš„é¢‘ç‡ï¼Œç„¶åä¾æ¬¡å°†åŸå­—ç¬¦ä¸²è¦†ç›–å³å¯ã€‚\nclass Solution { struct Element { int asc; int num; Element() : num(0) {} }; struct Compare { bool operator()(Element \u0026amp;e1, Element \u0026amp;e2) { return e1.num \u0026lt; e2.num; } }; public: string frequencySort(string s) { vector\u0026lt;Element\u0026gt; count(200); for (int i = 0; i \u0026lt; 200; ++i) count[i].asc = i; for (auto c:s) ++count[c].num; priority_queue\u0026lt;Element, vector\u0026lt;Element\u0026gt;, Compare\u0026gt; heap; for (auto \u0026amp;c:count) if (c.num != 0) heap.push(c); int i = 0; while (!heap.empty()) { auto t = heap.top(); heap.pop(); for (int j = 0; j \u0026lt; t.num; ++j) s[i++] = t.asc; } return s; } }; 692 å‰ K ä¸ªé«˜é¢‘å•è¯ ç”¨ä¸€ä¸ª pair\u0026lt;string, int\u0026gt; æˆ–ç»“æ„ä½“ä¿å­˜æ¯ä¸ªå­—ç¬¦ä¸²åŠå…¶è®¡æ•°çš„ä¿¡æ¯ï¼Œå¹¶ç»´æŠ¤ä¸€ä¸ªå°æ ¹å †ï¼Œä¿è¯å †é‡Œå­˜å‚¨å‰ K ä¸ªé«˜é¢‘å•è¯ï¼Œæ”¾å›å †é‡Œçš„æ‰€æœ‰å…ƒç´ ã€‚\nclass Solution { struct Comp { bool operator()(pair\u0026lt;string, int\u0026gt; const \u0026amp;p1, pair\u0026lt;string, int\u0026gt; const \u0026amp;p2) { if (p1.second == p2.second) return p1.first \u0026lt; p2.first; return p1.second \u0026gt; p2.second; } }; public: vector\u0026lt;string\u0026gt; topKFrequent(vector\u0026lt;string\u0026gt; \u0026amp;words, int k) { vector\u0026lt;string\u0026gt; res(k); unordered_map\u0026lt;string, int\u0026gt; count; priority_queue\u0026lt;pair\u0026lt;string, int\u0026gt;, vector\u0026lt;pair\u0026lt;string, int\u0026gt;\u0026gt;, Comp\u0026gt; heap; for (auto \u0026amp;word:words) ++count[word]; for (auto \u0026amp;c:count) { heap.push(c); if (heap.size() \u0026gt; k) heap.pop(); } for (int i = 0; i \u0026lt; k; ++i) { res[i] = heap.top().first; heap.pop(); } reverse(res.begin(), res.end()); return res; } }; 778 æ°´ä½ä¸Šå‡çš„æ³³æ± ä¸­æ¸¸æ³³ ç±»ä¼¼äº AI ä¸­ç”¨åˆ°çš„ Greedy Best-First Search æ–¹æ³•ã€‚ä¸èƒ½ç”¨è´ªå¿ƒæ˜¯å› ä¸ºæœªè®¿é—®è¿‡çš„è·¯å¾„ä¸­å¯èƒ½å‡ºç°æœ€ä¼˜è§£ï¼Œæ¯”å¦‚ [[0, 4, 7], [5, 8, 9], [2, 3, 1]] è¿™ä¸ªçŸ©é˜µï¼Œå¦‚æœé‡‡ç”¨è´ªå¿ƒä¼šç»è¿‡è·¯å¾„ 0 -\u0026gt; 4 -\u0026gt; 7 -\u0026gt; 9 -\u0026gt; 1ï¼Œè€Œå®é™…ä¸Šæœ€ä¼˜è·¯å¾„æ˜¯ 0 -\u0026gt; 5 - \u0026gt; 2 -\u0026gt; 3 -\u0026gt; 1ï¼Œæ‰€ä»¥éœ€è¦æŠŠä¹‹å‰æœªç»è¿‡çš„èŠ‚ç‚¹å€¼ä¿å­˜ä¸‹æ¥ï¼Œä»¥ä¾¿åœ¨è´ªå¿ƒçš„è¿‡ç¨‹ä¸­é‡åˆ°å½“å‰èŠ‚ç‚¹å¤§äºä¹‹å‰æœªç»è¿‡çš„èŠ‚ç‚¹æ—¶é‡æ–°å›åˆ°ä¹‹å‰çš„ä½ç½®ç»§ç»­æœç´¢ï¼Œä¿å­˜çš„æ–¹æ³•æ˜¯ç”¨ä¸€ä¸ªå°æ ¹å †ä¿å­˜æ‰€æœ‰å¯èƒ½ç»è¿‡çš„ä¸‹ä¸€æ­¥èŠ‚ç‚¹ï¼Œè¿™æ ·å°±å¯ä»¥æ¯æ¬¡ä»å †é¡¶å–å‡ºä¸‹ä¸€æ­¥çš„æœ€ä¼˜å€¼ï¼Œè€Œæœç´¢çš„ç­–ç•¥åˆ™ç”¨ DFSï¼Œæ¯æ¬¡å°è¯•å››ä¸ªæ–¹å‘æœªè®¿é—®è¿‡çš„èŠ‚ç‚¹ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { struct Element { int val; int x, y; Element(int val, int x, int y) : val(val), x(x), y(y) {} }; struct Compare { bool operator()(Element const \u0026amp;e1, Element const \u0026amp;e2) { return e1.val \u0026gt; e2.val; } }; int dir[4][2] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; public: int swimInWater(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { int m = grid.size(), n = m ? grid[0].size() : 0, res = 0; if (m == 0) return 0; priority_queue\u0026lt;Element, vector\u0026lt;Element\u0026gt;, Compare\u0026gt; heap; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(m, vector\u0026lt;bool\u0026gt;(n, false)); heap.push(Element(grid[0][0], 0, 0)); visited[0][0] = true; while (!heap.empty()) { Element e = heap.top(); heap.pop(); res = max(res, e.val); if (e.x == m - 1 \u0026amp;\u0026amp; e.y == n - 1) break; for (auto \u0026amp;d:dir) { int x = e.x + d[0], y = e.y + d[1]; if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; m \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; n \u0026amp;\u0026amp; !visited[x][y]) { heap.push(Element(grid[x][y], x, y)); visited[x][y] = true; } } } return res; } }; 703 æ•°æ®æµä¸­çš„ç¬¬ K å¤§å…ƒç´  ç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸º K çš„å°æ ¹å †ï¼Œå¦‚æœæ–°çš„æ•°æ¯”å †é¡¶å…ƒç´ å¤§åˆ™å°†è¿™ä¸ªæ•° push è¿›å»å¹¶ç»´æŠ¤å †ï¼Œå½“å †ä¸­çš„å…ƒç´ æ•°é‡è¶…è¿‡ K æ—¶ pop å‡ºå †é¡¶å…ƒç´ å¹¶ç»´æŠ¤å †ã€‚\nclass KthLargest { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; min_heap; int k; public: KthLargest(int k, vector\u0026lt;int\u0026gt; \u0026amp;nums) { this-\u0026gt;k = k; min_heap = priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt;(); for (auto \u0026amp;m:nums) { if (min_heap.size() \u0026lt; k || min_heap.top() \u0026lt; m) min_heap.push(m); if (min_heap.size() \u0026gt; k) min_heap.pop(); } } int add(int val) { if (min_heap.size() \u0026lt; k || min_heap.top() \u0026lt; val) min_heap.push(val); if (min_heap.size() \u0026gt; k) min_heap.pop(); return min_heap.top(); } }; 295 æ•°æ®æµçš„ä¸­ä½æ•° æœ€ä¼˜çš„åšæ³•æ˜¯ç”¨ä¸€ä¸ªå¤§æ ¹å †å’Œä¸€ä¸ªå°æ ¹å †ï¼Œå‰è€…å­˜æ•°æ®æµçš„ååŠéƒ¨åˆ†ï¼Œå‰è€…å­˜æ•°æ®æµçš„å‰åŠéƒ¨åˆ†ï¼Œè¿™æ ·ä¸¤ä¸ªå †çš„å †é¡¶åˆ†åˆ«æ˜¯å½“å‰æ•°æ®æµçš„ä¸­é—´çš„è¾ƒå¤§å’Œè¾ƒå°çš„æ•°ï¼Œæ¯æ¬¡å»ä¸­ä½æ•°åªéœ€è¦å–å †é¡¶å…ƒç´ å³å¯ï¼Œå› æ­¤å–æ•°çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(1)ï¼Œæ’å…¥æ•°çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(logk)ï¼Œk æ˜¯æ•°æ®æµæ•°æ®æ€»æ•°çš„ä¸€åŠã€‚è¿˜å¯ä»¥ç”¨äºŒåˆ†æŸ¥æ‰¾åŠ ä¸Šæ’å…¥æ’åºçš„åšæ³•ï¼Œè¿™æ ·åšæ’å…¥çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œéœ€è¦å°†æ•°æ®æµä¸­å¤§äºæ’å…¥æ•°æ®çš„æ‰€æœ‰æ•°å¾€å³ç§»åŠ¨ï¼ŒæŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(logn)ã€‚\nclass MedianFinder { priority_queue\u0026lt;double\u0026gt; max_heap; priority_queue\u0026lt;double, vector\u0026lt;double\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; min_heap; public: /** initialize your data structure here. */ MedianFinder() { max_heap = priority_queue\u0026lt;double\u0026gt;(); min_heap = priority_queue\u0026lt;double, vector\u0026lt;double\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt;(); } void addNum(int num) { if (max_heap.empty() || max_heap.top() \u0026gt; num) max_heap.push(num); else min_heap.push(num); while (max_heap.size() \u0026gt; min_heap.size() + 1) { min_heap.push(max_heap.top()); max_heap.pop(); } while (min_heap.size() \u0026gt; max_heap.size() + 1) { max_heap.push(min_heap.top()); min_heap.pop(); } } double findMedian() { int ls = max_heap.size(), rs = min_heap.size(); if ((ls + rs) % 2 == 0) return (max_heap.top() + min_heap.top()) * 1.0 / 2; return ls \u0026gt; rs ? max_heap.top() : min_heap.top(); } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/heap/","summary":"LeetCode å † é¢˜ç›® 215 æ•°ç»„ä¸­çš„ç¬¬ K ä¸ªæœ€å¤§å…ƒç´  æœ€ç®€å•çš„å †çš„åº”ç”¨ã€‚\nclass Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; heap; for (auto \u0026amp;m:nums) { if (heap.size() \u0026lt; k || m \u0026gt; heap.top()) heap.push(m); if (heap.size() \u0026gt; k) heap.pop(); } return heap.top(); } }; 347 å‰ K ä¸ªé«˜é¢‘å…ƒç´  å…ˆéå†ä¸€æ¬¡ç»Ÿè®¡å‡ºæ•°ç»„ä¸­å„ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œå†ç”¨ä¸€ä¸ªå¤§æ ¹å †å°†å‰ k ä¸ªé«˜é¢‘å…ƒç´ ä¿å­˜ä¸‹æ¥ï¼Œæœ€åå†å°†è¿™äº›å…ƒç´ ä¾æ¬¡ pop å‡ºæ¥å­˜å…¥ç»“æœæ•°ç»„ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; freq; unordered_map\u0026lt;int, int\u0026gt; count; vector\u0026lt;int\u0026gt; res(k, 0); for (auto \u0026amp;m:nums) ++count[m]; for (auto \u0026amp;c:count) { freq.","title":"LeetCode å †"},{"content":"LeetCode DFS é¢˜ç›® 26 åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ ç”¨ä¸¤ä¸ªæŒ‡é’ˆ len å’Œ i åˆ†åˆ«è¡¨ç¤ºæ²¡æœ‰é‡å¤çš„é¡¹çš„ä¸‹æ ‡ä¸éå†æ•°ç»„çš„ä¸‹æ ‡ï¼Œå°†æ²¡æœ‰é‡å¤çš„é¡¹æ‹·è´åˆ° nums[len] ä¸‹ç„¶å ++len å³å¯ã€‚\nclass Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int count = 0, len = 1, n = nums.size(); if (n == 0) return 0; for (int i = 1; i \u0026lt; n; ++i) { if (nums[i] == nums[i - 1]) continue; nums[len] = nums[i]; ++len; } return len; } }; 80 åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ II ç”¨ä¸¤ä¸ªæŒ‡é’ˆ len å’Œ i åˆ†åˆ«è¡¨ç¤ºæ²¡æœ‰æœ€å¤šé‡å¤ 2 æ¬¡çš„é¡¹çš„ä¸‹æ ‡ä¸éå†æ•°ç»„çš„ä¸‹æ ‡ï¼Œå°†é‡å¤æ•°å°äºç­‰äº 1 çš„é¡¹æ‹·è´åˆ° nums[len] ä¸‹ç„¶å ++len å³å¯ã€‚\nclass Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int count = 0, len = 1, n = nums.size(); if (n == 0) return 0; for (int i = 1; i \u0026lt; nums.size(); ++i) { if (nums[i] == nums[i - 1]) { if (count \u0026gt; 0) continue; ++count; } else count = 0; nums[len] = nums[i]; ++len; } return len; } }; 922 æŒ‰å¥‡å¶æ’åºæ•°ç»„ II ç”¨ä¸¤ä¸ªä¸‹æ ‡ i å’Œ j åˆ†åˆ«è¡¨ç¤ºå¶æ•°ä½å’Œå¥‡æ•°ä½çš„ä¸‹æ ‡ï¼Œå¦‚æœå¶æ•°ä½ä¸‹æ ‡å¯¹åº”çš„æ•°ä¸æ˜¯å¶æ•°é‚£ä¹ˆå°†å…¶ä¸å¥‡æ•°ä½ä¸‹æ ‡å¯¹åº”çš„æ•°ä¸æ˜¯å¥‡æ•°çš„æ•°è¿›è¡Œäº¤æ¢ã€‚\nclass Solution { public: vector\u0026lt;int\u0026gt; sortArrayByParityII(vector\u0026lt;int\u0026gt;\u0026amp; A) { for (int i = 0, j = 1; i \u0026lt; A.size(); i += 2) if (A[i] % 2 != 0) { while (j \u0026lt; A.size() \u0026amp;\u0026amp; A[j] % 2 != 0) j += 2; swap(A[i], A[j]); } return A; } }; 11 ç››æœ€å¤šæ°´çš„å®¹å™¨ ç”¨ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«è¡¨ç¤ºæ•°ç»„çš„å¤´å’Œå°¾ï¼Œæ¯æ¬¡å°†é«˜åº¦è¾ƒä½çš„å…ƒç´ çš„ä¸‹æ ‡å¾€ä¸­é—´ç§»åŠ¨ï¼ŒåŒæ—¶æ›´æ–°ç»“æœã€‚\nclass Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; h) { int i = 0, j = h.size() - 1, res = 0; while (i \u0026lt; j) { res = max(res, min(h[i], h[j]) * (j - i)); if (h[i] \u0026lt; h[j]) ++i; else --j; } return res; } }; 287 å¯»æ‰¾é‡å¤æ•° å°†å‡ºç°çš„æ•°å­—çš„ç»å¯¹å€¼ - 1 ä½œä¸ºä¸‹æ ‡ï¼ŒæŠŠå¯¹åº”ä½ç½®çš„æ•°å­—ä¹˜ä»¥ -1 è¿›è¡Œæ ‡è®°ï¼Œå› ä¸ºåªæœ‰ä¸€ä¸ªæ•°å­—é‡å¤äº†ï¼Œæ‰€ä»¥å¦‚æœåœ¨æ ‡è®°æ—¶å¦‚æœå‘ç°å¯¹åº”ä½ç½®çš„æ•°å­—å·²ç»æ˜¯è´Ÿæ•°åˆ™è¯´æ˜å‡ºç°è¿‡ç›¸åŒçš„ä¸‹æ ‡ï¼Œè¿”å›è¯¥æ•°å­—å³å¯ã€‚\nclass Solution { public: int findDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size(); ++i) { int index = abs(nums[i]) - 1; if (nums[index] \u0026lt; 0) return abs(nums[i]); nums[index] *= -1; } return 0; } }; 75 é¢œè‰²åˆ†ç±» ç±»ä¼¼äºåªæœ‰ä¸¤ä¸ªæ•°çš„æ•°ç»„æ’åºï¼Œåªéœ€è¦ç”¨ä¸¤ä¸ªå˜é‡ idx_0 = 0, idx_2 = n - 1 åˆ†åˆ«è¡¨ç¤ºä¸¤ç«¯çš„ä¸‹æ ‡ï¼Œå°† 0 å’Œ 2 åˆ†åˆ«æ›¿æ¢åˆ°æ•°ç»„çš„ä¸¤ç«¯ï¼Œå°† 1 ç•™åœ¨ä¸­é—´å³å¯ã€‚\nclass Solution { public: void sortColors(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(), idx_0 = 0, idx_2 = n - 1; for (int i = 0; i \u0026lt;= idx_2; ++i) { if (nums[i] == 2) { swap(nums[i], nums[idx_2]); --idx_2, --i; } else if (nums[i] == 0) { swap(nums[i], nums[idx_0]); ++idx_0; } } } }; 15 ä¸‰æ•°ä¹‹å’Œ é¦–å…ˆæ˜ç¡®ä¸¤æ•°ä¹‹å’Œçš„åšæ³•ï¼šæ’åºåç”¨ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä»å¤´å’Œå°¾å¾€ä¸­é—´éå†ï¼Œæ ¹æ®å¤§å°å…³ç³»ç§»åŠ¨æŒ‡é’ˆã€‚ä¸‰æ•°ä¹‹å’Œæ— éå°±æ˜¯å…ˆå›ºå®šä¸€ä¸ªæ•°ï¼Œä½¿å¾—å¦å¤–ä¸¤ä¸ªæ•°ä¹‹å’Œç­‰äºè¿™ä¸ªæ•°çš„è´Ÿæ•°ï¼Œå› æ­¤ä»ç„¶è¦å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œä¸ºäº†å›ºå®šä¸€ä¸ªæ•°éœ€è¦ç”¨ä¸€ä¸ª for å¾ªç¯éå†æ•°ç»„ï¼Œå¯¹äºå…¶åçš„æ‰€æœ‰å…ƒç´ ç”¨ä¸¤æ•°ä¹‹å’Œçš„æ–¹æ³•è¿›è¡Œæ±‚å’Œã€‚ä¸ºäº†é˜²æ­¢å‡ºç°é‡å¤éœ€è¦åœ¨è®¡ç®—ä¸¤æ•°ä¹‹å’Œåä¸æ–­åœ°ç§»åŠ¨æŒ‡é’ˆç›´åˆ°å½“å‰å…ƒç´ ä¸å…¶å‰/åä¸€ä¸ªå…ƒç´ ä¸ç›¸åŒã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; int n = nums.size(), i = 0; while (i \u0026lt; n) { int j = i + 1, k = n - 1, target = -nums[i]; while (j \u0026lt; k) { if (nums[j] + nums[k] == target) { res.push_back({nums[i], nums[j], nums[k]}); do ++j; while (j \u0026lt; k \u0026amp;\u0026amp; nums[j] == nums[j - 1]); do --k; while (j \u0026lt; k \u0026amp;\u0026amp; nums[k] == nums[k + 1]); } else if (nums[j] + nums[k] \u0026lt; target) ++j; else --k; } do ++i; while (i \u0026lt; n \u0026amp;\u0026amp; nums[i] == nums[i - 1]); } return res; } }; 424 æ›¿æ¢åçš„æœ€é•¿é‡å¤å­—ç¬¦ å¯¹äºä¸€ä¸ªå­ä¸²ï¼Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“è¿™ä¸ªå­ä¸²ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­—ç¬¦çš„å‡ºç°æ¬¡æ•°ï¼Œå°±å¯ä»¥æ ¹æ® j - i + 1 - max_count \u0026lt;= k çŸ¥é“è¿™ä¸ªå­ä¸²æ˜¯å¦èƒ½è¢«æ›¿æ¢ä¸ºé‡å¤å­ä¸²ï¼Œå› æ­¤ç”¨æ»‘åŠ¨çª—å£çš„æ–¹æ³•å›ºå®šä¸€ä¸ªå­ä¸²ï¼Œå¦‚æœè¿™ä¸ªå­ä¸²æ»¡è¶³æ¡ä»¶ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†æ»‘åŠ¨çª—å£çš„å³ç«¯ j ç»§ç»­å¾€åç§»åŠ¨ï¼Œå¦åˆ™éœ€è¦å°†å·¦ç«¯å¾€åç§»åŠ¨ç›´åˆ°è¿™ä¸ªå­ä¸²æ»¡è¶³æ¡ä»¶ï¼Œj - i + 1 å°±æ˜¯å¯èƒ½çš„æœ€é•¿é‡å¤å­ä¸²çš„é•¿åº¦ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: int characterReplacement(string s, int k) { int i = 0, j = 0, res = 0, n = s.size(), max_count = 0; vector\u0026lt;int\u0026gt; count(26, 0); while (j \u0026lt; n) { ++count[s[j] - \u0026#39;A\u0026#39;]; max_count = max(max_count, count[s[j] - \u0026#39;A\u0026#39;]); while (j - i + 1 - max_count \u0026gt; k) { --count[s[i] - \u0026#39;A\u0026#39;]; ++i; for (auto \u0026amp;c:count) max_count = max(max_count, c); } res = max(res, j - i + 1); ++j; } return res; } }; 1004 æœ€å¤§è¿ç»­ 1 çš„ä¸ªæ•° III ç”¨å·¦å³ä¸¤ä¸ªæŒ‡é’ˆä¿è¯æ»‘åŠ¨çª—å£ä¸­æœ‰å°äºç­‰äº K ä¸ª 0ï¼Œå¦‚æœå½“å‰ä½æ˜¯ 1 é‚£ä¹ˆå³è¾¹çš„æŒ‡é’ˆç»§ç»­å‘åç§»åŠ¨ï¼Œå¦‚æœå½“å‰ä½æ˜¯ 0 å¹¶ä¸”å·²ç»æœ‰ K ä¸ª 0ï¼Œé‚£ä¹ˆå·¦è¾¹çš„æŒ‡é’ˆå¾€å³ç§»åŠ¨ç›´åˆ°å‡ºç° 0ï¼Œè·³è¿‡è¿™ä¸€ä½ 0ï¼Œå°†å³è¾¹æŒ‡é’ˆçš„ 0 è§†ä½œ 1ï¼Œæ›´æ–°ç»“æœã€‚\nclass Solution { public: int longestOnes(vector\u0026lt;int\u0026gt; \u0026amp;A, int K) { int i = 0, res = 0; for (int j = 0; j \u0026lt; A.size(); ++j) { if (A[j] == 0) { if (K \u0026gt; 0) --K; else { while (A[i] == 1) ++i; ++i; } } res = max(res, j - i + 1); } return res; } }; 42 æ¥é›¨æ°´ å¯ä»¥å…ˆå°†æ¯ä¸ªä½ç½®å·¦è¾¹å’Œå³è¾¹æœ€é«˜çš„æŸ±å­é«˜åº¦éƒ½ä¿å­˜ä¸‹æ¥ï¼Œå†è®¡ç®—ä¸¤è€…ä¸­è¾ƒä½çš„å‡å»å½“å‰ä½ç½®çš„æŸ±å­æ•°é‡å¾—åˆ°å½“å‰ä½ç½®èƒ½å¤Ÿæ¥ä½çš„é›¨æ°´æ•°é‡ã€‚\nclass Solution { public: int trap(vector\u0026lt;int\u0026gt; \u0026amp;height) { int n = height.size(), res = 0; vector\u0026lt;int\u0026gt; left(n, 0), right(n, 0); for (int i = 1; i \u0026lt; n; ++i) left[i] = max(left[i - 1], height[i - 1]); for (int i = n - 2; i \u0026gt;= 0; --i) right[i] = max(right[i + 1], height[i + 1]); for (int i = 0; i \u0026lt; n; ++i) res += max(0, min(left[i], right[i]) - height[i]); return res; } }; ä¹Ÿå¯ä»¥ç”¨ä¸¤ä¸ªå˜é‡ l_max å’Œ r_max åˆ†åˆ«è®°å½•å·¦è¾¹å’Œå³è¾¹åˆ°ç›®å‰ä¸ºæ­¢æœ€é«˜çš„æŸ±å­é«˜åº¦ï¼Œæ¯æ¬¡æ£€æŸ¥è¾ƒä½çš„ä¸€è¾¹ï¼Œèƒ½å¤Ÿæ¥ä½çš„é›¨æ°´æ•°é‡ç­‰äº min(l_max, r_max) å‡å»å½“å‰çš„æŸ±å­é«˜åº¦ï¼ŒåŒæ—¶æ›´æ–°æŸ±å­çš„æœ€é«˜é«˜åº¦ã€‚\nclass Solution { public: int trap(vector\u0026lt;int\u0026gt; \u0026amp;height) { int n = height.size(), res = 0, l_max = 0, r_max = 0, i = 0, j = n - 1; while (i \u0026lt;= j) { if (l_max \u0026lt;= r_max) { res += max(0, min(l_max, r_max) - height[i]); l_max = max(l_max, height[i]); ++i; } else { res += max(0, min(l_max, r_max) - height[j]); r_max = max(r_max, height[j]); --j; } } return res; } }; 632 æœ€å°åŒºé—´ æ¯”è¾ƒå®¹æ˜“æƒ³åˆ°çš„æ–¹æ³•æ˜¯ä»æ¯ä¸ªæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹éå†ï¼Œä½¿ç”¨ä¸€ä¸ªæ•°ç»„ idx å­˜å‚¨æ¯ä¸€ä¸ªæ•°ç»„å½“å‰éå†åˆ°çš„å…ƒç´ çš„ä¸‹æ ‡ï¼Œæ¯æ¬¡å–è¿™äº›å…ƒç´ ä¸­çš„æœ€å¤§æœ€å°å€¼è¿›è¡Œæ›´æ–°ï¼Œè¿™æ ·åšæ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ï¼Œå…¶ä¸­ m æ˜¯æ•°ç»„çš„ä¸ªæ•°ï¼Œn æ˜¯æ‰€æœ‰å…ƒç´ çš„ä¸ªæ•°ï¼Œä½†æ˜¯è¿™æ ·åšä¼š TLEã€‚ç›¸è¾ƒäºæ¯æ¬¡éƒ½éå†ä¸€éæ•´ä¸ªäºŒç»´æ•°ç»„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªå°æ ¹å †æŠŠæ‰€æœ‰å½“å‰éå†åˆ°çš„å…ƒç´ ä¸­çš„æœ€å°å€¼è¿å¸¦å…¶æ•°ç»„ä¸‹æ ‡åŠå…¶ä¸‹æ ‡ä¿å­˜ä¸‹æ¥ï¼Œè¿™æ ·å°±èƒ½æ¯æ¬¡ä»¥ O(1) çš„æ—¶é—´å¤æ‚åº¦å–åˆ°æ‰€æœ‰æ•°ç»„ä¸­å½“å‰å…ƒç´ çš„æœ€å°å€¼ï¼Œå†ç”¨ä¸€ä¸ªå˜é‡ max_val å­˜å‚¨æ‰€æœ‰æ•°ç»„ä¸­å½“å‰å…ƒç´ çš„æœ€å¤§å€¼ï¼Œæ¯æ¬¡ä»å°æ ¹å † pop å‡ºå †é¡¶å…ƒç´ åï¼Œå…ˆæ›´æ–° res ç»“æœæ•°ç»„ï¼Œç„¶åç”¨è¿™ä¸ªå…ƒç´ å¯¹åº”ä¸‹æ ‡çš„åä¸€ä¸ªä¸‹æ ‡çš„å€¼æ›´æ–° max_valï¼Œç›´åˆ°å †é¡¶å…ƒç´ å·²ç»æ˜¯æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * logn)ã€‚\nclass Solution { struct element { int val; int vec_idx; int idx; element(int val, int vec_idx, int idx) : val(val), vec_idx(vec_idx), idx(idx) {} }; struct Compare { bool operator()(const element \u0026amp;e1, const element \u0026amp;e2) { return e1.val \u0026gt; e2.val; } }; public: vector\u0026lt;int\u0026gt; smallestRange(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;nums) { int n = nums.size(), max_val = INT_MIN; vector\u0026lt;int\u0026gt; res(2, 0); res[1] = INT_MAX; priority_queue\u0026lt;element, vector\u0026lt;element\u0026gt;, Compare\u0026gt; heap; for (int i = 0; i \u0026lt; n; ++i) { heap.push(element(nums[i][0], i, 0)); max_val = max(max_val, nums[i][0]); } while (true) { element e = heap.top(); heap.pop(); if (res[1] - res[0] \u0026gt; max_val - e.val) res[0] = e.val, res[1] = max_val; if (e.idx == nums[e.vec_idx].size() - 1) break; ++e.idx; e.val = nums[e.vec_idx][e.idx]; heap.push(e); max_val = max(max_val, e.val); } return res; } }; 76 æœ€å°è¦†ç›–å­ä¸² å…ˆä»å·¦å¾€å³æ‰¾åˆ°ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å­—ç¬¦ä¸²ï¼Œç„¶åç”¨æ»‘åŠ¨çª—å£çš„åšæ³•æ¯æ¬¡åœ¨å·¦è¾¹å»æ‰ä¸€ä¸ªå­—ç¬¦ï¼Œå¾€å³è¾¹æ‰¾åˆ°ä¸€ä¸ªæœªè¢«ä½¿ç”¨è¿‡çš„å¯¹åº”çš„å­—ç¬¦ï¼Œå¦‚æœé•¿åº¦å°äºä¹‹å‰å¾—åˆ°çš„å­—ç¬¦ä¸²åˆ™æ›´æ–°ç»“æœã€‚\nclass Solution { struct Element { int pos; char c; Element(int pos, char c) : pos(pos), c(c) {} }; public: string minWindow(string s, string t) { string res; unordered_map\u0026lt;char, int\u0026gt; count; vector\u0026lt;Element\u0026gt; ele; unordered_set\u0026lt;int\u0026gt; used; for (auto c:t) ++count[c]; for (int i = 0; i \u0026lt; s.size(); ++i) if (count.find(s[i]) != count.end()) ele.push_back(Element(i, s[i])); int i = 0, j = 0, n = ele.size(), pos = 0, l = n, start = 0, end = 0; while (j \u0026lt; n \u0026amp;\u0026amp; !count.empty()) { if (count.find(ele[j].c) != count.end()) { --count[ele[j].c]; used.insert(j); end = max(end,j); if (count[ele[j].c] == 0) count.erase(ele[j].c); } ++j; } if (!count.empty()) return res; res = s.substr(ele[i].pos, ele[j - 1].pos - ele[i].pos + 1); while (start \u0026lt; n) { char target = ele[start].c; used.erase(start); ++start; int k = start; while (k \u0026lt; n) { if (ele[k].c == target \u0026amp;\u0026amp; used.find(k) == used.end()) { used.insert(k); end = min(n - 1, max(end, k)); if (res.size() \u0026gt; ele[end].pos - ele[start].pos + 1) res = s.substr(ele[start].pos, ele[end].pos - ele[start].pos + 1); break; } ++k; } if (k == n) break; } return res; } }; 992 K ä¸ªä¸åŒæ•´æ•°çš„å­æ•°ç»„ ç”¨ä¸¤ä¸ªæŒ‡é’ˆ left å’Œ right ä¿è¯æ»‘åŠ¨çª—å£å†…å­æ•°ç»„ä¸­ä¸åŒçš„æ•´æ•°æœ‰ K ä¸ªï¼Œå½“æœ€å·¦è¾¹æ•°çš„è®¡æ•°å¤§äº 1 æ—¶ä»£è¡¨ç”± [left, right] ç»„æˆçš„æ•°ç»„å’Œ [left + 1, right] ç»„æˆçš„æ•°ç»„éƒ½æ˜¯ç¬¦åˆé¢˜æ„çš„å«æœ‰ K ä¸ªä¸åŒæ•´æ•°çš„å­æ•°ç»„ï¼Œå¹¶ä¸”å¦‚æœ [left + 1, right + 1] ä¹Ÿæ˜¯ç¬¦åˆé¢˜æ„çš„æ•°ç»„çš„è¯é‚£ä¹ˆ [left, right + 1] ä¹Ÿæ˜¯ç¬¦åˆé¢˜æ„çš„æ•°ç»„ï¼Œå› æ­¤ ++acc å¹¶ ++leftï¼Œå½“å“ˆå¸Œè¡¨çš„ size ç­‰äº K æ—¶å°†ç°åœ¨ acc åŠ åˆ°ç»“æœä¸Šå»å³å¯ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int subarraysWithKDistinct(vector\u0026lt;int\u0026gt; \u0026amp;A, int K) { unordered_map\u0026lt;int, int\u0026gt; count; int acc = 1, res = 0, left = 0; for (int right = 0; right \u0026lt; A.size(); ++right) { ++count[A[right]]; while (count.size() \u0026gt; K) { --count[A[left]]; if (count[A[left]] == 0) count.erase(A[left]); ++left; acc = 1; } while (count[A[left]] \u0026gt; 1) { --count[A[left]]; ++left; ++acc; } if (count.size() == K) res += acc; } return res; } }; 239 æ»‘åŠ¨çª—å£æœ€å¤§å€¼ ç”¨ä¸€ä¸ªç±»ä¼¼å•è°ƒæ ˆçš„åŒç«¯é˜Ÿåˆ—å­˜å‚¨æ»‘åŠ¨çª—å£ä¸­çš„å…ƒç´ ï¼Œå½“éœ€è¦ push_back è¿›æ¥çš„æ•°å¤§äºå…¶å‰é¢çš„æ•°æ—¶ï¼Œä¸æ–­çš„å°†å°äºå®ƒçš„æ•° pop_backï¼Œè¿™æ ·ä¸€æ¥åŒç«¯é˜Ÿåˆ—çš„ front ä½ç½®ä¸€å®šæ˜¯å½“å‰æ»‘åŠ¨çª—å£é‡Œæœ€å¤§çš„æ•°ï¼Œå½“æ»‘åŠ¨çª—å£ç§»åŠ¨æ—¶æœ€å·¦è¾¹çš„æ•°å¦‚æœç­‰äºåŒç«¯é˜Ÿåˆ—ä¸­ front ä½ç½®çš„æ•°æ—¶åˆ™ pop_frontï¼Œè¿™æ ·ä¸€æ¥ front ä½ç½®çš„æ•°ä»ç„¶æ˜¯å½“å‰æ»‘åŠ¨çª—å£é‡Œæœ€å¤§çš„æ•°ã€‚è¿™æ ·åšæ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { int n = nums.size(); deque\u0026lt;int\u0026gt; d; vector\u0026lt;int\u0026gt; res; if (n == 0) return res; for (int i = 0; i \u0026lt; k; ++i) { while (!d.empty() \u0026amp;\u0026amp; d.back() \u0026lt; nums[i]) d.pop_back(); d.push_back(nums[i]); } res.push_back(d.front()); for (int i = k; i \u0026lt; n; ++i) { if (!d.empty() \u0026amp;\u0026amp; nums[i - k] == d.front()) d.pop_front(); while (!d.empty() \u0026amp;\u0026amp; d.back() \u0026lt; nums[i]) d.pop_back(); d.push_back(nums[i]); res.push_back(d.front()); } return res; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/twopointers/","summary":"LeetCode DFS é¢˜ç›® 26 åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ ç”¨ä¸¤ä¸ªæŒ‡é’ˆ len å’Œ i åˆ†åˆ«è¡¨ç¤ºæ²¡æœ‰é‡å¤çš„é¡¹çš„ä¸‹æ ‡ä¸éå†æ•°ç»„çš„ä¸‹æ ‡ï¼Œå°†æ²¡æœ‰é‡å¤çš„é¡¹æ‹·è´åˆ° nums[len] ä¸‹ç„¶å ++len å³å¯ã€‚\nclass Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int count = 0, len = 1, n = nums.size(); if (n == 0) return 0; for (int i = 1; i \u0026lt; n; ++i) { if (nums[i] == nums[i - 1]) continue; nums[len] = nums[i]; ++len; } return len; } }; 80 åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ II ç”¨ä¸¤ä¸ªæŒ‡é’ˆ len å’Œ i åˆ†åˆ«è¡¨ç¤ºæ²¡æœ‰æœ€å¤šé‡å¤ 2 æ¬¡çš„é¡¹çš„ä¸‹æ ‡ä¸éå†æ•°ç»„çš„ä¸‹æ ‡ï¼Œå°†é‡å¤æ•°å°äºç­‰äº 1 çš„é¡¹æ‹·è´åˆ° nums[len] ä¸‹ç„¶å ++len å³å¯ã€‚","title":"LeetCode åŒæŒ‡é’ˆ"},{"content":"LeetCode DFS é¢˜ç›® 78 å­é›† å…¸å‹çš„å›æº¯ï¼Œæ‰¾å‡ºæ‰€æœ‰å¯èƒ½æƒ…å†µã€‚\nclass Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt; \u0026amp;nums) { res = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(1, vector\u0026lt;int\u0026gt;()); vector\u0026lt;int\u0026gt; curr; DFS(nums, 0, curr); return res; } void DFS(vector\u0026lt;int\u0026gt; \u0026amp;nums, int idx, vector\u0026lt;int\u0026gt; \u0026amp;curr) { for (int i = idx; i \u0026lt; nums.size(); ++i) { curr.push_back(nums[i]); res.push_back(curr); DFS(nums, i + 1, curr); curr.pop_back(); } } }; 733 å›¾åƒæ¸²æŸ“ ä»ç»™å®šçš„ image[sr][sc] å¼€å§‹ DFS æˆ– BFSï¼Œå°†ç›¸é‚»çš„å€¼ç›¸åŒçš„ç‚¹çš„å€¼å…¨éƒ¨ä¿®æ”¹ä¸º newColorï¼Œæ³¨æ„è¦åˆ¤æ–­ç»™å®šçš„ image[sr][sc] æ˜¯å¦ç­‰äº newColorï¼Œå¦åˆ™å¦‚æœä¸ä½¿ç”¨é¢å¤–ç©ºé—´çš„ visited æ•°ç»„è®°å½•å·²ç»è®¿é—®è¿‡çš„ç‚¹çš„è¯ä¼šé€ æˆæ­»å¾ªç¯æ ˆæº¢å‡ºã€‚\nclass Solution { int m, n; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; floodFill(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;image, int sr, int sc, int newColor) { m = image.size(), n = m ? image[0].size() : 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); if (image[sr][sc] != newColor) DFS(image, sr, sc, newColor); return image; } void DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;image, int r, int c, int val) { int ori = image[r][c]; image[r][c] = val; for (int d = 0; d \u0026lt; 4; ++d) { int i = r + dir[d][0]; int j = c + dir[d][1]; if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; image[i][j] == ori) DFS(image, i, j, val); } } }; 463 å²›å±¿çš„å‘¨é•¿ å¯¹å°å²›è¿›è¡Œ DFSï¼Œæ ¹æ®ä¸€ä¸ªç‚¹å‘¨å›´æœ‰å‡ ä¸ªç›¸é‚»çš„ç‚¹æ¥è®¡ç®—å½“å‰ç‚¹çš„å‘¨é•¿ã€‚\nclass Solution { int x, y, res; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int islandPerimeter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { x = grid.size(), y = x ? grid[0].size() : 0, res = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(x, vector\u0026lt;bool\u0026gt;(y, false)); if (x == 0) return 0; for (int i = 0; i \u0026lt; x; ++i) for (int j = 0; j \u0026lt; y; ++j) if (grid[i][j] == 1) { DFS(grid, i, j); return res; } return res; } void DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { visited[i][j] = true; int edge = 4; for (int l = 0; l \u0026lt; 4; ++l) { int a = i + dir[l][0]; int b = j + dir[l][1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; x \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; y \u0026amp;\u0026amp; grid[a][b] == 1) { --edge; if (!visited[a][b]) DFS(grid, a, b); } } res += edge; } }; 200 å²›å±¿æ•°é‡ æ¯æ¬¡è¿›è¡Œ DFS çš„å…¨éƒ¨èŠ‚ç‚¹å³ä¸ºä¸€ä¸ªå²›å±¿ï¼ŒDFS å®Œæ•´ä¸ªæ•°ç»„å³å¯ã€‚\nclass Solution { vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int x, y, res; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid) { x = grid.size(), y = x ? grid[0].size() : 0, res = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(x, vector\u0026lt;bool\u0026gt;(y, 0)); if (x == 0) return 0; for (int i = 0; i \u0026lt; x; ++i) for (int j = 0; j \u0026lt; y; ++j) if (grid[i][j] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; !visited[i][j]) { ++res; DFS(grid, i, j); } return res; } void DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { visited[i][j] = true; for (int d = 0; d \u0026lt; 4; ++d) { int a = i + dir[d][0]; int b = j + dir[d][1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; x \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; y \u0026amp;\u0026amp; grid[a][b] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; !visited[a][b]) DFS(grid, a, b); } } }; 695 å²›å±¿çš„æœ€å¤§é¢ç§¯ å¯¹æ¯ä¸ªå²›å±¿è¿›è¡Œ DFSï¼Œæ¯æ¬¡éƒ½æ›´æ–°æœ€å¤§é¢ç§¯å³å¯ã€‚\nclass Solution { vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int x, y, res; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int maxAreaOfIsland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { x = grid.size(), y = x ? grid[0].size() : 0, res = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(x, vector\u0026lt;bool\u0026gt;(y, 0)); if (x == 0) return 0; for (int i = 0; i \u0026lt; x; ++i) for (int j = 0; j \u0026lt; y; ++j) if (grid[i][j] == 1 \u0026amp;\u0026amp; !visited[i][j]) { int area = 1; DFS(grid, i, j, area); } return res; } void DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j, int \u0026amp;area) { visited[i][j] = true; res = max(res, area); for (int d = 0; d \u0026lt; 4; ++d) { int a = i + dir[d][0]; int b = j + dir[d][1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; x \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; y \u0026amp;\u0026amp; grid[a][b] == 1 \u0026amp;\u0026amp; !visited[a][b]) { ++area; DFS(grid, a, b, area); } } } }; 841 é’¥åŒ™å’Œæˆ¿é—´ å¯¹æ¯ä¸ªæˆ¿é—´è¿›è¡Œ DFSã€‚\nclass Solution { vector\u0026lt;bool\u0026gt; visited; int m, n; public: bool canVisitAllRooms(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;rooms) { m = n = rooms.size(); visited = vector\u0026lt;bool\u0026gt;(n, false); return DFS(rooms, 0); } bool DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;rooms, int room_num) { --m; visited[room_num] = true; if (m == 0) return true; for (auto \u0026amp;r:rooms[room_num]) if (!visited[r] \u0026amp;\u0026amp; DFS(rooms, r)) return true; return false; } }; 113 è·¯å¾„æ€»å’Œ II å¯¹æ•´ä¸ªæ ‘è¿›è¡Œ DFSï¼Œåœ¨å¶å­èŠ‚ç‚¹è¿›è¡Œåˆ¤æ–­ã€‚\nclass Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode *root, int sum) { res = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(); vector\u0026lt;int\u0026gt; path; DFS(root, sum, path); return res; } void DFS(TreeNode *root, int sum, vector\u0026lt;int\u0026gt; \u0026amp;path) { if (!root) return; path.push_back(root-\u0026gt;val); if (!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right) { if (sum - root-\u0026gt;val == 0) res.push_back(path); } else { DFS(root-\u0026gt;left, sum - root-\u0026gt;val, path); DFS(root-\u0026gt;right, sum - root-\u0026gt;val, path); } path.pop_back(); } }; 130 è¢«å›´ç»•çš„åŒºåŸŸ å¯¹æœ€å¤–å›´çš„æ‰€æœ‰ \u0026lsquo;O\u0026rsquo; è¿›è¡Œ DFS å¹¶è¿›è¡Œæ ‡è®°ï¼Œæœ€ååœ¨éå†ä¸€éæ•´ä¸ªçŸ©é˜µï¼Œå°†æ‰€æœ‰æœªè¢«æ ‡è®°çš„ \u0026lsquo;O\u0026rsquo; æ”¹ä¸º \u0026lsquo;X\u0026rsquo;ã€‚\nclass Solution { int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; int m, n; public: void solve(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board) { m = board.size(), n = m ? board[0].size() : 0; for (int i = 0; i \u0026lt; m; ++i) { if (board[i][0] == \u0026#39;O\u0026#39;) DFS(board, i, 0); if (board[i][n - 1] == \u0026#39;O\u0026#39;) DFS(board, i, n - 1); } for (int j = 1; j \u0026lt; n - 1; ++j) { if (board[0][j] == \u0026#39;O\u0026#39;) DFS(board, 0, j); if (board[m - 1][j] == \u0026#39;O\u0026#39;) DFS(board, m - 1, j); } for (auto \u0026amp;bo:board) for (auto \u0026amp;b:bo) b = (b == \u0026#39;O\u0026#39; ? \u0026#39;X\u0026#39; : (b == \u0026#39;M\u0026#39; ? \u0026#39;O\u0026#39; : b)); } void DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int x, int y) { board[x][y] = \u0026#39;M\u0026#39;; for (auto \u0026amp;d:dir) { int i = x + d[0], j = y + d[1]; if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; board[i][j] == \u0026#39;O\u0026#39;) DFS(board, i, j); } } }; 529 æ‰«é›·æ¸¸æˆ å…ˆè®¡ç®—å‡ºæ¯ä¸ªä½ç½®å‘¨å›´çš„ 8 ä¸ªä½ç½®çš„ç‚¸å¼¹çš„æ•°é‡ï¼Œå¦‚æœæ•°é‡å¤§äºç­‰äº 1ï¼Œé‚£ä¹ˆæ ‡è®°å‡ºæ¥å¹¶ä¸”ç»“æŸæœç´¢ï¼Œå¦‚æœæ•°é‡ä¸º 0ï¼Œé‚£ä¹ˆç»§ç»­å‘å‘¨å›´ 8 ä¸ªä½ç½®æœç´¢ã€‚\nclass Solution { int m, n; public: vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; updateBoard(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, vector\u0026lt;int\u0026gt; \u0026amp;click) { if (board[click[0]][click[1]] == \u0026#39;M\u0026#39;) { board[click[0]][click[1]] = \u0026#39;X\u0026#39;; return board; } m = board.size(), n = m ? board[0].size() : 0; DFS(board, click[0], click[1]); return board; } void DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int x, int y) { int b = 0; for (int i = x - 1; i \u0026lt;= x + 1; ++i) for (int j = y - 1; j \u0026lt;= y + 1; ++j) if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; board[i][j] == \u0026#39;M\u0026#39;) ++b; if (b != 0) { board[x][y] = static_cast\u0026lt;char\u0026gt;(b + \u0026#39;0\u0026#39;); return; } board[x][y] = \u0026#39;B\u0026#39;; for (int i = x - 1; i \u0026lt;= x + 1; ++i) for (int j = y - 1; j \u0026lt;= y + 1; ++j) if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; board[i][j] == \u0026#39;E\u0026#39;) DFS(board, i, j); } }; 473 ç«æŸ´æ‹¼æ­£æ–¹å½¢ å› ä¸ºè¦æ±‚ç”¨æ‰€æœ‰çš„ç«æŸ´æ¥æ‹¼æˆæ­£æ–¹å½¢ï¼Œæ‰€ä»¥å…ˆåˆ¤æ–­æ‰€æœ‰çš„ç«æŸ´ç»„æˆçš„æ˜¯å¦æ˜¯ 4 çš„å€æ•°ä»¥åŠæ˜¯å¦æœ‰æ•°å­—å¤§äº sum / 4 ï¼Œç„¶åå°†æ•°ç»„ä»å¤§åˆ°å°æ’åºï¼Œè¿™æ ·å¯ä»¥ç”¨è´ªå¿ƒçš„ç­–ç•¥å‡å°‘æœç´¢çš„æ¬¡æ•°ï¼Œå¦åˆ™éœ€è¦è¿›è¡Œå›æº¯ï¼Œæœ€åå¯¹æ•´ä¸ªæ•°ç»„è¿›è¡Œ DFSã€‚\nclass Solution { int match, n, sum; vector\u0026lt;bool\u0026gt; visited; public: bool makesquare(vector\u0026lt;int\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end(), [](int \u0026amp;a, int \u0026amp;b) { return a \u0026gt; b; }); sum = accumulate(nums.begin(), nums.end(), 0), n = nums.size(), match = 4; visited = vector\u0026lt;bool\u0026gt;(n, false); if (n == 0 || sum % 4 != 0) return false; for (auto \u0026amp;m:nums) if (m \u0026gt; sum / 4) return false; for (int i = 0; i \u0026lt; n; ++i) { if (!visited[i] \u0026amp;\u0026amp; DFS(nums, i, nums[i])) { visited[i] = true; --match; } } return match == 0; } bool DFS(vector\u0026lt;int\u0026gt; \u0026amp;nums, int m, int acc) { if (acc \u0026gt; sum / 4) return false; else if (acc == sum / 4) return true; for (int i = m + 1; i \u0026lt; n; ++i) if (!visited[i] \u0026amp;\u0026amp; DFS(nums, i, acc + nums[i])) { visited[i] = true; return true; } return false; } }; 980 ä¸åŒè·¯å¾„ III ç”¨ä¸€ä¸ªå˜é‡ zeros æŠŠçŸ©é˜µä¸­ 0 çš„æ•°é‡è®°å½•ä¸‹æ¥ï¼Œæ¯æ¬¡éå†åˆ° 0 å³ zeros - 1ï¼Œç›´åˆ° zeros == 0 ä¸”å½“å‰ç‚¹çš„å››ä¸ªæ–¹å‘ä¸Šæœ‰ç»ˆç‚¹ï¼Œé‚£ä¹ˆç»“æœ +1 å¹¶è¿”å›ï¼Œç»§ç»­ä¸‹ä¸€æ­¥çš„ DFSã€‚\nclass Solution { int m, n, zeros, res; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int uniquePathsIII(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { m = grid.size(), n = m ? grid[0].size() : 0, zeros = m * n - 2, res = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); int sr, sc, er, ec; for (int i = 0; i \u0026lt; m; ++i) for (int j = 0; j \u0026lt; n; ++j) if (grid[i][j] == 1) sr = i, sc = j; else if (grid[i][j] == -1) --zeros; DFS(grid, sr, sc, 0); return res; } void DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int r, int c, int count) { visited[r][c] = true; for (auto \u0026amp;d:dir) { int i = r + d[0], j = c + d[1]; if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n) { if (grid[i][j] == 2 \u0026amp;\u0026amp; count == zeros) { ++res; break; } if (grid[i][j] == 0 \u0026amp;\u0026amp; !visited[i][j]) DFS(grid, i, j, count + 1); } } visited[r][c] = false; } }; 37 è§£æ•°ç‹¬ å¯¹æ¯ä¸ª \u0026lsquo;.\u0026rsquo; æ ¼å­è¿›è¡Œä» \u0026lsquo;1\u0026rsquo; åˆ° \u0026lsquo;9\u0026rsquo; çš„å›æº¯ï¼Œåˆ¤æ–­å½“å‰è¡Œï¼Œåˆ—ï¼Œä»¥åŠ 3 * 3 çš„æ ¼å­ä¸­æ˜¯å¦æœ‰ç›¸åŒçš„å€¼ï¼Œç›´åˆ°åˆ°è¾¾çŸ©é˜µçš„æœ€åã€‚\nclass Solution { int m, n; public: void solveSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board) { m = board.size(), n = board[0].size(); DFS(board, 0, 0); } bool DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int i, int j) { if (j \u0026gt;= n) return DFS(board, i + 1, 0); else if (i \u0026gt;= m) return true; else if (board[i][j] != \u0026#39;.\u0026#39;) return DFS(board, i, j + 1); for (char c = \u0026#39;1\u0026#39;; c \u0026lt;= \u0026#39;9\u0026#39;; ++c) { if (CheckNum(board, i, j, c)) { board[i][j] = c; if (DFS(board, i, j + 1)) return true; board[i][j] = \u0026#39;.\u0026#39;; } } return false; } bool CheckNum(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, const int \u0026amp;i, const int \u0026amp;j, const char \u0026amp;c) { for (int k = 0; k \u0026lt; 9; ++k) if (board[k][j] == c || board[i][k] == c) return false; for (int a = 0; a \u0026lt; 3; ++a) for (int b = 0; b \u0026lt; 3; ++b) if (board[a + i / 3 * 3][b + j / 3 * 3] == c) return false; return true; } }; 79 å•è¯æœç´¢ åœ¨çŸ©é˜µé‡Œè¿›è¡Œä¸€æ¬¡ DFS å³å¯ã€‚\nclass Solution { int m, n; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; public: bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, string word) { m = board.size(), n = m ? board[0].size() : 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); for (int i = 0; i \u0026lt; m; ++i) for (int j = 0; j \u0026lt; n; ++j) if (board[i][j] == word[0] \u0026amp;\u0026amp; DFS(board, i, j, word.substr(1))) return true; return false; } bool DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int i, int j, string word) { if (word == \u0026#34;\u0026#34;) return true; visited[i][j] = true; for (auto \u0026amp;d:dir) { int a = i + d[0], b = j + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n \u0026amp;\u0026amp; board[a][b] == word[0] \u0026amp;\u0026amp; !visited[a][b] \u0026amp;\u0026amp; DFS(board, a, b, word.substr(1))) return true; } visited[i][j] = false; return false; } }; 212 å•è¯æœç´¢ II æœ€ç®€å•çš„æ–¹æ³•æ˜¯å¯¹æ¯ä¸€ä¸ªå•è¯åœ¨çŸ©é˜µé‡Œè¿›è¡Œä¸€æ¬¡ DFSï¼Œè¿™æ ·çš„è¯æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n * k * l)ï¼Œå…¶ä¸­ m æ˜¯çŸ©é˜µçš„é•¿ï¼Œn æ˜¯çŸ©é˜µçš„å®½ï¼Œlæ˜¯å•è¯çš„æ•°é‡ï¼Œk æ˜¯æ‰€æœ‰å•è¯çš„æœ€é•¿é•¿åº¦ã€‚æˆ‘ä»¬å¯ä»¥ä¸ºæ‰€æœ‰å•è¯å»ºç«‹ä¸€ä¸ªå­—å…¸æ ‘ï¼Œç„¶åå†åœ¨çŸ©é˜µé‡Œè¿›è¡Œä¸€æ¬¡ DFSï¼Œåœ¨çŸ©é˜µçš„æ¯ä¸ªç‚¹å¤„åˆ¤æ–­å½“å‰çš„å­—æ¯æ˜¯å¦åœ¨å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹çš„ next æ•°ç»„ä¸­ï¼Œå¦‚æœæ˜¯çš„è¯æœç´¢å…¶å‘¨å›´çš„å­—æ¯ä»¥åŠç»§ç»­éå†å­—å…¸æ ‘ï¼Œè¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n * k)ã€‚\nclass Solution { struct TrieNode { vector\u0026lt;TrieNode *\u0026gt; next; bool end; TrieNode() { next = vector\u0026lt;TrieNode *\u0026gt;(26, nullptr); end = false; } }; TrieNode *root; int m, n; unordered_set\u0026lt;string\u0026gt; res; vector\u0026lt;string\u0026gt; ret; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: vector\u0026lt;string\u0026gt; findWords(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, vector\u0026lt;string\u0026gt; \u0026amp;words) { res = unordered_set\u0026lt;string\u0026gt;(); m = board.size(), n = board[0].size(); visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); BuildTrie(words); for (int i = 0; i \u0026lt; m; ++i) for (int j = 0; j \u0026lt; n; ++j) if (root-\u0026gt;next[board[i][j] - \u0026#39;a\u0026#39;]) DFS(board, i, j, root-\u0026gt;next[board[i][j] - \u0026#39;a\u0026#39;], string(1, board[i][j])); ret = vector\u0026lt;string\u0026gt;(res.begin(), res.end()); return ret; } void BuildTrie(vector\u0026lt;string\u0026gt; \u0026amp;words) { root = new TrieNode(); TrieNode *node; for (auto \u0026amp;s:words) { node = root; for (auto c:s) { if (!node-\u0026gt;next[c - \u0026#39;a\u0026#39;]) node-\u0026gt;next[c - \u0026#39;a\u0026#39;] = new TrieNode(); node = node-\u0026gt;next[c - \u0026#39;a\u0026#39;]; } node-\u0026gt;end = true; } } void DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int i, int j, TrieNode *node, string word) { if (!node) return; if (node-\u0026gt;end) res.insert(word); visited[i][j] = true; for (auto \u0026amp;d:dir) { int a = i + d[0], b = j + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n \u0026amp;\u0026amp; node-\u0026gt;next[board[a][b] - \u0026#39;a\u0026#39;] \u0026amp;\u0026amp; !visited[a][b]) DFS(board, a, b, node-\u0026gt;next[board[a][b] - \u0026#39;a\u0026#39;], word + board[a][b]); } visited[i][j] = false; } }; 749 éš”ç¦»ç—…æ¯’ çŸ©é˜µä¼šæŒç»­åœ°å˜åŒ–ï¼Œæ¯ä¸€è½® DFS ç»“æŸåéœ€è¦è¿›è¡Œä¸¤ä¸ªæ“ä½œï¼Œä¸€æ˜¯å°†å·²ç»éš”ç¦»çš„ç—…æ¯’è¿›è¡Œæ ‡è®°ï¼ŒäºŒæ˜¯å°†æœªéš”ç¦»çš„ç—…æ¯’è¿›è¡Œæ„ŸæŸ“ï¼ˆå»¶ä¼¸ï¼‰ï¼Œå¯ä»¥å…ˆå°†æ‰€æœ‰çš„æœªéš”ç¦»çš„ç—…æ¯’å…ˆä¿å­˜ä¸‹æ¥å†ä¾æ¬¡è¿›è¡Œå»¶ä¼¸ï¼Œå†™èµ·æ¥æ¯”è¾ƒå¤æ‚ã€‚\nclass Solution { int m, n; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; public: int containVirus(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { m = grid.size(), n = m ? grid[0].size() : 0; int res = 0; bool exist = true; while (exist) { exist = false; int perimeter = 0, co_x = 0, co_y = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (grid[i][j] == 1 \u0026amp;\u0026amp; !visited[i][j]) { exist = true; int peri = CalcPeri(grid, i, j); if (peri \u0026gt; perimeter) { perimeter = peri; co_x = i, co_y = j; } } } } res += perimeter; if (exist) { Contain(grid, co_x, co_y); Infect(grid); } } return res; } int CalcPeri(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { int peri = 4, res = 0; visited[i][j] = true; for (auto \u0026amp;d:dir) { int a = i + d[0], b = j + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n) { if (grid[a][b] != 0) --peri; if (grid[a][b] == 1 \u0026amp;\u0026amp; !visited[a][b]) res += CalcPeri(grid, a, b); } else --peri; } return res + peri; } void Contain(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { grid[i][j] = 2; for (auto \u0026amp;d:dir) { int a = i + d[0], b = j + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n \u0026amp;\u0026amp; grid[a][b] == 1) Contain(grid, a, b); } } void Infect(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; infect; for (int i = 0; i \u0026lt; m; ++i) for (int j = 0; j \u0026lt; n; ++j) if (grid[i][j] == 1) infect.push_back(pair\u0026lt;int, int\u0026gt;(i, j)); for (auto \u0026amp;f:infect) { for (auto \u0026amp;d:dir) { int a = f.first + d[0], b = f.second + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n \u0026amp;\u0026amp; grid[a][b] == 0) grid[a][b] = 1; } } } }; 51 Nçš‡å å¾ˆç»å…¸çš„å›æº¯é—®é¢˜ï¼Œç”¨ DFS æœç´¢æ¯ä¸€ç§å¯èƒ½ç›´åˆ°æœç´¢å®Œæœ€åä¸€è¡Œï¼Œç”¨å½“å‰ä½ç½®çš„æ¨ªçºµåæ ‡çš„å’Œå’Œå·®åˆ†åˆ«åˆ¤æ–­ä¸¤ä¸ªå¯¹è§’çº¿ä¸Šæ˜¯å¦æœ‰çš‡åå³å¯ã€‚\nclass Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; string temp = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; ++i) temp += \u0026#34;.\u0026#34;; vector\u0026lt;string\u0026gt; board(n, temp); unordered_map\u0026lt;int, bool\u0026gt; left_diagonal, right_diagonal; vector\u0026lt;bool\u0026gt; row(n, false), col(n, false); for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { left_diagonal[i + j] = false; right_diagonal[i - j] = false; } } Backtrack(0, n, board, res, col, left_diagonal, right_diagonal); return res; } void Backtrack(int i, int \u0026amp;n, vector\u0026lt;string\u0026gt; \u0026amp;board, vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; \u0026amp;res, vector\u0026lt;bool\u0026gt; \u0026amp;col, unordered_map\u0026lt;int, bool\u0026gt; \u0026amp;left_diagonal, unordered_map\u0026lt;int, bool\u0026gt; \u0026amp;right_diagonal) { if (i == n) { res.push_back(board); return; } for (int j = 0; j \u0026lt; n; ++j) { if (!col[j] \u0026amp;\u0026amp; !left_diagonal[i + j] \u0026amp;\u0026amp; !right_diagonal[i - j]) { col[j] = true; left_diagonal[i + j] = true; right_diagonal[i - j] = true; board[i][j] = \u0026#39;Q\u0026#39;; Backtrack(i + 1, n, board, res, col, left_diagonal, right_diagonal); board[i][j] = \u0026#39;.\u0026#39;; col[j] = false; left_diagonal[i + j] = false; right_diagonal[i - j] = false; } } } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/dfs/","summary":"LeetCode DFS é¢˜ç›® 78 å­é›† å…¸å‹çš„å›æº¯ï¼Œæ‰¾å‡ºæ‰€æœ‰å¯èƒ½æƒ…å†µã€‚\nclass Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt; \u0026amp;nums) { res = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(1, vector\u0026lt;int\u0026gt;()); vector\u0026lt;int\u0026gt; curr; DFS(nums, 0, curr); return res; } void DFS(vector\u0026lt;int\u0026gt; \u0026amp;nums, int idx, vector\u0026lt;int\u0026gt; \u0026amp;curr) { for (int i = idx; i \u0026lt; nums.size(); ++i) { curr.push_back(nums[i]); res.push_back(curr); DFS(nums, i + 1, curr); curr.pop_back(); } } }; 733 å›¾åƒæ¸²æŸ“ ä»ç»™å®šçš„ image[sr][sc] å¼€å§‹ DFS æˆ– BFSï¼Œå°†ç›¸é‚»çš„å€¼ç›¸åŒçš„ç‚¹çš„å€¼å…¨éƒ¨ä¿®æ”¹ä¸º newColorï¼Œæ³¨æ„è¦åˆ¤æ–­ç»™å®šçš„ image[sr][sc] æ˜¯å¦ç­‰äº newColorï¼Œå¦åˆ™å¦‚æœä¸ä½¿ç”¨é¢å¤–ç©ºé—´çš„ visited æ•°ç»„è®°å½•å·²ç»è®¿é—®è¿‡çš„ç‚¹çš„è¯ä¼šé€ æˆæ­»å¾ªç¯æ ˆæº¢å‡ºã€‚","title":"LeetCode æ·±åº¦ä¼˜å…ˆæœç´¢"},{"content":"LeetCode å¹¶å‘ é¢˜ç›® 1114 æŒ‰åºæ‰“å° C++ mutex class Foo { mutex lock1, lock2; public: Foo() { lock1.lock(); lock2.lock(); } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); lock1.unlock(); } void second(function\u0026lt;void()\u0026gt; printSecond) { lock1.lock(); printSecond(); lock1.unlock(); lock2.unlock(); } void third(function\u0026lt;void()\u0026gt; printThird) { lock2.lock(); printThird(); lock2.unlock(); } }; C++ condition_variable class Foo { int i; mutex mut; condition_variable con_var1, con_var2; public: Foo() : i(1) { } void first(function\u0026lt;void()\u0026gt; printFirst) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); printFirst(); ++i; con_var1.notify_one(); } void second(function\u0026lt;void()\u0026gt; printSecond) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var1.wait(lock, [this]() { return i == 2; }); printSecond(); ++i; con_var2.notify_one(); } void third(function\u0026lt;void()\u0026gt; printThird) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var2.wait(lock, [this]() { return i == 3; }); printThird(); } }; C++ atomic class Foo { atomic_int i; public: Foo() : i(1) { } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); ++i; } void second(function\u0026lt;void()\u0026gt; printSecond) { while (i != 2) {} printSecond(); ++i; } void third(function\u0026lt;void()\u0026gt; printThird) { while (i != 3) {} printThird(); i = 1; } }; C++ promise class Foo { promise\u0026lt;void\u0026gt; pro1, pro2; public: Foo() { } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); pro1.set_value(); } void second(function\u0026lt;void()\u0026gt; printSecond) { pro1.get_future().wait(); printSecond(); pro2.set_value(); } void third(function\u0026lt;void()\u0026gt; printThird) { pro2.get_future().wait(); printThird(); } }; 1115 äº¤æ›¿æ‰“å°FooBar C++ mutex class FooBar { private: int n; mutex mut1, mut2; public: FooBar(int n) { this-\u0026gt;n = n; mut2.lock(); } void foo(function\u0026lt;void()\u0026gt; printFoo) { for (int i = 0; i \u0026lt; n; i++) { mut1.lock(); printFoo(); mut2.unlock(); } } void bar(function\u0026lt;void()\u0026gt; printBar) { for (int i = 0; i \u0026lt; n; i++) { mut2.lock(); printBar(); mut1.unlock(); } } }; C++ condition_variable class FooBar { private: int m, n; mutex mut; condition_variable con_var1, con_var2; public: FooBar(int n) : n(n), m(0) { } void foo(function\u0026lt;void()\u0026gt; printFoo) { for (int i = 0; i \u0026lt; n; i++) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var1.wait(lock, [\u0026amp;]() { return m == 0; }); printFoo(); ++m; con_var2.notify_one(); } } void bar(function\u0026lt;void()\u0026gt; printBar) { for (int i = 0; i \u0026lt; n; i++) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var2.wait(lock, [\u0026amp;]() { return m == 1; }); printBar(); m = 0; con_var1.notify_one(); } } }; C++ atomic class FooBar { private: int n; atomic_int m; public: FooBar(int n) : n(n), m(0) { } void foo(function\u0026lt;void()\u0026gt; printFoo) { for (int i = 0; i \u0026lt; n; i++) { while (m != 0) {} printFoo(); m = 1; } } void bar(function\u0026lt;void()\u0026gt; printBar) { for (int i = 0; i \u0026lt; n; i++) { while (m != 1) {} printBar(); m = 0; } } }; C++ promise class FooBar { private: int n; vector\u0026lt;promise\u0026lt;void\u0026gt;\u0026gt; pros1, pros2; public: FooBar(int n) : n(n) { for (int i = 0; i \u0026lt; n; ++i) { pros1.push_back(promise\u0026lt;void\u0026gt;()); pros2.push_back(promise\u0026lt;void\u0026gt;()); } } void foo(function\u0026lt;void()\u0026gt; printFoo) { for (int i = 0; i \u0026lt; n; i++) { if (i != 0) pros1[i - 1].get_future().wait(); printFoo(); pros2[i].set_value(); } } void bar(function\u0026lt;void()\u0026gt; printBar) { for (int i = 0; i \u0026lt; n; i++) { pros2[i].get_future().wait(); printBar(); pros1[i].set_value(); } } }; 1116 æ‰“å°é›¶ä¸å¥‡å¶æ•° C++ mutex class ZeroEvenOdd { private: int m, n; mutex mut_zero, mut_odd, mut_even; public: ZeroEvenOdd(int n) { this-\u0026gt;m = 1; this-\u0026gt;n = n; mut_odd.lock(); mut_even.lock(); } void zero(function\u0026lt;void(int)\u0026gt; printNumber) { for (int i = 0; i \u0026lt; n; ++i) { mut_zero.lock(); printNumber(0); if (this-\u0026gt;m % 2 == 1) mut_odd.unlock(); else mut_even.unlock(); } } void even(function\u0026lt;void(int)\u0026gt; printNumber) { for (int i = 0; i \u0026lt; n / 2; ++i) { mut_even.lock(); printNumber(this-\u0026gt;m); ++this-\u0026gt;m; mut_zero.unlock(); } } void odd(function\u0026lt;void(int)\u0026gt; printNumber) { for (int i = 0; i \u0026lt; (n + 1) / 2; ++i) { mut_odd.lock(); printNumber(this-\u0026gt;m); ++this-\u0026gt;m; mut_zero.unlock(); } } }; 1117 H2O ç”Ÿæˆ C++ condition variable class H2O { int m = 1; mutex mut; condition_variable con_var; public: void hydrogen(function\u0026lt;void()\u0026gt; releaseHydrogen) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var.wait(lock, [\u0026amp;]() { return m % 3 != 0; }); ++m; releaseHydrogen(); con_var.notify_all(); } void oxygen(function\u0026lt;void()\u0026gt; releaseOxygen) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var.wait(lock, [\u0026amp;]() { return m % 3 == 0; }); ++m; releaseOxygen(); con_var.notify_all(); } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/concurrency/","summary":"LeetCode å¹¶å‘ é¢˜ç›® 1114 æŒ‰åºæ‰“å° C++ mutex class Foo { mutex lock1, lock2; public: Foo() { lock1.lock(); lock2.lock(); } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); lock1.unlock(); } void second(function\u0026lt;void()\u0026gt; printSecond) { lock1.lock(); printSecond(); lock1.unlock(); lock2.unlock(); } void third(function\u0026lt;void()\u0026gt; printThird) { lock2.lock(); printThird(); lock2.unlock(); } }; C++ condition_variable class Foo { int i; mutex mut; condition_variable con_var1, con_var2; public: Foo() : i(1) { } void first(function\u0026lt;void()\u0026gt; printFirst) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); printFirst(); ++i; con_var1.","title":"LeetCode å¹¶å‘"},{"content":"LeetCode æ ‘ï¼ˆ2ï¼‰ é¢˜ç›® 3. äºŒå‰æœç´¢æ ‘ 95 ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II ç”Ÿæˆç”± 1 \u0026hellip; n ä¸ºèŠ‚ç‚¹æ‰€ç»„æˆçš„äºŒå‰æœç´¢æ ‘ã€‚\nä¸ºäº†æ„é€ ä»¥ i ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æœç´¢æ ‘ï¼Œæˆ‘ä»¬éœ€è¦å…ˆæ„é€ ä»¥ 1 \u0026hellip; i - 1 ä¸ºå·¦å­æ ‘çš„æ‰€æœ‰äºŒå‰æœç´¢æ ‘ä¸ä»¥ i + 1 \u0026hellip; n ä¸ºå³å­æ ‘çš„æ‰€æœ‰äºŒå‰æœç´¢æ ‘ï¼Œå†å°†è¿™äº›å­æ ‘æ’åˆ—ç»„åˆå¾—åˆ°ä»¥ i ä¸ºæ ¹èŠ‚ç‚¹çš„æ‰€æœ‰äºŒå‰æœç´¢æ ‘ã€‚\nclass Solution { public: vector\u0026lt;TreeNode *\u0026gt; generateTrees(int n) { if (n == 0) return {}; return Generate(1, n); } vector\u0026lt;TreeNode *\u0026gt; Generate(int m, int n) { vector\u0026lt;TreeNode *\u0026gt; nodes; if (m == n) nodes.push_back(new TreeNode(n)); if (m \u0026gt; n) nodes.push_back(nullptr); if (m \u0026gt;= n) return nodes; for (int i = m; i \u0026lt;= n; ++i) { vector\u0026lt;TreeNode *\u0026gt; left = Generate(m, i - 1); vector\u0026lt;TreeNode *\u0026gt; right = Generate(i + 1, n); for (auto \u0026amp;l:left) for (auto \u0026amp;r:right) { TreeNode *node = new TreeNode(i); node-\u0026gt;left = l, node-\u0026gt;right = r; nodes.push_back(node); } } return nodes; } }; 98 éªŒè¯äºŒå‰æœç´¢æ ‘ å› ä¸ºäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ç»“æœæ˜¯ä¸€ä¸ªæœ‰åºæ•°ç»„ï¼Œæ‰€ä»¥ä¸€ç§æ–¹æ³•æ˜¯å°†ä¸­åºéå†çš„ç»“æœä¿å­˜ä¸‹æ¥è¿›è¡Œåˆ¤æ–­ï¼Œä¹Ÿå¯ä»¥æ ¹æ®äºŒå‰æœç´¢æ ‘çš„å®šä¹‰åˆ¤æ–­å­èŠ‚ç‚¹å’Œæ ¹èŠ‚ç‚¹çš„å¤§å°å…³ç³»ã€‚\nclass Solution { public: bool isValidBST(TreeNode *root) { return IsValidSubtree(root, nullptr, nullptr); } bool IsValidSubtree(TreeNode *node, const int *min_val, const int *max_val) { if (!node) return true; if ((min_val \u0026amp;\u0026amp; *min_val \u0026gt;= node-\u0026gt;val) || (max_val \u0026amp;\u0026amp; *max_val \u0026lt;= node-\u0026gt;val)) return false; return IsValidSubtree(node-\u0026gt;left, min_val, \u0026amp;(node-\u0026gt;val)) \u0026amp;\u0026amp; IsValidSubtree(node-\u0026gt;right, \u0026amp;(node-\u0026gt;val), max_val); } }; 108 å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘ ç»™ä¸€ä¸ªæœ‰åºæ•°ç»„ï¼Œå°†å…¶è½¬æ¢ä¸ºä¸€æ£µå¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚\näºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ç»“æœå³ä¸ºæœ‰åºæ•°ç»„ï¼Œæ‰€ä»¥åªéœ€è¦æ¯æ¬¡æ‰¾åˆ°ä¸­é—´çš„å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œå·¦è¾¹çš„å­æ•°ç»„ä½œä¸ºå·¦å­æ ‘ï¼Œå³è¾¹çš„å­æ•°ç»„ä½œä¸ºå³å­æ ‘ï¼Œé€’å½’æ„é€ å³å¯ã€‚\nclass Solution { public: TreeNode *sortedArrayToBST(vector\u0026lt;int\u0026gt; \u0026amp;nums) { return Build(nums, 0, nums.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;nums, int x, int y) { if (x \u0026gt;= y) return nullptr; int pos = x + (y - x) / 2; TreeNode *node = new TreeNode(nums[pos]); node-\u0026gt;left = Build(nums, x, pos); node-\u0026gt;right = Build(nums, pos + 1, y); return node; } }; 235 äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ æ‰¾åˆ°ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚\nç”±äºŒå‰æœç´¢æ ‘å¯çŸ¥ï¼Œå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¤§äºæ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä»–ä»¬éƒ½åº”è¯¥åœ¨æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ä¸Šï¼›å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å°äºæ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä»–ä»¬éƒ½åº”è¯¥åœ¨æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸Šï¼›å¦åˆ™ä»–ä»¬å¯èƒ½åœ¨æ ¹èŠ‚ç‚¹åŠå…¶å­æ ‘ä¸Šçš„ä»»æ„ä½ç½®ï¼Œé‚£ä¹ˆæ ¹èŠ‚ç‚¹å³æ˜¯ä»–ä»¬çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚\nclass Solution { public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) { if (!root) return nullptr; else if (root-\u0026gt;val \u0026gt; p-\u0026gt;val \u0026amp;\u0026amp; root-\u0026gt;val \u0026gt; q-\u0026gt;val) return lowestCommonAncestor(root-\u0026gt;left, p, q); else if (root-\u0026gt;val \u0026lt; p-\u0026gt;val \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt; q-\u0026gt;val) return lowestCommonAncestor(root-\u0026gt;right, p, q); return root; } }; 671 äºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹ ç»™ä¸€ä¸ªäºŒå‰æ ‘ï¼Œå…¶å­èŠ‚ç‚¹æ•°é‡åªä¸º 0 æˆ– 2ï¼Œå¹¶ä¸”æ ¹èŠ‚ç‚¹çš„å€¼ä¸€å®šå°äºç­‰äºå­èŠ‚ç‚¹çš„å€¼ï¼Œæ‰¾åˆ°æ‰€æœ‰èŠ‚ç‚¹ä¸­çš„ç¬¬äºŒå°çš„å€¼ã€‚\nå› ä¸ºäºŒå‰æ ‘ä¸Šæ ¹èŠ‚ç‚¹ä¸€å®šå°äºç­‰äºå­èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ•´ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ä¸€å®šæ˜¯æœ€å°å€¼ï¼Œåªéœ€è¦éå†æ•´ä¸ªæ ‘ï¼Œæ‰¾åˆ°é™¤æ ¹èŠ‚ç‚¹ä¹‹å¤–çš„æœ€å°å€¼å³å¯ã€‚\nclass Solution { public: int findSecondMinimumValue(TreeNode *root) { if (!root) return -1; int first = root-\u0026gt;val, *res = nullptr; queue\u0026lt;TreeNode *\u0026gt; q; q.push(root); while (!q.empty()) { TreeNode *node = q.front(); q.pop(); if (first \u0026lt; node-\u0026gt;val) if (!res) res = new int(node-\u0026gt;val); else *res = min(*res, node-\u0026gt;val); if (node-\u0026gt;left \u0026amp;\u0026amp; node-\u0026gt;right) q.push(node-\u0026gt;left), q.push(node-\u0026gt;right); } return res ? *res : -1; } }; 230 äºŒå‰æœç´¢æ ‘ä¸­ç¬¬ K å°çš„å…ƒç´  æ‰¾åˆ°ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ä¸­ç¬¬ k å°çš„å…ƒç´ ã€‚\nå› ä¸ºäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ç»“æœæ˜¯æœ‰åºçš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸­åºéå†å¹¶åœ¨æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ æ—¶æå‰ç»ˆæ­¢å¹¶è¿”å›ç»“æœã€‚\nclass Solution { int res; public: int kthSmallest(TreeNode *root, int k) { res = 0; Inorder(root, k); return res; } void Inorder(TreeNode *root, int \u0026amp;k) { if (!root) return; Inorder(root-\u0026gt;left, k); if (k \u0026lt;= 0) return; --k; if (k == 0) { res = root-\u0026gt;val; return; } Inorder(root-\u0026gt;right, k); } }; 450 åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹ ç»™ä¸€ä¸ªäºŒå‰æœç´¢æ ‘å’Œä¸€ä¸ªå€¼ï¼Œåˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„å¯¹åº”èŠ‚ç‚¹ã€‚\næ ¹æ®äºŒå‰æœç´ æ ‘çš„å®šä¹‰ï¼Œå¾ˆå®¹æ˜“é€šè¿‡å¤§å°å…³ç³»æ‰¾åˆ°å¯¹åº”èŠ‚ç‚¹ï¼Œæ‰¾åˆ°ä¹‹ååªéœ€è¦å°†åŸå…ˆçš„èŠ‚ç‚¹æ›¿æ¢ä¸ºå·¦å­æ ‘ä¸Šçš„æœ€å¤§èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯å·¦å­èŠ‚ç‚¹çš„æœ€å³å­èŠ‚ç‚¹å³å¯ï¼Œæ³¨æ„è¦å°†å·¦å­èŠ‚ç‚¹çš„æœ€å³å­èŠ‚ç‚¹çš„å·¦å­æ ‘æ¥åˆ°å…¶çˆ¶èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ä¸Šã€‚\nclass Solution { public: TreeNode *deleteNode(TreeNode *root, int key) { if (!root) return nullptr; if (root-\u0026gt;val == key) { if (!root-\u0026gt;left) return root-\u0026gt;right; auto node = root-\u0026gt;left, head = node; if (!node-\u0026gt;right) { node-\u0026gt;right = root-\u0026gt;right; return node; } while (node-\u0026gt;right) head = node, node = node-\u0026gt;right; head-\u0026gt;right = node-\u0026gt;left; node-\u0026gt;left = root-\u0026gt;left, node-\u0026gt;right = root-\u0026gt;right; return node; } else if (root-\u0026gt;val \u0026lt; key) root-\u0026gt;right = deleteNode(root-\u0026gt;right, key); else if (root-\u0026gt;val \u0026gt; key) root-\u0026gt;left = deleteNode(root-\u0026gt;left, key); return root; } }; 669 ä¿®å‰ªäºŒå‰æœç´¢æ ‘ ç»™ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼Œä»¥åŠæœ€å°è¾¹ç•Œ L å’Œæœ€å¤§è¾¹ç•Œ Rï¼Œä¿®å‰ªäºŒå‰æœç´¢æ ‘ä½¿å¾—æ‰€æœ‰èŠ‚ç‚¹å€¼éƒ½åœ¨ [L, R] çš„èŒƒå›´å†…ã€‚\nå¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„å€¼åœ¨èŒƒå›´å¤–ï¼Œæ ¹æ®äºŒå‰æœç´¢æ ‘çš„å®šä¹‰ï¼Œè¿”å›å¯¹åº”æ–¹å‘çš„èŠ‚ç‚¹ä¿®å‰ªåçš„ç»“æœå³å¯ï¼›å¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„å€¼åœ¨èŒƒå›´å†…ï¼Œå¯¹å…¶å·¦å³å­æ ‘åˆ†åˆ«è¿›è¡Œä¿®å»ºå³å¯ã€‚\nclass Solution { public: TreeNode *trimBST(TreeNode *root, const int \u0026amp;L, const int \u0026amp;R) { if (!root) return nullptr; if (root-\u0026gt;val \u0026lt; L) return trimBST(root-\u0026gt;right, L, R); if (root-\u0026gt;val \u0026gt; R) return trimBST(root-\u0026gt;left, L, R); root-\u0026gt;left = trimBST(root-\u0026gt;left, L, R); root-\u0026gt;right = trimBST(root-\u0026gt;right, L, R); return root; } }; 530 äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·® æ±‚ä¸€ä¸ªäºŒå‰æœç´¢æ ‘æ ‘ä¸­ä»»æ„ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼ã€‚\nå› ä¸ºäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ç»“æœæ˜¯æœ‰åºçš„ï¼Œä»»æ„ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼ä¸€å®šäº§ç”Ÿåœ¨ç›¸é‚»çš„ä¸¤ä¸ªå€¼ä¹‹é—´ï¼Œå› æ­¤åšä¸€æ¬¡ä¸­åºéå†ï¼ŒåŒæ—¶æ›´æ–°ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼å³å¯ã€‚\nclass Solution { TreeNode *node; int res; public: int getMinimumDifference(TreeNode *root) { node = nullptr; res = INT_MAX; Inorder(root); return res; }\nvoid Inorder(TreeNode *root) {\rif (!root)\rreturn;\rInorder(root-\u0026gt;left);\rif (!node)\rnode = root;\relse\rres = min(res, abs(node-\u0026gt;val - root-\u0026gt;val));\rnode = root;\rInorder(root-\u0026gt;right);\r}\r };\n783 äºŒå‰æœç´¢æ ‘ç»“ç‚¹æœ€å°è·ç¦» æ±‚ä¸€ä¸ªäºŒå‰æœç´¢æ ‘æ ‘ä¸­ä»»æ„ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼ã€‚\nåŒä¸Šã€‚\nclass Solution { TreeNode *node; int res; public: int minDiffInBST(TreeNode *root) { node = nullptr; res = INT_MAX; Inorder(root); return res; }\nvoid Inorder(TreeNode *root) {\rif (!root)\rreturn;\rInorder(root-\u0026gt;left);\rif (!node)\rnode = root;\relse\rres = min(res, abs(node-\u0026gt;val - root-\u0026gt;val));\rnode = root;\rInorder(root-\u0026gt;right);\r}\r };\n501 äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•° æ‰¾å‡ºä¸€ä¸ªäºŒå‰æœç´¢æ ‘ä¸­çš„æ‰€æœ‰ä¼—æ•°ã€‚\nå› ä¸ºäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ç»“æœæ˜¯æœ‰åºçš„ï¼Œå¯ä»¥ç›´æ¥è¿›è¡Œä¸€æ¬¡ä¸­åºéå†ï¼ŒåŒæ—¶æ›´æ–°ç»“æœæ•°ç»„ã€‚\nclass Solution { vector\u0026lt;int\u0026gt; res; TreeNode *node; int n, m; public: vector\u0026lt;int\u0026gt; findMode(TreeNode *root) { res = vector\u0026lt;int\u0026gt;(); node = nullptr; n = m = 0; Inorder(root); return res; } void Inorder(TreeNode *root) { if (!root) return; Inorder(root-\u0026gt;left); if (!node || node-\u0026gt;val != root-\u0026gt;val) m = 1; else ++m; node = root; if (m \u0026gt; n) { n = m; res.clear(); } if (m == n) res.push_back(node-\u0026gt;val); Inorder(root-\u0026gt;right); } }; 538 æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘ æŠŠä¸€ä¸ªäºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸ºç´¯åŠ æ ‘ã€‚\næŒ‰ç…§äºŒå‰æœç´¢æ ‘çš„å®šä¹‰ï¼Œæ¯ä¸ªèŠ‚ç‚¹å€¼ä¸€å®šæ¯”å³å­æ ‘ä¸Šçš„èŠ‚ç‚¹å€¼å°ï¼Œæ‰€ä»¥æŒ‰ç…§å³ä¸­å·¦çš„é¡ºåºéå†æ•´ä¸ªæ ‘ï¼ŒåŒæ—¶åœ¨æ ¹èŠ‚ç‚¹å¤„åŠ ä¸Šå³è¾¹çš„ç´¯ç§¯å€¼ã€‚\nclass Solution { int val; public: TreeNode *convertBST(TreeNode *root) { val = 0; Accumulate(root); return root; } void Accumulate(TreeNode *root) { if (!root) return; Accumulate(root-\u0026gt;right); root-\u0026gt;val += val; val = root-\u0026gt;val; Accumulate(root-\u0026gt;left); } }; 700 äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢ åœ¨äºŒå‰æœç´¢æ ‘ä¸­æœç´¢ä¸€ä¸ªç‰¹å®šå€¼ã€‚\næŒ‰ç…§äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§æœç´¢å³å¯ã€‚\nclass Solution { public: TreeNode *searchBST(TreeNode *root, const int \u0026amp;val) { if (!root) return nullptr; if (root-\u0026gt;val \u0026lt; val) return searchBST(root-\u0026gt;right, val); else if (root-\u0026gt;val \u0026gt; val) return searchBST(root-\u0026gt;left, val); else return root; } }; 701 äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ åœ¨ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ä¸­æ’å…¥ä¸€ä¸ªå€¼ã€‚\næŒ‰ç…§ç»™å®šå€¼ä¸èŠ‚ç‚¹çš„å€¼çš„å¤§å°å…³ç³»ä¾æ¬¡å¾€ä¸‹æœç´¢ç›´åˆ°æ‰¾åˆ°ç©ºèŠ‚ç‚¹ï¼Œæ–°å»ºä¸€ä¸ªèŠ‚ç‚¹å¹¶è¿”å›å³å¯ã€‚\nclass Solution { public: TreeNode *insertIntoBST(TreeNode *root, const int \u0026amp;val) { if (!root) return new TreeNode(val); else if (val \u0026lt; root-\u0026gt;val) root-\u0026gt;left = insertIntoBST(root-\u0026gt;left, val); else if (val \u0026gt; root-\u0026gt;val) root-\u0026gt;right = insertIntoBST(root-\u0026gt;right, val); return root; } }; 938 äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œ ç»™ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼Œè®¡ç®— L å’Œ R ä¹‹é—´çš„æ‰€æœ‰ç»“ç‚¹çš„å€¼çš„å’Œã€‚\nåˆ¤æ–­æ ¹èŠ‚ç‚¹çš„å€¼ L \u0026lt;= val \u0026lt;= R å³å¯ã€‚\nclass Solution { public: int rangeSumBST(TreeNode* root, const int \u0026amp;L, const int \u0026amp;R) { if (!root) return 0; int left = 0, right = 0; if (root-\u0026gt;val \u0026gt;= L) left = rangeSumBST(root-\u0026gt;left, L, R); if (root-\u0026gt;val \u0026lt;= R) right = rangeSumBST(root-\u0026gt;right, L, R); return left + right + (root-\u0026gt;val \u0026gt;= L \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= R ? root-\u0026gt;val : 0); } }; 99 æ¢å¤äºŒå‰æœç´¢æ ‘ æ¢å¤ä¸€ä¸ªæœ‰ä¸¤ä¸ªèŠ‚ç‚¹è¢«é”™è¯¯åœ°äº¤æ¢çš„äºŒå‰æœç´¢æ ‘ã€‚\nå› ä¸ºåªæœ‰ä¸¤ä¸ªèŠ‚ç‚¹è¢«é”™è¯¯åœ°äº¤æ¢ï¼Œåªéœ€è¦åšä¸€æ¬¡ä¸­åºéå†å°±èƒ½ä»ç›¸é‚»èŠ‚ç‚¹çš„å¤§å°å…³ç³»æ‰¾åˆ°è¿™ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå°†ç¬¬ä¸€æ¬¡å‡ºç°é”™è¯¯ä½ç½®å…³ç³»çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ä¸ç¬¬äºŒæ¬¡å‡ºç°é”™è¯¯ä½ç½®å…³ç³»çš„åä¸€ä¸ªèŠ‚ç‚¹äº¤æ¢å³å¯ã€‚\nclass Solution { TreeNode *first, *second, *prev; public: void recoverTree(TreeNode *root) { first = second = prev = nullptr; Inorder(root); swap(first-\u0026gt;val, second-\u0026gt;val); } void Inorder(TreeNode *root) { if (!root) return; Inorder(root-\u0026gt;left); if (prev \u0026amp;\u0026amp; prev-\u0026gt;val \u0026gt;= root-\u0026gt;val \u0026amp;\u0026amp; !first) first = prev; if (prev \u0026amp;\u0026amp; prev-\u0026gt;val \u0026gt;= root-\u0026gt;val \u0026amp;\u0026amp; first) second = root; prev = root; Inorder(root-\u0026gt;right); } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/tree-2/","summary":"LeetCode æ ‘ï¼ˆ2ï¼‰ é¢˜ç›® 3. äºŒå‰æœç´¢æ ‘ 95 ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II ç”Ÿæˆç”± 1 \u0026hellip; n ä¸ºèŠ‚ç‚¹æ‰€ç»„æˆçš„äºŒå‰æœç´¢æ ‘ã€‚\nä¸ºäº†æ„é€ ä»¥ i ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æœç´¢æ ‘ï¼Œæˆ‘ä»¬éœ€è¦å…ˆæ„é€ ä»¥ 1 \u0026hellip; i - 1 ä¸ºå·¦å­æ ‘çš„æ‰€æœ‰äºŒå‰æœç´¢æ ‘ä¸ä»¥ i + 1 \u0026hellip; n ä¸ºå³å­æ ‘çš„æ‰€æœ‰äºŒå‰æœç´¢æ ‘ï¼Œå†å°†è¿™äº›å­æ ‘æ’åˆ—ç»„åˆå¾—åˆ°ä»¥ i ä¸ºæ ¹èŠ‚ç‚¹çš„æ‰€æœ‰äºŒå‰æœç´¢æ ‘ã€‚\nclass Solution { public: vector\u0026lt;TreeNode *\u0026gt; generateTrees(int n) { if (n == 0) return {}; return Generate(1, n); } vector\u0026lt;TreeNode *\u0026gt; Generate(int m, int n) { vector\u0026lt;TreeNode *\u0026gt; nodes; if (m == n) nodes.push_back(new TreeNode(n)); if (m \u0026gt; n) nodes.push_back(nullptr); if (m \u0026gt;= n) return nodes; for (int i = m; i \u0026lt;= n; ++i) { vector\u0026lt;TreeNode *\u0026gt; left = Generate(m, i - 1); vector\u0026lt;TreeNode *\u0026gt; right = Generate(i + 1, n); for (auto \u0026amp;l:left) for (auto \u0026amp;r:right) { TreeNode *node = new TreeNode(i); node-\u0026gt;left = l, node-\u0026gt;right = r; nodes.","title":"LeetCode æ ‘ï¼ˆ2ï¼‰"},{"content":"LeetCode æ ‘ï¼ˆ1ï¼‰ é¢˜ç›® 1. æ ‘çš„éå† 144 äºŒå‰æ ‘çš„å‰åºéå† å‰åºéå†ä¸€ä¸ªäºŒå‰æ ‘ã€‚\nå‰åºéå†æ˜¯æŒ‰ç…§æ ¹èŠ‚ç‚¹ï¼Œå·¦å­èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹çš„é¡ºåºæ¥éå†ä¸€ä¸ªäºŒå‰æ ‘ï¼Œæœ‰é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•ã€‚å¯¹äºè¿­ä»£æ–¹æ³•ï¼Œå…ˆå°†èŠ‚ç‚¹åŠ å…¥ç»“æœæ•°ç»„ï¼Œç„¶åç”¨ä¸€ä¸ªæ ˆä¿å­˜å³ï¼Œå·¦å­èŠ‚ç‚¹ï¼Œä¾æ¬¡è®¿é—®ï¼Œé‡å¤æ­¤è¿‡ç¨‹ã€‚\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) { res = vector\u0026lt;int\u0026gt;(); Preorder(root); return res; } void Preorder(TreeNode *root) { if (!root) return; res.push_back(root-\u0026gt;val); Preorder(root-\u0026gt;left); Preorder(root-\u0026gt;right); } }; class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;TreeNode *\u0026gt; pre; pre.push(root); while (!pre.empty()) { TreeNode *node = pre.top(); pre.pop(); res.push_back(node-\u0026gt;val); if (node-\u0026gt;right) pre.push(node-\u0026gt;right); if (node-\u0026gt;left) pre.push(node-\u0026gt;left); } return res; } }; 589 Nå‰æ ‘çš„å‰åºéå† å‰åºéå†ä¸€ä¸ª N å‰æ ‘ã€‚\nè·ŸäºŒå‰æ ‘çš„å‰åºéå†ç±»ä¼¼ï¼Œæœ‰é€’å½’å’Œè¿­ä»£ä¸¤ç§åšæ³•ã€‚\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; preorder(Node *root) { res = vector\u0026lt;int\u0026gt;(); Preorder(root); return res; } void Preorder(Node *root) { if (!root) return; res.push_back(root-\u0026gt;val); for (auto \u0026amp;c:root-\u0026gt;children) Preorder(c); } }; class Solution { public: vector\u0026lt;int\u0026gt; preorder(Node *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;Node *\u0026gt; pre; pre.push(root); while (!pre.empty()) { Node *node = pre.top(); pre.pop(); res.push_back(node-\u0026gt;val); for (auto iter = node-\u0026gt;children.rbegin(); iter \u0026lt; node-\u0026gt;children.rend(); ++iter) pre.push(*iter); } return res; } }; 94 äºŒå‰æ ‘çš„ä¸­åºéå† ä¸­åºéå†ä¸€ä¸ªäºŒå‰æ ‘ã€‚\nä¸­åºéå†æ˜¯æŒ‰ç…§å·¦å­èŠ‚ç‚¹ï¼Œæ ¹èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹çš„é¡ºåºæ¥éå†ä¸€ä¸ªäºŒå‰æ ‘ï¼Œæœ‰é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•ã€‚å¯¹äºè¿­ä»£æ–¹æ³•ï¼Œç”¨ä¸€ä¸ªæ ˆä¿å­˜çˆ¶èŠ‚ç‚¹ä»¥ä¾¿æœ€åè®¿é—®ï¼Œå…ˆæ‰¾åˆ°æœ€å·¦èŠ‚ç‚¹ï¼Œå°†å…¶åŠ å…¥ç»“æœæ•°ç»„ï¼Œç„¶åè®¿é—®å…¶å³å­èŠ‚ç‚¹ï¼Œé‡å¤æ­¤è¿‡ç¨‹ã€‚\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { res = vector\u0026lt;int\u0026gt;(); Inorder(root); return res; } void Inorder(TreeNode *root) { if (!root) return; Inorder(root-\u0026gt;left); res.push_back(root-\u0026gt;val); Inorder(root-\u0026gt;right); } }; class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;TreeNode *\u0026gt; in; TreeNode *node = root; while (node || !in.empty()) { while (node) { in.push(node); node = node-\u0026gt;left; } if (!in.empty()) { node = in.top(); in.pop(); res.push_back(node-\u0026gt;val); node = node-\u0026gt;right; } } return res; } }; 145 äºŒå‰æ ‘çš„ååºéå† ååºéå†ä¸€ä¸ªäºŒå‰æ ‘ã€‚\nååºéå†æ˜¯æŒ‰ç…§å·¦å­èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹ï¼Œæ ¹èŠ‚ç‚¹çš„é¡ºåºæ¥éå†ä¸€ä¸ªäºŒå‰æ ‘ï¼Œæœ‰é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•ã€‚å¯¹äºè¿­ä»£æ–¹æ³•ï¼Œç”¨ä¸€ä¸ªæ ˆä¿å­˜çˆ¶èŠ‚ç‚¹ä»¥ä¾¿æœ€åè®¿é—®ï¼Œå…ˆæ‰¾åˆ°æœ€å·¦èŠ‚ç‚¹ï¼Œå¦‚æœå…¶å·²ç»æ˜¯å¶å­èŠ‚ç‚¹åˆ™å°†å…¶åŠ å…¥ç»“æœæ•°ç»„ï¼Œå¦åˆ™è®¿é—®å…¶å³å­èŠ‚ç‚¹ï¼Œç”¨ last ä¿å­˜ä¸Šä¸€æ¬¡è®¿é—®è¿‡çš„å³å­èŠ‚ç‚¹é˜²æ­¢å†æ¬¡è®¿é—®ï¼Œé‡å¤æ­¤è¿‡ç¨‹ã€‚\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { res = vector\u0026lt;int\u0026gt;(); Postorder(root); return res; } void Postorder(TreeNode *root) { if (!root) return; Postorder(root-\u0026gt;left); Postorder(root-\u0026gt;right); res.push_back(root-\u0026gt;val); } }; class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;TreeNode *\u0026gt; post; TreeNode *node = root, *last = nullptr; while (node || !post.empty()) { while (node) { post.push(node); node = node-\u0026gt;left; } if (!post.empty()) { node = post.top(); if (node-\u0026gt;right \u0026amp;\u0026amp; node-\u0026gt;right != last) node = node-\u0026gt;right; else { res.push_back(node-\u0026gt;val); post.pop(); last = node; node = nullptr; } } } return res; } }; 590 Nå‰æ ‘çš„ååºéå† è·ŸäºŒå‰æ ‘çš„ååºéå†ç±»ä¼¼ï¼Œæœ‰é€’å½’å’Œè¿­ä»£ä¸¤ç§åšæ³•ã€‚\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; postorder(Node *root) { res = vector\u0026lt;int\u0026gt;(); Postorder(root); return res; } void Postorder(Node *root) { if (!root) return; for (auto \u0026amp;c:root-\u0026gt;children) Postorder(c); res.push_back(root-\u0026gt;val); } }; class Solution { public: vector\u0026lt;int\u0026gt; postorder(Node *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;Node *\u0026gt; post; post.push(root); while (!post.empty()) { Node *node = post.top(); post.pop(); res.push_back(node-\u0026gt;val); for (auto \u0026amp;c:node-\u0026gt;children) post.push(c); } reverse(res.begin(), res.end()); return res; } }; 102 äºŒå‰æ ‘çš„å±‚æ¬¡éå† ç»™ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶æŒ‰å±‚æ¬¡éå†çš„èŠ‚ç‚¹å€¼ã€‚\nç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥ä¿å­˜è¯¥äºŒå‰æ ‘å½“å‰ä¸€å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¸€è¾¹å°†è¿™äº›èŠ‚ç‚¹ pop å¹¶ push è¿›ç»“æœæ•°ç»„ä¸­ï¼Œä¸€è¾¹å°†è¿™äº›èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ push è¿›é˜Ÿåˆ—ã€‚\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (!root) return res; queue\u0026lt;TreeNode *\u0026gt; q; q.push(root); int n = 1; while (!q.empty()) { vector\u0026lt;int\u0026gt; lvl; for (int i = 0; i \u0026lt; n; ++i) { TreeNode *node = q.front(); q.pop(); lvl.push_back(node-\u0026gt;val); if (node-\u0026gt;left) q.push(node-\u0026gt;left); if (node-\u0026gt;right) q.push(node-\u0026gt;right); } res.push_back(lvl); n = q.size(); } return res; } }; 107 äºŒå‰æ ‘çš„å±‚æ¬¡éå† II ç»™ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼è‡ªåº•å‘ä¸Šçš„å±‚æ¬¡éå†ã€‚\nè·Ÿä¸Šä¸€é¢˜ç›¸åŒï¼Œåªéœ€è¦å°†ç»“æœæ•°ç»„å€’ç½®ï¼Œæˆ–ç”¨ä¸€ä¸ªæ ˆä¿å­˜ç»“æœï¼Œå† pop è¿›ç»“æœæ•°ç»„å³å¯ã€‚\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrderBottom(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (!root) return res; queue\u0026lt;TreeNode *\u0026gt; q; int n = 1; q.push(root); while (!q.empty()) { vector\u0026lt;int\u0026gt; lvl; for (int i = 0; i \u0026lt; n; ++i) { TreeNode *node = q.front(); q.pop(); lvl.push_back(node-\u0026gt;val); if (node-\u0026gt;left) q.push(node-\u0026gt;left); if (node-\u0026gt;right) q.push(node-\u0026gt;right); } res.push_back(lvl); n = q.size(); } reverse(res.begin(), res.end()); return res; } }; 429 N å‰æ ‘çš„å±‚åºéå† å±‚åºéå†ä¸€ä¸ª N å‰æ ‘ã€‚\nç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥ä¿å­˜è¯¥ N å‰æ ‘å½“å‰ä¸€å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¸€è¾¹å°†è¿™äº›èŠ‚ç‚¹ pop å¹¶ push è¿›ç»“æœæ•°ç»„ä¸­ï¼Œä¸€è¾¹å°†è¿™äº›èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ push è¿›é˜Ÿåˆ—ã€‚\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(Node *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (!root) return res; queue\u0026lt;Node *\u0026gt; q; q.push(root); int n = 1; while (!q.empty()) { vector\u0026lt;int\u0026gt; lvl; for (int i = 0; i \u0026lt; n; ++i) { Node *node = q.front(); q.pop(); lvl.push_back(node-\u0026gt;val); for (auto \u0026amp;c:node-\u0026gt;children) q.push(c); } res.push_back(lvl); n = q.size(); } return res; } }; 987 äºŒå‰æ ‘çš„å‚åºéå† å‚åºéå†ä¸€ä¸ªäºŒå‰æ ‘ã€‚\nç”¨çº¢é»‘æ ‘æŠŠäºŒå‰æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„ä½ç½®ä¿å­˜ä¸‹æ¥ï¼Œå¦‚æœæ ¹èŠ‚ç‚¹çš„ä½ç½®æ˜¯ (x, y)ï¼Œé‚£ä¹ˆå…¶å·¦å­èŠ‚ç‚¹å’Œå³å­èŠ‚ç‚¹çš„ä½ç½®åˆ†åˆ«æ˜¯ (x - 1, y + 1) å’Œ (x + 1, y + 1)ï¼Œå†æŒ‰é¡ºåºä¿å­˜åˆ°ç»“æœæ•°ç»„å³å¯ã€‚\nclass Solution { map\u0026lt;int, map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; matrix; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; verticalTraversal(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; matrix = map\u0026lt;int, map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(); Traverse(root, 0, 0); for (auto \u0026amp;m:matrix) { vector\u0026lt;int\u0026gt; temp; for (auto \u0026amp;n:m.second) { sort(n.second.begin(), n.second.end()); temp.insert(temp.end(), n.second.begin(), n.second.end()); } res.push_back(temp); } return res; } void Traverse(TreeNode *root, int x, int y) { if (!root) return; if (matrix.find(x) == matrix.end()) matrix[x] = map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt;(); if (matrix[x].find(y) == matrix[x].end()) matrix[x][y] = vector\u0026lt;int\u0026gt;(); matrix[x][y].push_back(root-\u0026gt;val); Traverse(root-\u0026gt;left, x - 1, y + 1); Traverse(root-\u0026gt;right, x + 1, y + 1); } }; 103 äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚æ¬¡éå† é”¯é½¿å½¢å±‚æ¬¡éå†ä¸€ä¸ªäºŒå‰æ ‘ã€‚\nç”¨ä¸¤ä¸ªæ ˆè½®æµä»å·¦å¾€å³å’Œä»å³å¾€å·¦ä¿å­˜èŠ‚ç‚¹ï¼Œå†ä¾æ¬¡åŠ å…¥ç»“æœæ•°ç»„å³å¯ã€‚\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s1, s2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (!root) return res; s1.push(root); while (!s1.empty() || !s2.empty()) { vector\u0026lt;int\u0026gt; lvl; if (s2.empty()) { while (!s1.empty()) { TreeNode *node = s1.top(); s1.pop(); lvl.push_back(node-\u0026gt;val); if (node-\u0026gt;left) s2.push(node-\u0026gt;left); if (node-\u0026gt;right) s2.push(node-\u0026gt;right); } } else { while (!s2.empty()) { TreeNode *node = s2.top(); s2.pop(); lvl.push_back(node-\u0026gt;val); if (node-\u0026gt;right) s1.push(node-\u0026gt;right); if (node-\u0026gt;left) s1.push(node-\u0026gt;left); } } res.push_back(lvl); } return res; } }; 124 äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ ç”¨é€’å½’çš„æ–¹å¼ï¼Œåœ¨æ¯ä¸ªèŠ‚ç‚¹å€¼åŠ ä¸Šå…¶å·¦å³å­æ ‘çš„æœ€å¤§è·¯å¾„æ¥æ›´æ–°ç»“æœï¼Œå¹¶ä»¥å…¶å·¦å³å­æ ‘ä¸­è¾ƒå¤§çš„ä¸€ä¸ªåŠ ä¸Šå…¶èŠ‚ç‚¹å€¼è¿”å›å³å¯ã€‚\nclass Solution { int res; public: int maxPathSum(TreeNode *root) { res = INT_MIN; Traverse(root); return res; } int Traverse(TreeNode *node) { if (!node) return 0; int left = max(0, Traverse(node-\u0026gt;left)); int right = max(0, Traverse(node-\u0026gt;right)); res = max(res, left + right + node-\u0026gt;val); return max(left, right) + node-\u0026gt;val; } }; 968 ç›‘æ§äºŒå‰æ ‘ è´ªå¿ƒæ³•ï¼Œåˆ†æƒ…å†µè®¨è®ºï¼Œä¸‰ç§çŠ¶æ€åˆ†åˆ«æ˜¯ï¼š0 è¡¨ç¤ºèŠ‚ç‚¹æœªè¢«ç›‘æ§ï¼Œ1 è¡¨ç¤ºèŠ‚ç‚¹è‡ªå¸¦ç›‘æ§ï¼Œ2 è¡¨ç¤ºèŠ‚ç‚¹è¢«å­èŠ‚ç‚¹ç›‘æ§ï¼›ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸¤ä¸ªå­—å­èŠ‚ç‚¹ç»„åˆèµ·æ¥åˆ†åˆ«ç”± 6 ç§æƒ…å†µï¼Œåˆ†åˆ«æ˜¯ï¼šè‹¥ä¸¤ä¸ªå­èŠ‚ç‚¹éƒ½ä¸º 2ï¼ˆ22ï¼‰ï¼Œé‚£ä¹ˆå½“å‰èŠ‚ç‚¹æœªè¢«ç›‘æ§ï¼Œéœ€è¦è¢«çˆ¶èŠ‚ç‚¹ç›‘æ§ï¼Œè¿”å› 0ï¼›è‹¥ä¸¤ä¸ªå­èŠ‚ç‚¹è‡³å°‘æœ‰ä¸€ä¸ªä¸º 0ï¼ˆ00ï¼Œ01ï¼Œ02ï¼Œæœªè¢«ç›‘æ§ï¼‰ï¼Œé‚£ä¹ˆå½“å‰èŠ‚ç‚¹éœ€è¦è£…ä¸Šç›‘æ§ä»¥ç›‘æ§å­èŠ‚ç‚¹ï¼Œè¿”å› 1ï¼›å‰©ä¸‹çš„ 2 ç§æƒ…å†µæ˜¯è‡³å°‘æœ‰ä¸€ä¸ªå­èŠ‚ç‚¹è‡ªå¸¦ç›‘æ§ï¼ˆ11ï¼Œ12ï¼‰ï¼Œé‚£ä¹ˆå½“å‰èŠ‚ç‚¹è¢«å­èŠ‚ç‚¹ç›‘æ§ï¼Œä¸”å…¶å­èŠ‚ç‚¹éƒ½å·²è¢«ç›‘æ§æˆ–è‡ªå¸¦ç›‘æ§ï¼Œè¿”å› 2ï¼›æœ€åéœ€è¦å•ç‹¬åˆ¤æ–­æ ‘çš„æ ¹èŠ‚ç‚¹æ˜¯å¦æ˜¯ 0 çš„çŠ¶æ€ï¼Œå› ä¸ºå·²ç»æ²¡æœ‰çˆ¶èŠ‚ç‚¹å¯ä»¥è¿›è¡Œç›‘æ§ã€‚\nclass Solution { int res; public: int minCameraCover(TreeNode *root) { res = 0; if (Traverse(root) == 0) ++res; return res; } int Traverse(TreeNode *node) { if (!node) return 2; int left = Traverse(node-\u0026gt;left); int right = Traverse(node-\u0026gt;right); if (left == 2 \u0026amp;\u0026amp; right == 2) return 0; else if (left == 0 || right == 0) { ++res; return 1; } return 2; } }; 2. æ„é€ äºŒå‰æ ‘ 105 ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ æ ¹æ®å‰åºéå†ä¸ä¸­åºéå†çš„ç»“æœæ„é€ äºŒå‰æ ‘ã€‚\nå‰åºéå†ç»“æœä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œå› æ­¤åœ¨ä¸­åºéå†ç»“æœä¸­æ‰¾åˆ°è¿™ä¸ªå€¼ï¼Œé‚£ä¹ˆä¸­åºéå†ç»“æœä¸­è¿™ä¸ªå€¼å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ ä¸€å®šéƒ½åœ¨è¿™ä¸ªæ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸Šï¼Œå³è¾¹çš„æ‰€æœ‰å…ƒç´ ä¸€å®šéƒ½åœ¨è¿™ä¸ªæ ¹èŠ‚ç‚¹çš„å³å­æ ‘ä¸Šï¼Œå‡è®¾å·¦è¾¹çš„é•¿åº¦ä¸º mï¼Œé‚£ä¹ˆåœ¨å‰åºéå†ç»“æœçš„ç¬¬ä¸€ä¸ªå…ƒç´ åçš„ m ä¸ªå…ƒç´ ä¹Ÿéƒ½å¯¹åº”å·¦å­æ ‘ä¸Šçš„è¿™äº›å…ƒç´ ï¼Œåˆ†åˆ«æŠŠè¿™ä¸¤éƒ¨åˆ†é€’å½’è°ƒç”¨æ„é€ æ–°çš„å­æ ‘å³å¯ã€‚\nclass Solution { public: TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { return Build(preorder, 0, preorder.size(), inorder, 0, inorder.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;preorder, int x, int y, vector\u0026lt;int\u0026gt; \u0026amp;inorder, int m, int n) { if (x \u0026gt;= y || m \u0026gt;= n) return nullptr; TreeNode *node = new TreeNode(preorder[x]); int pos = m; while (pos \u0026lt; n \u0026amp;\u0026amp; inorder[pos] != preorder[x]) ++pos; node-\u0026gt;left = Build(preorder, x + 1, x + 1 + pos - m, inorder, m, pos); node-\u0026gt;right = Build(preorder, x + 1 + pos - m, y, inorder, pos + 1, n); return node; } }; 106 ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ æ ¹æ®ååºéå†ä¸ä¸­åºéå†çš„ç»“æœæ„é€ äºŒå‰æ ‘ã€‚\nååºéå†ç»“æœä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œå› æ­¤åœ¨ä¸­åºéå†ç»“æœä¸­æ‰¾åˆ°è¿™ä¸ªå€¼ï¼Œé‚£ä¹ˆä¸­åºéå†ç»“æœä¸­è¿™ä¸ªå€¼å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ ä¸€å®šéƒ½åœ¨è¿™ä¸ªæ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸Šï¼Œå³è¾¹çš„æ‰€æœ‰å…ƒç´ ä¸€å®šéƒ½åœ¨è¿™ä¸ªæ ¹èŠ‚ç‚¹çš„å³å­æ ‘ä¸Šï¼Œå‡è®¾å·¦è¾¹çš„é•¿åº¦ä¸º mï¼Œé‚£ä¹ˆåœ¨ååºéå†ç»“æœä¸­ä»ç¬¬ä¸€ä¸ªå…ƒç´ å¾€å m ä¸ªå…ƒç´ ä¹Ÿéƒ½å¯¹åº”å·¦å­æ ‘ä¸Šçš„è¿™äº›å…ƒç´ ï¼Œåˆ†åˆ«æŠŠè¿™ä¸¤éƒ¨åˆ†é€’å½’è°ƒç”¨æ„é€ æ–°çš„å­æ ‘å³å¯ã€‚\nclass Solution { public: TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;inorder, vector\u0026lt;int\u0026gt; \u0026amp;postorder) { return Build(inorder, 0, inorder.size(), postorder, 0, postorder.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;inorder, int x, int y, vector\u0026lt;int\u0026gt; \u0026amp;postorder, int m, int n) { if (x \u0026gt;= y || m \u0026gt;= n) return nullptr; TreeNode *node = new TreeNode(postorder[n - 1]); int pos = x; while (pos \u0026lt; y \u0026amp;\u0026amp; inorder[pos] != postorder[n - 1]) ++pos; node-\u0026gt;left = Build(inorder, x, pos, postorder, m, m + pos - x); node-\u0026gt;right = Build(inorder, pos + 1, y, postorder, m + pos - x, n - 1); return node; } }; 889 æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘ æ ¹æ®å‰åºéå†ä¸ååºéå†çš„ç»“æœæ„é€ äºŒå‰æ ‘ã€‚\nå‰åºéå†ç»“æœä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ å¯¹åº”ååºéå†ç»“æœä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œéƒ½æ˜¯äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œä»¥æ­¤æ„å»ºæ ¹èŠ‚ç‚¹ï¼›å‰åºéå†ç»“æœä¸­çš„ç¬¬äºŒä¸ªå…ƒç´ ä¸€å®šæ˜¯æ ¹èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ï¼Œè€Œååºéå†ç»“æœä¸­çš„è¿™ä¸ªå€¼ä¸€å®šæ˜¯å·¦å­æ ‘ä¸Šçš„æœ€åä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆåªéœ€è¦æ‰¾åˆ°è¿™ä¸ªå€¼åœ¨ååºéå†ç»“æœä¸­çš„ä½ç½®ï¼Œå°±å¯ä»¥ç¡®å®šå·¦å­æ ‘å’Œå³å­æ ‘çš„é•¿åº¦ï¼Œåˆ†åˆ«é€’å½’è°ƒç”¨æ„é€ æ–°çš„å­æ ‘å³å¯ã€‚\nclass Solution { public: TreeNode *constructFromPrePost(vector\u0026lt;int\u0026gt; \u0026amp;pre, vector\u0026lt;int\u0026gt; \u0026amp;post) { return Build(pre, 0, pre.size(), post, 0, post.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;pre, int x, int y, vector\u0026lt;int\u0026gt; \u0026amp;post, int m, int n) { if (x \u0026gt;= y || m \u0026gt;= n) return nullptr; TreeNode *node = new TreeNode(pre[x]); if (x == y - 1) return node; int pos = m; while (pos \u0026lt; n \u0026amp;\u0026amp; post[pos] != pre[x + 1]) ++pos; node-\u0026gt;left = Build(pre, x + 1, x + pos - m + 2, post, m, pos + 1); node-\u0026gt;right = Build(pre, x + pos - m + 2, y, post, pos + 1, n - 1); return node; } }; 1008 å…ˆåºéå†æ„é€ äºŒå‰æ ‘ ç»™ä¸€ä¸ªå…ˆåºéå†çš„ç»“æœï¼Œæ„é€ å…¶å¯¹åº”çš„äºŒå‰æœç´¢æ ‘ã€‚\næ ¹æ®å…ˆåºéå†å’ŒäºŒå‰æœç´¢æ ‘çš„å®šä¹‰ï¼Œæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ å³æ˜¯æ ¹èŠ‚ç‚¹ï¼Œå…¶åæ‰€æœ‰å°äºå®ƒçš„å…ƒç´ éƒ½åœ¨å®ƒçš„å·¦å­æ ‘ä¸Šï¼Œæ‰€æœ‰å¤§äºå®ƒçš„å…ƒç´ éƒ½åœ¨å®ƒçš„å³å­æ ‘ä¸Šï¼Œé€’å½’æ±‚è§£å³å¯ã€‚\nclass Solution { public: TreeNode *bstFromPreorder(vector\u0026lt;int\u0026gt; \u0026amp;preorder) { return Build(preorder, 0, preorder.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;preorder, int x, int y) { if (x \u0026gt;= y) return nullptr; TreeNode *root = new TreeNode(preorder[x]); int i = x + 1; while (i \u0026lt; y \u0026amp;\u0026amp; preorder[i] \u0026lt; preorder[x]) ++i; root-\u0026gt;left = Build(preorder, x + 1, i); root-\u0026gt;right = Build(preorder, i, y); return root; } }; 1028 ä»å…ˆåºéå†è¿˜åŸäºŒå‰æ ‘ ç»™ä¸€ä¸ªå…ˆåºéå†çš„ç»“æœå’Œç”¨ä¸åŒé•¿åº¦çš„ \u0026lsquo;-\u0026rsquo; ç›¸è¿çš„å­—ç¬¦ä¸²ï¼Œæ„é€ å…¶å¯¹åº”çš„äºŒå‰æ ‘ã€‚\n\u0026lsquo;-\u0026rsquo; çš„é•¿åº¦ä»£è¡¨å½“å‰çš„å±‚æ¬¡ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹ä¹‹åçš„ \u0026lsquo;-\u0026rsquo; çš„é•¿åº¦ç­‰äºå½“å‰çš„å±‚æ¬¡åŠ ä¸€ï¼Œé‚£ä¹ˆå…¶åçš„æ•°æ„æˆå½“å‰èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ï¼›å¦‚æœå·¦èŠ‚ç‚¹ä¹‹åçš„ \u0026lsquo;-\u0026rsquo; çš„é•¿åº¦ç­‰äºå½“å‰çš„å±‚æ¬¡åŠ ä¸€ï¼Œé‚£ä¹ˆå…¶åçš„æ•°æ„æˆå½“å‰èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼›å¦åˆ™å¦‚æœå½“å‰èŠ‚ç‚¹ä¹‹åæˆ–å·¦èŠ‚ç‚¹ä¹‹åçš„ \u0026lsquo;-\u0026rsquo; çš„é•¿åº¦å°äºç­‰äºç­‰é’±å±‚æ¬¡åˆ™ä»£è¡¨å½“å‰èŠ‚ç‚¹å·²ç»æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå…¶æ²¡æœ‰å·¦å³å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›ã€‚ç”¨ä¸€ä¸ªå˜é‡ pos ä¿å­˜å½“å‰éå†åˆ°çš„å­—ç¬¦ä¸²ä½ç½®ï¼Œé€’å½’è°ƒç”¨è¯¥è¿‡ç¨‹å³å¯ã€‚\nclass Solution { public: TreeNode *recoverFromPreorder(string S) { int pos = 0; return Build(S, 0, pos, 0); } TreeNode *Build(const string \u0026amp;S, int x, int \u0026amp;pos, int lvl) { int num = 0, i = x; while (S[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; S[i] \u0026lt;= \u0026#39;9\u0026#39;) ++i; TreeNode *node = new TreeNode(stoi(S.substr(x, i - x + 1))); pos = i; while (S[i] == \u0026#39;-\u0026#39;) ++i; if (i - pos == lvl + 1) node-\u0026gt;left = Build(S, i, pos, lvl + 1); else return node; i = pos; while (S[i] == \u0026#39;-\u0026#39;) ++i; if (i - pos == lvl + 1) node-\u0026gt;right = Build(S, i, y, pos, lvl + 1); return node; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/tree-1/","summary":"LeetCode æ ‘ï¼ˆ1ï¼‰ é¢˜ç›® 1. æ ‘çš„éå† 144 äºŒå‰æ ‘çš„å‰åºéå† å‰åºéå†ä¸€ä¸ªäºŒå‰æ ‘ã€‚\nå‰åºéå†æ˜¯æŒ‰ç…§æ ¹èŠ‚ç‚¹ï¼Œå·¦å­èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹çš„é¡ºåºæ¥éå†ä¸€ä¸ªäºŒå‰æ ‘ï¼Œæœ‰é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•ã€‚å¯¹äºè¿­ä»£æ–¹æ³•ï¼Œå…ˆå°†èŠ‚ç‚¹åŠ å…¥ç»“æœæ•°ç»„ï¼Œç„¶åç”¨ä¸€ä¸ªæ ˆä¿å­˜å³ï¼Œå·¦å­èŠ‚ç‚¹ï¼Œä¾æ¬¡è®¿é—®ï¼Œé‡å¤æ­¤è¿‡ç¨‹ã€‚\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) { res = vector\u0026lt;int\u0026gt;(); Preorder(root); return res; } void Preorder(TreeNode *root) { if (!root) return; res.push_back(root-\u0026gt;val); Preorder(root-\u0026gt;left); Preorder(root-\u0026gt;right); } }; class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;TreeNode *\u0026gt; pre; pre.push(root); while (!pre.empty()) { TreeNode *node = pre.top(); pre.pop(); res.push_back(node-\u0026gt;val); if (node-\u0026gt;right) pre.push(node-\u0026gt;right); if (node-\u0026gt;left) pre.","title":"LeetCode æ ‘ï¼ˆ1ï¼‰"},{"content":"LeetCode é“¾è¡¨ï¼ˆ2ï¼‰ é¢˜ç›® 4. åŒæŒ‡é’ˆ 19 åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ã€‚\nåœ¨é“¾è¡¨ä¸­ä¸æ˜“ç›´æ¥å–åˆ°å€’æ•°ç¬¬ n ä¸ªä½ç½®ï¼Œæ‰€ä»¥ç”¨ä¸¤ä¸ªæŒ‡é’ˆ prev å’Œ tailï¼Œtail å…ˆå¾€å‰èµ° n æ­¥ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆä¸€èµ·å¾€å‰èµ°ç›´åˆ° tail æ²¡æœ‰åç»§æŒ‡é’ˆï¼Œæ­¤æ—¶ prev çš„åç»§æŒ‡é’ˆå°±æ˜¯å€’æ•°ç¬¬ n ä¸ªä½ç½®ï¼Œåˆ é™¤å…¶å³å¯ã€‚æ³¨æ„å¦‚æœè¦åˆ é™¤çš„æŒ‡é’ˆæ˜¯å¤´æŒ‡é’ˆçš„è¯è¦å•ç‹¬å¤„ç†ã€‚\nclass Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *prev = head, *tail = head; for (int i = 0; i \u0026lt; n; ++i) tail = tail-\u0026gt;next; if (!tail) { head = head-\u0026gt;next; delete prev; return head; } while (tail-\u0026gt;next) tail = tail-\u0026gt;next, prev = prev-\u0026gt;next; ListNode *next = prev-\u0026gt;next; prev-\u0026gt;next = next-\u0026gt;next; delete next; return head; } }; 61 æ—‹è½¬é“¾è¡¨ ç»™ä¸€ä¸ªé“¾è¡¨ï¼Œå°†å…¶æ¯ä¸ªèŠ‚ç‚¹å‘å³ç§»åŠ¨ k ä¸ªä½ç½®ã€‚\nåœ¨é“¾è¡¨ä¸­ä¸æ˜“ç›´æ¥å–åˆ°å‰ k ä¸ªä½ç½®ï¼Œæ‰€ä»¥ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œç¬¬ä¸€ä¸ªå…ˆå¾€å‰èµ° k æ­¥ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆä¸€èµ·å¾€å‰èµ°ç›´åˆ°ç¬¬ä¸€ä¸ªæŒ‡é’ˆæ²¡æœ‰åç»§æŒ‡é’ˆï¼Œå°±å¯ä»¥å°†å¤´èŠ‚ç‚¹é“¾æ¥åˆ°ç¬¬ä¸€ä¸ªæŒ‡é’ˆåï¼Œå°†ç¬¬äºŒä¸ªæŒ‡é’ˆåç½®ä¸ºç©ºã€‚æ³¨æ„ k å¯èƒ½éå¸¸å¤§ï¼Œè¦å…ˆè®¡ç®—ä¸€æ¬¡é“¾è¡¨çš„é•¿åº¦ len ç„¶åç”¨ k % len è¿›è¡Œè®¡ç®—ã€‚\nclass Solution { public: ListNode *rotateRight(ListNode *head, int k) { if (!head) return nullptr; ListNode *first = head, *second = head, *traverse = head; int len = 0; while (traverse) { traverse = traverse-\u0026gt;next; ++len; } k %= len; for (int i = 0; i \u0026lt; k; i++) first = first-\u0026gt;next; while (first \u0026amp;\u0026amp; first-\u0026gt;next) first = first-\u0026gt;next, second = second-\u0026gt;next; first-\u0026gt;next = head; auto ret = second-\u0026gt;next; second-\u0026gt;next = nullptr; return ret; } }; 876 é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ æ‰¾é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ã€‚\nç”¨ä¸¤ä¸ªæŒ‡é’ˆ slow å’Œ fastï¼Œfast æ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥ï¼Œslow æ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼Œå½“ fast èµ°åˆ°æœ«å°¾çš„æ—¶å€™ slow æ°å¥½åˆ°æŒ‡é’ˆçš„ä¸­é—´ã€‚\nclass Solution { public: ListNode* middleNode(ListNode* head) { auto slow = head, fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return slow; } }; 160 ç›¸äº¤é“¾è¡¨ æ‰¾åˆ°ä¸¤ä¸ªé“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚\nå‡è®¾é“¾è¡¨ A æœªç›¸äº¤çš„é•¿åº¦ä¸º l1ï¼Œé“¾è¡¨ B æœªç›¸äº¤çš„é•¿åº¦ä¸º l2ï¼Œç›¸äº¤éƒ¨åˆ†çš„é•¿åº¦ä¸º lcï¼Œä¸ºäº†è®©ä¸¤ä¸ªæŒ‡é’ˆèµ°ç›¸åŒçš„é•¿åº¦ï¼Œåªéœ€è¦è®©ä¸¤ä¸ªæŒ‡é’ˆåœ¨èµ°åˆ°å°¾éƒ¨çš„æ—¶å€™é‡æ–°å›åˆ°å¦ä¸€ä¸ªé“¾è¡¨çš„å¤´éƒ¨å†ç»§ç»­èµ°ï¼Œæœ€åå½“ä¸¤ä¸ªæŒ‡é’ˆèµ°è¿‡çš„é•¿åº¦éƒ½æ˜¯ l1 + l2 + l3 æ—¶å³ç›¸äº¤ã€‚\nclass Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { auto a = headA, b = headB; if (!a || !b) return nullptr; while (a != b) { a = a ? a-\u0026gt;next : headB; b = b ? b-\u0026gt;next : headA; } return a; } }; 141 ç¯å½¢é“¾è¡¨ åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ã€‚\nç”¨ä¸¤ä¸ªæŒ‡é’ˆ slow å’Œ fastï¼Œfast æ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥ï¼Œslow æ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼Œå¦‚æœé“¾è¡¨ä¸­æœ‰ç¯é‚£ä¹ˆè¿™ä¸¤ä¸ªæŒ‡é’ˆä¸€å®šä¼šæœ€ç»ˆç›¸é‡ï¼Œå¦åˆ™ fast å°†å…ˆåˆ°è¾¾æœ«å°¾ï¼Œå½“ fast == nullptr æˆ– fast-\u0026gt;next == nullptr å³ä»£è¡¨é“¾è¡¨æ²¡æœ‰æ¢å¹¶ä¸” fast å·²ç»åˆ°è¾¾æœ«å°¾ã€‚\nclass Solution { public: bool hasCycle(ListNode *head) { auto slow = head, fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) return true; } return false; } }; 142 ç¯å½¢é“¾è¡¨ II ç»™ä¸€ä¸ªé“¾è¡¨ï¼Œæ‰¾åˆ°é“¾è¡¨ä¸­å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚\nè·Ÿä¸Šä¸€é¢˜ç›¸åŒï¼Œç”¨ä¸¤ä¸ªæŒ‡é’ˆ slow å’Œ fastï¼Œfast æ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥ï¼Œslow æ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼Œå¦‚æœé“¾è¡¨ä¸­æœ‰ç¯é‚£ä¹ˆè¿™ä¸¤ä¸ªæŒ‡é’ˆä¸€å®šä¼šæœ€ç»ˆç›¸é‡ï¼Œæ­¤æ—¶ fast æŒ‡é’ˆç§»åŠ¨çš„è·ç¦»æ˜¯ l1 + l2 + cï¼Œå…¶ä¸­ l1 æ˜¯é“¾è¡¨ä¸­ç¯å¤–éƒ¨åˆ†çš„é•¿åº¦ï¼Œl2 æ˜¯ç¯å†…ä¸¤ä¸ªæŒ‡é’ˆèµ°è¿‡çš„å…±åŒéƒ¨åˆ†çš„é•¿åº¦ï¼Œc æ˜¯ç¯çš„é•¿åº¦ï¼Œè€Œ slow æŒ‡é’ˆç§»åŠ¨çš„è·ç¦»åˆ™æ˜¯ l1 + l2ï¼Œå› ä¸º fast æŒ‡é’ˆçš„ç§»åŠ¨é€Ÿåº¦æ˜¯ slow çš„ä¸¤å€ï¼Œæ‰€ä»¥æœ‰ l1 + l2 + c = 2 * (l1 + l2)ï¼Œå› æ­¤ c = l1 + l2ï¼Œåˆå› ä¸º slow æŒ‡é’ˆå·²ç»åœ¨ç¯ä¸­èµ°è¿‡äº†é•¿åº¦ä¸º l2 çš„éƒ¨åˆ†ï¼Œåªå‰©ä¸‹é•¿åº¦ä¸º l1 çš„éƒ¨åˆ†ï¼Œåªéœ€è¦ç”¨ä¸€ä¸ªæ–°çš„æŒ‡é’ˆä»é“¾è¡¨çš„å¤´éƒ¨å¼€å§‹æ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼ŒåŒæ—¶è®© slow æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼Œæœ€ç»ˆä»–ä»¬éƒ½ä¼šç§»åŠ¨ l1 çš„è·ç¦»å¹¶åœ¨å…¥ç¯å¤„ç›¸é‡ã€‚\nclass Solution { public: ListNode *detectCycle(ListNode *head) { if (!head || !head-\u0026gt;next) return nullptr; auto slow = head-\u0026gt;next, fast = head-\u0026gt;next-\u0026gt;next; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next \u0026amp;\u0026amp; fast != slow) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } if (!fast || !fast-\u0026gt;next) return nullptr; auto lin = head; while (lin != slow) lin = lin-\u0026gt;next, slow = slow-\u0026gt;next; return lin; } }; 5. ç»¼åˆ 234 å›æ–‡é“¾è¡¨ åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚\nå…ˆæ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ï¼Œç„¶åå°†å³è¾¹çš„é“¾è¡¨ç¿»è½¬ï¼Œå°†å·¦è¾¹çš„é“¾è¡¨ä»ä¸­é—´æˆªæ–­ï¼Œå†ä¸€æ¬¡å¯¹æ¯”ä¸¤è¾¹çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ã€‚\nclass Solution { public: bool isPalindrome(ListNode *head) { if (!head || !head-\u0026gt;next) return true; auto prev = head, slow = head, fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { prev = slow; slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } auto node = Reverse(fast ? slow-\u0026gt;next : slow); prev-\u0026gt;next = nullptr; while (head \u0026amp;\u0026amp; node \u0026amp;\u0026amp; head-\u0026gt;val == node-\u0026gt;val) head = head-\u0026gt;next, node = node-\u0026gt;next; return !head \u0026amp;\u0026amp; !node; } ListNode *Reverse(ListNode *head) { if (!head) return head; ListNode *prev = nullptr, *curr = head, *next = head-\u0026gt;next; while(curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 109 æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘ ç»™ä¸€ä¸ªæœ‰åºé“¾è¡¨ï¼Œå°†å…¶è½¬æ¢ä¸ºä¸€ä¸ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚\nå…ˆæ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ï¼Œå°†å…¶ä½œä¸ºæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå°†ä¸­é—´èŠ‚ç‚¹çš„å·¦è¾¹éƒ¨åˆ†é“¾è¡¨ä½œä¸ºå…¶å·¦å­æ ‘ï¼Œå³è¾¹éƒ¨åˆ†é“¾è¡¨ä½œä¸ºå…¶å³å­æ ‘ã€‚\nclass Solution { public: TreeNode *sortedListToBST(ListNode *head) { if (!head) return nullptr; ListNode *prev = nullptr, *slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) prev = slow, slow = slow-\u0026gt;next, fast = fast-\u0026gt;next-\u0026gt;next; if (prev) prev-\u0026gt;next = nullptr; auto root = new TreeNode(slow-\u0026gt;val); root-\u0026gt;left = sortedListToBST(prev ? head : nullptr); root-\u0026gt;right = sortedListToBST(slow-\u0026gt;next); return root; } }; 426 å°†äºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºæ’åºçš„åŒå‘é“¾è¡¨ å°†ä¸€ä¸ªäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºä¸€ä¸ªåŒå‘å¾ªç¯é“¾è¡¨ã€‚\nå¯¹äºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶è¢«è½¬æ¢ä¸ºåŒå‘é“¾è¡¨ä¹‹åçš„å‰é©±èŠ‚ç‚¹åº”è¯¥æ˜¯å…¶å·¦å­æ ‘ä¸­å€¼æœ€å¤§çš„èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯å…¶å·¦å­èŠ‚ç‚¹çš„æœ€å³å­èŠ‚ç‚¹ï¼Œå› æ­¤åªéœ€è¦å…ˆæ‰¾åˆ°è¿™ä¸ªèŠ‚ç‚¹ï¼Œç„¶åå°†æ ¹èŠ‚ç‚¹ä¸å…¶é¦–å°¾ç›¸è¿å³å¯ï¼Œåœ¨æ­¤ä¹‹å‰åº”è¯¥å…ˆå¯¹æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘å·¦å¯¹åº”çš„æ“ä½œï¼Œå³å­æ ‘äº¦ç„¶ã€‚é™¤æ­¤ä¹‹å¤–è¿˜è¦æŠŠæœ€å°çš„å’Œæœ€å¤§çš„ä¸¤ä¸ªèŠ‚ç‚¹ä¿å­˜ä¸‹æ¥ï¼Œå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹é¦–å°¾ç›¸è¿ï¼Œå½¢æˆå¾ªç¯é“¾è¡¨ã€‚\nclass Solution { Node *first, *last; public: Node *treeToDoublyList(Node *root) { first = last = nullptr; TreeToList(root); if (first) first-\u0026gt;left = last; if (last) last-\u0026gt;right = first; return first; } void TreeToList(Node *root) { if (!root) return; if (!first || first-\u0026gt;val \u0026gt; root-\u0026gt;val) first = root; if (!last || last-\u0026gt;val \u0026lt; root-\u0026gt;val) last = root; auto left = root-\u0026gt;left, right = root-\u0026gt;right; TreeToList(left); TreeToList(right); while (left \u0026amp;\u0026amp; left-\u0026gt;right) left = left-\u0026gt;right; if (left) left-\u0026gt;right = root; root-\u0026gt;left = left; while (right \u0026amp;\u0026amp; right-\u0026gt;left) right = right-\u0026gt;left; if (right) right-\u0026gt;left = root; root-\u0026gt;right = right; } }; 143 é‡æ’é“¾è¡¨ å°†ä¸€ä¸ªé“¾è¡¨ä» L0â†’L1â†’â€¦â†’Ln-1â†’Ln é‡æ–°æ’åˆ—ä¸º L0â†’Lnâ†’L1â†’Ln-1â†’L2â†’Ln-2â†’\u0026hellip;ã€‚\nå…ˆå°†é“¾è¡¨ä»ä¸­é—´åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œå°†ååŠéƒ¨åˆ†åè½¬ï¼Œå†å°†å¯¹åº”ä½ç½®çš„èŠ‚ç‚¹ä¾æ¬¡é“¾æ¥ä¸Šã€‚\nclass Solution { public: void reorderList(ListNode* head) { if (!head) return; auto prev = head, slow = head, fast = head, first = head, second = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) prev = slow, slow = slow-\u0026gt;next, fast = fast-\u0026gt;next-\u0026gt;next; if (fast) { second = slow-\u0026gt;next; slow-\u0026gt;next = nullptr; } else { second = slow; prev-\u0026gt;next = nullptr; } second = Reverse(second); while (second) { auto n1 = first-\u0026gt;next, n2 = second-\u0026gt;next; first-\u0026gt;next = second; second-\u0026gt;next = n1; first = n1; second = n2; } } ListNode *Reverse(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 138 å¤åˆ¶å¸¦éšæœºæŒ‡é’ˆçš„é“¾è¡¨ ç»™ä¸€ä¸ªé“¾è¡¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ª random æŒ‡é’ˆæŒ‡å‘é“¾è¡¨çš„æŸä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›è¿™ä¸ªé“¾è¡¨çš„æ·±æ‹·è´ã€‚\nå› ä¸ºåœ¨ç¬¬ä¸€æ¬¡éå†æ—¶ random æŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹å¯èƒ½å¹¶æœªè¢«æ‹·è´ï¼Œå¯ä»¥å…ˆå°†æ‰€æœ‰èŠ‚ç‚¹å…ˆæ‹·è´ä¸€æ¬¡ï¼Œç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨å°†èŠ‚ç‚¹çš„å¯¹åº”å…³ç³»ä¿å­˜ä¸‹æ¥ï¼Œå†éå†ä¸€æ¬¡å°† random æŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ä¾æ¬¡é“¾æ¥ä¸Šï¼Œè¿™æ ·åšç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚ä¹Ÿå¯ä»¥å…ˆå°†æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½æ‹·è´ä¸€æ¬¡ï¼Œå¹¶å°†æ‹·è´çš„èŠ‚ç‚¹é“¾æ¥åˆ°è¯¥èŠ‚ç‚¹åï¼Œå†éå†ä¸¤æ¬¡åˆ†åˆ«ä¿®æ”¹ random æŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ä»¥åŠå°†åŸé“¾è¡¨åŠå…¶æ‹·è´åˆ†å¼€ï¼Œè¿™æ ·åšç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: Node *copyRandomList(Node *head) { if (!head) return head; Node *node = head; while (node) { Node *cop = new Node(node-\u0026gt;val, node-\u0026gt;next, node-\u0026gt;random); node-\u0026gt;next = cop; node = node-\u0026gt;next-\u0026gt;next; } node = head; while (node \u0026amp;\u0026amp; node-\u0026gt;next) { if (node-\u0026gt;random) node-\u0026gt;next-\u0026gt;random = node-\u0026gt;random-\u0026gt;next; node = node-\u0026gt;next-\u0026gt;next; } node = head; Node *res = head-\u0026gt;next; while (node) { Node *next = node-\u0026gt;next; node-\u0026gt;next = next-\u0026gt;next; next-\u0026gt;next = next-\u0026gt;next ? next-\u0026gt;next-\u0026gt;next : nullptr; node = node-\u0026gt;next; } return res; } }; 23 åˆå¹¶Kä¸ªæ’åºé“¾è¡¨ åˆå¹¶ k ä¸ªæœ‰åºé“¾è¡¨ã€‚\næœ€ç®€å•çš„åšæ³•æ˜¯æ¯æ¬¡éå†æ‰€æœ‰å¤´èŠ‚ç‚¹ï¼Œå–å‡ºå€¼æœ€å°çš„ä¸€ä¸ªï¼Œå°†å…¶åŠ åˆ°è¦è¿”å›çš„é“¾è¡¨ä¸­ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ï¼Œå…¶ä¸­ m æ˜¯é“¾è¡¨çš„ä¸ªæ•°ï¼Œn æ˜¯èŠ‚ç‚¹çš„æ€»ä¸ªæ•°ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { ListNode *root = new ListNode(0), *node = root; while (node) { ListNode *min_ptr = nullptr; for (auto \u0026amp;l :lists) if (l \u0026amp;\u0026amp; (!min_ptr || l-\u0026gt;val \u0026lt; min_ptr-\u0026gt;val)) min_ptr = l; node-\u0026gt;next = min_ptr; for (auto \u0026amp;l :lists) if (l \u0026amp;\u0026amp; l == min_ptr) l = l-\u0026gt;next; node = node-\u0026gt;next; } return root-\u0026gt;next; } }; åœ¨æ­¤åŸºç¡€ä¸Šå¯ä»¥ç”¨ä¸€ä¸ªå°æ ¹å †æ¥ä¿å­˜æ‰€æœ‰å¤´èŠ‚ç‚¹ï¼Œæ¯æ¬¡å–å‡ºå †é¡¶çš„èŠ‚ç‚¹ï¼Œå°†è¯¥èŠ‚ç‚¹åŠ å…¥è¦è¿”å›çš„é“¾è¡¨ä¸­ï¼Œåˆ¤æ–­è¯¥èŠ‚ç‚¹æ˜¯å¦æœ‰åç»§èŠ‚ç‚¹ï¼Œå¦‚æœæœ‰çš„è¯åˆ™å°†å…¶åŠ å…¥å †ä¸­å¹¶ç»´æŠ¤ï¼Œæ³¨æ„éœ€è¦é‡è½½ä¼˜å…ˆé˜Ÿåˆ—çš„æ¯”è¾ƒå‡½æ•°ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n * logm)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(m)ã€‚\nclass Solution { struct compare { bool operator()(ListNode *l1, ListNode *l2) { return l1-\u0026gt;val \u0026gt; l2-\u0026gt;val; } }; public: ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { ListNode *root = new ListNode(0), *node = root; priority_queue\u0026lt;ListNode *, vector\u0026lt;ListNode *\u0026gt;, compare\u0026gt; heap; for (auto \u0026amp;l:lists) if (l) heap.push(l); while (!heap.empty()) { ListNode *curr = heap.top(); node-\u0026gt;next = curr; node = node-\u0026gt;next; heap.pop(); if (curr-\u0026gt;next) heap.push(curr-\u0026gt;next); } return root-\u0026gt;next; } }; è¿˜å¯ä»¥ç”¨åˆ†æ²»æ³•ä¸¤ä¸¤åˆå¹¶é“¾è¡¨ï¼Œçœå»ç»´æŠ¤å †æ‰€èŠ±è´¹çš„ç©ºé—´å’Œæ—¶é—´ï¼Œå› ä¸ºé“¾è¡¨çš„æ•°é‡æ˜¯ mï¼Œæ‰€ä»¥ç”¨åˆ†æ²»æ³•éœ€è¦èŠ±è´¹ logm çš„æ—¶é—´æ¥åˆå¹¶æ‰€æœ‰çš„é“¾è¡¨ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n * logm)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { ListNode *MergeLists(ListNode *l1, ListNode *l2) { ListNode *root = new ListNode(0), *node = root; while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { node-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { node-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } node = node-\u0026gt;next; } node-\u0026gt;next = l1 ? l1 : l2; return root-\u0026gt;next; } public: ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { int n = lists.size(); for (int interval = 1; interval \u0026lt; n; interval *= 2) { for (int i = 0; i \u0026lt; n; i += interval * 2) if (i + interval \u0026lt; n) lists[i] = MergeLists(lists[i], lists[i + interval]); } return n == 0 ? nullptr : lists[0]; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/linkedlist-2/","summary":"LeetCode é“¾è¡¨ï¼ˆ2ï¼‰ é¢˜ç›® 4. åŒæŒ‡é’ˆ 19 åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ã€‚\nåœ¨é“¾è¡¨ä¸­ä¸æ˜“ç›´æ¥å–åˆ°å€’æ•°ç¬¬ n ä¸ªä½ç½®ï¼Œæ‰€ä»¥ç”¨ä¸¤ä¸ªæŒ‡é’ˆ prev å’Œ tailï¼Œtail å…ˆå¾€å‰èµ° n æ­¥ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆä¸€èµ·å¾€å‰èµ°ç›´åˆ° tail æ²¡æœ‰åç»§æŒ‡é’ˆï¼Œæ­¤æ—¶ prev çš„åç»§æŒ‡é’ˆå°±æ˜¯å€’æ•°ç¬¬ n ä¸ªä½ç½®ï¼Œåˆ é™¤å…¶å³å¯ã€‚æ³¨æ„å¦‚æœè¦åˆ é™¤çš„æŒ‡é’ˆæ˜¯å¤´æŒ‡é’ˆçš„è¯è¦å•ç‹¬å¤„ç†ã€‚\nclass Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *prev = head, *tail = head; for (int i = 0; i \u0026lt; n; ++i) tail = tail-\u0026gt;next; if (!tail) { head = head-\u0026gt;next; delete prev; return head; } while (tail-\u0026gt;next) tail = tail-\u0026gt;next, prev = prev-\u0026gt;next; ListNode *next = prev-\u0026gt;next; prev-\u0026gt;next = next-\u0026gt;next; delete next; return head; } }; 61 æ—‹è½¬é“¾è¡¨ ç»™ä¸€ä¸ªé“¾è¡¨ï¼Œå°†å…¶æ¯ä¸ªèŠ‚ç‚¹å‘å³ç§»åŠ¨ k ä¸ªä½ç½®ã€‚","title":"LeetCode é“¾è¡¨ï¼ˆ2ï¼‰"},{"content":"LeetCode é“¾è¡¨ï¼ˆ1ï¼‰ é¢˜ç›® 1. å¸¸è§„é¢˜ 2 ä¸¤æ•°ç›¸åŠ  ç»™ä¸¤ä¸ªé“¾è¡¨åˆ†åˆ«ä»£è¡¨ä¸¤ä¸ªæ­£æ•°çš„é€†åºè¡¨ç¤ºï¼Œè®¡ç®—ä¸¤ä¸ªé“¾è¡¨ä¹‹å’Œã€‚\nä¾æ¬¡æŒ‰ä½è¿›è¡Œç›¸åŠ ã€‚\nclass Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { int acc = 0, val = 0; auto head = l1, tail = l1; while (l1 \u0026amp;\u0026amp; l2) { val = l1-\u0026gt;val + l2-\u0026gt;val + acc; acc = val / 10; l1-\u0026gt;val = val % 10; if (!l1-\u0026gt;next) l1-\u0026gt;next = l2-\u0026gt;next, l2-\u0026gt;next = nullptr; tail = l1; l1 = l1-\u0026gt;next, l2 = l2-\u0026gt;next; } while (l1) { val = l1-\u0026gt;val + acc; acc = val / 10; l1-\u0026gt;val = val % 10; tail = l1; l1 = l1-\u0026gt;next; } if (acc) tail-\u0026gt;next = new ListNode(1); return head; } }; 21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ã€‚\né€ä¸ªæ¯”è¾ƒå¤§å°å¹¶æ·»åŠ åˆ°å½“å‰èŠ‚ç‚¹åé¢ï¼Œå¹¶ç§»åŠ¨å¯¹åº”çš„é“¾è¡¨èŠ‚ç‚¹ã€‚\nclass Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head = new ListNode(0), *node = head; while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) head-\u0026gt;next = l1, l1 = l1-\u0026gt;next; else head-\u0026gt;next = l2, l2 = l2-\u0026gt;next; head = head-\u0026gt;next; } while (l1) head-\u0026gt;next = l1, l1 = l1-\u0026gt;next, head = head-\u0026gt;next; while (l2) head-\u0026gt;next = l2, l2 = l2-\u0026gt;next, head = head-\u0026gt;next; return node-\u0026gt;next; } }; 83 åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰é‡å¤çš„èŠ‚ç‚¹ã€‚\nå°†æ¯ä¸ªèŠ‚ç‚¹ä¸å…¶åé¢çš„èŠ‚ç‚¹çš„å€¼åšå¯¹æ¯”ï¼Œå¦‚æœç›¸åŒåˆ™åˆ é™¤åé¢çš„èŠ‚ç‚¹ã€‚\nclass Solution { public: ListNode* deleteDuplicates(ListNode* head) { auto ret = head; while (head) { while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;next-\u0026gt;val == head-\u0026gt;val) { auto next = head-\u0026gt;next; head-\u0026gt;next = next-\u0026gt;next; delete next; } head = head-\u0026gt;next; } return ret; } }; 82 åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰é‡å¤çš„èŠ‚ç‚¹ï¼Œåªä¿ç•™åŸå§‹é“¾è¡¨ä¸­æ²¡æœ‰é‡å¤å‡ºç°çš„æ•°å­—ã€‚\nä¸ºäº†åˆ é™¤æ‰€æœ‰é‡å¤çš„èŠ‚ç‚¹å¹¶åªä¿ç•™æ‰€æœ‰æ²¡æœ‰å‡ºç°è¿‡çš„æ•°å­—ï¼Œéœ€è¦æå‰ä¸¤ä¸ªèŠ‚ç‚¹æ£€æŸ¥æ¥ä¸‹æ¥çš„ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼æ˜¯å¦ç›¸åŒï¼Œå¦‚æœç›¸åŒçš„è¯éœ€è¦å°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹åŠå…¶åçš„æ‰€æœ‰é‡å¤èŠ‚ç‚¹éƒ½åˆ é™¤ã€‚\nclass Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode *node = new ListNode(0), *ret = node, *next = nullptr, *temp = nullptr; node-\u0026gt;next = head; while (node \u0026amp;\u0026amp; node-\u0026gt;next) { next = node-\u0026gt;next-\u0026gt;next; while (next \u0026amp;\u0026amp; node-\u0026gt;next-\u0026gt;val == next-\u0026gt;val) { temp = next; next = next-\u0026gt;next; delete temp; } if (next != node-\u0026gt;next-\u0026gt;next) { temp = node-\u0026gt;next; node-\u0026gt;next = next; delete temp; } else node = node-\u0026gt;next; } return ret-\u0026gt;next; } }; 203 ç§»é™¤é“¾è¡¨å…ƒç´  åˆ é™¤é“¾è¡¨ä¸­ç­‰äºç»™å®šå€¼çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚\nå…ˆåˆ¤æ–­å¤´èŠ‚ç‚¹æ˜¯å¦ç­‰äºç»™å®šå€¼ï¼Œå†åˆ¤æ–­å…¶åé¢çš„èŠ‚ç‚¹æ˜¯å¦ç­‰äºç»™å®šå€¼ã€‚\nclass Solution { public: ListNode* removeElements(ListNode* head, int val) { while (head \u0026amp;\u0026amp; head-\u0026gt;val == val) { auto prev = head; head = head-\u0026gt;next; delete prev; } auto ret = head; while (head) { while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;next-\u0026gt;val == val) { auto next = head-\u0026gt;next; head-\u0026gt;next = next-\u0026gt;next; delete next; } head = head-\u0026gt;next; } return ret; } }; 817 é“¾è¡¨ç»„ä»¶ ç»™ä¸€ä¸ªé“¾è¡¨å’Œä¸€ä¸ªæ•°ç»„ï¼Œæ‰¾åˆ°é“¾è¡¨ä¸­ä¸€æ®µå­é“¾è¡¨çš„å€¼éƒ½åœ¨æ•°ç»„ä¸­çš„å­é“¾è¡¨çš„ä¸ªæ•°ã€‚\nå…ˆå°†æ•°ç»„è½¬æ¢æˆå“ˆå¸Œè¡¨æ–¹ä¾¿æŸ¥è¯¢ï¼Œå†ä¾æ¬¡éå†æ•´ä¸ªé“¾è¡¨ï¼Œåˆ¤æ–­ä¸€æ®µå­é“¾è¡¨ç»“æŸæ—¶æˆ–éå†ç»“æŸæ—¶å­é“¾è¡¨æ˜¯å¦æ˜¯ç¬¦åˆæ¡ä»¶ã€‚\nclass Solution { public: int numComponents(ListNode* head, vector\u0026lt;int\u0026gt;\u0026amp; G) { unordered_set\u0026lt;int\u0026gt; exist(G.begin(), G.end()); bool cont = false, curr = false; int res = 0; while (head) { curr = exist.count(head-\u0026gt;val); res += cont \u0026amp;\u0026amp; !curr; cont = curr; head = head-\u0026gt;next; } return res + cont; } }; 24 ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ ç»™ä¸€ä¸ªé“¾è¡¨ï¼Œè¿”å›ä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹åçš„ç»“æœã€‚\nç”¨ä¸‰ä¸ªæŒ‡é’ˆæŠŠè¦äº¤æ¢çš„ä¸¤ä¸ªèŠ‚ç‚¹å’Œä»–ä»¬çš„å‰é©±èŠ‚ç‚¹ä¿å­˜ä¸‹æ¥ï¼Œäº¤æ¢åå†æ›´æ–°ä¸‰ä¸ªæŒ‡é’ˆï¼ŒæŒ‰é¡ºåºäº¤æ¢å³å¯ã€‚\nclass Solution { public: ListNode *swapPairs(ListNode *head) { if (!head || !head-\u0026gt;next) return head; ListNode *root = new ListNode(0), *prev = root; root-\u0026gt;next = head; auto first = head, second = head-\u0026gt;next; while (first \u0026amp;\u0026amp; second) { auto temp = second-\u0026gt;next; prev-\u0026gt;next = second; second-\u0026gt;next = first; first-\u0026gt;next = temp; prev = first; first = temp; second = temp ? temp-\u0026gt;next : nullptr; } return root-\u0026gt;next; } }; 430 æ‰å¹³åŒ–å¤šçº§åŒå‘é“¾è¡¨ ç»™ä¸€ä¸ªå¸¦å­èŠ‚ç‚¹çš„åŒå‘é“¾è¡¨ï¼Œå°†å…¶æ‰å¹³åŒ–å¹¶ä½¿æ‰€æœ‰ç»“ç‚¹å‡ºç°åœ¨å•çº§åŒé“¾è¡¨ä¸­ã€‚\nå¯¹äºæŸä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœå®ƒæœ‰ child èŠ‚ç‚¹ï¼Œé‚£ä¹ˆéœ€è¦å°†å…¶ child èŠ‚ç‚¹ä½œä¸ºå…¶æ–°çš„ next èŠ‚ç‚¹ï¼Œå°†å…¶ child é“¾è¡¨ä¸Šçš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºå…¶åŸæœ¬ next èŠ‚ç‚¹çš„ prev èŠ‚ç‚¹ï¼Œé€’å½’è°ƒç”¨æ•´ä¸ªè¿‡ç¨‹å³å¯ã€‚\nclass Solution { public: Node *flatten(Node *head) { if (!head) return nullptr; Node *node = head, *next = nullptr; while (node) { if (node-\u0026gt;child) { next = node-\u0026gt;next; auto child = flatten(node-\u0026gt;child); node-\u0026gt;next = child; child-\u0026gt;prev = node; node-\u0026gt;child = nullptr; while (node-\u0026gt;next) node = node-\u0026gt;next; node-\u0026gt;next = next; if (next) next-\u0026gt;prev = node; } node = node-\u0026gt;next; } return head; } }; 2. é“¾è¡¨åè½¬ 206 åè½¬é“¾è¡¨ class Solution { public: ListNode* reverseList(ListNode* head) { if (!head) return nullptr; ListNode *prev = nullptr, *curr = head, *next = head-\u0026gt;next; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 92 åè½¬é“¾è¡¨ II å°†é“¾è¡¨ä¸­ä» m åˆ° n ä½ç½®çš„èŠ‚ç‚¹åè½¬ã€‚\nå…ˆæ‰¾åˆ°ä½ç½®åœ¨ m - 1 çš„èŠ‚ç‚¹ï¼Œå°†å…¶åçš„èŠ‚ç‚¹æˆªæ–­ï¼Œå†æ‰¾åˆ°ä½ç½®åœ¨ n çš„èŠ‚ç‚¹ï¼Œå°†å…¶åçš„èŠ‚ç‚¹æˆªæ–­ï¼Œå°†ä¸­é—´çš„ä¸€æ®µé“¾è¡¨åè½¬åå†é“¾æ¥åˆ°æ„¿é“¾è¡¨ä¸Šã€‚\nclass Solution { public: ListNode *reverseBetween(ListNode *head, int m, int n) { ListNode *root = new ListNode(0), *r = root, *prev, *last; root-\u0026gt;next = head; int cnt = 1; while (cnt \u0026lt; m \u0026amp;\u0026amp; r) r = r-\u0026gt;next, ++cnt; prev = r; while (cnt \u0026lt;= n \u0026amp;\u0026amp; r \u0026amp;\u0026amp; r-\u0026gt;next) r = r-\u0026gt;next, ++cnt; last = r-\u0026gt;next; r-\u0026gt;next = nullptr; prev-\u0026gt;next = Reverse(prev-\u0026gt;next); while (prev \u0026amp;\u0026amp; prev-\u0026gt;next) prev = prev-\u0026gt;next; prev-\u0026gt;next = last; return root-\u0026gt;next; } ListNode *Reverse(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 369 ç»™å•é“¾è¡¨åŠ ä¸€ ç”¨ä¸€ä¸ªå•é“¾è¡¨è¡¨ç¤ºä¸€ä¸ªæ•´æ•°ï¼Œè®¡ç®—å°†å…¶åŠ ä¸€çš„ç»“æœã€‚\nå…ˆå°†é“¾è¡¨åè½¬æ–¹ä¾¿è¿›ä½ï¼Œç„¶åè¿›è¡ŒåŠ ä¸€å’Œè¿›ä½çš„æ“ä½œï¼Œæœ€åå†åè½¬ä¸€æ¬¡é“¾è¡¨ã€‚\nclass Solution { public: ListNode* plusOne(ListNode* head) { if (!head) return nullptr; head = Reverse(head); auto root = head; while (head) { if (head-\u0026gt;val == 9) { head-\u0026gt;val = 0; if (!head-\u0026gt;next) { head-\u0026gt;next = new ListNode(1); break; } head = head-\u0026gt;next; } else { ++head-\u0026gt;val; break; } } return Reverse(root); } ListNode *Reverse(ListNode* head) { if (!head) return nullptr; ListNode *prev = nullptr, *curr = head, *next = head-\u0026gt;next; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 445 ä¸¤æ•°ç›¸åŠ  II ç»™ä¸¤ä¸ªé“¾è¡¨åˆ†åˆ«ä»£è¡¨ä¸¤ä¸ªæ­£æ•°ï¼Œè®¡ç®—ä¸¤ä¸ªé“¾è¡¨ä¹‹å’Œã€‚\nå…ˆå°†ä¸¤ä¸ªé“¾è¡¨åè½¬ï¼Œå†ä¾æ¬¡æŒ‰ä½è¿›è¡Œç›¸åŠ ï¼Œæœ€åå†å°†å¾—åˆ°çš„ç»“æœåè½¬å¹¶è¿”å›ã€‚\nclass Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { if (!l1 || !l2) return !l1 ? l2 : l1; l1 = Reverse(l1); l2 = Reverse(l2); int carry = 0, sum = 0; ListNode *head = l1, *prev = l1; while (l1 \u0026amp;\u0026amp; l2) { prev = l1; sum = l1-\u0026gt;val + l2-\u0026gt;val + carry; carry = sum / 10; l1-\u0026gt;val = sum - carry * 10; if (l2-\u0026gt;next \u0026amp;\u0026amp; !l1-\u0026gt;next) l1-\u0026gt;next = l2-\u0026gt;next, l2-\u0026gt;next = nullptr; l1 = l1-\u0026gt;next; l2 = l2-\u0026gt;next; } while (l1) { prev = l1; sum = l1-\u0026gt;val + carry; carry = sum / 10; l1-\u0026gt;val = sum - carry * 10; l1 = l1-\u0026gt;next; } if (carry \u0026amp;\u0026amp; prev) prev-\u0026gt;next = new ListNode(1); return Reverse(head); } ListNode *Reverse(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 25 K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ ç»™ä¸€ä¸ªé“¾è¡¨ï¼Œæ¯ k ä¸ªèŠ‚ç‚¹ä¸€ç»„è¿›è¡Œç¿»è½¬ã€‚\nç”¨å‡ ä¸ªæŒ‡é’ˆè®°å½•ä¸‹éœ€è¦åè½¬çš„éƒ¨åˆ†çš„èµ·å§‹ï¼Œç»ˆæ­¢ä½ç½®ï¼Œä¾æ¬¡åè½¬å³å¯ã€‚\nclass Solution { ListNode *ReverseLinkedList(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } public: ListNode *reverseKGroup(ListNode *head, int k) { ListNode *root = new ListNode(0), *prev = root; prev-\u0026gt;next = head; while (prev) { int i = 1; ListNode *start = prev-\u0026gt;next, *end = prev-\u0026gt;next, *curr = end, *next = nullptr; while (curr \u0026amp;\u0026amp; i \u0026lt; k) curr = curr-\u0026gt;next, ++i; if (i \u0026lt; k || !curr) break; next = curr-\u0026gt;next; curr-\u0026gt;next = nullptr; start = ReverseLinkedList(start); prev-\u0026gt;next = start; end-\u0026gt;next = next; prev = end; } return root-\u0026gt;next; } }; 3. åŒé“¾è¡¨ 328 å¥‡å¶é“¾è¡¨ æŠŠä¸€ä¸ªé“¾è¡¨ä¸­çš„å¥‡æ•°ä½èŠ‚ç‚¹å’Œå¶æ•°ä½èŠ‚ç‚¹åˆ†åˆ«æ’åœ¨ä¸€èµ·ã€‚\nç”¨ä¸¤ä¸ªå¤´èŠ‚ç‚¹åˆ†åˆ«è¡¨ç¤ºå¥‡æ•°ä½å’Œå¶æ•°ä½èŠ‚ç‚¹çš„èµ·å§‹ä½ç½®ï¼Œéå†æ•´ä¸ªé“¾è¡¨ï¼Œå°†å¥‡æ•°ä½èŠ‚ç‚¹é“¾æ¥åœ¨å¥‡æ•°ä½èµ·å§‹èŠ‚ç‚¹åï¼Œå°†å¶æ•°ä½èŠ‚ç‚¹é“¾æ¥åœ¨å¶æ•°ä½èµ·å§‹èŠ‚ç‚¹åï¼Œæœ€åå°†å¶æ•°ä½èµ·å§‹èŠ‚ç‚¹é“¾æ¥åœ¨å¥‡æ•°ä½æœ€åèŠ‚ç‚¹åå³å¯ã€‚\nclass Solution { public: ListNode* oddEvenList(ListNode* head) { if (!head || !head-\u0026gt;next) return head; auto odd = head, even = head-\u0026gt;next, node = even-\u0026gt;next, even_head = even; bool flag = true; while (node) { if (flag) { odd-\u0026gt;next = node; odd = odd-\u0026gt;next; flag = false; } else { even-\u0026gt;next = node; even = even-\u0026gt;next; flag = true; } node = node-\u0026gt;next; } odd-\u0026gt;next = even_head; even-\u0026gt;next = nullptr; return head; } }; 86 åˆ†éš”é“¾è¡¨ ç»™ä¸€ä¸ªé“¾è¡¨å’Œä¸€ä¸ªå€¼ xï¼Œé‡æ–°æ’åˆ—é“¾è¡¨ä½¿å¾—æ‰€æœ‰å°äº x çš„èŠ‚ç‚¹éƒ½åœ¨å¤§äºç­‰äº x çš„èŠ‚ç‚¹ä¹‹å‰ã€‚\nç”¨ä¸¤ä¸ªå¤´èŠ‚ç‚¹ sth å’Œ geq åˆ†åˆ«è¡¨ç¤ºå°äº x å’Œå¤§äºç­‰äº x çš„èŠ‚ç‚¹çš„èµ·å§‹ä½ç½®ï¼Œéå†æ•´ä¸ªé“¾è¡¨ï¼Œåˆ†åˆ«å°†å„ä¸ªèŠ‚ç‚¹é“¾æ¥åˆ°ä¸¤ä¸ªå¤´èŠ‚ç‚¹ä¹‹åï¼Œæœ€åå°† geq é“¾æ¥åˆ° sth ä¹‹åï¼Œå†å°† geq çš„æœ«ç«¯è®¾ä¸ºç©ºæŒ‡é’ˆã€‚\nclass Solution { public: ListNode* partition(ListNode* head, int x) { auto sth = new ListNode(0), sth_head = sth, geq = new ListNode(0), geq_head = geq; while (head) { if (head-\u0026gt;val \u0026lt; x) { sth-\u0026gt;next = head; sth = sth-\u0026gt;next; } else { geq-\u0026gt;next = head; geq = geq-\u0026gt;next; } head = head-\u0026gt;next; } sth-\u0026gt;next = geq_head-\u0026gt;next; geq-\u0026gt;next = nullptr; return sth_head-\u0026gt;next; } }; 725 åˆ†éš”é“¾è¡¨ ç»™ä¸€ä¸ªé“¾è¡¨, å°†å…¶åˆ†éš”ä¸º k ä¸ªè¿ç»­çš„éƒ¨åˆ†ã€‚\nå…ˆè®¡ç®—å‡ºé“¾è¡¨çš„é•¿åº¦å’Œ k ä¸ªè¿ç»­éƒ¨åˆ†ä¸­æ¯ä¸ªéƒ¨åˆ†çš„é•¿åº¦ï¼Œä¾æ¬¡å°†æ¯ä¸ªéƒ¨åˆ†çš„å¤´èŠ‚ç‚¹æ”¾å…¥æ•°ç»„ä¸­ã€‚\nclass Solution { public: vector\u0026lt;ListNode *\u0026gt; splitListToParts(ListNode *root, int k) { vector\u0026lt;ListNode *\u0026gt; res(k, nullptr); int len = 0; ListNode *head = root, *temp = nullptr; while (root) root = root-\u0026gt;next, ++len; int n = len / k, m = len % k, i = 0; while (head) { res[i] = head; for (int j = 0; j \u0026lt; n + (m \u0026gt; 0) - 1; ++j) head = head-\u0026gt;next; temp = head; head = head-\u0026gt;next; temp-\u0026gt;next = nullptr; ++i; --m; } return res; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/linkedlist-1/","summary":"LeetCode é“¾è¡¨ï¼ˆ1ï¼‰ é¢˜ç›® 1. å¸¸è§„é¢˜ 2 ä¸¤æ•°ç›¸åŠ  ç»™ä¸¤ä¸ªé“¾è¡¨åˆ†åˆ«ä»£è¡¨ä¸¤ä¸ªæ­£æ•°çš„é€†åºè¡¨ç¤ºï¼Œè®¡ç®—ä¸¤ä¸ªé“¾è¡¨ä¹‹å’Œã€‚\nä¾æ¬¡æŒ‰ä½è¿›è¡Œç›¸åŠ ã€‚\nclass Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { int acc = 0, val = 0; auto head = l1, tail = l1; while (l1 \u0026amp;\u0026amp; l2) { val = l1-\u0026gt;val + l2-\u0026gt;val + acc; acc = val / 10; l1-\u0026gt;val = val % 10; if (!l1-\u0026gt;next) l1-\u0026gt;next = l2-\u0026gt;next, l2-\u0026gt;next = nullptr; tail = l1; l1 = l1-\u0026gt;next, l2 = l2-\u0026gt;next; } while (l1) { val = l1-\u0026gt;val + acc; acc = val / 10; l1-\u0026gt;val = val % 10; tail = l1; l1 = l1-\u0026gt;next; } if (acc) tail-\u0026gt;next = new ListNode(1); return head; } }; 21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ã€‚","title":"LeetCode é“¾è¡¨ï¼ˆ1ï¼‰"},{"content":"LeetCode åŠ¨æ€è§„åˆ’ é¢˜ç›® 6. å­—ç¬¦ä¸²ç›¸å…³ 712 ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€å°ASCIIåˆ é™¤å’Œ ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œè®¡ç®—ä½¿ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒæ‰€éœ€è¦åˆ é™¤çš„å­—ç¬¦çš„ASCIIå€¼çš„å’Œçš„æœ€å°å€¼ã€‚\nå¯¹äºä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ s1[i] å’Œ s2[j]ï¼Œå¦‚æœs1[i] == s2[j]ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå­—ç¬¦éƒ½ä¸éœ€è¦è¢«åˆ é™¤ï¼Œæ‰€ä»¥ dp[i][j] = dp[i - 1][j - 1]ï¼Œå¦åˆ™è‡³å°‘æœ‰ä¸€ä¸ªåº”è¯¥è¢«åˆ é™¤ï¼Œå–ä¸¤ä¸ªä¸­çš„æœ€å°å€¼ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(m * n)ã€‚\nclass Solution { public: int minimumDeleteSum(string s1, string s2) { int n1 = s1.size(), n2 = s2.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n1 + 1, vector\u0026lt;int\u0026gt;(n2 + 1, 0)); for (int i = 1; i \u0026lt;= n1; ++i) dp[i][0] = dp[i - 1][0] + s1[i - 1]; for (int j = 1; j \u0026lt;= n2; ++j) dp[0][j] = dp[0][j - 1] + s2[j - 1]; for (int i = 0; i \u0026lt; n1; ++i) for (int j = 0; j \u0026lt; n2; ++j) if (s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j]; else dp[i + 1][j + 1] = min(dp[i][j] + s1[i] + s2[j], min(dp[i][j + 1] + s1[i], dp[i + 1][j] + s2[j])); return dp[n1][n2]; } }; 5 æœ€é•¿å›æ–‡å­ä¸² æ‰¾åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„æœ€é•¿å›æ–‡å­ä¸²ã€‚\næœ€ç®€å•çš„æ–¹æ³•æ˜¯ä»ä¸€ä¸ªå­—ç¬¦ä¸å…¶å‰ä¸€ä¸ª/ä¸¤ä¸ªå­—ç¬¦åˆ†åˆ«å¾€ä¸¤è¾¹éå†ã€‚ä¹Ÿå¯ä»¥æŒ‰ç…§è‡ªä¸‹è€Œä¸Šçš„åŠ¨æ€è§„åˆ’æ€æƒ³ï¼Œç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„ dp[i][j]ï¼Œåˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ s[i] ä¸ s[j] æ˜¯å¦ç›¸ç­‰ï¼Œä»¥åŠä»–ä»¬å†…ä¾§çš„å­å­—ç¬¦ä¸²æ˜¯å¦æ˜¯ä¸€ä¸ªå›æ–‡ä¸²ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯ dp[i][j] = s[i] == s[j] \u0026amp;\u0026amp; (dp[i + 1][j - 1] || j - i \u0026lt; 3)ã€‚\nclass Solution { public: string longestPalindrome(string s) { int n = s.size(); string res; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n, vector\u0026lt;bool\u0026gt;(n, false)); for (int i = 0; i \u0026lt; n; ++i) for (int j = i; j \u0026gt;= 0; --j) if (s[i] == s[j] \u0026amp;\u0026amp; (i - j \u0026lt; 3 || dp[j + 1][i - 1])) { dp[j][i] = true; if (i - j + 1 \u0026gt; res.size()) res = s.substr(j, i - j + 1); } return res; } }; 647 å›æ–‡å­ä¸² æ‰¾åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„å›æ–‡å­ä¸²çš„ä¸ªæ•°ã€‚\nä¸ä¸Šä¸€é¢˜ç±»ä¼¼ï¼Œç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„ dp[i][j]ï¼Œåˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ s[i] ä¸ s[j] æ˜¯å¦ç›¸ç­‰ï¼Œä»¥åŠä»–ä»¬å†…ä¾§çš„å­å­—ç¬¦ä¸²æ˜¯å¦æ˜¯ä¸€ä¸ªå›æ–‡ä¸²ï¼Œå¦‚æœæ˜¯é‚£ä¹ˆ s.substr(j, i - j + 1)ï¼Œå°†ç»“æœ +1 å³å¯ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ã€‚\nclass Solution { public: int countSubstrings(string s) { int res = 0, n = s.size(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n, vector\u0026lt;bool\u0026gt;(n, false)); for (int i = 0; i \u0026lt; n; ++i) for (int j = i; j \u0026gt;= 0; --j) if (s[i] == s[j] \u0026amp;\u0026amp; (i - j \u0026lt; 3 || dp[j + 1][i - 1])) dp[j][i] = true, ++res; return res; } }; 516 æœ€é•¿å›æ–‡å­åºåˆ— ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾æœ€é•¿çš„å›æ–‡å­åºåˆ—ã€‚\nåªæœ‰å½“ä¸¤ä¸ªå­—ç¬¦ç›¸ç­‰æ—¶ï¼Œä»–ä»¬æ‰æœ‰å¯èƒ½å’Œä»–ä»¬ä¹‹é—´çš„å­åºåˆ—å½¢æˆå›æ–‡å­åºåˆ—ï¼Œå› æ­¤åªéœ€è¦çŸ¥é“ä»–ä»¬ä¹‹é—´çš„æœ€é•¿å›æ–‡å­åºåˆ—çš„é•¿åº¦å³å¯ï¼Œå¦åˆ™ä»–ä»¬ä¹‹é—´çš„æœ€é•¿å›æ–‡å­åºåˆ—åªèƒ½æ˜¯å…¶ä¸­ä¸€ä¸ªå­—ç¬¦çš„å·¦è¾¹æˆ–å³è¾¹åˆ°å¦ä¸€ä¸ªå­—ç¬¦ä¹‹é—´çš„æœ€å¤§å›æ–‡å­åºåˆ—é•¿åº¦ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯ dp[j][i] = s[i] == s[j] ? dp[j + 1][i - 1] + 2 : max(dp[j + 1][i], dp[j][i - 1])ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ã€‚\nclass Solution { public: int longestPalindromeSubseq(string s) { int n = s.size(); if (n \u0026lt;= 1) return n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 1; i \u0026lt; n; ++i) { dp[i][i] = 1; for (int j = i - 1; j \u0026gt;= 0; --j) { if (s[i] == s[j]) dp[j][i] = dp[j + 1][i - 1] + 2; else dp[j][i] = max(dp[j + 1][i], dp[j][i - 1]); } } return dp[0][n - 1]; } }; 7. è·¯å¾„å’Œ 62 ä¸åŒè·¯å¾„ ç»™ä¸€ä¸ªçŸ©é˜µï¼Œæ±‚ä»å·¦ä¸Šè§’èµ°åˆ°å³ä¸‹è§’æœ‰å¤šå°‘ç§æ–¹æ³•ã€‚\nèµ°åˆ°ç¬¬ä¸€åˆ—å’Œç¬¬ä¸€è¡Œçš„æ¯ä¸€æ ¼éƒ½åªæœ‰ä¸€ç§æ–¹æ³•ï¼Œå…¶ä½™çš„æ ¼å­å‡å¯ä»¥ä»å…¶ä¸Šæ–¹å’Œå·¦æ–¹èµ°ä¸€æ ¼åˆ°è¾¾ï¼Œå› æ­¤æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i][j] = dp[i][j - 1] + dp[i - 1][j]ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(m * n)ã€‚\nclass Solution { public: int uniquePaths(int m, int n) { if (m == 0 || n == 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 1)); for (int i = 1; i \u0026lt; m; ++i) for (int j = 1; j \u0026lt; n; ++j) dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; return dp[m - 1][n - 1]; } }; å¯¹äºæ¯ä¸€ä¸ªæ ¼å­æ¥è¯´ï¼Œå®ƒçš„å€¼éƒ½ç­‰äºåˆ°è¾¾ä¸Šæ–¹å’Œå·¦æ–¹æ ¼å­çš„æ–¹æ³•æ•°é‡ä¹‹å’Œï¼Œä¹Ÿå°±ç›¸å½“äºåœ¨éå†å®Œä¸€è¡Œä¹‹åï¼ŒæŠŠä¸Šä¸€è¡Œçš„å€¼å…¨éƒ¨èµ‹å€¼ç»™ä¸‹ä¸€è¡Œï¼Œåœ¨ä¸‹ä¸€è¡Œéå†æ—¶ä½¿å…¶åŠ ä¸Šå·¦æ–¹æ ¼å­çš„æ–¹æ³•æ•°é‡ï¼Œç”±æ­¤å¯ä»¥å°†èµ‹å€¼çš„è¿‡ç¨‹ç®€åŒ–ä¸ºä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼Œç©ºé—´å¤æ‚åº¦é™ä½ä¸º O(min(m, n))ã€‚\nclass Solution { public: int uniquePaths(int m, int n) { if (m == 0 || n == 0) return 0; vector\u0026lt;int\u0026gt; dp(n, 1); for (int i = 1; i \u0026lt; m; ++i) for (int j = 1; j \u0026lt; n; ++j) dp[j] += dp[j - 1]; return dp[n - 1]; } }; 63 ä¸åŒè·¯å¾„ II ç»™ä¸€ä¸ªçŸ©é˜µï¼Œéƒ¨åˆ†ä½ç½®æœ‰éšœç¢ç‰©ï¼Œæ±‚ä»å·¦ä¸Šè§’èµ°åˆ°å³ä¸‹è§’æœ‰å¤šå°‘ç§æ–¹æ³•ã€‚\nå’Œä¸Šä¸€é¢˜ç›¸æ¯”åœ¨éƒ¨åˆ†ä½ç½®å¢åŠ äº†éšœç¢ç‰©ï¼Œé¦–å…ˆè¦å¤„ç†ç¬¬ä¸€åˆ—å’Œç¬¬ä¸€è¡Œï¼Œå¦‚æœæœ‰ä¸€ä¸ªä½ç½®æœ‰éšœç¢ç‰©é‚£ä¹ˆæ¥ä¸‹æ¥çš„ä½ç½®éƒ½ä¸èƒ½åˆ°è¾¾äº†ï¼Œç„¶åå¯¹äºå…¶ä»–æ ¼å­ï¼Œå¦‚æœæœ¬èº«æ˜¯éšœç¢ç‰©é‚£ä¹ˆä¹Ÿæ— æ³•åˆ°è¾¾ï¼Œå¦åˆ™ä»ç„¶ç­‰äºå…¶ä¸Šæ–¹å’Œå·¦æ–¹ä¹‹å’Œã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(m * n)ã€‚\nclass Solution { public: int uniquePathsWithObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = m != 0 ? grid[0].size() : 0; if (m == 0 || n == 0) return 0; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(m, vector\u0026lt;long long\u0026gt;(n, 0)); dp[0][0] = grid[0][0] ^ 1; for (int i = 1; i \u0026lt; m; ++i) dp[i][0] = (grid[i][0] ^ 1) \u0026amp; dp[i - 1][0]; for (int j = 1; j \u0026lt; n; ++j) dp[0][j] = (grid[0][j] ^ 1) \u0026amp; dp[0][j - 1]; for (int i = 1; i \u0026lt; m; ++i) for (int j = 1; j \u0026lt; n; ++j) dp[i][j] = grid[i][j] ? 0 : dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; } }; 64 æœ€å°è·¯å¾„å’Œ ç»™ä¸€ä¸ªå¸¦æƒå€¼çš„çŸ©é˜µï¼Œæ±‚ä»å·¦ä¸Šè§’èµ°åˆ°å³ä¸‹è§’çš„æœ€å°æƒå€¼ä¹‹å’Œã€‚\nåˆ°è¾¾ç¬¬ä¸€åˆ—å’Œç¬¬ä¸€è¡Œçš„æ¯ä¸€æ ¼éƒ½åªæœ‰ä¸€ç§æ–¹æ³•ï¼Œå› æ­¤å…ˆå°†å…¶åˆå§‹åŒ–ã€‚å› ä¸ºæ¯ä¸€æ ¼åªèƒ½ä»å…¶ä¸Šæ–¹å’Œå·¦æ–¹åˆ°è¾¾ï¼Œå› æ­¤æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ã€‚å¯ä»¥ç›´æ¥åœ¨ç»™çš„çŸ©é˜µä¸­æ“ä½œï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = m != 0 ? grid[0].size() : 0; if (m == 0) return 0; for (int i = 1; i \u0026lt; m; ++i) grid[i][0] += grid[i - 1][0]; for (int j = 1; j \u0026lt; n; ++j) grid[0][j] += grid[0][j - 1]; for (int i = 1; i \u0026lt; m; ++i) for (int j = 1; j \u0026lt; n; ++j) grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]); return grid[m - 1][n - 1]; } }; 120 ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ ç»™ä¸€ä¸ªå¸¦æƒå€¼çš„ä¸‰è§’å½¢ï¼Œæ±‚è‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œã€‚æ¯ä¸€æ­¥å¯ä»¥ç§»åŠ¨åˆ°å·¦ä¸‹æ–¹æˆ–å³ä¸‹æ–¹ã€‚\nå› ä¸ºæ¯ä¸€æ ¼åªèƒ½ä»å…¶å·¦ä¸Šæ–¹å’Œå³ä¸Šæ–¹åˆ°è¾¾ï¼Œå› æ­¤æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ tri[i][j] += min(tri[i - 1][j], tri[i - 1][j - 1])ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ã€‚å¯ä»¥ç›´æ¥åœ¨ç»™çš„çŸ©é˜µä¸­æ“ä½œï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: int minimumTotal(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;tri) { int n = tri.size(), res = INT_MAX; if (n \u0026lt;= 1) return n == 0 ? 0 : tri[0][0]; for (int i = 1; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; tri[i].size(); ++j) { if (j == 0) tri[i][j] += tri[i - 1][j]; else if (j \u0026gt;= tri[i - 1].size()) tri[i][j] += tri[i - 1][j - 1]; else tri[i][j] += min(tri[i - 1][j], tri[i - 1][j - 1]); if (i == n - 1) res = min(res, tri[i][j]); } } return res; } }; 931 ä¸‹é™è·¯å¾„æœ€å°å’Œ ç»™ä¸€ä¸ªå¸¦æƒå€¼çš„æ–¹å½¢ï¼Œæ±‚è‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œã€‚æ¯ä¸€æ­¥å¯ä»¥ç§»åŠ¨åˆ°å·¦ä¸‹æ–¹ï¼Œä¸‹æ–¹æˆ–å³ä¸‹æ–¹ã€‚\næ¯ä¸€æ ¼å¯ä»¥ä»å…¶å·¦ä¸Šæ–¹ï¼Œä¸Šæ–¹å’Œå³ä¸Šæ–¹åˆ°è¾¾ï¼Œå› æ­¤æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ A[i][j] += min({A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1]})ã€‚\nclass Solution { public: int minFallingPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; A) { int m = A.size(), n = m != 0 ? A[0].size() : 0, val = INT_MAX, res = INT_MAX; if (m == 0) return 0; for (int i = 1; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { val = A[i - 1][j]; if (j \u0026lt; n - 1) val = min(val, A[i - 1][j + 1]); if (j \u0026gt; 0) val = min(val, A[i - 1][j - 1]); A[i][j] += val; } } return *min_element(A[m - 1].begin(), A[m - 1].end()); } }; 8. å…¶ä»– 650 åªæœ‰ä¸¤ä¸ªé”®çš„é”®ç›˜ æœ‰ä¸€ä¸ªå­—ç¬¦ \u0026lsquo;A\u0026rsquo;ï¼Œåªèƒ½è¿›è¡Œå¤åˆ¶å’Œç²˜è´´æ“ä½œï¼Œæ±‚å¾—åˆ° n ä¸ª \u0026lsquo;A\u0026rsquo; çš„æœ€å°æ“ä½œæ¬¡æ•°ã€‚\nm ä¸ª \u0026lsquo;A\u0026rsquo; åªèƒ½é€šè¿‡ç²˜è´´çš„æ“ä½œå¾—åˆ°ï¼Œæ±‚å‡ºæ‰€æœ‰èƒ½æ•´é™¤ m çš„æ•°é‡Œé€šè¿‡å¤åˆ¶ç²˜è´´æ“ä½œå¾—åˆ° m çš„æœ€å°æ¬¡æ•°å³å¯ã€‚\nclass Solution { public: int minSteps(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, n); dp[1] = 0; for (int i = 1; i \u0026lt;= n; ++i) { int res = dp[i] + 1; for (int j = i; j \u0026lt;= n; j += i) { dp[j] = min(dp[j], res); ++res; } } return dp[n]; } }; 651 4é”®é”®ç›˜ ä¸€ä¸ªé”®ç›˜ä¸Šæœ‰å››ä¸ªé”®ï¼šè¾“å…¥ \u0026lsquo;A\u0026rsquo;ï¼Œé€‰ä¸­å…¨éƒ¨ï¼Œå¤åˆ¶ï¼Œå’Œç²˜è´´ã€‚å¯ä»¥æŒ‰ N æ¬¡é”®ç›˜ï¼Œæ±‚æœ€å¤šèƒ½æ˜¾ç¤ºå¤šå°‘ä¸ª \u0026lsquo;A\u0026rsquo;ã€‚\nå› ä¸º N æ˜¯æœ€åä¸€æ¬¡æ“ä½œï¼Œæ‰€ä»¥åªèƒ½è¿›è¡Œè¾“å…¥ \u0026lsquo;A\u0026rsquo; å’Œç²˜è´´ä¸¤ç§æ“ä½œï¼Œåªéœ€è¦æ±‚å‡ºæ¯ä¸€æ­¥åœ¨ä¹‹å‰ä¸€æ­¥åŸºç¡€ä¸Šè¾“å…¥ \u0026lsquo;A\u0026rsquo;ï¼Œä»¥åŠåœ¨å¾€å‰ä¸‰æ­¥çš„æ¯ä¸€æ­¥åŸºç¡€ä¸Šé€‰ä¸­ï¼Œå¤åˆ¶ï¼Œç²˜è´´èƒ½å¾—åˆ°çš„æœ€2ä¼˜è§£ã€‚\nclass Solution { public: int maxA(int N) { vector\u0026lt;int\u0026gt; dp(N + 1, 0); for (int i = 1; i \u0026lt;= N; ++i) { dp[i] = dp[i - 1] + 1; for (int j = i - 1; j \u0026gt;= 2; --j) dp[i] = max(dp[i], dp[j - 2] * (i - j + 1)); } return dp[N]; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/dynamicprogramming-3/","summary":"LeetCode åŠ¨æ€è§„åˆ’ é¢˜ç›® 6. å­—ç¬¦ä¸²ç›¸å…³ 712 ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€å°ASCIIåˆ é™¤å’Œ ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œè®¡ç®—ä½¿ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒæ‰€éœ€è¦åˆ é™¤çš„å­—ç¬¦çš„ASCIIå€¼çš„å’Œçš„æœ€å°å€¼ã€‚\nå¯¹äºä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ s1[i] å’Œ s2[j]ï¼Œå¦‚æœs1[i] == s2[j]ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå­—ç¬¦éƒ½ä¸éœ€è¦è¢«åˆ é™¤ï¼Œæ‰€ä»¥ dp[i][j] = dp[i - 1][j - 1]ï¼Œå¦åˆ™è‡³å°‘æœ‰ä¸€ä¸ªåº”è¯¥è¢«åˆ é™¤ï¼Œå–ä¸¤ä¸ªä¸­çš„æœ€å°å€¼ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(m * n)ã€‚\nclass Solution { public: int minimumDeleteSum(string s1, string s2) { int n1 = s1.size(), n2 = s2.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n1 + 1, vector\u0026lt;int\u0026gt;(n2 + 1, 0)); for (int i = 1; i \u0026lt;= n1; ++i) dp[i][0] = dp[i - 1][0] + s1[i - 1]; for (int j = 1; j \u0026lt;= n2; ++j) dp[0][j] = dp[0][j - 1] + s2[j - 1]; for (int i = 0; i \u0026lt; n1; ++i) for (int j = 0; j \u0026lt; n2; ++j) if (s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j]; else dp[i + 1][j + 1] = min(dp[i][j] + s1[i] + s2[j], min(dp[i][j + 1] + s1[i], dp[i + 1][j] + s2[j])); return dp[n1][n2]; } }; 5 æœ€é•¿å›æ–‡å­ä¸² æ‰¾åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„æœ€é•¿å›æ–‡å­ä¸²ã€‚","title":"LeetCode åŠ¨æ€è§„åˆ’ï¼ˆ3ï¼‰"},{"content":"LeetCode åŠ¨æ€è§„åˆ’ é¢˜ç›® 3. æ•°ç»„ç›¸å…³ 300 æœ€é•¿ä¸Šå‡å­åºåˆ— åœ¨æ— åºæ•°ç»„ä¸­æ‰¾åˆ°æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ã€‚\nç”¨ä¸€ä¸ªæ•°ç»„ dp[i] è¡¨ç¤ºåˆ°ç¬¬ i ä¸ªæ•°å­—ä¸ºæ­¢çš„æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼Œæ¯æ¬¡éå† i ä¹‹å‰çš„æ¯ä¸ªæ•°å­— jï¼Œå¦‚æœ nums[i] \u0026gt; nums[j]ï¼Œé‚£ä¹ˆ j å’Œ i å¯ä»¥å½¢æˆä¸€ä¸ªä¸Šå‡å­åºåˆ—ï¼Œè®© dp[i] = max(dp[i], dp[j] + 1) å°±èƒ½å¾—åˆ°æœ€é•¿çš„ä¸Šå‡å­åºåˆ—äº†ã€‚\nclass Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), res = 2; if (n \u0026lt;= 1) return n; vector\u0026lt;int\u0026gt; dp(n, 1); for (int i = 1; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; i; ++j) if (nums[i] \u0026gt; nums[j]) { dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); } return res; } }; 53 æœ€å¤§å­åºå’Œ æ‰¾ä¸€ä¸ªæ•°ç»„ä¸­å…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„çš„å’Œã€‚\nä»å¤´å¼€å§‹ç”¨ä¸€ä¸ªå˜é‡ val ä¿å­˜åˆ°å½“å‰æ•°ä¸ºæ­¢çš„è¿ç»­å­æ•°ç»„å’Œï¼Œæ¯ä¸€ä¸ªæ•°å¯¹äºä¹‹å‰çš„è¿ç»­å­æ•°ç»„å’Œåªæœ‰åŠ ä¸ä¸åŠ ä¸¤ç§é€‰æ‹©ï¼Œå½“ä¹‹å‰çš„è¿ç»­å­æ•°ç»„å’Œå¤§äº 0 æ—¶åŠ ä¸Šä¹‹å‰çš„è¿ç»­å­æ•°ç»„å’Œï¼Œå¦åˆ™ä¸åŠ ã€‚\nclass Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int res = INT_MIN, val = 0; for (auto \u0026amp;n:nums) { val = max(val, 0) + n; res = max(res, val); } return res; } }; 718 æœ€é•¿é‡å¤å­æ•°ç»„ ç»™ä¸¤ä¸ªæ•°ç»„ï¼Œæ±‚ä¸¤ä¸ªæ•°ç»„ä¸­å…¬å…±çš„é•¿åº¦æœ€é•¿çš„å­æ•°ç»„çš„é•¿åº¦ã€‚\nå¯¹äºæŸä¸¤ä¸ªå­—ç¬¦ A[i] å’Œ B[j]ï¼Œå¦‚æœ A[i] == B[j]ï¼Œåˆ™ä»£è¡¨ A[i]ï¼ŒB[j] ä¸ä»–ä»¬ä¹‹å‰çš„å­æ•°ç»„æœ‰å¯èƒ½æ˜¯å…¬å…±å­æ•°ç»„ï¼Œå…¶æœ€é•¿é•¿åº¦ dp[i][j] = dp[i - 1][j - 1] + 1ï¼Œå¦åˆ™ä»–ä»¬ä¸èƒ½ç»„æˆå…¬å…±å­æ•°ç»„ï¼Œdp[i][j] = 0ã€‚ç”¨ä¸¤å±‚å¾ªç¯éå†ä¸¤ä¸ªæ•°ç»„å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(m * n)ã€‚\nclass Solution { public: int findLength(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { int m = A.size(), n = B.size(), res = 0; if (m == 0 || n == 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 1; i \u0026lt;= m; ++i) for (int j = 1; j \u0026lt;= n; ++j) { dp[i][j] = A[i - 1] == B[j - 1] ? dp[i - 1][j - 1] + 1 : 0; res = max(res, dp[i][j]); } return res; } }; 983 æœ€ä½ç¥¨ä»· ç»™å‡ºè¦æ—…è¡Œçš„æ‰€æœ‰æ—¥æœŸï¼Œæœ‰ä¸‰ç§é€šè¡Œè¯ï¼šä¸€æ—¥ç¥¨ï¼Œä¸ƒæ—¥ç¥¨ï¼Œä¸‰åæ—¥ç¥¨ã€‚æ±‚æœ€ä½æ¶ˆè´¹ã€‚\nå¯¹äºç¬¬ i å¤©çš„æœ€ä½æ¶ˆè´¹ï¼Œåªéœ€è¦é€‰å‡ºä¸€å¤©å‰çš„æœ€ä½æ¶ˆè´¹åŠ ä¸Šä¸€æ—¥ç¥¨çš„æ¶ˆè´¹ï¼Œä¸ƒå¤©å‰çš„æœ€ä½æ¶ˆè´¹åŠ ä¸Šä¸ƒæ—¥ç¥¨ï¼Œä¸‰åå¤©å‰çš„æœ€ä½æ¶ˆè´¹åŠ ä¸Šä¸‰åæ—¥ç¥¨è¿™ä¸‰ç§æ¶ˆè´¹ä¸­æœ€ä½çš„å³å¯ï¼Œå› æ­¤æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i] = min({dp[i - 1] + costs[0], dp[i - 7] + costs[1], dp[i - 30] + costs[2]})ã€‚\nclass Solution { public: int mincostTickets(vector\u0026lt;int\u0026gt; \u0026amp;days, vector\u0026lt;int\u0026gt; \u0026amp;costs) { vector\u0026lt;int\u0026gt; dp(366, INT_MAX); dp[0] = 0; int j = 0, n = days.size(); for (int i = 1; i \u0026lt;= 365 \u0026amp;\u0026amp; j \u0026lt; n; ++i) { if (i == days[j]) { dp[i] = min({dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2]}); ++j; } else dp[i] = dp[i - 1]; } return dp[days[n - 1]]; } }; 813 æœ€å¤§å¹³å‡å€¼å’Œçš„åˆ†ç»„ å°†æ•°ç»„åˆ†ä¸º K ä¸ªç›¸é‚»çš„éç©ºå­æ•°ç»„ï¼Œæ±‚æ‰€æœ‰å­æ•°ç»„çš„å¹³å‡å€¼çš„å’Œçš„æœ€å¤§å€¼ã€‚\nç”¨äºŒç»´æ•°ç»„ dp[n][K] æ¥è¡¨ç¤ºå‰ i ä¸ªæ•°åˆ†æˆ k ç»„å¾—åˆ°çš„æœ€ä¼˜å€¼ï¼Œæ¯æ¬¡å°†ä»ç¬¬ j ä¸ªæ•°åˆ°ç¬¬ n ä¸ªæ•°åˆ†ä¸ºä¸€ç»„ï¼Œå°†å‰é¢ j - 1 ä¸ªæ•°åˆ†ä¸º k - 1 ç»„ï¼Œæ±‚å¾— dp[i][k] çš„æœ€å¤§å€¼ã€‚ä¸ºäº†å¿«é€Ÿåœ°ç®—å‡ºç¬¬ j ä¸ªæ•°åˆ°ç¬¬ n ä¸ªæ•°çš„å’Œä»¥åŠå‰ j - 1 ä¸ªæ•°çš„å’Œï¼Œå¯ä»¥ç”¨ä¸€ä¸ªå‰ç¼€å’Œæ•°ç»„å°†å‰ m ä¸ªæ•°çš„å’Œä¿å­˜ä¸‹æ¥ï¼Œå†ç”¨çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i][k] = max(dp[i][k], dp[j][k - 1] + (pre[i] - pre[j]) / (i - j)) æ±‚å¾—æœ€ä¼˜å€¼ã€‚\nclass Solution { public: double largestSumOfAverages(vector\u0026lt;int\u0026gt; \u0026amp;A, int K) { int n = A.size(); if (n == 0) return 0; vector\u0026lt;double\u0026gt; pre(n + 1, 0); for (int i = 1; i \u0026lt;= n; ++i) pre[i] += pre[i - 1] + A[i - 1]; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;double\u0026gt;(K + 1, 0)); for (int i = 1; i \u0026lt;= n; ++i) { dp[i][1] = pre[i] / i; for (int k = 2; k \u0026lt;= K \u0026amp;\u0026amp; k \u0026lt;= i; ++k) for (int j = 1; j \u0026lt; i; ++j) dp[i][k] = max(dp[i][k], dp[j][k - 1] + (pre[i] - pre[j]) / (i - j)); } return dp[n][K]; } }; 646 æœ€é•¿æ•°å¯¹é“¾ æŒ‰ç…§æ¯ä¸ªæ•°å¯¹çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä»å°åˆ°å¤§æ’åºï¼Œä»ç¬¬äºŒä¸ªæ•°å¯¹å¼€å§‹ï¼Œä¾æ¬¡åˆ¤æ–­å…¶ä¸å…¶å‰é¢çš„æ‰€æœ‰æ•°å¯¹æ˜¯å¦ç¬¦åˆé¢˜æ„ï¼Œæ˜¯çš„è¯åˆ™ dp[j] = max(dp[j], dp[i] + 1ï¼‰ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2)ã€‚\nclass Solution { public: int findLongestChain(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; pairs) { sort(pairs.begin(), pairs.end()); int n = pairs.size(), res = 1; vector\u0026lt;int\u0026gt; dp(n, 1); for (int j = 1; j \u0026lt; n; ++j) for (int i = 0; i \u0026lt; j; ++i) if (pairs[j][0] \u0026gt; pairs[i][1]) { dp[j] = max(dp[j], dp[i] + 1); res = max(res, dp[j]); } return res; } }; 4. ç­‰å·®æ•°åˆ— 413 ç­‰å·®æ•°åˆ—åˆ’åˆ† ç»™ä¸€ä¸ªæ•°ç»„ï¼Œè®¡ç®—æ•°ç»„ä¸­ç­‰å·®å­æ•°ç»„çš„ä¸ªæ•°ã€‚\nç­‰å·®æ•°åˆ—å¿…é¡»æ˜¯ç›¸é‚»ä¸¤ä¸ªå…ƒç´ ä¹‹å·®ç›¸ç­‰çš„é•¿åº¦å¤§äº 3 çš„å­æ•°ç»„ï¼Œå› æ­¤åªéœ€è¦çŸ¥é“ nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 1] å³å¯ã€‚ç”¨ä¸€ä¸ªå˜é‡ cul è¡¨ç¤ºåˆ°ç›®å‰ä¸ºæ­¢ç­‰å·®æ•°åˆ—çš„é•¿åº¦ï¼Œdiff è¡¨ç¤ºä¹‹å‰çš„å…¬å·®ï¼Œå¦‚æœç›®å‰çš„å·®ç­‰äº diff åˆ™åŠ ä¸Š culã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: int numberOfArithmeticSlices(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = 0, n = nums.size(), cul = 1, curr = 0; if (n \u0026lt; 3) return 0; int diff = nums[1] - nums[0]; for (int i = 2; i \u0026lt; n; ++i) { if ((curr = nums[i] - nums[i - 1]) == diff) { res += cul; ++cul; } else { diff = curr; cul = 1; } } return res; } }; 446 ç­‰å·®æ•°åˆ—åˆ’åˆ† II - å­åºåˆ— ç»™ä¸€ä¸ªæ•°ç»„ï¼Œè®¡ç®—æ•°ç»„ä¸­ç­‰å·®å­åºåˆ—çš„ä¸ªæ•°ã€‚\nå¯¹äºæŸä¸€ä¸ªæ•° nums[i]ï¼Œå·²çŸ¥å…¶ä¸å…¶ä¹‹å‰æŸä¸€ä¸ªæ•°çš„å·® diff = nums[i] - nums[j]ï¼Œéœ€è¦çŸ¥é“åœ¨ nums[j] ä¹‹å‰å…¬å·®ä¸º diff çš„ç­‰å·®å­åºåˆ—çš„æœ€å¤§ä¸ªæ•°ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨æ•°ç»„æ¥è¡¨ç¤ºæ•° nums[j] ä¹‹å‰å…¬å·®ä¸º diff çš„ç­‰å·®å­åºåˆ—çš„æœ€å¤§ä¸ªæ•°ï¼Œå¦‚æœ nums[i] - nums[j] == diff åˆ™åˆ°ä½ç½® i ä¸ºæ­¢å…¬å·®ä¸º diff çš„ç­‰å·®å­åºåˆ—çš„ä¸ªæ•° dp[i][diff] += dp[j][diff]ï¼Œæ³¨æ„è¦ç”¨ += è€Œä¸æ˜¯ =ï¼Œå› ä¸ºå¦‚æœåœ¨ nums[i] ä¹‹å‰æœ‰å¤šä¸ªç›¸åŒçš„æ•°å­—é‚£ä¹ˆéœ€è¦æŠŠæ¯ä¸€ä¸ªéƒ½ç®—ä½œä¸€ä¸ªç‹¬ç«‹çš„ç­‰å·®å­åºåˆ—ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ã€‚å¾ˆæç¬‘çš„æ˜¯è¿™é“é¢˜çš„åŠ¨æ€è§„åˆ’è§£æ³•åœ¨ LeetCode ä¸Šæäº¤çš„æ—¶å€™ runtime æ˜¯ 1000ms +-ï¼Œè€Œåœ¨LeetCode-CN ä¸Šæäº¤çš„æ—¶å€™æ‰§è¡Œç”¨æ—¶æ˜¯ 1400ms ~ 1800msï¼Œè€Œä¸”å¶å°”è¿˜ä¼šè¶…æ—¶ï¼Œè¶…æ—¶çš„ case çš„å…¬å·®è¶…è¿‡äº† int32 çš„è¡¨ç¤ºèŒƒå›´ï¼Œå¦‚æœåŠ ä¸Šåˆ¤æ–­ diff \u0026lt; INT_MIN || diff \u0026gt; INT_MAX ç›´æ¥ continue å°±èƒ½æ­£å¸¸é€šè¿‡äº†ã€‚\nclass Solution { public: int numberOfArithmeticSlices(vector\u0026lt;int\u0026gt;\u0026amp; A) { int n = A.size(), res = 0; long long diff = 0; vector\u0026lt;unordered_map\u0026lt;long long, int\u0026gt;\u0026gt; dp(n); for (int i = 1; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { diff = static_cast\u0026lt;long long\u0026gt;(A[i]) - A[j]; if (diff \u0026lt; INT_MIN || diff \u0026gt; INT_MAX) continue; dp[i][diff] += dp[j][diff] + 1; res += dp[j][diff]; } } return res; } }; 1027 æœ€é•¿ç­‰å·®æ•°åˆ— ç»™ä¸€ä¸ªæ•°ç»„ï¼Œè®¡ç®—æ•°ç»„ä¸­æœ€é•¿ç­‰å·®å­åºåˆ—çš„é•¿åº¦ã€‚\nå¯¹äºæŸä¸€ä¸ªæ•° nums[i]ï¼Œå·²çŸ¥å…¶ä¸å…¶ä¹‹å‰æŸä¸€ä¸ªæ•°çš„å·® diff = nums[i] - nums[j]ï¼Œéœ€è¦çŸ¥é“åœ¨ nums[j] ä¹‹å‰å…¬å·®ä¸º diff çš„ç­‰å·®å­åºåˆ—æœ‰å¤šé•¿ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨æ•°ç»„æ¥è¡¨ç¤ºæ¯ä¸€ä¸ªæ•°ä¹‹å‰å…¬å·®ä¸º diff çš„ç­‰å·®å­åºåˆ—çš„æœ€é•¿é•¿åº¦ï¼Œåœ¨æ­¤åŸºç¡€ä¸Š +1 å³å¯å¾—åˆ°æœ€é•¿çš„ç­‰å·®å­åºåˆ—çš„é•¿åº¦ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ã€‚\nclass Solution { public: int longestArithSeqLength(vector\u0026lt;int\u0026gt; \u0026amp;A) { int n = A.size(), res = 2; vector\u0026lt;unordered_map\u0026lt;int, int\u0026gt;\u0026gt; dp(n); for (int i = 1; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { int diff = A[i] - A[j]; if (dp[j].find(diff) == dp[j].end()) dp[i][diff] = 2; else { dp[i][diff] = dp[j][diff] + 1; res = max(res, dp[i][diff]); } } } return res; } }; 5. æ–æ³¢é‚£å¥‘æ•°åˆ— 70 çˆ¬æ¥¼æ¢¯ æ¯æ¬¡èƒ½çˆ¬ 1 æˆ– 2 é˜¶æ¥¼æ¢¯ï¼Œæ±‚çˆ¬ n é˜¶æ¥¼æ¢¯æœ‰å¤šå°‘ç§æ–¹æ³•ã€‚\nçˆ¬åˆ°å½“å‰æ¥¼æ¢¯çš„æ–¹æ³•ç­‰äºçˆ¬åˆ°å‰ä¸¤é˜¶æ¥¼æ¢¯çš„æ–¹æ³•ä¹‹å’Œï¼Œå› æ­¤æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i] = dp[i - 1] + dp[i - 2]ï¼Œåˆå› ä¸ºå½“å‰çŠ¶æ€åªå–å†³äºå‰ä¸¤ä¸ªçŠ¶æ€ï¼Œå› æ­¤å¯ä»¥åªä½¿ç”¨ä¸¤ä¸ªå˜é‡ s1 å’Œ s2 æ¥ä¿å­˜å‰ä¸¤ä¸ªçŠ¶æ€çš„ç»“æœã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: int climbStairs(int n) { if (n \u0026lt;= 1) return 1; int s1 = 1, s2 = 1, temp; for (int i = 1; i \u0026lt; n; ++i) { temp = s2; s2 += s1; s1 = temp; } return s2; } }; 746 ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ æ¯æ¬¡èƒ½çˆ¬ 1 æˆ– 2 é˜¶æ¥¼æ¢¯ï¼Œæ¯ä¸€é˜¶æ¥¼æ¢¯æœ‰ä¸€ä¸ªæƒå€¼ï¼Œæ±‚çˆ¬ n é˜¶æ¥¼æ¢¯çš„æœ€å°èŠ±è´¹ã€‚\nå’Œä¸Šä¸€é¢˜ç±»ä¼¼ï¼Œä¸è¿‡æ¯æ¬¡åªéœ€è¦å–å‰ä¸¤é˜¶æ¥¼æ¢¯ä¸­æƒå€¼è¾ƒå°çš„å°±å¯ä»¥äº†ã€‚\nclass Solution { public: int minCostClimbingStairs(vector\u0026lt;int\u0026gt;\u0026amp; cost) { int n = cost.size(); if (n == 0) return 0; else if (n == 1) return cost[0]; else if (n == 2) return cost[0] + cost[1]; int s1 = cost[0], s2 = cost[1]; for (int i = 2; i \u0026lt; n; ++i) { int temp = s2; s2 = min(s1, s2) + cost[i]; s1 = temp; } return min(s1, s2); } }; 740 åˆ é™¤ä¸è·å¾—ç‚¹æ•° ç»™ä¸€ä¸ªæ•°ç»„ï¼Œæ¯æ¬¡ä»»é€‰ä¸€ä¸ªÂ nums[i]ï¼Œè·å¾—Â nums[i] çš„ä¸ªæ•°ä¹˜ä»¥ nums[i] çš„ç‚¹æ•°ï¼Œè®¡ç®—èƒ½è·å¾—çš„æœ€å¤§ç‚¹æ•°ã€‚\nå¯¹äº nums[i]ï¼Œèƒ½å–åˆ°çš„æœ€å¤§ç‚¹æ•°åªèƒ½æ˜¯ nums[i - 1] çš„æœ€å¤§ç‚¹æ•°æˆ– nums[i - 2] çš„æœ€å¤§ç‚¹ä¹¦åŠ ä¸Š nums[i] èƒ½è·å¾—çš„ç‚¹æ•°ï¼Œå› æ­¤æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i] = max(dp[i - 1], dp[i - 2] + val[i])ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚æ¯ä¸ªç‚¹åªä¸å…¶ä¹‹å‰ä¸¤ä¸ªç‚¹æœ‰å…³ï¼Œå› æ­¤å¯ä»¥åªä½¿ç”¨ä¸¤ä¸ªå˜é‡ p1 å’Œ p2 æ¥ä¿å­˜å‰ä¸¤ä¸ªç‚¹çš„ç»“æœï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: int deleteAndEarn(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; val(10001, 0); for (auto \u0026amp;m:nums) val[m] += m; int res = 0, prev = 0, curr = 0; for (int i = 1; i \u0026lt;= 10000; ++i) { res = max(curr, prev + val[i]); prev = curr; curr = res; } return res; } }; 198 æ‰“å®¶åŠ«èˆ ç»™ä¸€ä¸ªå¸¦æƒå€¼çš„æ•°ç»„ï¼Œå–ä¸ç›¸é‚»çš„æ•°ï¼Œæ±‚èƒ½å–åˆ°çš„æœ€å¤§å€¼ã€‚\nå¯¹äºæŸä¸€ç‚¹ï¼Œå¦‚æœåˆ°ä¹‹å‰ä¸€ç‚¹ä¸ºæ­¢èƒ½å–åˆ°çš„æœ€å¤§å€¼å¤§äºå–å½“å‰ç‚¹ä¸ä¹‹å‰ä¸¤ç‚¹çš„æœ€å¤§å€¼çš„å’Œåˆ™ä¸å–ï¼Œå¦åˆ™å–å½“å‰ç‚¹ï¼Œå½“å‰ç‚¹çš„å€¼ä¸ä¹‹å‰ä¸¤ç‚¹çš„æœ€å¤§å€¼ä¹‹å’Œå°±æ˜¯å½“å‰ç‚¹çš„æœ€ä¼˜å€¼ï¼Œå› æ­¤æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚å½“å‰ç‚¹åªä¸ä¹‹å‰ä¸¤ä¸ªç‚¹æœ‰å…³ï¼Œå› æ­¤å¯ä»¥åªä½¿ç”¨ä¸¤ä¸ªå˜é‡ p1 å’Œ p2 æ¥ä¿å­˜å‰ä¸¤ä¸ªç‚¹çš„ç»“æœï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n \u0026lt;= 2) return n == 0 ? 0 : n == 1 ? nums[0] : max(nums[0], nums[1]); int p1 = nums[0], p2 = max(nums[0], nums[1]), temp; for (int i = 2; i \u0026lt; n; ++i) { temp = p2; p2 = max(p1 + nums[i], p2); p1 = temp; } return p2; } }; 213 æ‰“å®¶åŠ«èˆ II ç»™ä¸€ä¸ªå¸¦æƒå€¼çš„æ•°ç»„ï¼Œæ•°ç»„é¦–å°¾ç›¸é‚»ï¼Œå–ä¸ç›¸é‚»çš„æ•°ï¼Œæ±‚èƒ½å–åˆ°çš„æœ€å¤§å€¼ã€‚\næ•°ç»„é¦–å°¾ç›¸é‚»ä»£è¡¨ä¸èƒ½åŒæ—¶å–ç¬¬ä¸€ä¸ªç‚¹å’Œæœ€åä¸€ä¸ªç‚¹ï¼Œå› æ­¤ä»ç¬¬ä¸€ä¸ªç‚¹åˆ°å€’æ•°ç¬¬äºŒä¸ªç‚¹è¿›è¡ŒåŠ¨æ€è§„åˆ’å¾—åˆ°çš„å°±æ˜¯åŒ…å«ç¬¬ä¸€ä¸ªç‚¹è€Œä¸åŒ…å«æœ€åä¸€ä¸ªç‚¹èƒ½å–åˆ°çš„æœ€å¤§å€¼ï¼Œä»ç¬¬äºŒä¸ªç‚¹åˆ°æœ€åä¸€ä¸ªç‚¹è¿›è¡ŒåŠ¨æ€è§„åˆ’å¾—åˆ°çš„å°±æ˜¯åŒ…å«æœ€åä¸€ä¸ªç‚¹è€Œä¸åŒ…å«ç¬¬ä¸€ä¸ªç‚¹èƒ½å–åˆ°çš„æœ€å¤§å€¼ï¼Œç”¨äºä¸Šä¸€é¢˜åŒæ ·çš„æ–¹æ³•åˆ†åˆ«åšä¸¤æ¬¡å°±èƒ½å¾—åˆ°ç»“æœã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)ã€‚\nclass Solution {\rpublic:\rint rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) {\rint res = 0, n = nums.size();\rif (n \u0026lt;= 2)\rreturn n == 0 ? 0 : n == 1 ? nums[0] : max(nums[0], nums[1]);\rint p1 = nums[0], p2 = max(nums[0], nums[1]);\rfor (int i = 2; i \u0026lt; n - 1; ++i) {\rint temp = p2;\rp2 = max(p2, p1 + nums[i]);\rp1 = temp;\r}\rres = p2;\rp1 = nums[1], p2 = max(nums[1], nums[2]);\rfor (int i = 3; i \u0026lt; n; ++i) {\rint temp = p2;\rp2 = max(p2, p1 + nums[i]);\rp1 = temp;\r}\rreturn max(res, p2);\r}\r};\r337 æ‰“å®¶åŠ«èˆ III ç»™ä¸€ä¸ªå¸¦æƒå€¼çš„äºŒå‰æ ‘ï¼Œå–ä¸ç›¸é‚»çš„æ•°ï¼Œæ±‚èƒ½å–åˆ°çš„æœ€å¤§å€¼ã€‚\nå¯¹äºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœå–èŠ‚ç‚¹æœ¬èº«åˆ™ä¸èƒ½å–ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œå¦‚æœå–ä¸¤ä¸ªå­èŠ‚ç‚¹åˆ™ä¸èƒ½å»å…¶æœ¬èº«å’Œå››ä¸ªå­èŠ‚ç‚¹ï¼Œå› æ­¤å¯¹æ¯”å…¶ä¸¤ä¸ªå­èŠ‚ç‚¹çš„å’Œä¸å…¶æœ¬èº«å’Œå››ä¸ªå­™å­èŠ‚ç‚¹çš„å’Œï¼Œå–æœ€å¤§å€¼è¿”å›ï¼Œä¹Ÿå°±æ˜¯ max(dp[node-\u0026gt;left-\u0026gt;left] + dp [node-\u0026gt;left-\u0026gt;right] + dp[node-\u0026gt;right-\u0026gt;left] + dp [node-\u0026gt;right-\u0026gt;right] + dp[node], dp[node-\u0026gt;left] + dp[node-\u0026gt;right])ã€‚å› ä¸ºé€’å½’ä¼šé€ æˆå¤§é‡çš„é‡å¤è®¡ç®—ï¼Œå› æ­¤ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨æŠŠå·²ç»è®¡ç®—è¿‡çš„èŠ‚ç‚¹çš„æœ€ä¼˜å€¼ä¿å­˜ä¸‹æ¥ï¼Œé€’å½’åˆ°è¯¥èŠ‚ç‚¹çš„æ—¶å€™ç›´æ¥å–å€¼é˜²æ­¢é€ æˆTLEã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { unordered_map\u0026lt;TreeNode *, int\u0026gt; val; public: int rob(TreeNode *node) { if (!node) return 0; if (val.find(node) != val.end()) return val[node]; int p1 = 0, p2 = 0; if (node-\u0026gt;left) p1 += rob(node-\u0026gt;left-\u0026gt;left) + rob(node-\u0026gt;left-\u0026gt;right); if (node-\u0026gt;right) p1 += rob(node-\u0026gt;right-\u0026gt;left) + rob(node-\u0026gt;right-\u0026gt;right); p1 += node-\u0026gt;val; p2 += rob(node-\u0026gt;left) + rob(node-\u0026gt;right); val[node] = max(p1, p2); return val[node]; } } 96 ä¸åŒçš„äºŒå‰æœç´¢æ ‘ æ±‚æœ‰ n ä¸ªèŠ‚ç‚¹çš„äºŒå‰æœç´¢æ ‘æœ‰å¤šå°‘ç§ã€‚\nå¯¹äºæŸä¸€ä¸ªæ•° i ä½œä¸ºæ ¹ç»“ç‚¹æ—¶ï¼Œæ— è®º i æ˜¯å¤šå°‘ï¼Œå…¶å·¦å­æ ‘å·¦å­æ ‘æ€»æ˜¯ç”± i - 1 ä¸ªèŠ‚ç‚¹æ„æˆçš„ï¼Œè€Œå…¶å³èŠ‚ç‚¹æ€»æ˜¯ç”± n - i ä¸ªèŠ‚ç‚¹æ„æˆçš„ï¼Œä¾‹å¦‚ n = 3 æ—¶ï¼Œå¦‚æœè®© 3 ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå…¶å·¦å­æ ‘ä¸€å®šæ˜¯ç”± 1 å’Œ 2 ä¸¤ä¸ªèŠ‚ç‚¹æ„æˆçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦çŸ¥é“ç”±ä¸¤ä¸ªèŠ‚ç‚¹æ„æˆçš„äºŒå‰æœç´¢æ ‘æœ‰å¤šå°‘ç§ï¼Œå†ç”¨è¿™ä¸ªå·¦å­æ ‘çš„ç§ç±»æ•° dp[2] ä¹˜ä»¥å³å­æ ‘çš„ç§ç±»æ•° dp[0] å°±èƒ½çŸ¥é“ç”± 3 ä¸ªèŠ‚ç‚¹æ„æˆçš„ï¼Œä»¥ 3 ä½œä¸ºæ ¹èŠ‚ç‚¹çš„ç§ç±»æ•°ï¼Œå…¶æ¬¡éœ€è¦ä¾æ¬¡è®© 1 å’Œ 2 ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä»–ä»¬çš„å·¦å­æ ‘åˆ†åˆ«æœ‰ dp[0] å’Œ dp[1] ç§æ„æˆçš„æ–¹æ³•ï¼Œå› æ­¤å¾—åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i] += dp[j - 1] * dp[i - j]ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int numTrees(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, 0); dp[0] = dp[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= i; ++j) dp[i] += dp[j - 1] * dp[i - j]; return dp[n]; } }; 873 æœ€é•¿çš„æ–æ³¢é‚£å¥‘å­åºåˆ—çš„é•¿åº¦ ç»™ä¸€ä¸ªä¸¥æ ¼é€’å¢çš„æ•°ç»„ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿çš„æ–æ³¢é‚£å¥‘å­åºåˆ—çš„é•¿åº¦ã€‚\næ ¹æ®æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å®šä¹‰ï¼Œè¦åˆ¤æ–­ A[i] å’Œ A[j] èƒ½å¦åœ¨åŸæ•°ç»„ä¸­æ„æˆæ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œåªéœ€è¦çŸ¥é“ A[i - j] æ˜¯å¦åœ¨åŸæ•°ç»„ä¸­ï¼Œå¹¶ä¸” A[i] - A[j] \u0026lt; A[j] \u0026lt; A[i] æ˜¯å¦æˆç«‹ï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„ dp[n][n] æ¥ä»£è¡¨ç”± A[i] å’Œ A[j] ä»¥åŠ A[i - j] æ„æˆçš„æ–æ³¢é‚£å¥‘å­åºåˆ—çš„æœ€é•¿é•¿åº¦ã€‚ä¸ºäº†æŸ¥æ‰¾ A[i - j] æ˜¯å¦åœ¨åŸæ•°ç»„ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ pos æ¥ä¿å­˜ A[i - j] åœ¨åŸæ•°ç»„ä¸­çš„ä¸‹æ ‡ï¼Œè·å–ä¸‹æ ‡ k = pos[A[i] - A[j]] åï¼Œç”¨çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i][j] = dp[j][k] + 1 æ¥æ›´æ–°æœ€é•¿é•¿åº¦ã€‚\næ³¨æ„åœ¨åˆ¤æ–­ä¸‹æ ‡æ˜¯å¦å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­æ—¶è¦ç”¨ pos.find(A[i] - A[j]) == pos.end()ï¼Œè€Œä¸èƒ½ç›´æ¥ç”¨ pos[A[i] - A[j]] æ¥è·å–ï¼Œè¿™æ ·è™½ç„¶å¦‚æœ A[i] - A[j] ä¸å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­ä»ç„¶èƒ½å¤Ÿå¾—åˆ°ç»“æœ 0ï¼Œä½†æ•ˆç‡éå¸¸ä½ï¼Œä¼šå¯¼è‡´TLEã€‚\nclass Solution { public: int lenLongestFibSubseq(vector\u0026lt;int\u0026gt; \u0026amp;A) { int n = A.size(), res = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n, 0)); unordered_map\u0026lt;int, int\u0026gt; pos; for (int i = 0; i \u0026lt; n; ++i) { pos[A[i]] = i; for (int j = 0; j \u0026lt; i; ++j) { auto k = pos.find(A[i] - A[j]) == pos.end() ? -1 : pos[A[i] - A[j]]; dp[i][j] = A[i] - A[j] \u0026lt; A[j] \u0026amp;\u0026amp; k != -1 ? dp[j][k] + 1 : 2; res = max(res, dp[i][j]); } } return res \u0026lt; 3 ? 0 : res; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/dynamicprogramming-2/","summary":"LeetCode åŠ¨æ€è§„åˆ’ é¢˜ç›® 3. æ•°ç»„ç›¸å…³ 300 æœ€é•¿ä¸Šå‡å­åºåˆ— åœ¨æ— åºæ•°ç»„ä¸­æ‰¾åˆ°æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ã€‚\nç”¨ä¸€ä¸ªæ•°ç»„ dp[i] è¡¨ç¤ºåˆ°ç¬¬ i ä¸ªæ•°å­—ä¸ºæ­¢çš„æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼Œæ¯æ¬¡éå† i ä¹‹å‰çš„æ¯ä¸ªæ•°å­— jï¼Œå¦‚æœ nums[i] \u0026gt; nums[j]ï¼Œé‚£ä¹ˆ j å’Œ i å¯ä»¥å½¢æˆä¸€ä¸ªä¸Šå‡å­åºåˆ—ï¼Œè®© dp[i] = max(dp[i], dp[j] + 1) å°±èƒ½å¾—åˆ°æœ€é•¿çš„ä¸Šå‡å­åºåˆ—äº†ã€‚\nclass Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), res = 2; if (n \u0026lt;= 1) return n; vector\u0026lt;int\u0026gt; dp(n, 1); for (int i = 1; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; i; ++j) if (nums[i] \u0026gt; nums[j]) { dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); } return res; } }; 53 æœ€å¤§å­åºå’Œ æ‰¾ä¸€ä¸ªæ•°ç»„ä¸­å…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„çš„å’Œã€‚","title":"LeetCode åŠ¨æ€è§„åˆ’ï¼ˆ2ï¼‰"},{"content":"LeetCode åŠ¨æ€è§„åˆ’ é¢˜ç›® 1. æ•°å­—ç›¸å…³ 263 ä¸‘æ•° åˆ¤æ–­ä¸€ä¸ªæ•° num æ˜¯å¦æ˜¯ä¸‘æ•°ã€‚\né€šç”¨çš„æ–¹æ³•æ˜¯è‡ªåº•å‘ä¸Šæ±‚å‡ºå¤§äºç­‰äº num çš„ç¬¬ä¸€ä¸ªæ•°æ¥åˆ¤æ–­ num æ˜¯å¦æ˜¯ä¸‘æ•°ã€‚ä½†è¿™é“é¢˜å·²ç»ç»™å‡ºäº†æ•° numï¼Œç›´æ¥é€šè¿‡æ¨¡è¿ç®—å°±èƒ½å¾—åˆ°ç»“æœäº†ã€‚\nclass Solution { public: bool isUgly(int num) { if (num \u0026lt; 1) return false; while (num % 2 == 0) num /= 2; while (num % 3 == 0) num /= 3; while (num % 5 == 0) num /= 5; return num == 1; } }; 264 ä¸‘æ•° II æ±‚ç¬¬ n ä¸ªä¸‘æ•°ã€‚\nç”¨ä¸€ä¸ªæ•°ç»„ ugly æ¥ä¿å­˜å‰ m ä¸ªä¸‘æ•°ï¼Œç”¨ä¸‰ä¸ªè´¨å› æ•° 2ï¼Œ3ï¼Œ5 ä¹˜ä»¥å…¶å½“å‰ç³»æ•°å¯¹åº”çš„ä¸‘æ•°ï¼Œå¾—åˆ°æ–°çš„ä¸‘æ•°ï¼Œæœ€å°çš„ä¸€ä¸ªå°±æ˜¯ç¬¬ m + 1 ä¸ªä¸‘æ•°ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ï¼Œå…¶ä¸­ m æ˜¯è´¨å› æ•°çš„ä¸ªæ•°ï¼Œn æ˜¯è¦æ‰¾çš„ç¬¬ n ä¸ªä¸‘æ•°ã€‚\nclass Solution { public: int nthUglyNumber(int n) { vector\u0026lt;int\u0026gt; ugly(n, 1); int base_2 = 0, base_3 = 0, base_5 = 0; int m = INT_MAX; for (int i = 1; i \u0026lt; n; ++i) { ugly[i] = min({2 * ugly[base_2], 3 * ugly[base_3], 5 * ugly[base_5]}); if (2 * ugly[base_2] == ugly[i]) ++base_2; if (3 * ugly[base_3] == ugly[i]) ++base_3; if (5 * ugly[base_5] == ugly[i]) ++base_5; cout \u0026lt;\u0026lt; ugly[i] \u0026lt;\u0026lt; endl; } return ugly[n - 1]; } }; 313 è¶…çº§ä¸‘æ•° ç»™å®šè´¨å› æ•°æ•°ç»„ primesï¼Œæ±‚ç¬¬ n ä¸ªä¸‘æ•°ã€‚\nè·Ÿä¸Šä¸€é¢˜å®Œå…¨ç›¸åŒï¼Œåªæ˜¯æŠŠåŸæœ‰çš„ä¸‰ä¸ªè´¨å› æ•° 2ï¼Œ3ï¼Œ5 æ¢æˆäº†ä¸€ä¸ªæ•°ç»„ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n * m)ï¼Œå…¶ä¸­ n æ˜¯ç¬¬ n ä¸ªä¸‘æ•°ï¼Œm æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚\nclass Solution { public: int nthSuperUglyNumber(int N, vector\u0026lt;int\u0026gt;\u0026amp; primes) { int n = primes.size(), m = INT_MAX;; vector\u0026lt;int\u0026gt; ugly(N, 1), base(n, 0); for (int i = 1; i \u0026lt; N; ++i) { m = INT_MAX; for (int j = 0; j \u0026lt; n; ++j) m = min(m, primes[j] * ugly[base[j]]); ugly[i] = m; for (int j = 0; j \u0026lt; n; ++j) if (primes[j] * ugly[base[j]] == m) ++base[j]; } return ugly[N - 1]; } }; 279 å®Œå…¨å¹³æ–¹æ•° ç»™ä¸€ä¸ªæ•° nï¼Œå…¶å¯ä»¥è¢«è¡¨ç¤ºä¸º m ä¸ªå®Œå…¨å¹³æ–¹æ•°çš„ï¼Œæ‰¾åˆ°æœ€å°çš„ mã€‚\nn åªèƒ½ç”±æ¯” n å° 1, 4, 9 ç­‰ç­‰çš„æ•°çš„æœ€ä¼˜å€¼åŠ ä¸€å¾—åˆ°ï¼Œå› æ­¤ç”¨ä¸€ä¸ªæ•°ç»„ dp[n] ä¿å­˜å°äºç­‰äº n çš„æ•°è¢«è¡¨ç¤ºä¸º k ä¸ªå®Œå…¨å¹³æ–¹æ•°çš„å’Œçš„æœ€å°çš„ k çš„æ•°é‡ï¼Œæ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[n] = min({dp[n], dp[n - 1], dp[n - 4], dp[n - 9], \u0026hellip;}) + 1 è®¡ç®—å¾—åˆ°ç»“æœã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n * w)ï¼Œw æ˜¯æ¯” n å°çš„å®Œå…¨å¹³æ–¹æ•°çš„ä¸ªæ•°ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int numSquares(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, INT_MAX); dp[0] = 0, dp[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) for (int j = 1; i - j * j \u0026gt;= 0; ++j) dp[i] = min(dp[i], dp[i - j * j] + 1); return dp[n]; } }; 343 æ•´æ•°æ‹†åˆ† ç»™ä¸€ä¸ªæ•° nï¼Œå°†å…¶æ‹†åˆ†ä¸ºè‡³å°‘ä¸¤ä¸ªæ•°çš„å’Œï¼Œæ±‚è¿™äº›æ•´æ•°çš„æœ€å¤§ä¹˜ç§¯ã€‚\nn å¯ä»¥è¢«æ‹†åˆ†ä¸º 2 ä¸ªæ•°çš„å’Œï¼Œè¿™ä¸¤ä¸ªæ•°åˆå¯ä»¥è¢«æ‹†åˆ†ä¸ºè‹¥å¹²ä¸ªæ•°çš„å’Œï¼Œå› æ­¤åªéœ€è¦çŸ¥é“å…¶è¢«æ‹†åˆ†ä¸ºä¸¤ä¸ªæ•°æ—¶è¿™ä¸¤ä¸ªæ•°çš„æœ€å¤§ä¹˜ç§¯ï¼Œè‡ªä¸‹å¾€ä¸Šåœ°è®¡ç®—å°äºç­‰äº n çš„æ•°è¢«æ‹†åˆ†æ—¶çš„æœ€å¤§ä¹˜ç§¯å³å¯ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯ dp[i] = max(dp[i], dp[j] * dp[i - j])ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n ^ 2)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int integerBreak(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, 0); if (n \u0026lt; 3) return 1; if (n == 3) return 2; dp[2] = 2, dp[3] = 3; for (int i = 4; i \u0026lt;= n; ++i) for (int j = 1, k = i - j; j \u0026lt;= k; ++j, --k) dp[i] = max(dp[i], dp[j] * dp[k]); return dp[n]; } }; 1155 æ·éª°å­çš„ N ç§æ–¹æ³• å¯¹äºæ¯ä¸€ä¸ªéª°å­æ¥è¯´ï¼Œå®ƒå¯ä»¥åœ¨ä¹‹å‰çš„åŸºç¡€ä¸Šæœ‰ f ç§æŠ•æ·çš„æ–¹æ³•ï¼Œå®ƒä¹‹åçš„çŠ¶æ€æ˜¯ dp[i + 1][j + k]ï¼Œi æ˜¯æŠ•æ·è¿‡çš„éª°å­çš„ä¸ªæ•°ï¼Œk æ˜¯å®ƒæŠ•æ·ä¸åŒçš„ f ç§æ–¹æ³•ï¼Œj æ˜¯åˆ°å®ƒä¸ºæ­¢æŠ•æ·å‡ºå’Œä¸º j çš„ç§æ•°ï¼Œè‡ªä¸‹è€Œä¸ŠåŠ¨æ€è§„åˆ’å³å¯ã€‚\nclass Solution { public: int numRollsToTarget(int d, int f, int target) { int dp[d + 1][target + f + 1]; memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 0; i \u0026lt; d; ++i) for (int j = 0; j \u0026lt; target; ++j) if (dp[i][j]) for (int k = 1; k \u0026lt;= f; ++k) if (j + k \u0026lt;= target) dp[i + 1][j + k] = (dp[i + 1][j + k] + dp[i][j]) % 1000000007; return dp[d][target]; } }; 2. ä¹°å–è‚¡ç¥¨ 121 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº ç»™ä¸€ä¸ªè‚¡ç¥¨æ•°ç»„ï¼Œåªèƒ½è¿›è¡Œä¸€æ¬¡äº¤æ˜“ï¼Œæ±‚æœ€å¤§åˆ©æ¶¦ã€‚\næœ€å¤§åŒ–å½“å‰å€¼ä¸ä¹‹å‰çš„æœ€å°å€¼ä¹‹å·®ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int min_val = INT_MAX, res = 0; for (auto \u0026amp;p:prices) { min_val = min(min_val, p); res = max(res, p - min_val); } return res; } }; 122 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II ç»™ä¸€ä¸ªè‚¡ç¥¨æ•°ç»„ï¼Œä¸é™åˆ¶äº¤æ˜“æ¬¡æ•°ï¼Œæ±‚æœ€å¤§åˆ©æ¶¦ã€‚\næ¯ä¸€ä¸ªä¸¥æ ¼é€’å¢çš„åŒºé—´éƒ½æ˜¯äº¤æ˜“çš„æ—¶æœºï¼Œæ‰€ä»¥å°†ä¸¥æ ¼é€’å¢åŒºé—´å†…çš„å·®å€¼å…¨éƒ¨åŠ ä¸Šå³å¯ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { int res = 0; for (int i = 1; i \u0026lt; prices.size(); ++i) res += max(prices[i] - prices[i - 1], 0); return res; } }; 123 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III ç»™ä¸€ä¸ªè‚¡ç¥¨æ•°ç»„ï¼Œåªèƒ½è¿›è¡Œä¸¤ç¬”äº¤æ˜“ï¼Œæ±‚æœ€å¤§åˆ©æ¶¦ã€‚\nå› ä¸ºè¦è¿›è¡Œä¸¤ç¬”äº¤æ˜“ï¼Œæ‰€ä»¥éœ€è¦æœ€å¤§åŒ–ä¸¤ä¸ªå€¼ï¼šä¸€ä¸ªæ˜¯åˆ°ç¬¬ i å¤©ä¸ºæ­¢çš„æœ€å¤§æ”¶ç›Šï¼Œä¸€ä¸ªæ˜¯ç¬¬ i å¤©ä¹‹åçš„æœ€å¤§æ”¶ç›Šã€‚ç¬¬ä¸€ç§æ–¹æ³•æ˜¯ä¸¤æ¬¡éå†ï¼Œç¬¬ä¸€æ¬¡è®¡ç®—åˆ°ç¬¬ i å¤©ä¸ºæ­¢çš„æœ€å¤§æ”¶ç›Šï¼Œç¬¬äºŒæ¬¡åå‘éå†è®¡ç®—ç¬¬ i å¤©ä¹‹åçš„æœ€å¤§æ”¶ç›Šï¼Œæ–¹æ³•è·Ÿç¬¬ä¸€é¢˜ç›¸åŒï¼Œæ³¨æ„ç¬¬äºŒæ¬¡ä¹°å…¥æ“ä½œå¿…é¡»åœ¨ç¬¬ä¸€æ¬¡å–å‡ºæ“ä½œä¹‹åï¼Œä¸èƒ½å‘ç”Ÿåœ¨åŒä¸€å¤©ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { int n = prices.size(), pre_min = INT_MAX, post_max = 0, res = 0; vector\u0026lt;int\u0026gt; pre(n, 0), post(n, 0); for (int i = 0; i \u0026lt; n - 1; ++i) { pre_min = min(pre_min, prices[i]); pre[i] = max(pre[max(0, i - 1)], prices[i] - pre_min); } for (int i = n - 1; i \u0026gt;= 0; --i) { post_max = max(post_max, prices[i]); post[i] = max(post[min(n - 1, i + 1)], post_max - prices[i]); } for (int i = 0; i \u0026lt; n; ++i) res = max(res, pre[i] + post[i]); return res; } }; ç¬¬äºŒç§æ–¹æ³•åˆ™æ˜¯åŸºäºæ¯å¤©åªæœ‰å››ç§å¯èƒ½çš„æ“ä½œï¼šç¬¬ä¸€æ¬¡ä¹°å…¥ï¼Œç¬¬ä¸€æ¬¡å–å‡º res1ï¼Œç¬¬äºŒæ¬¡ä¹°å…¥ï¼Œå’Œç¬¬äºŒæ¬¡å–å‡º res2ã€‚ç¬¬ä¸€æ¬¡ä¹°å…¥éœ€è¦æœ€å¤§åŒ–ä¹‹å‰ä¹°å…¥è‚¡ç¥¨çš„æœ€å°èŠ±è´¹ï¼Œç¬¬ä¸€æ¬¡å–å‡ºéœ€è¦æœ€å¤§åŒ–åˆ°ç¬¬ i å¤©ä¸ºæ­¢çš„è‚¡ç¥¨ä»·æ ¼ä¸ç¬¬ä¸€æ¬¡ä¹°å…¥çš„å·®å€¼ï¼Œç¬¬äºŒæ¬¡ä¹°å…¥éœ€è¦æœ€å¤§åŒ–åœ¨ç¬¬ i å¤©ä¹°å…¥è‚¡ç¥¨å¹¶å‡å»ç¬¬ä¸€æ¬¡å–å‡ºçš„æ”¶ç›Šï¼Œæœ€åç¬¬äºŒæ¬¡å–å‡ºéœ€è¦æœ€å¤§åŒ–åˆ°ç¬¬ i å¤©ä¸ºæ­¢çš„è‚¡ç¥¨ä»·æ ¼ä¸ç¬¬äºŒæ¬¡ä¹°å…¥çš„å·®å€¼ã€‚æœ€åå¾—åˆ°ç¬¬äºŒæ¬¡å–å‡ºçš„æœ€ä¼˜å€¼ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { int buy1 = INT_MIN, sell1 = 0, buy2 = INT_MIN, sell2 = 0; for (auto \u0026amp;p:prices) { buy1 = max(buy1, -p); sell1 = max(sell1, p + buy1); buy2 = max(buy2, sell1 - p); sell2 = max(sell2, p + buy2); cout \u0026lt;\u0026lt; buy1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; sell1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; buy2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; sell2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; endl; } return sell2; } }; 309 æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ ç»™ä¸€ä¸ªè‚¡ç¥¨æ•°ç»„ï¼Œä¸é™åˆ¶äº¤æ˜“æ¬¡æ•°ï¼Œå–å‡ºå’Œä¹°å…¥ä¹‹é—´éœ€è¦éš”ä¸€å¤©ï¼Œæ±‚æœ€å¤§åˆ©æ¶¦ã€‚\nå’Œä¸Šä¸€é¢˜çš„ç¬¬äºŒç§æ–¹æ³•ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸¤ä¸ªæ•°ç»„ buy å’Œ sell åˆ†åˆ«è¡¨ç¤ºä¹°å…¥å’Œå–å‡ºæ“ä½œï¼Œå¯¹äºä¹°å…¥æ“ä½œï¼Œéœ€è¦æœ€å¤§åŒ–ä¸¤å¤©å‰å–å‡ºçš„æœ€ä¼˜å€¼äºä»Šå¤©ä¹°å…¥çš„å·®å€¼ï¼Œå¯¹äºå–å‡ºæ“ä½œï¼Œéœ€è¦æœ€å¤§åŒ–å½“å¤©ä»·æ ¼ä¸å‰ä¸€å¤©ä¹°å…¥çš„æœ€ä¼˜å€¼çš„å·®å€¼ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (n \u0026lt; 2) return 0; vector\u0026lt;int\u0026gt; buy(n, 0), sell(n, 0); buy[0] = -prices[0], sell[0] = 0; for (int i = 1; i \u0026lt; n; ++i) { buy[i] = max(buy[i - 1], sell[max(0, i - 2)] - prices[i]); sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]); } return sell[n - 1]; } }; 714 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹ ç»™ä¸€ä¸ªè‚¡ç¥¨æ•°ç»„ï¼Œä¸é™åˆ¶äº¤æ˜“æ¬¡æ•°ï¼Œæ¯æ¬¡å–å‡ºæœ‰ä¸€å®šæ‰‹ç»­è´¹ï¼Œæ±‚æœ€å¤§åˆ©æ¶¦ã€‚\nå’Œä¸Šä¸€é¢˜ç±»ä¼¼ï¼ŒåŒºåˆ«åœ¨äºæ²¡æœ‰äº†äº¤æ˜“é—´éš”ï¼Œä»¥åŠæ¯æ¬¡è¿›è¡Œ sell æ“ä½œçš„æ—¶å€™éœ€è¦å‡å»æ‰‹ç»­è´¹ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices, int fee) { int n = prices.size(); if (n \u0026lt; 2) return 0; vector\u0026lt;int\u0026gt; buy(n, 0), sell(n, 0); buy[0] = -prices[0]; for (int i = 1; i \u0026lt; n; ++i) { buy[i] = max(buy[i - 1], sell[i - 1] - prices[i]); sell[i] = max(sell[i - 1], buy[i - 1] + prices[i] - fee); } return sell[n - 1]; } }; 188 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IV ç»™ä¸€ä¸ªè‚¡ç¥¨æ•°ç»„ï¼Œæœ€å¤šèƒ½è¿›è¡Œ k ç¬”äº¤æ˜“ï¼Œæ±‚æœ€å¤§åˆ©æ¶¦ã€‚\næŠŠä¸Šé¢äº”é“é¢˜éƒ½åšå®Œä¹‹åè¿™é“é¢˜å°±å¾ˆç®€å•äº†ã€‚ç›¸æ¯”äºç¬¬äºŒé¢˜ï¼Œå› ä¸ºè¿™é“é¢˜çš„ k æ˜¯æœªçŸ¥çš„ï¼Œæ‰€ä»¥è¦ç”¨ä¸€ä¸ªå¾ªç¯å°†æ‰€æœ‰å¯èƒ½çš„ k ç¬”äº¤æ˜“çš„æœ€ä¼˜å€¼éƒ½è®¡ç®—å‡ºæ¥ï¼Œå› æ­¤ç”¨ä¸€ä¸ªä¸‰ç»´æ•°ç»„ dp[n][k][2]ï¼Œæˆ–æ˜¯åˆ†å¼€æˆä¸¤ä¸ªäºŒç»´æ•°ç»„ buy[n][k] å’Œ sell[n][k]ï¼Œæ¥è¡¨ç¤ºå‰ n å¤©è¿›è¡Œ k ç¬”äº¤æ˜“çš„æœ€ä¼˜çš„ä¹°å…¥å’Œå–å‡ºå€¼ã€‚åŒæ ·çš„ï¼Œä¹°å…¥å’Œå–å‡ºæ“ä½œéƒ½æ˜¯åœ¨ä¹‹å‰ä¸€æ¬¡çš„å–å‡ºå’Œä¹°å…¥çš„åŸºç¡€ä¸Šè¿›è¡Œçš„ï¼Œä½¿ç”¨ buy[i][j] = max({buy[i][j - 1], buy[i - 1][j], sell[i - 1][j - 1] - prices[i]}) æ¥è¡¨ç¤ºå‰ i å¤©è¿›è¡Œäº† j æ¬¡äº¤æ˜“çš„æœ€ä¼˜çš„ä¹°å…¥å€¼ï¼Œç¬¬ä¸€é¡¹åœ¨ j \u0026lt;= i / 2 æ—¶ä¼šå¡«å……ä¸º buy[i][j - 1]çš„å€¼ï¼Œé˜²æ­¢åé¢æ“ä½œæ—¶ä¸ä¼šå–åˆ°ç©ºå€¼æˆ–é»˜è®¤å€¼é€ æˆé”™è¯¯ï¼Œç¬¬äºŒé¡¹æ˜¯å½“å‰ä¹°å…¥æ“ä½œä¸èƒ½å–å¾—æœ€ä¼˜å€¼çš„ç»“æœï¼Œç¬¬ä¸‰é¡¹åˆ™æ˜¯å½“å‰ä¹°å…¥æ“ä½œèƒ½å–å¾—æœ€ä¼˜å€¼çš„ç»“æœï¼›å¯¹åº”çš„å–å‡ºæ“ä½œåˆ™æ˜¯ sell[i][j] = max({sell[i][j - 1], sell[i - 1][j], buy[i - 1][j] + prices[i]})ã€‚\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå½“ k è¿œå¤§äºæ•°ç»„é•¿åº¦çš„ä¸¤å€ï¼Œæˆ– k éå¸¸å¤§æ—¶ï¼Œæ„é€ äºŒç»´æ•°ç»„ä¼šé€ æˆMLEï¼Œæ­¤æ—¶å¯ä»¥ç›´æ¥ç”¨ç¬¬äºŒé¢˜çš„æ€è·¯è§£å†³ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n * k)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(n * k)ã€‚\nclass Solution { public: int maxProfit(int k, vector\u0026lt;int\u0026gt; \u0026amp;prices) { int n = prices.size(), res = 0; if (n \u0026lt; 2 || k == 0) return 0; if (k \u0026gt;= n * 2) { for (int i = 1; i \u0026lt; n; ++i) res += max(0, prices[i] - prices[i - 1]); return res; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; buy(n, vector\u0026lt;int\u0026gt;(k, INT_MIN)), sell(n, vector\u0026lt;int\u0026gt;(k, 0)); buy[0][0] = -prices[0], sell[0][0] = 0; for (int i = 1; i \u0026lt; n; ++i) { buy[i][0] = max(buy[i - 1][0], -prices[i]); sell[i][0] = max(sell[i - 1][0], buy[i - 1][0] + prices[i]); for (int j = 1; j \u0026lt; k; ++j) { buy[i][j] = max({buy[i][j - 1], buy[i - 1][j], sell[i - 1][j - 1] - prices[i]}); sell[i][j] = max({sell[i][j - 1], sell[i - 1][j], buy[i - 1][j] + prices[i]}); } } return sell[n - 1][k - 1]; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/dynamicprogramming-1/","summary":"LeetCode åŠ¨æ€è§„åˆ’ é¢˜ç›® 1. æ•°å­—ç›¸å…³ 263 ä¸‘æ•° åˆ¤æ–­ä¸€ä¸ªæ•° num æ˜¯å¦æ˜¯ä¸‘æ•°ã€‚\né€šç”¨çš„æ–¹æ³•æ˜¯è‡ªåº•å‘ä¸Šæ±‚å‡ºå¤§äºç­‰äº num çš„ç¬¬ä¸€ä¸ªæ•°æ¥åˆ¤æ–­ num æ˜¯å¦æ˜¯ä¸‘æ•°ã€‚ä½†è¿™é“é¢˜å·²ç»ç»™å‡ºäº†æ•° numï¼Œç›´æ¥é€šè¿‡æ¨¡è¿ç®—å°±èƒ½å¾—åˆ°ç»“æœäº†ã€‚\nclass Solution { public: bool isUgly(int num) { if (num \u0026lt; 1) return false; while (num % 2 == 0) num /= 2; while (num % 3 == 0) num /= 3; while (num % 5 == 0) num /= 5; return num == 1; } }; 264 ä¸‘æ•° II æ±‚ç¬¬ n ä¸ªä¸‘æ•°ã€‚\nç”¨ä¸€ä¸ªæ•°ç»„ ugly æ¥ä¿å­˜å‰ m ä¸ªä¸‘æ•°ï¼Œç”¨ä¸‰ä¸ªè´¨å› æ•° 2ï¼Œ3ï¼Œ5 ä¹˜ä»¥å…¶å½“å‰ç³»æ•°å¯¹åº”çš„ä¸‘æ•°ï¼Œå¾—åˆ°æ–°çš„ä¸‘æ•°ï¼Œæœ€å°çš„ä¸€ä¸ªå°±æ˜¯ç¬¬ m + 1 ä¸ªä¸‘æ•°ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(m * n)ï¼Œå…¶ä¸­ m æ˜¯è´¨å› æ•°çš„ä¸ªæ•°ï¼Œn æ˜¯è¦æ‰¾çš„ç¬¬ n ä¸ªä¸‘æ•°ã€‚","title":"LeetCode åŠ¨æ€è§„åˆ’ï¼ˆ1ï¼‰"},{"content":"LeetCode äºŒåˆ†æŸ¥æ‰¾ äºŒåˆ†æŸ¥æ‰¾å¯ä»¥åœ¨æœ‰åºæ•°ç»„ä¸­ä»¥è¾ƒé«˜çš„æ•ˆç‡æŸ¥æ‰¾ç¬¦åˆæ¡ä»¶çš„å€¼ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(logN)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯O(1)ã€‚\næ˜“é”™ç‚¹   è®¡ç®—ä¸­é—´å€¼çš„æ–¹æ³•\n k = i + (j - i) / 2 k = (i + j) / 2  ç¬¬äºŒç§æ–¹æ³•ä¸€èˆ¬éƒ½ä¼šé€ æˆæ•´å‹æ•°æ®æº¢å‡ºï¼Œæ‰€ä»¥åªç”¨ç¬¬ä¸€ç§æ–¹æ³•ã€‚\n  å¾ªç¯æ¡ä»¶\n  å¦‚æœè¦æ‰¾å”¯ä¸€çš„å€¼ï¼Œä¸”ä¸‹é™iå’Œä¸Šé™jéƒ½ä¼šåœ¨æ›´æ–°æ—¶åœ¨ä¸­é—´å€¼kçš„åŸºç¡€ä¸Š+1æˆ–-1ï¼Œé‚£ä¹ˆå¾ªç¯æ¡ä»¶æ˜¯ i \u0026lt;= jï¼Œjèƒ½è¢«å–åˆ°ï¼Œj = nums.size() - 1ï¼Œè®¡ç®—ä¸­é—´å€¼ç”¨ k = i + (j - i + 1) / 2\n  å¦‚æœè¦æ‰¾å¤§äºç­‰äºæˆ–å°äºç­‰äºæŸæ¡ä»¶çš„å€¼ï¼Œä¸”ä¸‹é™iå’Œä¸Šé™jå…¶ä¸­ä¹‹ä¸€ä¸ä¼šåœ¨kçš„åŸºç¡€ä¸Š+1æˆ–-1ï¼Œé‚£ä¹ˆå¾ªç¯æ¡ä»¶æ˜¯ i \u0026lt; jï¼Œjä¸èƒ½è¢«å–åˆ°ï¼Œj = nums.size()ï¼Œè®¡ç®—ä¸­é—´å€¼ç”¨ k = i + (j - i) / 2\n  ä¸¤ç§æ–¹æ³•æœ‰å„è‡ªçš„åº”ç”¨åœºæ™¯ï¼Œæ²¡ç”¨å¯¹çš„è¯ä¼šå‡ºç°è¾¹ç•Œå€¼çš„é—®é¢˜ï¼Œæˆ–æ˜¯æ­»å¾ªç¯å¯¼è‡´TLEã€‚\n  é¢˜ç›® 1. æŸ¥æ‰¾æ•° 704 äºŒåˆ†æŸ¥æ‰¾ åœ¨æœ‰åºæ•°ç»„ä¸­æœç´¢ç›®æ ‡å€¼ï¼Œå¦‚æœå­˜åœ¨åˆ™è¿”å›ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1ã€‚\næœ€æ ‡å‡†çš„äºŒåˆ†æŸ¥æ‰¾ã€‚å› ä¸ºä¸‹é™iå’Œä¸Šé™jéƒ½ä¼šåœ¨æ›´æ–°æ—¶+1å’Œ-1ï¼Œæ‰€ä»¥è®©j = nums.size() - 1ï¼Œå¾ªç¯æ¡ä»¶æ˜¯ i \u0026lt;= jã€‚\nclass Solution { public: int search(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int i = 0, j = nums.size() - 1, k = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; if (nums[k] \u0026gt; target) j = k - 1; else if (nums[k] \u0026lt; target) i = k + 1; else return k; } return -1; } }; 374 çŒœæ•°å­—å¤§å° ä»Â 1Â åˆ°Â nÂ é€‰æ‹©ä¸€ä¸ªæ•°å­—ï¼Œé€šè¿‡ä¸€ä¸ªé¢„å®šä¹‰çš„æ¥å£Â guess(int num)å¾—åˆ°-1ï¼šæ•°å­—æ‰“äº†ï¼›1ï¼šæ•°å­—å°äº†ï¼›0ï¼šçŒœå¯¹äº†ã€‚\nè·Ÿä¸Šä¸€é¢˜å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œåªæ˜¯æŠŠtargetæ¢æˆäº†ä¸€ä¸ªæ¥å£ã€‚\nint guess(int num); class Solution { public: int guessNumber(int n) { int i = 1, j = n, k = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; auto res = guess(k); if (res == 1) i = k + 1; else if (res == -1) j = k - 1; else return k; } return 0; } }; 367 æœ‰æ•ˆçš„å®Œå…¨å¹³æ–¹æ•° åˆ¤æ–­ä¸€ä¸ªæ­£æ•´æ•°æ˜¯å¦æ˜¯ä¸€ä¸ªå®Œå…¨å¹³æ–¹æ•°ã€‚\nåˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦æ˜¯å®Œå…¨å¹³æ–¹æ•°ã€‚å› ä¸ºåœ¨äºŒåˆ†çš„è¿‡ç¨‹ä¸­å¹³æ–¹å¾—åˆ°çš„ç»“æœå¯èƒ½ä¼šè¶…è¿‡32ä½intå‹çš„ä¸Šé™ï¼Œæ‰€ä»¥ç”¨long longã€‚\nclass Solution { public: bool isPerfectSquare(int num) { long long i = 0, j = num, k = 0, res = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; res = k * k; if (res \u0026lt; num) i = k + 1; else if (res \u0026gt; num) j = k - 1; else return true; } return j * j == num; } }; 69 xçš„å¹³æ–¹æ ¹ è®¡ç®—ä¸€ä¸ªæ•°çš„å¹³æ–¹æ ¹ï¼Œåªä¿ç•™æ•´æ•°éƒ¨åˆ†ã€‚\nå®ç°int sqrt(int x)å‡½æ•°ã€‚ç”¨å•†æ¥åˆ¤æ–­æ¯”ç”¨ä¹˜ç§¯æ¥åˆ¤æ–­æ›´ç›´è§‚ã€‚\nclass Solution { public: int mySqrt(int x) { if (x \u0026lt;= 1) return x; int i = 1, j = x, k = 0, sqrt = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; sqrt = x / k; if (sqrt \u0026lt; k) j = k - 1; else if (sqrt \u0026gt; k) i = k + 1; else return k; } return j; } }; 2. æŸ¥æ‰¾ä¸Šç•Œ/ä¸‹ç•Œ 35 æœç´¢æ’å…¥ä½ç½® åœ¨æœ‰åºæ•°ç»„ä¸­æ‰¾åˆ°ç›®æ ‡å€¼ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›å®ƒå°†ä¼šè¢«æŒ‰é¡ºåºæ’å…¥çš„ä½ç½®ï¼Œæ•°ç»„ä¸­æ— é‡å¤å…ƒç´ ã€‚\næ‰¾åˆ°å¤§äºç­‰äºtargetçš„ç¬¬ä¸€ä¸ªæ•°ã€‚å› ä¸ºä¸Šé™jåœ¨æ›´æ–°æ—¶ä¼šç›´æ¥è¢«èµ‹ç»™kçš„å€¼ï¼Œæ‰€ä»¥è®©j = nums.size()ï¼Œå¾ªç¯æ¡ä»¶æ˜¯i \u0026lt; jã€‚\nclass Solution { public: int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int i = 0, j = nums.size(), k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; if (nums[k] \u0026lt; target) i = k + 1; else if (nums[k] \u0026gt; target) j = k; else return k; } return j; } }; 744 å¯»æ‰¾æ¯”ç›®æ ‡å­—æ¯å¤§çš„æœ€å°å­—æ¯ åœ¨æœ‰åºæ•°ç»„ä¸­æ‰¾åˆ°æ¯”ç›®æ ‡å­—æ¯å¤§çš„æœ€å°å­—æ¯ï¼Œæ•°ç»„é‡Œçš„å­—æ¯æ˜¯å¾ªç¯çš„ã€‚\næ‰¾åˆ°å¤§äºtargetçš„ç¬¬ä¸€ä¸ªæ•°ï¼Œç›¸æ¯”äºä¸Šä¸€é¢˜åªæ˜¯å°‘äº†åœ¨å¾ªç¯å†…åˆ¤æ–­æ˜¯å¦ç­‰äºçš„æƒ…å†µã€‚ä»intç±»å‹æ•°ç»„å˜æˆäº†charç±»å‹æ•°ç»„ï¼Œä¸è¿‡è¿™ä¸€ç‚¹å¹¶æ²¡æœ‰ä»»ä½•å½±å“ã€‚\nclass Solution { public: char nextGreatestLetter(vector\u0026lt;char\u0026gt;\u0026amp; letters, char target) { int n = letters.size(), i = 0, j = n, k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; if (letters[k] \u0026lt;= target) i = k + 1; else if (letters[k] \u0026gt; target) j = k; } return j \u0026lt; n ? letters[j] : letters[0]; } }; 278 ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬ äº§å“éƒ½æ˜¯åŸºäºä¹‹å‰çš„ç‰ˆæœ¬å¼€å‘çš„ï¼Œæ‰€æœ‰é”™è¯¯çš„ç‰ˆæœ¬ä¹‹åçš„æ‰€æœ‰ç‰ˆæœ¬éƒ½æ˜¯é”™çš„ï¼Œæ‰¾åˆ°å‡ºé”™çš„ç¬¬ä¸€ä¸ªç‰ˆæœ¬ã€‚é€šè¿‡ä¸€ä¸ªæ¥å£Â bool isBadVersion(version)Â æ¥åˆ¤æ–­ç‰ˆæœ¬æ˜¯å¦å‡ºé”™ã€‚\nå¾ˆæ ‡å‡†çš„æ‰¾ä¸‹ç•Œã€‚\nbool isBadVersion(int version); class Solution { public: int firstBadVersion(long long n) { long long i = 0, j = n + 1, k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; if (!isBadVersion(k)) i = k + 1; else j = k; } return j; } }; 875 çˆ±åƒé¦™è•‰çš„ç‚ç‚ æœ‰ N å †é¦™è•‰ï¼Œæ¯å°æ—¶å†…åƒå®Œä¸€å †åˆ™ä¸åƒå¦å¤–ä¸€å †ï¼Œè®¡ç®—èƒ½åœ¨ H å°æ—¶å†…åƒå®Œçš„æœ€æ…¢é€Ÿåº¦ã€‚\nå°†é€Ÿåº¦ä½œä¸ºäºŒåˆ†æŸ¥æ‰¾çš„å˜é‡ï¼Œæ¯æ¬¡åˆ¤æ–­ä»¥å½“å‰é€Ÿåº¦æ˜¯å¦èƒ½åƒå®Œæ‰€æœ‰é¦™è•‰ï¼Œå¦‚æœèƒ½åˆ™ j = kï¼Œk æœ‰å¯èƒ½æ˜¯æœ€åçš„ç»“æœï¼Œå¦åˆ™ i = k + 1ï¼Œæ­¤æ—¶çš„ k ä¸€å®šæ¯”ç»“æœå°ã€‚\nclass Solution { public: int minEatingSpeed(vector\u0026lt;int\u0026gt;\u0026amp; piles, int H) { int i = 1, j = INT_MAX, k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; int res = CanEatAll(k, H, piles); if (res) j = k; else i = k + 1; } return j; } bool CanEatAll(const int \u0026amp;speed, int hour, vector\u0026lt;int\u0026gt;\u0026amp; piles) { for (auto \u0026amp;p:piles) hour -= p / speed + (p % speed \u0026gt; 0); return hour \u0026gt;= 0; } }; 3. æ ¹æ®ä½ç½®å…³ç³»æŸ¥æ‰¾ 378 æœ‰åºçŸ©é˜µä¸­ç¬¬Kå°çš„å…ƒç´  n x n çš„çŸ©é˜µä¸­æ¯è¡Œå’Œæ¯åˆ—å‡æŒ‰å‡åºæ’åºï¼Œæ‰¾åˆ°çŸ©é˜µä¸­ç¬¬kå°çš„å…ƒç´ ã€‚\nè¿™é“é¢˜å¯ä»¥ç”¨è·Ÿå‰‘æŒ‡offeré‡ŒäºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾è¿™é“é¢˜çš„æ€è·¯ç»“åˆäºŒåˆ†æŸ¥æ‰¾æ¥åšï¼ŒäºŒåˆ†çš„æ—¶å€™æ¯æ¬¡è®¡ç®—çŸ©é˜µé‡Œå°äºç­‰äºä¸­é—´å€¼çš„æ•°çš„ä¸ªæ•°å°±èƒ½å¾—åˆ°ç»“æœäº†ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(logm * n)ï¼Œm æ˜¯ matrix[n - 1][n - 1]ï¼Œn æ˜¯ matrix.size()ã€‚\nclass Solution { public: int kthSmallest(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int m) { int n = matrix.size(), i = matrix[0][0], j = matrix[n - 1][n - 1] + 1, k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; auto res = CountLess(matrix, k); if (res \u0026lt; m) i = k + 1; else j = k; } return i; } int CountLess(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, const int \u0026amp;target) { int n = matrix.size(), i = 0, j = n - 1, res = 0; while (i \u0026lt; n \u0026amp;\u0026amp; j \u0026gt;= 0) { if (matrix[i][j] \u0026lt;= target) res += j + 1, ++i; else --j; } return res; } }; 153 å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ ä¸€ä¸ªæœ‰åºæ•°ç»„åœ¨æŸä¸ªç‚¹ä¸Šè¿›è¡Œäº†æ—‹è½¬ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€å°çš„å…ƒç´ ã€‚\næ ¹æ®ä¸­é—´å€¼ä¸å·¦å³è¾¹å€¼å’Œå…¶å·¦å³è¾¹ä¸€ä½çš„å¤§å°å…³ç³»æ¥åˆ¤æ–­ï¼Œå¦‚æœä¸­é—´å€¼kæ¯”å·¦è¾¹å€¼å°ï¼Œé‚£ä¹ˆkæœ‰å¯èƒ½æ˜¯ç»“æœï¼Œè®© j = k ï¼›å¦åˆ™æ¯”è¾ƒä¸­é—´å€¼ä¸å…¶å³è¾¹ä¸€ä½ï¼Œå¦‚æœä¸­é—´å€¼å¤§äºå³è¾¹ä¸€ä½çš„å€¼ï¼Œé‚£ä¹ˆå³è¾¹ä¸€ä½çš„å€¼å°±æ˜¯ç»“æœï¼Œå¦åˆ™è®© i = k + 1ã€‚\nclass Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), i = 0, j = nums.size(), k = 0; if (n == 1 || nums[0] \u0026lt; nums[n - 1]) return nums[0]; else if (n == 2) return min(nums[0], nums[1]); while (i \u0026lt; j) { k = i + (j - i) / 2; if (nums[i] \u0026gt; nums[k]) j = k; else if (k + 1 \u0026lt; j \u0026amp;\u0026amp; nums[k + 1] \u0026gt; nums[i]) i = k + 1; else return nums[k + 1]; } return j \u0026gt;= n ? nums[i] : min(nums[i], nums[j]); } }; 540 æœ‰åºæ•°ç»„ä¸­çš„å•ä¸€å…ƒç´  ä¸€ä¸ªæœ‰åºæ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ éƒ½ä¼šå‡ºç°äº†ä¸¤æ¬¡ï¼Œåªæœ‰ä¸€ä¸ªæ•°å‡ºç°äº†ä¸€æ¬¡ï¼Œæ‰¾å‡ºè¿™ä¸ªæ•°ã€‚\næœ‰åºæ•°ç»„é‡Œå…¶ä»–æ¯ä¸ªå…ƒç´ éƒ½å‡ºç°ä¸¤æ¬¡ï¼Œæ‰¾åˆ°å”¯ä¸€åªå‡ºç°ä¸€æ¬¡çš„æ•°ã€‚åœ¨å”¯ä¸€çš„æ•°å‡ºç°ä¹‹åå¥‡å¶ä½çš„ç›¸ç­‰å…³ç³»ä¼šå‘ç”Ÿå˜åŒ–ï¼Œåˆ©ç”¨è¿™ä¸€ç‚¹æ¥åšåˆ¤æ–­ã€‚æ¯”è¾ƒç›´è§‚çš„å†™æ³•æ˜¯åˆ†åˆ«åˆ¤æ–­ k % 2 == 0 å’Œ k % 2 == 1 çš„æƒ…å†µï¼Œè¿™æ ·å†™èµ·æ¥æ¯”è¾ƒå¤æ‚ï¼Œå¯ä»¥ç›´æ¥åœ¨ k % 2 == 1 çš„æ—¶å€™ \u0026ndash;kï¼Œå†ç›´æ¥åˆ¤æ–­ nums[k] å’Œ nums[k + 1] çš„å…³ç³»ã€‚\nclass Solution { public: int singleNonDuplicate(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0, j = nums.size() - 1, k = 0, n = nums.size(); while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; endl; if (k % 2 == 0) { if (k + 1 \u0026lt; n \u0026amp;\u0026amp; nums[k] == nums[k + 1]) i = k + 1; else if (k - 1 \u0026gt;= 0 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) j = k - 1; else return nums[k]; } else { if (k + 1 \u0026lt; n \u0026amp;\u0026amp; nums[k] == nums[k + 1]) j = k - 1; else if (k - 1 \u0026gt;= 0 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) i = k + 1; else return nums[k]; } } return 0; } }; class Solution { public: int singleNonDuplicate(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0, j = nums.size(), k = 0, n = nums.size(); while (i \u0026lt; j) { k = i + (j - i) / 2; if (k % 2 == 1) --k; if (k + 1 \u0026lt; n \u0026amp;\u0026amp; nums[k] == nums[k + 1]) i = k + 2; else j = k; } return nums[j]; } }; 4. ç»¼åˆ 1095 å±±è„‰æ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼ åœ¨ä¸€ä¸ªå±±è„‰æ•°ç»„ä¸­æ‰¾åˆ°ç­‰äºç›®æ ‡å€¼çš„æœ€å°ä¸‹æ ‡ã€‚\nå› ä¸ºå·²çŸ¥æ•°ç»„ä¸€å®šæ˜¯ä¸€ä¸ªå±±è„‰æ•°ç»„ï¼Œæ‰€ä»¥ä¸€å®šæœ‰å”¯ä¸€çš„å±±é¡¶ï¼Œç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°å±±é¡¶çš„ä¸‹æ ‡ã€‚å¦‚æœå±±é¡¶å°äºç›®æ ‡å€¼é‚£ä¹ˆæ•°ç»„ä¸­ä¸€å®šæ²¡æœ‰ç›®æ ‡å€¼å­˜åœ¨ï¼Œè¿”å› -1ï¼Œå¦åˆ™åœ¨å±±é¡¶å·¦è¾¹ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾ç›®æ ‡å€¼ï¼Œæ²¡æœ‰çš„è¯åˆ™åœ¨å±±é¡¶å³è¾¹ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾ç›®æ ‡å€¼ã€‚\nclass Solution { public: int findInMountainArray(int target, MountainArray \u0026amp;mountainArr) { int n = mountainArr.length(), i = 0, j = n - 1, k = 0, peak = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; if (mountainArr.get(k) \u0026gt; mountainArr.get(k - 1) \u0026amp;\u0026amp; mountainArr.get(k) \u0026gt; mountainArr.get(k + 1)) break; else if (mountainArr.get(k) \u0026lt; mountainArr.get(k - 1)) j = k - 1; else i = k + 1; } if (mountainArr.get(k) \u0026lt; target) return -1; else if (mountainArr.get(k) == target) return k; peak = k; i = 0, j = peak; while (i \u0026lt; j) { k = i + (j - i) / 2; if (mountainArr.get(k) \u0026lt; target) i = k + 1; else j = k; } if (mountainArr.get(j) == target) return j; i = peak + 1, j = n; while (i \u0026lt; j) { k = i + (j - i) / 2; if (mountainArr.get(k) \u0026lt; target) j = k - 1; else if (mountainArr.get(k) \u0026gt; target) i = k + 1; else j = k; } if (i \u0026lt; n \u0026amp;\u0026amp; mountainArr.get(i) == target) return i; return -1; } }; 5. çŒœæ•° 719 æ‰¾å‡ºç¬¬ k å°çš„è·ç¦»å¯¹ æœ€ç®€å•çš„åšæ³•éå†ä¸¤éç®—å‡ºæ‰€æœ‰æ•°å¯¹çš„å·®å€¼ä¿å­˜åœ¨ä¸€ä¸ªå°æ ¹å †ä¸­ï¼Œç„¶åä¾æ¬¡æ‰¾åˆ°å°äºç­‰äº k çš„æœ€å°è·ç¦»ï¼Œä½†è¿™æ ·åšæ—¶é—´å¤æ‚åº¦æ˜¯ O(n ^ 2) ä¼šè¶…æ—¶ã€‚æˆ‘ä»¬å¯ä»¥å…ˆå°†æ•°ç»„æ’åºï¼Œç„¶åç”¨ low = 0, high = nums[n - 1] - nums[0] è¡¨ç¤ºå¯èƒ½ç»“æœçš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œç”¨äºŒåˆ†æ³•æ¥åˆ¤æ–­ä¸­é—´å€¼ mid æ˜¯å¦æ»¡è¶³å°äºç­‰äº mid çš„æ•°å¯¹å·®å€¼çš„æ•°æ˜¯å¦å°äºç­‰äº kï¼Œåˆ¤æ–­æ—¶å› ä¸ºæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œå¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆè®©ä¸­é—´çš„å·®å€¼ç»´æŒåœ¨å°äºç­‰äº midï¼Œä»è€Œè®¡ç®—å‡ºå°äºç­‰äº mid çš„æ•°å¯¹å·®å€¼çš„æ•°ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogn + nlogm)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ï¼Œm æ˜¯æ•°ç»„æœ€å¤§å€¼ä¸æœ€å°å€¼ä¹‹å·®ï¼Œnlogn æ˜¯æ’åºçš„å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼Œè€Œ nlogm ä¸­ n æ˜¯ä½¿ç”¨åŒæŒ‡é’ˆåˆ¤æ–­çš„æ—¶é—´å¤æ‚åº¦ï¼Œlogm æ˜¯äºŒåˆ†æ³•çš„æ—¶é—´å¤æ‚åº¦ã€‚\nclass Solution { public: int smallestDistancePair(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { sort(nums.begin(), nums.end()); int n = nums.size(), low = 0, high = nums[n - 1] - nums[0], mid = 0; while (low \u0026lt; high) { mid = low + (high - low) / 2; if (IsDistMoreThanK(nums, mid, k)) high = mid; else low = mid + 1; } return high; } bool IsDistMoreThanK(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int m, const int \u0026amp;k) { int left = 0, right = 0, count = 0; while (right \u0026lt; nums.size()) { while (nums[right] - nums[left] \u0026gt; m) ++left; count += right - left; ++right; } return count \u0026gt;= k; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/binarysearch/","summary":"LeetCode äºŒåˆ†æŸ¥æ‰¾ äºŒåˆ†æŸ¥æ‰¾å¯ä»¥åœ¨æœ‰åºæ•°ç»„ä¸­ä»¥è¾ƒé«˜çš„æ•ˆç‡æŸ¥æ‰¾ç¬¦åˆæ¡ä»¶çš„å€¼ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(logN)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯O(1)ã€‚\næ˜“é”™ç‚¹   è®¡ç®—ä¸­é—´å€¼çš„æ–¹æ³•\n k = i + (j - i) / 2 k = (i + j) / 2  ç¬¬äºŒç§æ–¹æ³•ä¸€èˆ¬éƒ½ä¼šé€ æˆæ•´å‹æ•°æ®æº¢å‡ºï¼Œæ‰€ä»¥åªç”¨ç¬¬ä¸€ç§æ–¹æ³•ã€‚\n  å¾ªç¯æ¡ä»¶\n  å¦‚æœè¦æ‰¾å”¯ä¸€çš„å€¼ï¼Œä¸”ä¸‹é™iå’Œä¸Šé™jéƒ½ä¼šåœ¨æ›´æ–°æ—¶åœ¨ä¸­é—´å€¼kçš„åŸºç¡€ä¸Š+1æˆ–-1ï¼Œé‚£ä¹ˆå¾ªç¯æ¡ä»¶æ˜¯ i \u0026lt;= jï¼Œjèƒ½è¢«å–åˆ°ï¼Œj = nums.size() - 1ï¼Œè®¡ç®—ä¸­é—´å€¼ç”¨ k = i + (j - i + 1) / 2\n  å¦‚æœè¦æ‰¾å¤§äºç­‰äºæˆ–å°äºç­‰äºæŸæ¡ä»¶çš„å€¼ï¼Œä¸”ä¸‹é™iå’Œä¸Šé™jå…¶ä¸­ä¹‹ä¸€ä¸ä¼šåœ¨kçš„åŸºç¡€ä¸Š+1æˆ–-1ï¼Œé‚£ä¹ˆå¾ªç¯æ¡ä»¶æ˜¯ i \u0026lt; jï¼Œjä¸èƒ½è¢«å–åˆ°ï¼Œj = nums.size()ï¼Œè®¡ç®—ä¸­é—´å€¼ç”¨ k = i + (j - i) / 2\n  ä¸¤ç§æ–¹æ³•æœ‰å„è‡ªçš„åº”ç”¨åœºæ™¯ï¼Œæ²¡ç”¨å¯¹çš„è¯ä¼šå‡ºç°è¾¹ç•Œå€¼çš„é—®é¢˜ï¼Œæˆ–æ˜¯æ­»å¾ªç¯å¯¼è‡´TLEã€‚","title":"LeetCode äºŒåˆ†æŸ¥æ‰¾"},{"content":"LeetCode ä½è¿ç®— ä½è¿ç®—åŒ…æ‹¬ï¼š\n ä¸ \u0026amp; æˆ– | å¼‚æˆ– ^ å–å ~ å·¦ç§» \u0026laquo; å³ç§» \u0026raquo;  æŠ€å·§   ç§»ä½è¿ç®—\n x \u0026laquo; 1ï¼šç®—æ•°å·¦ç§»  æ•°å­—çš„äºŒè¿›åˆ¶è¡¨ç¤ºçš„æ‰€æœ‰ä½å‘å·¦ç§»åŠ¨ä¸€ä½ï¼Œç›¸å½“äºä¹˜ä»¥ 2 åœ¨å³è¾¹è¡¥ 0   x \u0026raquo; 1ï¼šç®—æ•°å³ç§»  æ•°å­—çš„äºŒè¿›åˆ¶è¡¨ç¤ºçš„æ‰€æœ‰ä½å‘å³ç§»åŠ¨ä¸€ä½ï¼Œç›¸å½“äºé™¤ä»¥ 2 åœ¨å·¦è¾¹è¡¥ç¬¦å·ä½ï¼Œå³æ­£æ•°è¡¥ 0ï¼Œè´Ÿæ•°ï¼ˆåœ¨è¡¥ç çš„åŸºç¡€ä¸Šï¼‰è¡¥ 1   è´Ÿæ•°ç§»ä½  è´Ÿæ•°æ˜¯ä»¥è¡¥ç çš„å½¢å¼å­˜å‚¨çš„ï¼Œè´Ÿæ•°è¿›è¡Œå³ç§»è¿ç®—æ—¶éœ€è¦å°†å…¶å–åè½¬æ¢æˆåç ï¼ŒåŠ ä¸€è½¬æ¢æˆè¡¥ç ï¼Œå†å°†å…¶å‘å³ç§»åŠ¨ä¸€ä½å¾—åˆ°æ–°çš„è¡¥ç ï¼Œå†å°†å…¶å‡ä¸€å¾—åˆ°æ–°çš„åç ï¼Œå†å–åè½¬æ¢æˆåŸç æ‰èƒ½å¾—åˆ°ç»“æœã€‚ä¾‹å¦‚ -7 çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ˜¯ 10000111ï¼ˆå› ä¸º 32 ä½å¤ªé•¿æ‰€ä»¥è¿™é‡Œç”¨ 8 ä½ int å‹è¡¨ç¤ºï¼‰ï¼Œå…¶åç æ˜¯ 11111000ï¼Œè¡¥ç æ˜¯11111001ï¼Œå‘å³ç§»åŠ¨ä¸€ä½æ˜¯ 11111100ï¼Œå‡ä¸€å¾—åˆ°æ–°çš„åç  11111011ï¼ŒåŸç æ˜¯10000100ï¼Œä¹Ÿå°±æ˜¯ -4ï¼›è¡¥ç å‘å·¦ç§»ä¸€ä½æ˜¯ 11110010ï¼Œå‡ä¸€å¾—åˆ°æ–°çš„åç  11110001ï¼ŒåŸç æ˜¯ 10001110ï¼Œä¹Ÿå°±æ˜¯ -14 æ¯”è¾ƒç®€å•çš„ç†è§£æ–¹å¼æ˜¯å·¦ç§»ä¹˜ä»¥ 2ï¼Œå³ç§»é™¤ä»¥ 2ã€‚ä¾‹å¦‚ -7 \u0026raquo; 1 = -7 / 2 = -4ï¼Œ-7 \u0026laquo; 1 = -14      é¢˜ç›® 1. å•ä¸ªæ•°å­— 693 äº¤æ›¿ä½äºŒè¿›åˆ¶æ•° æ£€æŸ¥ä¸€ä¸ªäºŒè¿›åˆ¶æ•°ç›¸é‚»çš„ä¸¤ä¸ªä½æ•°æ˜¯å¦å‡ä¸ç›¸ç­‰ã€‚\né€ä½ \u0026amp; 1 è¿›è¡Œåˆ¤æ–­å³å¯ã€‚\nclass Solution { public: bool hasAlternatingBits(int n) { bool rel = n \u0026amp; 1; while (n \u0026gt; 0 \u0026amp;\u0026amp; (n \u0026amp; 1) == rel) { rel = !rel; n \u0026gt;\u0026gt;= 1; } return n \u0026lt;= 0; } }; 476 æ•°å­—çš„è¡¥æ•° ç»™ä¸€ä¸ªæ­£æ•´æ•°ï¼Œæ±‚äºŒè¿›åˆ¶è¡¨ç¤ºå–åçš„ç»“æœï¼Œå–åä¸åŒ…æ‹¬å‰å¯¼ 0ã€‚\nå¯¹æ¯ä¸€ä½å¼‚æˆ– 1 å³å¯ã€‚å°†å¤§äº num çš„ç¬¬ä¸€ä¸ª 2 ^ n çš„æ•°å‡ä¸€å³å¯å¾—åˆ°äºŒè¿›åˆ¶è¡¨ç¤ºå…¨æ˜¯ 1 çš„ï¼Œä½æ•°ç­‰äº num çš„ä½æ•°çš„æ•°ã€‚\nclass Solution { public: int findComplement(int num) { long long util = 1; while (util \u0026lt;= num) util \u0026lt;\u0026lt;= 1; return num ^ (util - 1); } }; 461 æ±‰æ˜è·ç¦» è®¡ç®—ä¸¤ä¸ªæ•´æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºåœ¨å„ä½ä¸Šä¸åŒçš„æ•°ç›®ã€‚\né€ä½è¿›è¡Œå¼‚æˆ–åˆ¤æ–­å³å¯ã€‚\nclass Solution { public: int hammingDistance(int x, int y) { int res = 0; while (x \u0026gt; 0 || y \u0026gt; 0) { res += ((x \u0026amp; 1) ^ (y \u0026amp; 1)); x \u0026gt;\u0026gt;= 1, y \u0026gt;\u0026gt;= 1; } return res; } }; 762 äºŒè¿›åˆ¶è¡¨ç¤ºä¸­è´¨æ•°ä¸ªè®¡ç®—ç½®ä½ è®¡ç®— [L, R] ä¸­ç½®ä½ä½æ•°ä¸ºè´¨æ•°çš„ä¸ªæ•°ã€‚\nå…ˆé€ä½åˆ¤æ–­æ•° i åœ¨å½“å‰ä½ä¸Šæ˜¯å¦ç­‰ä¸€ 1ï¼Œå¾—åˆ°ç½®ä½ä½æ•°ååˆ¤æ–­æ˜¯å¦æ˜¯è´¨æ•°ã€‚åˆ¤æ–­è´¨æ•°çš„æ—¶å€™å¯ä»¥å…ˆæ’é™¤æ‰æ¨¡ä»¥ 6 ç­‰äº 0, 2, 3, 4 çš„æƒ…å†µï¼Œå› ä¸ºè¿™å‡ ç§æƒ…å†µåˆ†åˆ«å¯ä»¥è¢« 6, 2, 3, 2 æ•´é™¤ï¼Œå‰©ä¸‹çš„å†åˆ¤æ–­å…¶æ¨¡ä»¥ 6n - 1 å’Œ 6n + 1 æ˜¯å¦ç­‰äº 0 å³å¯ã€‚è¿˜å¯ä»¥å…ˆæŠŠå°äºç­‰äº 32 çš„è´¨æ•°å­˜å‚¨åœ¨å“ˆå¸Œè¡¨æˆ–æ•°ç»„ä¸­ï¼Œè¿™æ ·çš„è¯æŸ¥è¯¢æ—¶é—´ä¼šé™ä½ä¸€äº›ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œn æ˜¯ [L, R] çš„ä¸ªæ•°ã€‚\nclass Solution { public: int countPrimeSetBits(int L, int R) { int res = 0; for (int i = L; i \u0026lt;= R; ++i) { int m = i; int cnt = 0; while (m \u0026gt; 0) { if (m \u0026amp; 1) ++cnt; m \u0026gt;\u0026gt;= 1; } if (IsPrime(cnt)) ++res; } return res; } bool IsPrime(int num) { if (num \u0026lt; 4) return num \u0026gt; 1; else if (num % 6 != 1 \u0026amp;\u0026amp; num % 6 != 5) return false; for (int i = 5; i \u0026lt;= sqrt(num); i += 6) if (num % i == 0 || num % (i + 2) == 0) return false; return true; } }; 136 åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— ç»™ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä»–æ•°éƒ½å‡ºç°äº†ä¸¤æ¬¡ï¼Œåªæœ‰ä¸€ä¸ªæ•°å‡ºç°äº†ä¸€æ¬¡ï¼Œæ‰¾åˆ°è¿™ä¸ªæ•°ã€‚\nå› ä¸º a ^ a = 0ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ 0 å¼‚æˆ–è¿™ä¸ªæ•°ç»„ä¸­çš„æ‰€æœ‰æ•°ï¼Œæœ€åå¾—åˆ°çš„å°±æ˜¯å”¯ä¸€çš„ä¸€ä¸ªæ•°ã€‚\nclass Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = 0; for (auto \u0026amp;m:nums) res ^= m; return res; } }; ","permalink":"http://zintrulcre.github.io/posts/leetcode/bitmanipulation/","summary":"LeetCode ä½è¿ç®— ä½è¿ç®—åŒ…æ‹¬ï¼š\n ä¸ \u0026amp; æˆ– | å¼‚æˆ– ^ å–å ~ å·¦ç§» \u0026laquo; å³ç§» \u0026raquo;  æŠ€å·§   ç§»ä½è¿ç®—\n x \u0026laquo; 1ï¼šç®—æ•°å·¦ç§»  æ•°å­—çš„äºŒè¿›åˆ¶è¡¨ç¤ºçš„æ‰€æœ‰ä½å‘å·¦ç§»åŠ¨ä¸€ä½ï¼Œç›¸å½“äºä¹˜ä»¥ 2 åœ¨å³è¾¹è¡¥ 0   x \u0026raquo; 1ï¼šç®—æ•°å³ç§»  æ•°å­—çš„äºŒè¿›åˆ¶è¡¨ç¤ºçš„æ‰€æœ‰ä½å‘å³ç§»åŠ¨ä¸€ä½ï¼Œç›¸å½“äºé™¤ä»¥ 2 åœ¨å·¦è¾¹è¡¥ç¬¦å·ä½ï¼Œå³æ­£æ•°è¡¥ 0ï¼Œè´Ÿæ•°ï¼ˆåœ¨è¡¥ç çš„åŸºç¡€ä¸Šï¼‰è¡¥ 1   è´Ÿæ•°ç§»ä½  è´Ÿæ•°æ˜¯ä»¥è¡¥ç çš„å½¢å¼å­˜å‚¨çš„ï¼Œè´Ÿæ•°è¿›è¡Œå³ç§»è¿ç®—æ—¶éœ€è¦å°†å…¶å–åè½¬æ¢æˆåç ï¼ŒåŠ ä¸€è½¬æ¢æˆè¡¥ç ï¼Œå†å°†å…¶å‘å³ç§»åŠ¨ä¸€ä½å¾—åˆ°æ–°çš„è¡¥ç ï¼Œå†å°†å…¶å‡ä¸€å¾—åˆ°æ–°çš„åç ï¼Œå†å–åè½¬æ¢æˆåŸç æ‰èƒ½å¾—åˆ°ç»“æœã€‚ä¾‹å¦‚ -7 çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ˜¯ 10000111ï¼ˆå› ä¸º 32 ä½å¤ªé•¿æ‰€ä»¥è¿™é‡Œç”¨ 8 ä½ int å‹è¡¨ç¤ºï¼‰ï¼Œå…¶åç æ˜¯ 11111000ï¼Œè¡¥ç æ˜¯11111001ï¼Œå‘å³ç§»åŠ¨ä¸€ä½æ˜¯ 11111100ï¼Œå‡ä¸€å¾—åˆ°æ–°çš„åç  11111011ï¼ŒåŸç æ˜¯10000100ï¼Œä¹Ÿå°±æ˜¯ -4ï¼›è¡¥ç å‘å·¦ç§»ä¸€ä½æ˜¯ 11110010ï¼Œå‡ä¸€å¾—åˆ°æ–°çš„åç  11110001ï¼ŒåŸç æ˜¯ 10001110ï¼Œä¹Ÿå°±æ˜¯ -14 æ¯”è¾ƒç®€å•çš„ç†è§£æ–¹å¼æ˜¯å·¦ç§»ä¹˜ä»¥ 2ï¼Œå³ç§»é™¤ä»¥ 2ã€‚ä¾‹å¦‚ -7 \u0026raquo; 1 = -7 / 2 = -4ï¼Œ-7 \u0026laquo; 1 = -14      é¢˜ç›® 1.","title":"LeetCode ä½è¿ç®—"},{"content":"Kick Start 2019 Round C Wiggle Walk (6pts, 12pts) åœ¨ä¸€ä¸ªR * Cçš„çŸ©é˜µé‡Œé¢ç§»åŠ¨ï¼Œé‡åˆ°å·²ç»èµ°è¿‡çš„æ ¼å­ç›´æ¥è·³è¿‡ã€‚æ•°æ®ä¿è¯ç§»åŠ¨æ—¶ä¸ä¼šè¶…å‡ºç»™å®šçš„çŸ©é˜µã€‚\nSolution: Simulation ç”¨ä¸€ä¸ªvisitedæ•°ç»„è®°å½•å·²ç»èµ°è¿‡çš„æ ¼å­ï¼Œé‡åˆ°èµ°è¿‡çš„æ ¼å­åˆ™ç›´æ¥è·³è¿‡å¾€åéå†ã€‚è®²é“ç†è¿™ä¸ªæ–¹æ³•æ—¶é—´å¤æ‚åº¦æ˜¯è¿‡ä¸äº†Hidden Test Setçš„ï¼Œä½†æ˜¯æˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆå°±è¿‡äº†ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(n^2) ç©ºé—´å¤æ‚åº¦ï¼šO(n^2)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(50001, vector\u0026lt;bool\u0026gt;(50001, false)); void Forward(char \u0026amp;p, int \u0026amp;r, int \u0026amp;c) { if (p == \u0026#39;E\u0026#39;) { while (visited[r][c + 1]) ++c; visited[r][++c] = true; } else if (p == \u0026#39;W\u0026#39;) { while (visited[r][c - 1]) --c; visited[r][--c] = true; } else if (p == \u0026#39;N\u0026#39;) { while (visited[r - 1][c]) --r; visited[--r][c] = true; } else if (p == \u0026#39;S\u0026#39;) { while (visited[r + 1][c]) ++r; visited[++r][c] = true; } } void solve(const int \u0026amp;t) { int n, R, C, r, c; string str; scanf(\u0026#34;%d %d %d %d %d\u0026#34;, \u0026amp;n, \u0026amp;R, \u0026amp;C, \u0026amp;r, \u0026amp;c); cin \u0026gt;\u0026gt; str; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(50001, vector\u0026lt;bool\u0026gt;(50001, false)); visited[r][c] = true; for (int i = 0; i \u0026lt; n; ++i) Forward(str[i], r, c); printf(\u0026#34;Case #%d: %d %d\\n\u0026#34;, t, r, c); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) solve(t); return 0; } Circuit Board (14pts, 20pts) åœ¨çŸ©é˜µé‡Œæ‰¾åˆ°æ¯ä¸€è¡Œæœ€å¤§å€¼ä¸æœ€å°å€¼ä¸è¶…è¿‡Kçš„æœ€å¤§å­çŸ©é˜µã€‚\nSolution: Dynamic Programming å®šä¹‰ä¸€ä¸ªçŸ©é˜µlen[r][c]æ¥ä¿å­˜æ ¼å­r, cåœ¨rè¡Œä¸Šç¬¦åˆæ¡ä»¶çš„æœ€é•¿æ•°ç»„ã€‚å› ä¸ºé¢˜ç›®è¦æ±‚æ˜¯éœ€è¦ä¿è¯æ¯ä¸€è¡Œçš„æœ€å¤§å€¼ä¸æœ€å°å€¼ä¸è¶…è¿‡Kï¼Œè¡Œä¸è¡Œä¹‹é—´æ˜¯æ²¡æœ‰å…³ç³»çš„ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸€ä¸ªæ ¼å­ï¼Œéå†è¯¥åˆ—ä¸Šçš„æ‰€æœ‰æ ¼å­ï¼Œæ‰¾åˆ°è¿™äº›æ ¼å­èƒ½å¤Ÿåˆ°è¾¾çš„æœ€è¿œçš„ä½ç½®ï¼Œå–æœ€å°å€¼ï¼Œç”¨å½“å‰çš„é«˜åº¦ä¹˜æœ€è¿œä½ç½®å°±èƒ½å¾—åˆ°ç­”æ¡ˆã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(RRC) ç©ºé—´å¤æ‚åº¦ï¼šO(RC)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; void solve(const int \u0026amp;t) { int R, C, K; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;R, \u0026amp;C, \u0026amp;K); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; len(301, vector\u0026lt;int\u0026gt;(301, 1)), matrix(301, vector\u0026lt;int\u0026gt;(301)); for (int r = 0; r \u0026lt; R; ++r) for (int c = 0; c \u0026lt; C; ++c) scanf(\u0026#34;%d\u0026#34;, \u0026amp;matrix[r][c]); for (int r = 0; r \u0026lt; R; ++r) { for (int c = 0; c \u0026lt; C; ++c) { int i = c - 1, current_max = matrix[r][c], current_min = matrix[r][c]; while (i \u0026gt;= 0) { current_max = max(current_max, matrix[r][i]); current_min = min(current_min, matrix[r][i]); if (current_max - current_min \u0026gt; K) break; --i; } len[r][c] = c - i; } } int res = 1; for (int r = 0; r \u0026lt; R; ++r) { for (int c = 0; c \u0026lt; C; ++c) { int min_c = len[r][c]; for (int line = r; line \u0026gt;= 0; --line) { min_c = min(min_c, len[line][c]); res = max(res, min_c * (r - line + 1)); } } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, t, res); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) solve(t); return 0; } Catch Some (18pts, 30pts) // TODO\n","permalink":"http://zintrulcre.github.io/posts/kick-start/2019-round-c/","summary":"Kick Start 2019 Round C Wiggle Walk (6pts, 12pts) åœ¨ä¸€ä¸ªR * Cçš„çŸ©é˜µé‡Œé¢ç§»åŠ¨ï¼Œé‡åˆ°å·²ç»èµ°è¿‡çš„æ ¼å­ç›´æ¥è·³è¿‡ã€‚æ•°æ®ä¿è¯ç§»åŠ¨æ—¶ä¸ä¼šè¶…å‡ºç»™å®šçš„çŸ©é˜µã€‚\nSolution: Simulation ç”¨ä¸€ä¸ªvisitedæ•°ç»„è®°å½•å·²ç»èµ°è¿‡çš„æ ¼å­ï¼Œé‡åˆ°èµ°è¿‡çš„æ ¼å­åˆ™ç›´æ¥è·³è¿‡å¾€åéå†ã€‚è®²é“ç†è¿™ä¸ªæ–¹æ³•æ—¶é—´å¤æ‚åº¦æ˜¯è¿‡ä¸äº†Hidden Test Setçš„ï¼Œä½†æ˜¯æˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆå°±è¿‡äº†ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(n^2) ç©ºé—´å¤æ‚åº¦ï¼šO(n^2)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(50001, vector\u0026lt;bool\u0026gt;(50001, false)); void Forward(char \u0026amp;p, int \u0026amp;r, int \u0026amp;c) { if (p == \u0026#39;E\u0026#39;) { while (visited[r][c + 1]) ++c; visited[r][++c] = true; } else if (p == \u0026#39;W\u0026#39;) { while (visited[r][c - 1]) --c; visited[r][--c] = true; } else if (p == \u0026#39;N\u0026#39;) { while (visited[r - 1][c]) --r; visited[--r][c] = true; } else if (p == \u0026#39;S\u0026#39;) { while (visited[r + 1][c]) ++r; visited[++r][c] = true; } } void solve(const int \u0026amp;t) { int n, R, C, r, c; string str; scanf(\u0026#34;%d %d %d %d %d\u0026#34;, \u0026amp;n, \u0026amp;R, \u0026amp;C, \u0026amp;r, \u0026amp;c); cin \u0026gt;\u0026gt; str; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(50001, vector\u0026lt;bool\u0026gt;(50001, false)); visited[r][c] = true; for (int i = 0; i \u0026lt; n; ++i) Forward(str[i], r, c); printf(\u0026#34;Case #%d: %d %d\\n\u0026#34;, t, r, c); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) solve(t); return 0; } Circuit Board (14pts, 20pts) åœ¨çŸ©é˜µé‡Œæ‰¾åˆ°æ¯ä¸€è¡Œæœ€å¤§å€¼ä¸æœ€å°å€¼ä¸è¶…è¿‡Kçš„æœ€å¤§å­çŸ©é˜µã€‚","title":"Kick Start 2019 Round C"},{"content":"Object Detection Object detection deals with detecting instances of objects of a certain class, such as humans, animals, etc, in digital images and videos. Object detection has applications in many areas of computer vision, including image retrieval, face detection, video surveillance, and self-driving, etc. Current detection systems repurpose classifiers to perform detection. To detect an object, these systems take a classifier for that object and evaluate it at various locations and scales in a test image.\nObject detection has made important progress in recent years. Mainstream algorithms are divided into two types: (1) two-stage detectors, such as R-CNN algorithm. The main idea is to adopt the heuristic method (selective search) first, or regional proposal network (RPN) to generate a series of sparse candidate boxes, and then classifies and returns these candidate boxes. This kind of approach needs two shots to detect objects, one for generating region proposals, one for detecting the object of each proposal. Such models reach the highest accuracy rate, but are typically slower; (2) single-stage detectors, such as YOLO (You Only Look Once) and SSD (Single Shot MultiBox Detector), that treat object detection as a simple regression problem by taking an input image and learning the class probabilities and bounding box coordinates. The main idea is to uniformly sample at different positions of the image. Different scales and aspect ratios can be used for sampling. Then, using convolutional neural networks to extract features and directly classify and return, the whole process only needs a single step, so its advantage is Fast. But an important disadvantage of uniform sampling is that the training is difficult, mainly because the positive and negative samples are extremely unbalanced, resulting in slightly lower model accuracy.\n![](https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Deep-Learning/YOLOv3 Inference Time.png)\nYOLO Sliding Window Image detection is harder than image recognition because, in image detection, there can be multiple objects, or even maybe even multiple objects of different categories within a single image. At this time, sliding windows can help. We define a window of some size and put the window over a region on the image. Then feeding the input region to the convolutional neural network model to get an output. Likewise, we repeat this process on each and every region of the image with a certain stride. Once done, we take a window of other sizes (longer, wider, etc) and slide the window over the image, and repeat this process again and again. We may probably end up with a window of the size of a snake in the image and seeing the model to output a breed for that window, meaning we detect a snake in that particular region.\nBounding Box One of the disadvantages of sliding windows is the computational cost. As we crop out many square regions in the image, we run each region on a model independently. We may think of using a bigger window as it will reduce computation but, as a cost, the accuracy will decrease dramatically. Bounding boxes are the boxes that enclose the object in an image. The idea of bounding boxes is to divide the image into grids and then for each grid we define our Y label with some arguments. P is the probability that there is an object in the grid cell. If P equals to 0, then the other arguments are all ignored. Bx, By, Bh, Bw are respectively the x coordinate, the y coordinate, the height, the width of the bounding box. C1, C2\u0026hellip; Cn refers to the class probability that the object is of a specific class. The number of classes may vary, depending on whether itâ€™s a Binary Classification or Multi-Class Classification. If a grid contains an object, i.e. P equals to 1, then we know there is an object in a certain region of the image. Now there are some issues we should consider, including how big is the size of the grid, which grid among all the girds whose P equals to 1 is responsible for outputting a bounding box for the object that span over multiple grids, etc. Usually, in practice 19 by 19 grid is used and the grid responsible for outputting the Bounding-Box for a particular object is the grid that contains the mid-point of the object. And, one more advantage of using 19 by 19 grid is that the chance of mid-point of the object appearing in two grid cells is smaller.\nIntersection Over Union IOU means to divide the intersection of the bounding box and the true rectangle edge of the object by the union of them. The concept of intersection over union comes in to determine how accurate are these predictions. Suppose there are multiple bounding boxes an object in some grids, what intersection over union tells us is how close our prediction is to the ground truth. Then if the result is high enough (namely, greater than equal to a certain threshold) then the prediction is considered to be correct else we need to work on other bounding boxes.\nNon-Max Suppression After doing intersection over union, for a prediction of a single object which spans over multiple grids, each grid would output its own prediction with a probability score, but it can make the predictions messy because there are multiple bounding boxes for a single object. What we do is, out of all the bounding boxes, we choose the box with the highest probability, and discard all the other boxes with a lower probability than the highest one. This is called non-max suppression.\nAnchor Box The last problem is how to detect multiple objects in the same grid cell. It is easy to deal with. The idea is to define multiple bounding box prediction values, that is to have many probabilities, x and y coordinates, heights, widths, and class confidences in a single array to refer to the class probability of an object, and this is called anchor boxes.\n","permalink":"http://zintrulcre.github.io/posts/deep-learning/object-detection-yolo/","summary":"Object Detection Object detection deals with detecting instances of objects of a certain class, such as humans, animals, etc, in digital images and videos. Object detection has applications in many areas of computer vision, including image retrieval, face detection, video surveillance, and self-driving, etc. Current detection systems repurpose classifiers to perform detection. To detect an object, these systems take a classifier for that object and evaluate it at various locations and scales in a test image.","title":"Object Detection"},{"content":"Code Jam 2019 Round 1C Robot Programming Strategy (10pts, 18pts) å·²çŸ¥æ‰€æœ‰äººçŸ³å¤´å‰ªåˆ€å¸ƒçš„å‡ºæ‹›é¡ºåºï¼Œæ¯ä¸€è½®åŒæ—¶å’Œæ‰€æœ‰äººæ¯”èµ›ï¼Œæ‰¾åˆ°å¿…èƒœçš„ç­–ç•¥ã€‚\nSolution: Eliminiating æ¯ä¸€è½®éå†å½“å‰è½®æ¬¡æ‰€æœ‰äººçš„å‡ºæ‹›ï¼Œå¦‚æœåŒæ—¶æœ‰ä¸‰ç§æƒ…å†µï¼ˆR, P, Sï¼‰åˆ™æ²¡æœ‰å¿…èƒœç­–ç•¥ï¼Œç›´æ¥è¾“å‡ºIMPOSSIBLEï¼›å¦åˆ™è¿”å›èƒœåˆ©æˆ–æ‰“å¹³çš„ç­–ç•¥ã€‚\nå¯¹äºå·²ç»æ‰“è´¥è¿‡çš„å¯¹æ‰‹æ²¡æœ‰å¿…è¦å†è€ƒè™‘å…¶ä¹‹åçš„å‡ºæ‹›ï¼Œæ‰€ä»¥ç”¨ä¸€ä¸ªdefeatedæ•°ç»„ä¿å­˜å·²ç»æ‰“è´¥è¿‡çš„å¯¹æ‰‹ä»¥ä¾¿ç›´æ¥è·³è¿‡ã€‚å› ä¸ºå½“å‰è½®æ¬¡æœ‰å¯èƒ½è¶…è¿‡å¯¹æ‰‹çš„å‡ºæ‹›é¡ºåºé•¿åº¦ï¼Œæ‰€ä»¥è¦ç”¨i % sizeè·å–å¯¹æ‰‹å½“å‰çš„å‡ºæ‹›ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(A ^ 2) ç©ºé—´å¤æ‚åº¦ï¼šO(A)  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; char Decide(const char \u0026amp;R, const char \u0026amp;P, const char \u0026amp;S) { if (R \u0026amp;\u0026amp; P \u0026amp;\u0026amp; S) return \u0026#39;X\u0026#39;; if (R \u0026amp;\u0026amp; P) return \u0026#39;P\u0026#39;; if (R \u0026amp;\u0026amp; S) return \u0026#39;R\u0026#39;; if (P \u0026amp;\u0026amp; S) return \u0026#39;S\u0026#39;; if (R) return \u0026#39;P\u0026#39;; if (P) return \u0026#39;S\u0026#39;; return \u0026#39;R\u0026#39;; } bool Defeate(const char \u0026amp;current, const char \u0026amp;opponent) { return (current == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; opponent == \u0026#39;S\u0026#39;) || (current == \u0026#39;S\u0026#39; \u0026amp;\u0026amp; opponent == \u0026#39;P\u0026#39;) || (current == \u0026#39;P\u0026#39; \u0026amp;\u0026amp; opponent == \u0026#39;R\u0026#39;); } void solve(const int \u0026amp;t) { int A; scanf(\u0026#34;%d\u0026#34;, \u0026amp;A); int i = 0; vector\u0026lt;string\u0026gt; opponent(A); vector\u0026lt;bool\u0026gt; defeated(A, false); bool R, P, S; string res; for (int a = 0; a \u0026lt; A; ++a) cin \u0026gt;\u0026gt; opponent[a]; while (true) { int current_opponent = 0; R = false, P = false, S = false; for (int a = 0; a \u0026lt; A; ++a) { if (!defeated[a]) { ++current_opponent; if (opponent[a][i % opponent[a].size()] == \u0026#39;R\u0026#39;) R = true; else if (opponent[a][i % opponent[a].size()] == \u0026#39;P\u0026#39;) P = true; else S = true; } } if (current_opponent == 0) break; char result = Decide(R, P, S); if (result == \u0026#39;X\u0026#39;) { res = \u0026#34;IMPOSSIBLE\u0026#34;; break; } res += result; for (int a = 0; a \u0026lt; A; ++a) { if (!defeated[a] \u0026amp;\u0026amp; Defeate(result, opponent[a][i % opponent[a].size()])) defeated[a] = true; } ++i; } printf(\u0026#34;Case #%d: %s\\n\u0026#34;, t, res.c_str()); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) solve(t); return 0; } Power Arrangers (11pts, 21pts) // TODO\nBacterial Tactics (15pts, 25pts) // TODO\n","permalink":"http://zintrulcre.github.io/posts/code-jam/2019-round-1c/","summary":"Code Jam 2019 Round 1C Robot Programming Strategy (10pts, 18pts) å·²çŸ¥æ‰€æœ‰äººçŸ³å¤´å‰ªåˆ€å¸ƒçš„å‡ºæ‹›é¡ºåºï¼Œæ¯ä¸€è½®åŒæ—¶å’Œæ‰€æœ‰äººæ¯”èµ›ï¼Œæ‰¾åˆ°å¿…èƒœçš„ç­–ç•¥ã€‚\nSolution: Eliminiating æ¯ä¸€è½®éå†å½“å‰è½®æ¬¡æ‰€æœ‰äººçš„å‡ºæ‹›ï¼Œå¦‚æœåŒæ—¶æœ‰ä¸‰ç§æƒ…å†µï¼ˆR, P, Sï¼‰åˆ™æ²¡æœ‰å¿…èƒœç­–ç•¥ï¼Œç›´æ¥è¾“å‡ºIMPOSSIBLEï¼›å¦åˆ™è¿”å›èƒœåˆ©æˆ–æ‰“å¹³çš„ç­–ç•¥ã€‚\nå¯¹äºå·²ç»æ‰“è´¥è¿‡çš„å¯¹æ‰‹æ²¡æœ‰å¿…è¦å†è€ƒè™‘å…¶ä¹‹åçš„å‡ºæ‹›ï¼Œæ‰€ä»¥ç”¨ä¸€ä¸ªdefeatedæ•°ç»„ä¿å­˜å·²ç»æ‰“è´¥è¿‡çš„å¯¹æ‰‹ä»¥ä¾¿ç›´æ¥è·³è¿‡ã€‚å› ä¸ºå½“å‰è½®æ¬¡æœ‰å¯èƒ½è¶…è¿‡å¯¹æ‰‹çš„å‡ºæ‹›é¡ºåºé•¿åº¦ï¼Œæ‰€ä»¥è¦ç”¨i % sizeè·å–å¯¹æ‰‹å½“å‰çš„å‡ºæ‹›ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(A ^ 2) ç©ºé—´å¤æ‚åº¦ï¼šO(A)  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; char Decide(const char \u0026amp;R, const char \u0026amp;P, const char \u0026amp;S) { if (R \u0026amp;\u0026amp; P \u0026amp;\u0026amp; S) return \u0026#39;X\u0026#39;; if (R \u0026amp;\u0026amp; P) return \u0026#39;P\u0026#39;; if (R \u0026amp;\u0026amp; S) return \u0026#39;R\u0026#39;; if (P \u0026amp;\u0026amp; S) return \u0026#39;S\u0026#39;; if (R) return \u0026#39;P\u0026#39;; if (P) return \u0026#39;S\u0026#39;; return \u0026#39;R\u0026#39;; } bool Defeate(const char \u0026amp;current, const char \u0026amp;opponent) { return (current == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; opponent == \u0026#39;S\u0026#39;) || (current == \u0026#39;S\u0026#39; \u0026amp;\u0026amp; opponent == \u0026#39;P\u0026#39;) || (current == \u0026#39;P\u0026#39; \u0026amp;\u0026amp; opponent == \u0026#39;R\u0026#39;); } void solve(const int \u0026amp;t) { int A; scanf(\u0026#34;%d\u0026#34;, \u0026amp;A); int i = 0; vector\u0026lt;string\u0026gt; opponent(A); vector\u0026lt;bool\u0026gt; defeated(A, false); bool R, P, S; string res; for (int a = 0; a \u0026lt; A; ++a) cin \u0026gt;\u0026gt; opponent[a]; while (true) { int current_opponent = 0; R = false, P = false, S = false; for (int a = 0; a \u0026lt; A; ++a) { if (!","title":"Code Jam 2019 Round 1C"},{"content":"Kick Start 2019 Round B Building Palindromes (5pts, 12pts) åˆ¤æ–­ç»™å®šåŒºé—´å†…çš„å­å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²ã€‚\nSolution: Prefix Sum åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²åªéœ€è¦åˆ¤æ–­å­—ç¬¦ä¸²é‡Œä¸ªæ•°ä¸ºå¥‡æ•°çš„å­—ç¬¦çš„æ•°é‡æ˜¯å¦å°äºç­‰äº1ï¼Œä½†å¦‚æœæ¯æ¬¡éƒ½éå†ä¸€éç»™å®šçš„åŒºé—´è‚¯å®šä¼šè¶…æ—¶ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å¯¹ç»™å®šçš„åŸå§‹å­—ç¬¦ä¸²è¿›è¡Œé¢„å¤„ç†ï¼Œè®¡ç®—å‡ºæ¯ä¸€ä¸ªä½ç½®çš„å‰ç¼€å’Œï¼ˆä»ä¸‹æ ‡ä¸º0åˆ°ä¸‹æ ‡ä¸ºi - 1çš„ä½ç½®çš„å­—ç¬¦çš„æ€»æ•°ï¼‰ã€‚è¿™æ ·åœ¨æŸ¥è¯¢çš„æ—¶å€™å°±åªæœ‰O(1)çš„æ—¶é—´å¤æ‚åº¦äº†ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(N) ç©ºé—´å¤æ‚åº¦ï¼šO(N)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { int N, Q, m, n, total = 0; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; string words; cin \u0026gt;\u0026gt; words; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; odds(N + 1, vector\u0026lt;int\u0026gt;(26)); for (int i = 1; i \u0026lt;= N; ++i) { for (int j = 0; j \u0026lt; 26; ++j) odds[i][j] = odds[i - 1][j]; ++odds[i][words[i - 1] - \u0026#39;A\u0026#39;]; } for (int q = 0; q \u0026lt; Q; ++q) { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; int odd = 0; for (int j = 0; j \u0026lt; 26; ++j) odd += ((odds[n][j] - odds[m - 1][j]) % 2 != 0); total += odd \u0026lt;= 1; } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, case_number, total); } return 0; } Energy Stones (17pts, 24pts) åœ¨æ‰€æœ‰ç‰©å“æ¶ˆè€—å®Œä¹‹å‰åƒæ‰ï¼Œä½¿å¾—èƒ½å¤Ÿè·å¾—çš„energyæœ€å¤šï¼Œç±»ä¼¼äºèƒŒåŒ…é—®é¢˜ã€‚\nSolution 1: Dynamic Programming (Visible Test Set) å¯¹äºVisible Test Setï¼Œåƒæ‰æ¯ä¸€ä»¶ç‰©å“æ‰€æ¶ˆè€—çš„secondséƒ½æ˜¯ç›¸åŒçš„ï¼Œå› æ­¤å¯ä»¥ç®€åŒ–ä¸ºä¸€ä¸ªå•çº¯çš„èƒŒåŒ…é—®é¢˜ã€‚ä¸ºäº†æœ€å¤§åŒ–è·å¾—çš„energyï¼ˆæœ€å°åŒ–æ‰€æœ‰ç‰©å“çš„æ€»lostï¼‰ï¼Œåº”è¯¥å…ˆåƒæ‰losté«˜çš„ç‰©å“ï¼Œæ‰€ä»¥æŒ‰ç…§lostæ’åºã€‚\nåˆå§‹çŠ¶æ€æ˜¯dp[index][time] = 0ï¼Œindex = 0, time = 0ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯\n å¦‚æœå½“å‰ç‰©å“è¿˜æœ‰å‰©ä½™çš„energyåˆ™åƒæ‰å½“å‰çš„ç‰©å“   if (stones[index].energy \u0026gt; stones[index].lost * time)\rres = max(res, stones[index].energy - stones[index].lost * time + DP(index + 1, time + stones[index].seconds));\rä¸åƒå½“å‰çš„ç‰©å“   res = max(res, DP(index + 1, time));\r æ—¶é—´å¤æ‚åº¦ï¼šO(N * (S * N)) ç©ºé—´å¤æ‚åº¦ï¼šO(N * (S * N))  //C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; struct Stone { int seconds; int energy; int lost; }; vector\u0026lt;Stone\u0026gt; stones; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; int N; int DP(int index, int time) { if (index \u0026gt;= N) return 0; int \u0026amp;res = dp[index][time]; if (res != -1) return res; if (stones[index].energy \u0026gt; stones[index].lost * time) res = max(res, stones[index].energy - stones[index].lost * time + DP(index + 1, time + stones[index].seconds)); res = max(res, DP(index + 1, time)); return res; } int solve(const int \u0026amp;T) { cin \u0026gt;\u0026gt; N; stones = vector\u0026lt;Stone\u0026gt;(N); for (int i = 0; i \u0026lt; N; ++i) cin \u0026gt;\u0026gt; stones[i].seconds \u0026gt;\u0026gt; stones[i].energy \u0026gt;\u0026gt; stones[i].lost; dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(N, vector\u0026lt;int\u0026gt;(stones[0].seconds * N, -1)); sort(stones.begin(), stones.end(), [](const Stone \u0026amp;s1, const Stone \u0026amp;s2) { return s1.lost \u0026gt; s2.lost; }); return DP(0, 0); } int main() { int T; cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; ++t) printf(\u0026#34;Case #%d: %d\\n\u0026#34;, t, solve(t)); return 0; } Solution 2: Dynamic Programming (Hidden Test Set) å¯¹äºHidden Test Setï¼Œæ¯ä¸€ä»¶ç‰©å“æ¶ˆè€—çš„æ—¶é—´å¹¶ä¸ç›¸åŒï¼Œä¸èƒ½ç›´æ¥ä½¿ç”¨lostè¿›è¡Œæ’åºã€‚å¯¹äºæ¯ä¸¤ä»¶ç‰©å“s1å’Œs2ï¼Œåªè¦æ»¡è¶³s1.lost * s2.seconds \u0026gt; s2.lost * s1.secondså°±å¯ä»¥ä¿è¯å¾—åˆ°æ›´å°çš„æ€»lostã€‚åŒæ—¶dpæ•°ç»„çš„å¤§å°éœ€è¦æŒ‰ç…§æ¯ä¸ªç‰©å“çš„è€—æ—¶æ¥è®¡ç®—ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(N * (S * N)) ç©ºé—´å¤æ‚åº¦ï¼šO(N * (S * N))  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; struct Stone { int seconds; int energy; int lost; }; vector\u0026lt;Stone\u0026gt; stones; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; int N; void solve(const int \u0026amp;T) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); stones = vector\u0026lt;Stone\u0026gt;(N); int total_time = 0; for (int i = 0; i \u0026lt; N; ++i) { scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;stones[i].seconds, \u0026amp;stones[i].energy,\u0026amp;stones[i].lost); total_time += stones[i].seconds; } sort(stones.begin(), stones.end(), [](const Stone \u0026amp;s1, const Stone \u0026amp;s2) { return s1.lost * s2.seconds \u0026gt; s2.lost * s1.seconds; }); int res = 0; dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(N + 1, vector\u0026lt;int\u0026gt;(total_time + 1, -1)); for (int i = 1; i \u0026lt;= N; ++i) { dp[i - 1][0] = 0; for (int j = 0; j \u0026lt; stones[i - 1].seconds; ++j) dp[i][j] = dp[i - 1][j]; for (int j = stones[i - 1].seconds; j \u0026lt; dp[i - 1].size(); ++j) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i - 1].seconds] + stones[i - 1].energy - (j - stones[i - 1].seconds) * stones[i - 1].lost); res = max(res, dp[i][j]); } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, T, res); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) solve(t); return 0; } Diverse Subarray (14pts, 28pts) ç»™å®šæœ€å¤§å€¼Sï¼Œé€‰å–ä¸€æ®µè¿ç»­å­æ•°ç»„ï¼Œä½¿å¾—å­æ•°ç»„ä¸­ç›¸åŒå€¼çš„ä¸ªæ•°ä¸è¶…è¿‡Sçš„æ€»æ•°æœ€å¤§åŒ–ã€‚\nSolution 1: Brute Force (Visible Test Set) Visible Test Setçš„æ•°ç»„é•¿åº¦N \u0026lt;= 1000ï¼Œåªéœ€è¦ä¸¤å±‚å¾ªç¯åšç©·ä¸¾ï¼Œæ¯æ¬¡è®¡ç®—ç¬¦åˆè¦æ±‚çš„æ€»æ•°ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(N^2) ç©ºé—´å¤æ‚åº¦ï¼šO(N)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { int N, S, res = 0; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; vector\u0026lt;int\u0026gt; trinkets(N); for (int i = 0; i \u0026lt; N; ++i) cin \u0026gt;\u0026gt; trinkets[i]; for (int j = 0; j \u0026lt; N; ++j) { unordered_map\u0026lt;int, int\u0026gt; types; for (int i = j; i \u0026gt;= 0; --i) { ++types[trinkets[i]]; int total = 0; for (auto t:types) { if (t.second \u0026lt;= S) total += t.second; } res = max(res, total); } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, case_number, res); } return 0; } Solution 2: Segment Tree (Hidden Test Set) // TODO\n","permalink":"http://zintrulcre.github.io/posts/kick-start/2019-round-b/","summary":"Kick Start 2019 Round B Building Palindromes (5pts, 12pts) åˆ¤æ–­ç»™å®šåŒºé—´å†…çš„å­å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²ã€‚\nSolution: Prefix Sum åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²åªéœ€è¦åˆ¤æ–­å­—ç¬¦ä¸²é‡Œä¸ªæ•°ä¸ºå¥‡æ•°çš„å­—ç¬¦çš„æ•°é‡æ˜¯å¦å°äºç­‰äº1ï¼Œä½†å¦‚æœæ¯æ¬¡éƒ½éå†ä¸€éç»™å®šçš„åŒºé—´è‚¯å®šä¼šè¶…æ—¶ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å¯¹ç»™å®šçš„åŸå§‹å­—ç¬¦ä¸²è¿›è¡Œé¢„å¤„ç†ï¼Œè®¡ç®—å‡ºæ¯ä¸€ä¸ªä½ç½®çš„å‰ç¼€å’Œï¼ˆä»ä¸‹æ ‡ä¸º0åˆ°ä¸‹æ ‡ä¸ºi - 1çš„ä½ç½®çš„å­—ç¬¦çš„æ€»æ•°ï¼‰ã€‚è¿™æ ·åœ¨æŸ¥è¯¢çš„æ—¶å€™å°±åªæœ‰O(1)çš„æ—¶é—´å¤æ‚åº¦äº†ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(N) ç©ºé—´å¤æ‚åº¦ï¼šO(N)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { int N, Q, m, n, total = 0; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; string words; cin \u0026gt;\u0026gt; words; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; odds(N + 1, vector\u0026lt;int\u0026gt;(26)); for (int i = 1; i \u0026lt;= N; ++i) { for (int j = 0; j \u0026lt; 26; ++j) odds[i][j] = odds[i - 1][j]; ++odds[i][words[i - 1] - \u0026#39;A\u0026#39;]; } for (int q = 0; q \u0026lt; Q; ++q) { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; int odd = 0; for (int j = 0; j \u0026lt; 26; ++j) odd += ((odds[n][j] - odds[m - 1][j]) % 2 !","title":"Kick Start 2019 Round B"},{"content":"Code Jam 2019 Round 1A Pylons (8pts, 23pts) åœ¨m*nçš„ç½‘æ ¼é‡Œç§»åŠ¨ï¼Œæ¯æ¬¡ç§»åŠ¨åçš„ä½ç½®ä¸èƒ½ä¸ä¹‹å‰çš„ä½ç½®åœ¨åŒä¸€è¡Œ/åˆ—/å¯¹è§’çº¿ä¸Šã€‚\nSolution: BackTracking ç±»ä¼¼äºå…«çš‡åé—®é¢˜ï¼Œä¸è¿‡æ¯æ¬¡çš„é™åˆ¶æ¡ä»¶åªå’Œä¸Šä¸€ä¸ªä½ç½®æœ‰å…³ï¼Œå¯ä»¥ç”¨å›æº¯è§£å†³ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(m^2 * n^2) ç©ºé—´å¤æ‚åº¦ï¼šO(m * n)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; int m, n; bool BackTracking(int t, int i, int j, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visited, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;res) { visited[i][j] = true; res[t] = {i, j}; if (t + 1 == m * n) return true; for (int x = 0; x \u0026lt; m; ++x) { for (int y = 0; y \u0026lt; n; ++y) { int r = (x + i) % m, c = (y + j) % n; if (!visited[r][c] \u0026amp;\u0026amp; r != i \u0026amp;\u0026amp; c != j \u0026amp;\u0026amp; r + c != i + j \u0026amp;\u0026amp; r - c != i - j \u0026amp;\u0026amp; BackTracking(t + 1, r, c, visited, res)) return true; } } visited[i][j] = false; return false; } int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { bool rev = false; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; if (m \u0026gt; n) { rev = true; swap(n, m); } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(m, vector\u0026lt;bool\u0026gt;(n, false)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(m * n, vector\u0026lt;int\u0026gt;()); printf(\u0026#34;Case #%d: \u0026#34;, case_number); if (BackTracking(0, 0, 0, visited, res)) { printf(\u0026#34;POSSIBLE\\n\u0026#34;); for (int i = 0; i \u0026lt; m * n; ++i) if (!rev) printf(\u0026#34;%d %d\\n\u0026#34;, res[i][0] + 1, res[i][1] + 1); else printf(\u0026#34;%d %d\\n\u0026#34;, res[i][1] + 1, res[i][0] + 1); } else printf(\u0026#34;IMPOSSIBLE\\n\u0026#34;); } return 0; } Alien Rhyme (10pts, 27pts) æ‰¾åˆ°åç¼€ç›¸åŒçš„ä¸€å¯¹å•è¯ï¼Œåç¼€çš„é•¿åº¦å¯ä»¥è‡ªå·±å®šä¹‰ï¼Œå…¶ä»–å•è¯çš„åç¼€ä¸èƒ½ä¸è¿™ä¸€å¯¹ç›¸åŒï¼Œä½¿å¾—è¿™æ ·çš„å•è¯å¯¹æœ€å¤šã€‚\nSolution: Suffix å…ˆç¿»è½¬æ¯ä¸€ä¸ªå•è¯ï¼ˆå¦‚æœä¸ç¿»è½¬çš„è¯å–substrçš„æ—¶å€™å°±ä»ä¸­é—´å¼€å§‹å–åˆ°æœ€åï¼Œç¿»è½¬çš„è¯åªéœ€è¦å–å‰é¢mä¸ªå­—æ¯ï¼‰ã€‚ä»æœ€é•¿çš„å•è¯é•¿åº¦ä¾æ¬¡é€’å‡ï¼Œå–æ¯ä¸€ä¸ªå•è¯çš„åç¼€ï¼Œå¦‚æœä¸¤ä¸ªå•è¯æœ‰ç›¸åŒçš„åç¼€åˆ™æŠŠè¿™ä¸¤ä¸ªå•è¯å»æ‰ï¼Œç»“æœ+2ã€‚å› ä¸ºæ˜¯ä»æœ€é•¿çš„å•è¯é•¿åº¦å¼€å§‹ä¾æ¬¡å–åç¼€ï¼Œå¯ä»¥ä¿è¯åç¼€ç›¸åŒçš„å•è¯ä¸è¢«æ¼æ‰ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(N * m)  mï¼šæœ€é•¿çš„å•è¯é•¿åº¦ Nï¼šå•è¯ä¸ªæ•°   ç©ºé—´å¤æ‚åº¦ï¼šO(N)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; #include \u0026#34;Print.h\u0026#34; using namespace std; int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { int N, sum = 0, max_len = 0; cin \u0026gt;\u0026gt; N; vector\u0026lt;string\u0026gt; words(N); for (int m = 0; m \u0026lt; N; ++m) { cin \u0026gt;\u0026gt; words[m]; max_len = max(max_len, static_cast\u0026lt;int\u0026gt;(words[m].size())); reverse(words[m].begin(), words[m].end()); } unordered_map\u0026lt;string, int\u0026gt; status; vector\u0026lt;bool\u0026gt; visited(N, false); int total = 0; for (int len = max_len; len \u0026gt; 0; --len) { for (int m = 0; m \u0026lt; N; ++m) { if (visited[m] || words[m].size() \u0026lt; len) continue; string str = words[m].substr(0, len); if (status.find(str) != status.end()) { if (status[str] != -1) { sum += 2; visited[status[str]] = true, visited[m] = true; status[str] = -1; } } else status[str] = m; } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, case_number, sum); } return 0; } Golf Gophers (11pts, 21pts) // TODO\n","permalink":"http://zintrulcre.github.io/posts/code-jam/2019-round-1a/","summary":"Code Jam 2019 Round 1A Pylons (8pts, 23pts) åœ¨m*nçš„ç½‘æ ¼é‡Œç§»åŠ¨ï¼Œæ¯æ¬¡ç§»åŠ¨åçš„ä½ç½®ä¸èƒ½ä¸ä¹‹å‰çš„ä½ç½®åœ¨åŒä¸€è¡Œ/åˆ—/å¯¹è§’çº¿ä¸Šã€‚\nSolution: BackTracking ç±»ä¼¼äºå…«çš‡åé—®é¢˜ï¼Œä¸è¿‡æ¯æ¬¡çš„é™åˆ¶æ¡ä»¶åªå’Œä¸Šä¸€ä¸ªä½ç½®æœ‰å…³ï¼Œå¯ä»¥ç”¨å›æº¯è§£å†³ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(m^2 * n^2) ç©ºé—´å¤æ‚åº¦ï¼šO(m * n)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; int m, n; bool BackTracking(int t, int i, int j, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visited, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;res) { visited[i][j] = true; res[t] = {i, j}; if (t + 1 == m * n) return true; for (int x = 0; x \u0026lt; m; ++x) { for (int y = 0; y \u0026lt; n; ++y) { int r = (x + i) % m, c = (y + j) % n; if (!","title":"Code Jam 2019 Round 1A"},{"content":"Code Jam 2019 Qualification Round Foregone Solution (6pts, 10pts, 1pts) å°†ä¸€ä¸ªå¸¦æœ‰æ•°å­—4çš„æ•°æ‹†åˆ†ä¸ºä¸¤ä¸ªä¸å¸¦æ•°å­—4çš„æ•°ã€‚\nSolution: Construction è¾“å…¥çš„æ•°ä¸€å®šå¸¦æœ‰æ•°å­—4ï¼Œå¯¹äºæ¯ä¸€ä½ä¸Šçš„æ•°å­—4ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æ‹†åˆ†ä¸º2+2ï¼ˆæˆ–1+3ï¼‰çš„ä¸¤ä¸ªæ•°ã€‚è¾“å…¥æ•°æ®æœ€å¤§æ˜¯10çš„100æ¬¡æ–¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†å…¶ä½œä¸ºå­—ç¬¦ä¸²å¤„ç†ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(n) ç©ºé—´å¤æ‚åº¦ï¼šO(1)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; ++t) { string N; cin \u0026gt;\u0026gt; N; string a, b; for (auto c:N) { a += c == \u0026#39;4\u0026#39; ? \u0026#39;2\u0026#39; : c; b += c == \u0026#39;4\u0026#39; ? \u0026#39;2\u0026#39; : \u0026#39;0\u0026#39;; } while (a[0] == \u0026#39;0\u0026#39;) a.erase(a.begin()); while (b[0] == \u0026#39;0\u0026#39;) b.erase(b.begin()); cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } } You Can Go Your Own Way (5pts, 9pts, 10pts) åœ¨n*nçš„çŸ©é˜µé‡Œä»(0,0)èµ°åˆ°(n-1,n-1)ï¼Œåªèƒ½å‘å³æˆ–å‘ä¸‹èµ°ã€‚çŸ©é˜µé‡Œæœ‰ä¸€æ¡å·²æœ‰çš„è·¯å¾„ï¼Œä¸èƒ½ä¸è¯¥è·¯å¾„æœ‰é‡åˆã€‚æœ€å¸¸è§„çš„åšæ³•æ˜¯DFS/BFSï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)ã€‚\nSolution: Mirror å› ä¸ºåªæœ‰ä¸€æ¡å·²çŸ¥è·¯å¾„ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ä»¥å¯¹è§’çº¿ä½œé•œåƒï¼Œå¾—åˆ°çš„æ–°è·¯å¾„ä¸€å®šä¸åŸè·¯å¾„æ²¡æœ‰é‡åˆã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(2 * n - 2) ç©ºé—´å¤æ‚åº¦ï¼šO(1)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; ++t) { int N; string str; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; str; for (int i = 0; i \u0026lt; N * 2 - 2; ++i) str[i] = str[i] == \u0026#39;E\u0026#39; ? \u0026#39;S\u0026#39; : \u0026#39;E\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } } Cryptopangrams (10pts, 15pts) è¾“å…¥ä¸Šé™Nå’Œä¸€ä¸ªé•¿ä¸ºLçš„æ•°ç»„productï¼Œæ•°ç»„é‡Œçš„æ¯ä¸€ä¸ªæ•°éƒ½æ˜¯ä¸€ä¸ªé•¿ä¸ºL+1çš„è´¨æ•°æ•°ç»„resé‡Œçš„ç›¸é‚»è´¨æ•°çš„ä¹˜ç§¯ã€‚è´¨æ•°æ•°ç»„é‡Œä¸€å…±åªæœ‰26ä¸ªè´¨æ•°ï¼Œè¿”å›å°†è¿™26ä¸ªè´¨æ•°æ’åºååˆ†åˆ«æ˜ å°„ä¸ºA-Zçš„ç»“æœã€‚å¯¹äºæ¯”è¾ƒå°çš„Nï¼Œå¯ä»¥æŠŠå°äºç­‰äºNçš„æ‰€æœ‰è´¨æ•°ä¿å­˜ä¸‹æ¥ï¼Œè®¡ç®—å‡ºproduct[0]æ˜¯å“ªä¸¤ä¸ªè´¨æ•°çš„ä¹˜ç§¯ï¼Œå†è®¡ç®—å‡ºproduct[1]æ˜¯å“ªä¸¤ä¸ªè´¨æ•°çš„ä¹˜ç§¯ï¼Œå¾—åˆ°res[1]ï¼Œå†ä¾æ¬¡è®¡ç®—è´¨æ•°æ•°ç»„resé‡Œçš„å…¶ä»–æ•°ã€‚åœ¨Næ¯”è¾ƒå¤§çš„æ—¶å€™æ—¶é—´å’Œç©ºé—´å ç”¨éƒ½ä¼šå¾ˆé«˜ã€‚\nSolution: Greatest Common Denominator ç›¸è¾ƒäºå…ˆæ‰¾åˆ°æ‰€æœ‰è´¨æ•°å†æ‰¾åˆ°product[0]æ˜¯å“ªä¸¤ä¸ªè´¨æ•°çš„ä¹˜ç§¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å°å­¦å­¦è¿‡çš„è¾—è½¬ç›¸é™¤æ³•æ¥æ±‚å‡ºè¿™ä¸ªè´¨æ•°ï¼Œè¿™æ ·å¯ä»¥éå¸¸æœ‰æ•ˆåœ°é™ä½æ—¶é—´å’Œç©ºé—´æ¶ˆè€—ã€‚\nè¿™é“é¢˜æµ‹è¯•ç”¨ä¾‹çš„Næœ€å¤§å€¼æ˜¯10çš„100æ¬¡æ–¹ï¼Œç”¨C++éœ€è¦è‡ªå·±å¤„ç†å¤§æ•°ä¹˜æ³•ï¼ˆC++æœ€å¤§åªæ”¯æŒ128ä½çš„intå‹æ•°ï¼‰ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(L) ç©ºé—´å¤æ‚åº¦ï¼šO(L)  # Python 3 def GCD(a: int, b: int) -\u0026gt; int: if b == 0: return a return GCD(b, a % b) T = int(input()) for t in range(1, T + 1): N, L = map(int, input().split()) product = list(map(int, input().split())) res = [0 for _ in range(L + 1)] pos = -1 for i in range(L - 1): if product[i] != product[i + 1]: res[i + 1] = GCD(product[i], product[i + 1]) pos = i + 1 break for i in range(pos + 1, L + 1): res[i] = product[i - 1] // res[i - 1] for i in range(pos - 1, -1, -1): res[i] = product[i] // res[i + 1] match = [] for m in res: if m not in match: match.append(m) match.sort() ret = [chr(match.index(res[i]) + ord(\u0026#39;A\u0026#39;)) for i in range(len(res))] print(\u0026#34;Case #{t}: {str}\u0026#34;.format(t=t, str=\u0026#34;\u0026#34;.join(ret))) Dat Bae (14pts, 20pts) // TODO\n","permalink":"http://zintrulcre.github.io/posts/code-jam/2019-qualification-round/","summary":"Code Jam 2019 Qualification Round Foregone Solution (6pts, 10pts, 1pts) å°†ä¸€ä¸ªå¸¦æœ‰æ•°å­—4çš„æ•°æ‹†åˆ†ä¸ºä¸¤ä¸ªä¸å¸¦æ•°å­—4çš„æ•°ã€‚\nSolution: Construction è¾“å…¥çš„æ•°ä¸€å®šå¸¦æœ‰æ•°å­—4ï¼Œå¯¹äºæ¯ä¸€ä½ä¸Šçš„æ•°å­—4ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æ‹†åˆ†ä¸º2+2ï¼ˆæˆ–1+3ï¼‰çš„ä¸¤ä¸ªæ•°ã€‚è¾“å…¥æ•°æ®æœ€å¤§æ˜¯10çš„100æ¬¡æ–¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†å…¶ä½œä¸ºå­—ç¬¦ä¸²å¤„ç†ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(n) ç©ºé—´å¤æ‚åº¦ï¼šO(1)  // C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;math.h\u0026gt;#include \u0026lt;limits\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; ++t) { string N; cin \u0026gt;\u0026gt; N; string a, b; for (auto c:N) { a += c == \u0026#39;4\u0026#39; ?","title":"Code Jam 2019 Qualification Round"},{"content":"Kick Start 2019 Round A Training (7pts, 13pts) ä¸€å…±æœ‰Nä¸ªäººï¼Œä»ä¸­é€‰Pä¸ªäººï¼Œè®¡ç®—è¿™Pä¸ªäººä¸­ skill rating çš„æœ€å¤§å€¼ä¸å…¶ä»–äººçš„ skill rating çš„å·®å€¼ä¹‹å’Œã€‚\n$$ \\sum_{i}^{j} max(rating) - rating[i] $$\nSolution: Sort + Prefix Sum å…ˆå¯¹æ•°ç»„æ’åºï¼Œç„¶ååœ¨é•¿åº¦ä¸ºNçš„æœ‰åºæ•°ç»„ä¸­éå†é•¿ä¸ºPçš„æ‰€æœ‰è¿ç»­å­æ•°ç»„ï¼Œè®¡ç®—å­æ•°ç»„ä¸­çš„æœ€å¤§å€¼ä¸å…¶ä»–å€¼çš„å·®å€¼ä¹‹å’Œã€‚\n$$ \\sum_{i}^{j - 1} rating[j] - rating[i] $$\nå¦‚æœç›´æ¥éå†é•¿ä¸ºPçš„å­æ•°ç»„ä¼šæµªè´¹å¾ˆå¤šæ—¶é—´ï¼Œå¯ä»¥å°†ä¸Šé¢çš„å…¬å¼ç®€åŒ–ä¸ºå¦‚ä¸‹ã€‚\n$$ \\sum_{i}^{j - 1} rating[j] - rating[i] = rating[j] * (j - 1 - i) - \\sum_{i}^{j - 1} rating[i] $$\nä¸ºäº†é¿å…é‡å¤è®¡ç®— $$ \\sum_{i}^{j - 1} rating[i] $$ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªé•¿ä¸ºN+1çš„æ•°ç»„å°†åŸå§‹æ•°ç»„çš„å‰ç¼€å’Œä¿å­˜ä¸‹æ¥ï¼Œè¿™æ ·æ¯æ¬¡ç›´æ¥è®¡ç®— prefix[j] - prefix[i] å°±èƒ½å¾—åˆ° $$ \\sum_{i}^{j - 1} rating[i] $$ äº†ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(N)ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(NlogN) ç©ºé—´å¤æ‚åº¦ï¼šO(N)  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; int main() { int c = 1; int T; std::cin \u0026gt;\u0026gt; T; for (int t = 0; t \u0026lt; T; ++t) { int N, P; int min_hour = 1000000000; std::cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; P; std::vector\u0026lt;int\u0026gt; rating(N, 0); for (int n = 0; n \u0026lt; N; ++n) std::cin \u0026gt;\u0026gt; rating[n]; std::sort(rating.begin(), rating.end()); std::vector\u0026lt;int\u0026gt; prefix(N + 1, 0); for (int i = 0; i \u0026lt; N; ++i) prefix[i + 1] = prefix[i] + rating[i]; for (int i = P - 1; i \u0026lt; N; ++i) { int sum = rating[i] * (P - 1) - (prefix[i] - prefix[i - P + 1]); min_hour = std::max(0, std::min(min_hour, sum)); } std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(c) + \u0026#34;: \u0026#34; + std::to_string(min_hour) \u0026lt;\u0026lt; std::endl; ++c; } return 0; } Parcels (15pts, 20pts) ä¸€é“ä¸­ç­‰éš¾åº¦çš„BFSï¼ŒDFSï¼ŒäºŒåˆ†æŸ¥æ‰¾çš„é¢˜ã€‚éœ€è¦å…ˆè®¡ç®—å‡ºå›¾ä¸­çš„æ›¼å“ˆé¡¿è·ç¦»ï¼Œå†æ‰¾åˆ°ä¸€ä¸ªæœ€ä¼˜çš„ä½ç½®ä½¿å¾—å…¶ä»–ç‚¹ç¦»è¿™äº›ç‚¹çš„è·ç¦»æœ€çŸ­ã€‚\nSolution #1: Manhattan Distance æ›¼å“ˆé¡¿è·ç¦»å¯ä»¥ç”¨å…¬å¼ $$ |r1 - r2| + |c1 - c2| $$ è®¡ç®—å¾—å‡ºï¼Œå› æ­¤å¯ä»¥ç›´æ¥ä½¿ç”¨ä¸¤å±‚å¾ªç¯æ¥è®¡ç®—å‡ºæ›¼å“ˆé¡¿è·ç¦»ã€‚\nç¬¬ä¸€æ­¥å¯¹äºæ¯ä¸ªå·²ç»å­˜åœ¨çš„ delivery officeï¼Œè®¡ç®—å‡ºå…¶è·ç¦»æ‰€æœ‰ç‚¹çš„æ›¼å“ˆé¡¿è·ç¦»ï¼Œå¾—åˆ°æ­¤æ—¶çš„æœ€å¤§è¿è¾“æ—¶é—´ max_timeï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(RC^2)ï¼›\nç¬¬äºŒæ­¥ä¾æ¬¡éå†æ‰€æœ‰å¯èƒ½çš„ç‚¹ï¼Œè®¡ç®—å‡ºåœ¨è¯¥ç‚¹æ·»åŠ  delivery office åçš„å›¾ä¸­çš„æœ€å¤§è¿è¾“æ—¶é—´ curr_max_timeï¼Œä¸ max_time æ¯”è¾ƒå–æœ€å°å€¼ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(RC^2)ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(RC^2) ç©ºé—´å¤æ‚åº¦ï¼šO(RC)  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;limits.h\u0026gt;#include \u0026lt;algorithm\u0026gt; int main() { int num_case = 1; int T; std::cin \u0026gt;\u0026gt; T; for (int t = 0; t \u0026lt; T; ++t) { int R, C; std::cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; grid(R, std::vector\u0026lt;int\u0026gt;(C, INT_MAX)); for (int i = 0; i \u0026lt; R; ++i) { std::string temp_in; std::cin \u0026gt;\u0026gt; temp_in; for (int j = 0; j \u0026lt; C; ++j) { char \u0026amp;temp = temp_in[j]; if (temp == \u0026#39;1\u0026#39;) { for (int x = 0; x \u0026lt; R; ++x) { for (int y = 0; y \u0026lt; C; ++y) { grid[x][y] = std::min(grid[x][y], abs(i - x) + abs(j - y)); } } } } } int max_time = 0; for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { max_time = std::max(max_time, grid[i][j]); } } if (max_time == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: 0\u0026#34; \u0026lt;\u0026lt; std::endl; ++num_case; continue; } for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { if (grid[i][j] != 0) { int curr_max_time = 0; for (int x = 0; x \u0026lt; R; ++x) { for (int y = 0; y \u0026lt; C; ++y) { curr_max_time = std::max(curr_max_time, std::min(grid[x][y], abs(i - x) + abs(j - y))); } } max_time = std::min(max_time, curr_max_time); } } } std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: \u0026#34; + std::to_string(max_time) \u0026lt;\u0026lt; std::endl; ++num_case; } return 0; } Solution #2: Breadth-First-Search å¯¹äºç¬¬ä¸€æ­¥æ¥è¯´ï¼Œå¯ä»¥å°†æ‰€æœ‰å·²ç»å­˜åœ¨çš„ delivery office ä¿å­˜åœ¨ä¸€ä¸ªé˜Ÿåˆ—ä¸­ï¼Œç„¶åä½¿ç”¨BFSç›´æ¥è®¡ç®—å‡ºæœ€çŸ­çš„æ›¼å“ˆé¡¿è·ç¦»ï¼Œå¾—åˆ°æ­¤æ—¶çš„æœ€å¤§è¿è¾“æ—¶é—´ max_timeï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(RC)ï¼›\nç¬¬äºŒæ­¥ä¸ç¬¬ä¸€æ­¥ç±»ä¼¼ï¼Œä¹Ÿå¯ä»¥é€šè¿‡BFSè®¡ç®—å‡ºåœ¨æ‰€æœ‰å¯èƒ½çš„ç‚¹å¢åŠ  delivery office åçš„æœ€å¤§è¿è¾“æ—¶é—´ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(RC^2)ã€‚\n æ—¶é—´å¤æ‚åº¦ï¼šO(RC^2) ç©ºé—´å¤æ‚åº¦ï¼šO(RC)  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;limits.h\u0026gt;#include \u0026lt;algorithm\u0026gt; int dir_x[4] = {-1, 0, 1, 0}; int dir_y[4] = {0, -1, 0, 1}; int BFS0(const int \u0026amp;R, const int \u0026amp;C, int x, int y, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;que) { int max_time = 0; int size = que.size(), degree = 1; while (!que.empty()) { x = que.front().first, y = que.front().second; que.pop(); max_time = std::max(max_time, grid[x][y]); for (int i = 0; i \u0026lt; 4; ++i) { int new_x = x + dir_x[i], new_y = y + dir_y[i]; if (new_x \u0026gt;= 0 \u0026amp;\u0026amp; new_x \u0026lt; R \u0026amp;\u0026amp; new_y \u0026gt;= 0 \u0026amp;\u0026amp; new_y \u0026lt; C \u0026amp;\u0026amp; grid[new_x][new_y] == -1) { que.push(std::pair\u0026lt;int, int\u0026gt;(new_x, new_y)); grid[new_x][new_y] = degree; } } --size; if (size == 0) { size = que.size(); ++degree; } } return max_time; } int BFS1(const int \u0026amp;R, const int \u0026amp;C, int x, int y, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;que) { std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; visited(R, std::vector\u0026lt;bool\u0026gt;(C, false)); visited[x][y] = true; int max_time = INT_MIN; int size = 1, degree = 0; while (!que.empty()) { x = que.front().first, y = que.front().second; que.pop(); max_time = std::max(max_time, std::min(grid[x][y], degree)); for (int i = 0; i \u0026lt; 4; ++i) { int new_x = x + dir_x[i], new_y = y + dir_y[i]; if (new_x \u0026gt;= 0 \u0026amp;\u0026amp; new_x \u0026lt; R \u0026amp;\u0026amp; new_y \u0026gt;= 0 \u0026amp;\u0026amp; new_y \u0026lt; C \u0026amp;\u0026amp; !visited[new_x][new_y]) { que.push(std::pair\u0026lt;int, int\u0026gt;(new_x, new_y)); visited[new_x][new_y] = true; } } --size; if (size == 0) { size = que.size(); ++degree; } } return max_time; } int main() { int num_case = 1; int T; std::cin \u0026gt;\u0026gt; T; for (int t = 0; t \u0026lt; T; ++t) { int R, C; std::cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; grid(R, std::vector\u0026lt;int\u0026gt;(C, -1)); std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; que; for (int i = 0; i \u0026lt; R; ++i) { std::string temp_in; std::cin \u0026gt;\u0026gt; temp_in; for (int j = 0; j \u0026lt; C; ++j) { char \u0026amp;temp = temp_in[j]; if (temp == \u0026#39;1\u0026#39;) { que.push(std::pair\u0026lt;int, int\u0026gt;(i, j)); grid[i][j] = 0; } } } int size = que.size(); if (size == R * C) { std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: 0\u0026#34; \u0026lt;\u0026lt; std::endl; ++num_case; continue; } // BFS for existing delivery offices  int max_time = BFS0(R, C, 0, 0, grid, que); // BFS for all possible positions  for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { if (grid[i][j] != 0) { que = std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;(); que.push(std::pair\u0026lt;int, int\u0026gt;(i, j)); int curr_max_time = BFS1(R, C, i, j, grid, que); max_time = std::min(max_time, curr_max_time); } } } std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: \u0026#34; + std::to_string(max_time) \u0026lt;\u0026lt; std::endl; ++num_case; } return 0; } Solution #3: Binary Search å‰é¢çš„æ–¹æ³•å¯¹æ¯ä¸ªå¯èƒ½çš„ç‚¹éƒ½è¿›è¡Œäº†æœç´¢ï¼Œæ—¶é—´å¤æ‚åº¦è¾¾åˆ°äº†å¹³æ–¹çº§åˆ«ï¼Œå› æ­¤ä¸èƒ½é€šè¿‡ Hidden Test Setã€‚å› ä¸ºé¢˜ç›®éœ€è¦æ±‚æ»¡è¶³è¦æ±‚çš„æœ€å°å€¼ï¼Œè‡ªç„¶å®¹æ˜“æƒ³åˆ°ä½¿ç”¨äºŒåˆ†æ³•æ¥æ±‚ä¸‹ç•Œã€‚\nå¯¹äºä¸€ä¸ªç»™å®šçš„midå€¼ï¼Œå¦‚æœèƒ½å¤Ÿæ·»åŠ æ–°çš„ delivery office ä½¿å¾—æœ€å¤§è¿è¾“æ—¶é—´å°äºç­‰äºmidï¼Œé‚£ä¹ˆå¯èƒ½æœ‰å°äº mid çš„å€¼ (1 \u0026hellip; k-1) ä½¿å¾—ç»“è®ºæˆç«‹ï¼›å¦‚æœç»™å®šçš„midå€¼ä¸èƒ½ä½¿ç»“è®ºæˆç«‹ï¼Œé‚£ä¹ˆå¤§äºç­‰äº mid çš„æ‰€æœ‰å€¼ (k \u0026hellip; INT_MAX) éƒ½ä¸èƒ½ä½¿ç»“è®ºæˆç«‹ã€‚\nä¸ºäº†ç¡®è®¤å›¾ä¸­çš„ç‚¹åˆ° delivery office çš„æœ€çŸ­è·ç¦»å°äº midï¼Œå¯ä»¥å°†å›¾æ—‹è½¬45åº¦ï¼Œä½¿ç”¨ i + j å’Œ i - j åˆ†åˆ«ä½œä¸ºå·¦ä¸‹å’Œå³ä¸Šä¸¤æ¡å¯¹è§’çº¿çš„å€¼æ¥è®¡ç®—å°† mid ä½œä¸ºæœ€å¤§è¿è¾“æ—¶é—´æ—¶èƒ½å¦å®Œæˆè¿è¾“ã€‚\n$$ distance((x1ï¼Œy1)ï¼Œ(x2ï¼Œy2))= \\max (abs(x1 + y1 - (x2 + y2))ï¼Œabs(x1 - y1 - (x2 - y2))) $$\n æ—¶é—´å¤æ‚åº¦ï¼šO(RClog(R+C)) ç©ºé—´å¤æ‚åº¦ï¼šO(RC)  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;limits.h\u0026gt;#include \u0026lt;algorithm\u0026gt; int dir_x[4] = {-1, 0, 1, 0}; int dir_y[4] = {0, -1, 0, 1}; int R, C; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; grid; int BFS(int x, int y, std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;que) { int max_time = 0; int size = que.size(), time = 1; while (!que.empty()) { x = que.front().first, y = que.front().second; que.pop(); max_time = std::max(max_time, grid[x][y]); for (int i = 0; i \u0026lt; 4; ++i) { int new_x = x + dir_x[i], new_y = y + dir_y[i]; if (new_x \u0026gt;= 0 \u0026amp;\u0026amp; new_x \u0026lt; R \u0026amp;\u0026amp; new_y \u0026gt;= 0 \u0026amp;\u0026amp; new_y \u0026lt; C \u0026amp;\u0026amp; grid[new_x][new_y] == -1) { que.push(std::pair\u0026lt;int, int\u0026gt;(new_x, new_y)); grid[new_x][new_y] = time; } } --size; if (size == 0) { size = que.size(); ++time; } } return max_time; } bool CanDeliver(int \u0026amp;max_time) { bool deliver = true; int left_low = INT_MAX, left_high = INT_MIN, right_low = INT_MAX, right_high = INT_MIN; for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { if (grid[i][j] \u0026gt; max_time) { deliver = false; left_low = std::min(left_low, i + j + max_time); left_high = std::max(left_high, i + j - max_time); right_low = std::min(right_low, i - j + max_time); right_high = std::max(right_high, i - j - max_time); } } } if (deliver) return true; for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { int left = i + j, right = i - j; if (left_high \u0026lt;= left \u0026amp;\u0026amp; left \u0026lt;= left_low \u0026amp;\u0026amp; right_high \u0026lt;= right \u0026amp;\u0026amp; right \u0026lt;= right_low) return true; } } return false; } int main() { int num_case = 1; int T; std::cin \u0026gt;\u0026gt; T; for (int t = 0; t \u0026lt; T; ++t) { std::cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; grid = std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(R, std::vector\u0026lt;int\u0026gt;(C, -1)); std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; que; for (int i = 0; i \u0026lt; R; ++i) { std::string temp_in; std::cin \u0026gt;\u0026gt; temp_in; for (int j = 0; j \u0026lt; C; ++j) { char \u0026amp;temp = temp_in[j]; if (temp == \u0026#39;1\u0026#39;) { que.push(std::pair\u0026lt;int, int\u0026gt;(i, j)); grid[i][j] = 0; } } } int size = que.size(); if (size == R * C) { std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: 0\u0026#34; \u0026lt;\u0026lt; std::endl; ++num_case; continue; } // BFS  int max_time = BFS(0, 0, que); // Binary Search  int lowest_time = 0, highest_time = INT_MAX; while (lowest_time \u0026lt; highest_time) { int mid_time = lowest_time + ((highest_time - lowest_time) \u0026gt;\u0026gt; 1); if (CanDeliver(mid_time)) highest_time = mid_time; else lowest_time = mid_time + 1; } std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: \u0026#34; + std::to_string(highest_time) \u0026lt;\u0026lt; std::endl; ++num_case; } return 0; } Contention (18pts, 27pts) // TODO\n","permalink":"http://zintrulcre.github.io/posts/kick-start/2019-round-a/","summary":"Kick Start 2019 Round A Training (7pts, 13pts) ä¸€å…±æœ‰Nä¸ªäººï¼Œä»ä¸­é€‰Pä¸ªäººï¼Œè®¡ç®—è¿™Pä¸ªäººä¸­ skill rating çš„æœ€å¤§å€¼ä¸å…¶ä»–äººçš„ skill rating çš„å·®å€¼ä¹‹å’Œã€‚\n$$ \\sum_{i}^{j} max(rating) - rating[i] $$\nSolution: Sort + Prefix Sum å…ˆå¯¹æ•°ç»„æ’åºï¼Œç„¶ååœ¨é•¿åº¦ä¸ºNçš„æœ‰åºæ•°ç»„ä¸­éå†é•¿ä¸ºPçš„æ‰€æœ‰è¿ç»­å­æ•°ç»„ï¼Œè®¡ç®—å­æ•°ç»„ä¸­çš„æœ€å¤§å€¼ä¸å…¶ä»–å€¼çš„å·®å€¼ä¹‹å’Œã€‚\n$$ \\sum_{i}^{j - 1} rating[j] - rating[i] $$\nå¦‚æœç›´æ¥éå†é•¿ä¸ºPçš„å­æ•°ç»„ä¼šæµªè´¹å¾ˆå¤šæ—¶é—´ï¼Œå¯ä»¥å°†ä¸Šé¢çš„å…¬å¼ç®€åŒ–ä¸ºå¦‚ä¸‹ã€‚\n$$ \\sum_{i}^{j - 1} rating[j] - rating[i] = rating[j] * (j - 1 - i) - \\sum_{i}^{j - 1} rating[i] $$\nä¸ºäº†é¿å…é‡å¤è®¡ç®— $$ \\sum_{i}^{j - 1} rating[i] $$ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªé•¿ä¸ºN+1çš„æ•°ç»„å°†åŸå§‹æ•°ç»„çš„å‰ç¼€å’Œä¿å­˜ä¸‹æ¥ï¼Œè¿™æ ·æ¯æ¬¡ç›´æ¥è®¡ç®— prefix[j] - prefix[i] å°±èƒ½å¾—åˆ° $$ \\sum_{i}^{j - 1} rating[i] $$ äº†ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(N)ã€‚","title":"Kick Start 2019 Round A"},{"content":"Methods to Prevent Overfitting in Deep Learning Overfitting Overfitting refers to that when a model fits the training data well but cannot predict the test data correctly, we may say that the model lacks the ability of generalization. It is important to figure out how it happens, and how we can prevent overfitting from the very beginning.\nDetect Overfitting The simplest way to detect overfitting is to split the dataset into two parts: the training set for training the model, and the test set for testing the accuracy of the model on a dataset that it has never seen before. Of course, we will also partition part of the training set to be the validation set for fine-tuning hyper-parameters. Note that it is necessary to shuffle all the data before splitting.\nThrough this split, we check the performance of the model to gain insight on how the training process goes, and detect overfitting.\nDuring training, we may see the process:\nThe accuracy on the training set has reached a very high ratio, but the accuracy on the validation set still remains not high enough, or even a little bit low.\nIf we plot the accuracy and loss of the training set and the validation set into one figure, we will see:\nIt is obvious that the accuracy of the validation data is much lower than that of the training data.\nAlthough overfitting is frustrating, there are plenty of methods to prevent it from happening.\nPrevent Overfitting Here are some practical methods to prevent overfitting during training deep neural networks:\n1. Regularization Regularization is the most-used method to prevent overfitting in Machine Learning. It constrains the learning of the model by adding a regularization term. Typical regularization is to explicitly add regularization terms in the objective function, e.g. L1 and L2 regularization terms.\nIn deep learning, there are two commonly-used regularization methods: Batch Normalization and Dropout.\nBatch Normalization As the training progresses, the parameters in the deep neural network are constantly updated. On the one hand, parameters are changing slightly during the training. Due to the activation functions in each layer, these slight changes are amplified as the number of layers deepens, and the input distribution of each layer changes; on the other hand, with the change of parameters, former layers need to adapt to these distribution changes, which makes it more difficult to train the model. These are called Internal Covariate Shift.\nBatch Normalization is proposed to solve these two problems. We perform normalization on each layer separately, making the features of each layer have a mean of 0 and a variance of 1, which lets the value of each layer propagate in the effective range. we can also add a linear transformation operation, so that the data can restore the ability of expression.\nThe intuition of Batch Normalization is not to prevent over-fitting or prevent the gradient from vanishing or exploding but to increase the robustness by normalizing the parameter. This constraint also improves the structural rationality of the system, which brings a series of improvements, e.g. accelerate convergence, prevent over-fitting, etc.\nDropout When we are training the model, we can set a probability P for eliminating a node in the deep neural network. For each node, there is a probability of (1-P) for keeping it and a probability of P for dropping it. Then we perform forward-propagation and backpropagation-propagation on this much-diminished deep neural network.\nAt each training step of a mini-batch dataset, the process of dropout creates a different deep neural network by randomly removing some units regarding the probability P. The process of dropout is similar to use ensemble learning on many different deep neural networks, each trained with a separate mini-batch dataset but share some context in the process of training.\nIn ensemble learning, since each classifier has been trained separately, it has learned different aspects of the dataset and their mistakes are different. Combining them helps to produce a more accurate classifier, which is less prone to overfitting. We can view dropout as a form of ensemble learning, and this is why it can prevent overfitting.\n2. Data Augmentation In Deep Learning, collectingÂ data is an effective way to enhance the training but also a tedious and intricate process. In fact, for the majority of image recognition problems, we cannot get as much data as we expect. In order to obtain more data, data augmentation techniques is a very efficient method to improve the result.\nFor Convolutional Neural Networks, some common image augmentation techniques are listed:\n mirroring/flipping (on vertical or horizontal axis) rotating cropping scaling warping color shifting adding noise  There are two ways to do data augmentation: Offline Augmentation and Online Augmentation.\nOffline Augmentation Offline Augmentation is to perform all augmentations in advance, before training, and save all the augmented data in memory. In fact, it will increase, or multiple, the size of the dataset. This method fits small datasets well.\nOnline Augmentation Another option, Online Augmentation, is to perform these augmentations on a mini-batch dataset right before they are fed to the model. This method is more suitable for large datasets because we do not have enough memory for staging all the augmented data when its scale is too enormous, so what we do is to perform mini-batch augmentation before feeding the current batch of data into the model.\n3. Early Stopping Early Stopping is a trade-off between training epochs and validation accuracy. At the end of each epoch, compare current validation accuracy of this epoch with the best validation accuracy. If the accuracy on the validation set decreases or does not reach the best one for more than 10 consecutive epochs, we stop the training, and we think the accuracy is no longer improved.\n4. Simplify The Model If we have done all the methods above to prevent overfitting but the performance is still bad, we may consider simplifying our model. The model may be too complicated for our dataset to fit and we can try to reduce the complexity of the model in some ways, e.g. reduce the number of layers, remove some neurons, etc.\n","permalink":"http://zintrulcre.github.io/posts/deep-learning/methods-to-prevent-overfitting-in-deep-learning/","summary":"Methods to Prevent Overfitting in Deep Learning Overfitting Overfitting refers to that when a model fits the training data well but cannot predict the test data correctly, we may say that the model lacks the ability of generalization. It is important to figure out how it happens, and how we can prevent overfitting from the very beginning.\nDetect Overfitting The simplest way to detect overfitting is to split the dataset into two parts: the training set for training the model, and the test set for testing the accuracy of the model on a dataset that it has never seen before.","title":"Methods to Prevent Overfitting in Deep Learning"},{"content":"C++æ™ºèƒ½æŒ‡é’ˆï¼ˆ3ï¼‰ï¼šshared_ptr åˆ†æ UniquePointerå¯¹è±¡åªèƒ½ç»‘å®šå•ä¸ªæŒ‡é’ˆï¼Œè¦å®ç°æŒ‡é’ˆçš„è‡ªåŠ¨ç®¡ç†å’Œé”€æ¯éœ€è¦å¼•å…¥è®¡æ•°å™¨\nprivate:\rint *counter;\rT *pointer;\rD *deleter;\rè®¡æ•°å™¨çš„ä¸»è¦ä½œç”¨æ˜¯æ ‡è¯†å½“å‰æŒ‡é’ˆè¢«å‡ ä¸ªæ™ºèƒ½æŒ‡é’ˆå¯¹è±¡æ‰€å¼•ç”¨ï¼Œåœ¨ææ„å½“å‰å¯¹è±¡æ—¶ï¼Œä½¿\u0008å…¶è®¡æ•°å™¨è‡ªå‡1ã€‚\u0008å¦‚æœè®¡æ•°å™¨ç­‰äº0ï¼Œåˆ™è¡¨ç¤ºå·²ç»æ²¡æœ‰å…¶ä»–çš„å¯¹è±¡åœ¨ä½¿ç”¨å½“å‰æŒ‡é’ˆï¼Œ\u0008æ­¤æ—¶åˆ™å¯ä»¥é”€æ¯æŒ‡é’ˆï¼Œè®¡æ•°å™¨å’Œåˆ é™¤å™¨ã€‚\ntemplate\u0026lt;typename T, typename D\u0026gt;\rvoid SharedPointer\u0026lt;T, D\u0026gt;::release() {\rif (pointer) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; counter remains \u0026quot; \u0026lt;\u0026lt; *counter \u0026lt;\u0026lt; std::endl;\rif (--(*counter) == 0) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; destructor called.\u0026quot; \u0026lt;\u0026lt; std::endl;\r(*deleter)(pointer);\r(*deleter)(counter);\r(*deleter)(deleter);\rpointer = nullptr;\rcounter = nullptr;\rdeleter = nullptr;\r}\r}\r}\rresetå‡½æ•°å°†æŒ‡é’ˆè®¾ä¸ºotherçš„æŒ‡é’ˆ\ntemplate\u0026lt;typename T, typename D\u0026gt;\rvoid SharedPointer\u0026lt;T, D\u0026gt;::reset(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) {\rpointer = other.pointer;\rcounter = other.counter;\rdeleter = other.deleter;\rif (pointer)\r++(*counter);\r}\rææ„å‡½æ•°å¯ä»¥ç›´æ¥è°ƒç”¨releaseå‡½æ•°\ntemplate\u0026lt;typename T, typename D\u0026gt;\rSharedPointer\u0026lt;T, D\u0026gt;::~SharedPointer() {\rrelease();\r}\ræ‹·è´æ„é€ å‡½æ•°å¯ä»¥ç›´æ¥è°ƒç”¨resetå‡½æ•°\ntemplate\u0026lt;typename T, typename D\u0026gt;\rSharedPointer\u0026lt;T, D\u0026gt;::SharedPointer(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; copy constructor called.\u0026quot; \u0026lt;\u0026lt; std::endl;\rreset(other);\r}\rä½¿ç”¨èµ‹å€¼æ“ä½œç¬¦æ—¶å…ˆè°ƒç”¨releaseå‡½æ•°ï¼Œå†è°ƒç”¨resetå‡½æ•°\ntemplate\u0026lt;typename T, typename D\u0026gt;\rSharedPointer\u0026lt;T, D\u0026gt; \u0026amp;SharedPointer\u0026lt;T, D\u0026gt;::operator=(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; assignment operator called.\u0026quot; \u0026lt;\u0026lt; std::endl;\rif (this != \u0026amp;other) {\rrelease();\rreset(other);\r}\rreturn *this;\r}\rå®ç° æ ¹æ®shared_ptrçš„æºç ï¼Œèƒ½å¤Ÿå¤§è‡´å®ç°SharedPointerç±»\ntemplate\u0026lt;typename T, typename D\u0026gt;\rclass SharedPointer {\rpublic:\rexplicit SharedPointer(T *t = nullptr, D *d = nullptr);\r~SharedPointer();\rT \u0026amp;operator*();\rT *operator-\u0026gt;();\rvoid reset(const SharedPointer \u0026amp;other);\rvoid release();\rSharedPointer(const SharedPointer \u0026amp;other);\rSharedPointer \u0026amp;operator=(const SharedPointer \u0026amp;other);\rprivate:\rint *counter;\rT *pointer;\rD *deleter;\r};\rtemplate\u0026lt;typename T, typename D\u0026gt;\rvoid SharedPointer\u0026lt;T, D\u0026gt;::reset(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) {\rpointer = other.pointer;\rcounter = other.counter;\rdeleter = other.deleter;\rif (pointer)\r++(*counter);\r}\rtemplate\u0026lt;typename T, typename D\u0026gt;\rvoid SharedPointer\u0026lt;T, D\u0026gt;::release() {\rif (pointer) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; counter remains \u0026quot; \u0026lt;\u0026lt; *counter \u0026lt;\u0026lt; std::endl;\rif (--(*counter) == 0) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; destructor called.\u0026quot; \u0026lt;\u0026lt; std::endl;\r(*deleter)(pointer);\r(*deleter)(counter);\r(*deleter)(deleter);\rpointer = nullptr;\rcounter = nullptr;\rdeleter = nullptr;\r}\r}\r}\rtemplate\u0026lt;typename T, typename D\u0026gt;\rSharedPointer\u0026lt;T, D\u0026gt;::SharedPointer(T *t, D *d): pointer(t), deleter(d) {\rif (pointer)\rcounter = new int(1);\relse\rcounter = nullptr;\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; constructor called.\u0026quot; \u0026lt;\u0026lt; std::endl;\r}\rtemplate\u0026lt;typename T, typename D\u0026gt;\rSharedPointer\u0026lt;T, D\u0026gt;::SharedPointer(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; copy constructor called.\u0026quot; \u0026lt;\u0026lt; std::endl;\rreset(other);\r}\rtemplate\u0026lt;typename T, typename D\u0026gt;\rSharedPointer\u0026lt;T, D\u0026gt;::~SharedPointer() {\rrelease();\r}\rtemplate\u0026lt;typename T, typename D\u0026gt;\rT \u0026amp;SharedPointer\u0026lt;T, D\u0026gt;::operator*() {\rreturn *pointer;\r}\rtemplate\u0026lt;typename T, typename D\u0026gt;\rT *SharedPointer\u0026lt;T, D\u0026gt;::operator-\u0026gt;() {\rreturn pointer;\r}\rtemplate\u0026lt;typename T, typename D\u0026gt;\rSharedPointer\u0026lt;T, D\u0026gt; \u0026amp;SharedPointer\u0026lt;T, D\u0026gt;::operator=(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; assignment operator called.\u0026quot; \u0026lt;\u0026lt; std::endl;\rif (this != \u0026amp;other) {\rrelease();\rreset(other);\r}\rreturn *this;\r}\ræµ‹è¯• å°è¯•ä½¿ç”¨æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ“ä½œç¬¦ä½¿å¤šä¸ªSharedPointerå¯¹è±¡ä½¿ç”¨åŒä¸€ä¸ªæŒ‡é’ˆï¼Œä»¥åŠä½¿ç”¨resetå‡½æ•°æ¸…ç©ºæ™ºèƒ½æŒ‡é’ˆå¯¹è±¡çš„æŒ‡é’ˆ\nint main() {\rDeleter *deleter = new Deleter();\rObj *o = new Obj();\rSharedPointer\u0026lt;Obj, Deleter\u0026gt; s1(o, deleter);\rSharedPointer\u0026lt;Obj, Deleter\u0026gt; s2(s1);\rSharedPointer\u0026lt;Obj, Deleter\u0026gt; s3;\rs3 = s1;\rreturn 0;\r}\r/*\routput:\rConstruct\rSharedPointer 0x7ffeeebdda00 constructor called.\rSharedPointer 0x7ffeeebdd9e8 copy constructor called.\rSharedPointer 0x7ffeeebdd9d0 constructor called.\rSharedPointer 0x7ffeeebdd9d0 assignment operator called.\rSharedPointer 0x7ffeeebdd9d0 counter remains 3\rSharedPointer 0x7ffeeebdd9e8 counter remains 2\rSharedPointer 0x7ffeeebdda00 counter remains 1\rSharedPointer 0x7ffeeebdda00 destructor called.\rDestruct\r*/\rè€ƒè™‘å¦‚ä¸‹ä¸€ä¸ªç±»\nclass Object : public Obj {\rpublic:\rSharedPointer\u0026lt;Object, Deleter\u0026gt; S;\r};\råˆ›å»ºä¸¤ä¸ªObjectç±»å‹çš„å¯¹è±¡\nint main() {\rSharedPointer\u0026lt;Object, Deleter\u0026gt; s1(new Object());\rSharedPointer\u0026lt;Object, Deleter\u0026gt; s2(new Object());\rs1-\u0026gt;S = s2;\rs2-\u0026gt;S = s1;\rreturn 0;\r}\r/*\routput:\rConstruct\rSharedPointer 0x7f88eac02ab0 constructor called.\rSharedPointer 0x7ffee0bfaa20 constructor called.\rConstruct\rSharedPointer 0x7f88eac02ae0 constructor called.\rSharedPointer 0x7ffee0bfa9f8 constructor called.\rSharedPointer 0x7f88eac02ab0 assignment operator called.\rSharedPointer 0x7f88eac02ae0 assignment operator called.\rSharedPointer 0x7ffee0bfa9f8 counter remains 2\rSharedPointer 0x7ffee0bfaa20 counter remains 2\r*/\rä¸¤ä¸ªObjectç±»å‹çš„æŒ‡é’ˆéƒ½åŒ…å«äº†ä¸€ä¸ªSharedPointerç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆå¯¹è±¡ï¼Œä½†è¿™ä¸¤ä¸ªæŒ‡é’ˆåˆä¾èµ–äºSharedPointerå¯¹è±¡å»è¿›è¡Œé”€æ¯ï¼Œå¯¼è‡´æœ€ås1å’Œs2çš„è®¡æ•°å™¨éƒ½ä¸èƒ½å‡ä¸º0ï¼Œä»è€Œä¸èƒ½æ­£ç¡®åœ°\u0008é”€æ¯æŒ‡é’ˆï¼Œå¯¼è‡´äº†å†…å­˜æ³„æ¼ã€‚è¿™ç§ç°è±¡å«åšäº¤å‰å¼•ç”¨ã€‚\næ€»ç»“ SharedPointeråˆ©ç”¨Reference countingï¼ˆè®¡æ•°å¼•ç”¨ï¼‰è§£å†³äº†å¤šä¸ªå¯¹è±¡ä½¿ç”¨åŒä¸€ä¸ªæŒ‡é’ˆæ—¶è‡ªåŠ¨é”€æ¯æŒ‡é’ˆçš„é—®é¢˜ï¼Œä½†åˆä¼šå‘ç”Ÿäº¤å‰å¼•ç”¨æ—¶ä¸èƒ½å¤Ÿæ­£ç¡®é”€æ¯æŒ‡é’ˆçš„é—®é¢˜ã€‚\u0008\nshared_pointeræºç  template\u0026lt;class _Tp\u0026gt;\rclass _LIBCPP_TEMPLATE_VIS shared_ptr\r{\rpublic:\rtypedef _Tp element_type;\r#if _LIBCPP_STD_VER \u0026gt; 14\rtypedef weak_ptr\u0026lt;_Tp\u0026gt; weak_type;\r#endif\rprivate:\relement_type* __ptr_;\r__shared_weak_count* __cntrl_;\rstruct __nat {int __for_bool_;};\rpublic:\r_LIBCPP_INLINE_VISIBILITY\r_LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\r_LIBCPP_INLINE_VISIBILITY\r_LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\rtemplate\u0026lt;class _Yp\u0026gt;\rexplicit shared_ptr(_Yp* __p,\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat());\rtemplate\u0026lt;class _Yp, class _Dp\u0026gt;\rshared_ptr(_Yp* __p, _Dp __d,\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat());\rtemplate\u0026lt;class _Yp, class _Dp, class _Alloc\u0026gt;\rshared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat());\rtemplate \u0026lt;class _Dp\u0026gt; shared_ptr(nullptr_t __p, _Dp __d);\rtemplate \u0026lt;class _Dp, class _Alloc\u0026gt; shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\rtemplate\u0026lt;class _Yp\u0026gt; _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp; __r, element_type* __p) _NOEXCEPT;\r_LIBCPP_INLINE_VISIBILITY\rshared_ptr(const shared_ptr\u0026amp; __r) _NOEXCEPT;\rtemplate\u0026lt;class _Yp\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rshared_ptr(const shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp; __r,\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat())\r_NOEXCEPT;\r#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\r_LIBCPP_INLINE_VISIBILITY\rshared_ptr(shared_ptr\u0026amp;\u0026amp; __r) _NOEXCEPT;\rtemplate\u0026lt;class _Yp\u0026gt; _LIBCPP_INLINE_VISIBILITY shared_ptr(shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp;\u0026amp; __r,\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat())\r_NOEXCEPT;\r#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES\rtemplate\u0026lt;class _Yp\u0026gt; explicit shared_ptr(const weak_ptr\u0026lt;_Yp\u0026gt;\u0026amp; __r,\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type= __nat());\r#if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\r#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\rtemplate\u0026lt;class _Yp\u0026gt;\rshared_ptr(auto_ptr\u0026lt;_Yp\u0026gt;\u0026amp;\u0026amp; __r,\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat());\r#else\rtemplate\u0026lt;class _Yp\u0026gt;\rshared_ptr(auto_ptr\u0026lt;_Yp\u0026gt; __r,\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat());\r#endif\r#endif\r#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\rtemplate \u0026lt;class _Yp, class _Dp\u0026gt;\rshared_ptr(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;\u0026amp;\u0026amp;,\rtypename enable_if\r\u0026lt;\r!is_lvalue_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp;\r!is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp;\ris_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value,\r__nat\r\u0026gt;::type = __nat());\rtemplate \u0026lt;class _Yp, class _Dp\u0026gt;\rshared_ptr(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;\u0026amp;\u0026amp;,\rtypename enable_if\r\u0026lt;\ris_lvalue_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp;\r!is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp;\ris_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value,\r__nat\r\u0026gt;::type = __nat());\r#else // _LIBCPP_HAS_NO_RVALUE_REFERENCES\rtemplate \u0026lt;class _Yp, class _Dp\u0026gt;\rshared_ptr(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;,\rtypename enable_if\r\u0026lt;\r!is_lvalue_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp;\r!is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp;\ris_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value,\r__nat\r\u0026gt;::type = __nat());\rtemplate \u0026lt;class _Yp, class _Dp\u0026gt;\rshared_ptr(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;,\rtypename enable_if\r\u0026lt;\ris_lvalue_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp;\r!is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp;\ris_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value,\r__nat\r\u0026gt;::type = __nat());\r#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES\r~shared_ptr();\r_LIBCPP_INLINE_VISIBILITY\rshared_ptr\u0026amp; operator=(const shared_ptr\u0026amp; __r) _NOEXCEPT;\rtemplate\u0026lt;class _Yp\u0026gt;\rtypename enable_if\r\u0026lt;\ris_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value,\rshared_ptr\u0026amp;\r\u0026gt;::type\r_LIBCPP_INLINE_VISIBILITY\roperator=(const shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp; __r) _NOEXCEPT;\r#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\r_LIBCPP_INLINE_VISIBILITY\rshared_ptr\u0026amp; operator=(shared_ptr\u0026amp;\u0026amp; __r) _NOEXCEPT;\rtemplate\u0026lt;class _Yp\u0026gt;\rtypename enable_if\r\u0026lt;\ris_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value,\rshared_ptr\u0026lt;_Tp\u0026gt;\u0026amp;\r\u0026gt;::type\r_LIBCPP_INLINE_VISIBILITY\roperator=(shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp;\u0026amp; __r);\r#if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\rtemplate\u0026lt;class _Yp\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rtypename enable_if\r\u0026lt;\r!is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp;\ris_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value,\rshared_ptr\r\u0026gt;::type\u0026amp;\roperator=(auto_ptr\u0026lt;_Yp\u0026gt;\u0026amp;\u0026amp; __r);\r#endif\r#else // _LIBCPP_HAS_NO_RVALUE_REFERENCES\r#if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\rtemplate\u0026lt;class _Yp\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rtypename enable_if\r\u0026lt;\r!is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp;\ris_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value,\rshared_ptr\u0026amp;\r\u0026gt;::type\roperator=(auto_ptr\u0026lt;_Yp\u0026gt; __r);\r#endif\r#endif\rtemplate \u0026lt;class _Yp, class _Dp\u0026gt;\rtypename enable_if\r\u0026lt;\r!is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp;\ris_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value,\rshared_ptr\u0026amp;\r\u0026gt;::type\r#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\r_LIBCPP_INLINE_VISIBILITY\roperator=(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;\u0026amp;\u0026amp; __r);\r#else // _LIBCPP_HAS_NO_RVALUE_REFERENCES\r_LIBCPP_INLINE_VISIBILITY\roperator=(unique_ptr\u0026lt;_Yp, _Dp\u0026gt; __r);\r#endif\r_LIBCPP_INLINE_VISIBILITY\rvoid swap(shared_ptr\u0026amp; __r) _NOEXCEPT;\r_LIBCPP_INLINE_VISIBILITY\rvoid reset() _NOEXCEPT;\rtemplate\u0026lt;class _Yp\u0026gt;\rtypename enable_if\r\u0026lt;\ris_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value,\rvoid\r\u0026gt;::type\r_LIBCPP_INLINE_VISIBILITY\rreset(_Yp* __p);\rtemplate\u0026lt;class _Yp, class _Dp\u0026gt;\rtypename enable_if\r\u0026lt;\ris_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value,\rvoid\r\u0026gt;::type\r_LIBCPP_INLINE_VISIBILITY\rreset(_Yp* __p, _Dp __d);\rtemplate\u0026lt;class _Yp, class _Dp, class _Alloc\u0026gt;\rtypename enable_if\r\u0026lt;\ris_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value,\rvoid\r\u0026gt;::type\r_LIBCPP_INLINE_VISIBILITY\rreset(_Yp* __p, _Dp __d, _Alloc __a);\r_LIBCPP_INLINE_VISIBILITY\relement_type* get() const _NOEXCEPT {return __ptr_;}\r_LIBCPP_INLINE_VISIBILITY\rtypename add_lvalue_reference\u0026lt;element_type\u0026gt;::type operator*() const _NOEXCEPT\r{return *__ptr_;}\r_LIBCPP_INLINE_VISIBILITY\relement_type* operator-\u0026gt;() const _NOEXCEPT {return __ptr_;}\r_LIBCPP_INLINE_VISIBILITY\rlong use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_-\u0026gt;use_count() : 0;}\r_LIBCPP_INLINE_VISIBILITY\rbool unique() const _NOEXCEPT {return use_count() == 1;}\r_LIBCPP_INLINE_VISIBILITY\r_LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\rtemplate \u0026lt;class _Up\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rbool owner_before(shared_ptr\u0026lt;_Up\u0026gt; const\u0026amp; __p) const _NOEXCEPT\r{return __cntrl_ \u0026lt; __p.__cntrl_;}\rtemplate \u0026lt;class _Up\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rbool owner_before(weak_ptr\u0026lt;_Up\u0026gt; const\u0026amp; __p) const _NOEXCEPT\r{return __cntrl_ \u0026lt; __p.__cntrl_;}\r_LIBCPP_INLINE_VISIBILITY\rbool\r__owner_equivalent(const shared_ptr\u0026amp; __p) const\r{return __cntrl_ == __p.__cntrl_;}\r#ifndef _LIBCPP_NO_RTTI\rtemplate \u0026lt;class _Dp\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\r_Dp* __get_deleter() const _NOEXCEPT\r{return static_cast\u0026lt;_Dp*\u0026gt;(__cntrl_\r? const_cast\u0026lt;void *\u0026gt;(__cntrl_-\u0026gt;__get_deleter(typeid(_Dp)))\r: nullptr);}\r#endif // _LIBCPP_NO_RTTI\r#ifndef _LIBCPP_HAS_NO_VARIADICS\rtemplate\u0026lt;class ..._Args\u0026gt;\rstatic\rshared_ptr\u0026lt;_Tp\u0026gt;\rmake_shared(_Args\u0026amp;\u0026amp; ...__args);\rtemplate\u0026lt;class _Alloc, class ..._Args\u0026gt;\rstatic\rshared_ptr\u0026lt;_Tp\u0026gt;\rallocate_shared(const _Alloc\u0026amp; __a, _Args\u0026amp;\u0026amp; ...__args);\r#else // _LIBCPP_HAS_NO_VARIADICS\rstatic shared_ptr\u0026lt;_Tp\u0026gt; make_shared();\rtemplate\u0026lt;class _A0\u0026gt;\rstatic shared_ptr\u0026lt;_Tp\u0026gt; make_shared(_A0\u0026amp;);\rtemplate\u0026lt;class _A0, class _A1\u0026gt;\rstatic shared_ptr\u0026lt;_Tp\u0026gt; make_shared(_A0\u0026amp;, _A1\u0026amp;);\rtemplate\u0026lt;class _A0, class _A1, class _A2\u0026gt;\rstatic shared_ptr\u0026lt;_Tp\u0026gt; make_shared(_A0\u0026amp;, _A1\u0026amp;, _A2\u0026amp;);\rtemplate\u0026lt;class _Alloc\u0026gt;\rstatic shared_ptr\u0026lt;_Tp\u0026gt;\rallocate_shared(const _Alloc\u0026amp; __a);\rtemplate\u0026lt;class _Alloc, class _A0\u0026gt;\rstatic shared_ptr\u0026lt;_Tp\u0026gt;\rallocate_shared(const _Alloc\u0026amp; __a, _A0\u0026amp; __a0);\rtemplate\u0026lt;class _Alloc, class _A0, class _A1\u0026gt;\rstatic shared_ptr\u0026lt;_Tp\u0026gt;\rallocate_shared(const _Alloc\u0026amp; __a, _A0\u0026amp; __a0, _A1\u0026amp; __a1);\rtemplate\u0026lt;class _Alloc, class _A0, class _A1, class _A2\u0026gt;\rstatic shared_ptr\u0026lt;_Tp\u0026gt;\rallocate_shared(const _Alloc\u0026amp; __a, _A0\u0026amp; __a0, _A1\u0026amp; __a1, _A2\u0026amp; __a2);\r#endif // _LIBCPP_HAS_NO_VARIADICS\rprivate:\rtemplate \u0026lt;class _Yp, bool = is_function\u0026lt;_Yp\u0026gt;::value\u0026gt;\rstruct __shared_ptr_default_allocator\r{\rtypedef allocator\u0026lt;_Yp\u0026gt; type;\r};\rtemplate \u0026lt;class _Yp\u0026gt;\rstruct __shared_ptr_default_allocator\u0026lt;_Yp, true\u0026gt;\r{\rtypedef allocator\u0026lt;__shared_ptr_dummy_rebind_allocator_type\u0026gt; type;\r};\rtemplate \u0026lt;class _Yp, class _OrigPtr\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rtypename enable_if\u0026lt;is_convertible\u0026lt;_OrigPtr*,\rconst enable_shared_from_this\u0026lt;_Yp\u0026gt;*\r\u0026gt;::value,\rvoid\u0026gt;::type\r__enable_weak_this(const enable_shared_from_this\u0026lt;_Yp\u0026gt;* __e,\r_OrigPtr* __ptr) _NOEXCEPT\r{\rtypedef typename remove_cv\u0026lt;_Yp\u0026gt;::type _RawYp;\rif (__e \u0026amp;\u0026amp; __e-\u0026gt;__weak_this_.expired())\r{\r__e-\u0026gt;__weak_this_ = shared_ptr\u0026lt;_RawYp\u0026gt;(*this,\rconst_cast\u0026lt;_RawYp*\u0026gt;(static_cast\u0026lt;const _Yp*\u0026gt;(__ptr)));\r}\r}\r_LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {}\rtemplate \u0026lt;class _Up\u0026gt; friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\rtemplate \u0026lt;class _Up\u0026gt; friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\r};\r","permalink":"http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-3/","summary":"C++æ™ºèƒ½æŒ‡é’ˆï¼ˆ3ï¼‰ï¼šshared_ptr åˆ†æ UniquePointerå¯¹è±¡åªèƒ½ç»‘å®šå•ä¸ªæŒ‡é’ˆï¼Œè¦å®ç°æŒ‡é’ˆçš„è‡ªåŠ¨ç®¡ç†å’Œé”€æ¯éœ€è¦å¼•å…¥è®¡æ•°å™¨\nprivate:\rint *counter;\rT *pointer;\rD *deleter;\rè®¡æ•°å™¨çš„ä¸»è¦ä½œç”¨æ˜¯æ ‡è¯†å½“å‰æŒ‡é’ˆè¢«å‡ ä¸ªæ™ºèƒ½æŒ‡é’ˆå¯¹è±¡æ‰€å¼•ç”¨ï¼Œåœ¨ææ„å½“å‰å¯¹è±¡æ—¶ï¼Œä½¿\u0008å…¶è®¡æ•°å™¨è‡ªå‡1ã€‚\u0008å¦‚æœè®¡æ•°å™¨ç­‰äº0ï¼Œåˆ™è¡¨ç¤ºå·²ç»æ²¡æœ‰å…¶ä»–çš„å¯¹è±¡åœ¨ä½¿ç”¨å½“å‰æŒ‡é’ˆï¼Œ\u0008æ­¤æ—¶åˆ™å¯ä»¥é”€æ¯æŒ‡é’ˆï¼Œè®¡æ•°å™¨å’Œåˆ é™¤å™¨ã€‚\ntemplate\u0026lt;typename T, typename D\u0026gt;\rvoid SharedPointer\u0026lt;T, D\u0026gt;::release() {\rif (pointer) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; counter remains \u0026quot; \u0026lt;\u0026lt; *counter \u0026lt;\u0026lt; std::endl;\rif (--(*counter) == 0) {\rstd::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; destructor called.\u0026quot; \u0026lt;\u0026lt; std::endl;\r(*deleter)(pointer);\r(*deleter)(counter);\r(*deleter)(deleter);\rpointer = nullptr;\rcounter = nullptr;\rdeleter = nullptr;\r}\r}\r}\rresetå‡½æ•°å°†æŒ‡é’ˆè®¾ä¸ºotherçš„æŒ‡é’ˆ","title":"C++ æ™ºèƒ½æŒ‡é’ˆï¼ˆ3ï¼‰ï¼šshared_ptr"},{"content":"C++æ™ºèƒ½æŒ‡é’ˆï¼ˆ2ï¼‰ï¼šunique_ptr åˆ†æ åœ¨ä½¿ç”¨ AutoPointer çš„æ—¶å€™ä¼šå‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»å’Œå†…å­˜æ³„æ¼çš„é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹ AutoPointer ç±»ç¨åŠ ä¿®æ”¹ï¼Œä¿®å¤è¿™ä¸¤ä¸ªé—®é¢˜\u0008ã€‚\næ‰€æœ‰æƒè½¬ç§» ä¸ºäº†è§„é¿å¯èƒ½å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»çš„æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ç¦æ­¢å®ƒä½¿ç”¨æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ“ä½œç¬¦ã€‚\nUniquePointer(UniquePointer\u0026lt;T\u0026gt; \u0026amp;other) = delete; UniquePointer\u0026lt;T\u0026gt; \u0026amp;operator=(const UniquePointer\u0026lt;T\u0026gt; \u0026amp;other) = delete; \u0008ä½†å¾ˆå¤šæ—¶å€™æˆ‘ä»¬éƒ½éœ€è¦ä½¿ç”¨åˆ°ä¼ é€’æŒ‡é’ˆçš„æ“ä½œï¼Œå¦‚æœåªæ˜¯ä½¿ç”¨ deleted å‡½æ•°ç¦æ­¢æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ“ä½œç¬¦ï¼Œé‚£ä¹ˆè¿™ä¸ªæ™ºèƒ½æŒ‡é’ˆå­˜åœ¨çš„æ„ä¹‰å°±ä¸å¤§äº†ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ move è¯­ä¹‰æ¥å®ç°ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦ï¼Œä»è€Œåœ¨ä½¿ç”¨ UniquePointer çš„æ—¶å€™å¯ä»¥åœ¨ç‰¹å®šæƒ…å†µä¸‹è¿›è¡Œæ‰€æœ‰æƒè½¬ç§»ã€‚\nUniquePointer(UniquePointer\u0026lt;T\u0026gt; \u0026amp;\u0026amp;other) noexcept; UniquePointer \u0026amp;operator=(UniquePointer \u0026amp;\u0026amp;other) noexcept; å†…å­˜æ³„æ¼ ä¸ºäº†é˜²æ­¢å‘ç”Ÿå†…å­˜æ³„æ¼ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨UniquePointerçš„ç§æœ‰æˆå‘˜ä¸­å¢åŠ ä¸€ä¸ªåˆ é™¤å™¨ï¼Œå¹¶\u0008æ ¹æ®å½“å‰æŒ‡é’ˆå¯¹è±¡çš„ç±»å‹æŒ‡å®šåˆ é™¤å™¨ï¼Œä»è€Œé˜²æ­¢å‘ç”Ÿå†…å­˜æ³„æ¼ã€‚\nclass Deleter { template\u0026lt;typename T\u0026gt; void operator()(T *p) { if (p) delete p; } }; template\u0026lt;typename T, typename D\u0026gt; class UniquePointer { ... private: T *pointer; Deleter deleter; }; å®ç° æ ¹æ®unique_ptrçš„æºç ï¼Œèƒ½å¤Ÿå¤§è‡´å®ç°UniquePointerç±»\ntemplate\u0026lt;typename T, typename D\u0026gt; class UniquePointer { public: explicit UniquePointer(T *t, const D \u0026amp;d); ~UniquePointer(); T \u0026amp;operator*(); T *operator-\u0026gt;(); T *release(); void reset(T *p); UniquePointer(UniquePointer \u0026amp;\u0026amp;other) noexcept; UniquePointer \u0026amp;operator=(UniquePointer \u0026amp;\u0026amp;other) noexcept; UniquePointer(const UniquePointer \u0026amp;other) = delete; UniquePointer \u0026amp;operator=(const UniquePointer \u0026amp;other) = delete; private: T *pointer; D deleter; }; template\u0026lt;typename T, typename D\u0026gt; UniquePointer\u0026lt;T, D\u0026gt;::UniquePointer(T *t, const D \u0026amp;d) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; this-\u0026gt;pointer = t; this-\u0026gt;deleter = d; } template\u0026lt;typename T, typename D\u0026gt; UniquePointer\u0026lt;T, D\u0026gt;::~UniquePointer() { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; deleter(this-\u0026gt;pointer); } template\u0026lt;typename T, typename D\u0026gt; T \u0026amp;UniquePointer\u0026lt;T, D\u0026gt;::operator*() { return *this-\u0026gt;pointer; } template\u0026lt;typename T, typename D\u0026gt; T *UniquePointer\u0026lt;T, D\u0026gt;::operator-\u0026gt;() { return this-\u0026gt;pointer; } template\u0026lt;typename T, typename D\u0026gt; T *UniquePointer\u0026lt;T, D\u0026gt;::release() { T *new_pointer = this-\u0026gt;pointer; this-\u0026gt;pointer = nullptr; return new_pointer; } template\u0026lt;typename T, typename D\u0026gt; void UniquePointer\u0026lt;T, D\u0026gt;::reset(T *p) { if (this-\u0026gt;pointer != p) { deleter(this-\u0026gt;pointer); this-\u0026gt;pointer = p; } } template\u0026lt;typename T, typename D\u0026gt; UniquePointer\u0026lt;T, D\u0026gt;::UniquePointer(UniquePointer\u0026lt;T, D\u0026gt; \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; move constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; this-\u0026gt;pointer = other.release(); deleter(std::move(other.deleter)); } template\u0026lt;typename T, typename D\u0026gt; UniquePointer\u0026lt;T, D\u0026gt; \u0026amp;UniquePointer\u0026lt;T, D\u0026gt;::operator=(UniquePointer\u0026lt;T, D\u0026gt; \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; assignment operator called.\u0026#34; \u0026lt;\u0026lt; std::endl; if (this-\u0026gt;pointer != other.pointer) { reset(other.release()); deleter = std::move(other.deleter); } return *this; } æµ‹è¯• å°è¯•ä½¿ç”¨ç§»åŠ¨æ„é€ å‡½æ•°\nclass Deleter { public: template\u0026lt;typename T\u0026gt; void operator()(T *p) { if (p) delete p; } }; int main() { Deleter deleter; Obj *o = new Obj(); UniquePointer\u0026lt;Obj, Deleter\u0026gt; u1(o, deleter); UniquePointer\u0026lt;Obj, Deleter\u0026gt; u2(move(u1)); return 0; } /* output: Construct UniquePointer 0x7ffee7dada08 constructor called. UniquePointer 0x7ffee7dad9f8 move constructor called. UniquePointer 0x7ffee7dad9f8 destructor called. Destruct UniquePointer 0x7ffee7dada08 destructor called. */ å°è¯•ä½¿ç”¨ç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦\nclass Deleter {\rpublic:\rtemplate\u0026lt;typename T\u0026gt;\rvoid operator()(T *p) {\rif (p)\rdelete p;\r}\r};\rint main() {\rDeleter deleter;\rObj *o = new Obj();\rUniquePointer\u0026lt;Obj, Deleter\u0026gt; u1(o, deleter);\rUniquePointer\u0026lt;Obj, Deleter\u0026gt; u2(nullptr, deleter);\ru2 = move(u1);\rreturn 0;\r}\r/*\routput:\rConstruct\rUniquePointer 0x7ffee915da08 constructor called.\rUniquePointer 0x7ffee915d9f8 constructor called.\rUniquePointer 0x7ffee915d9f8 assignment operator called.\rUniquePointer 0x7ffee915d9f8 destructor called.\rDestruct\rUniquePointer 0x7ffee915da08 destructor called.\r*/\rå®šä¹‰ä¸€ä¸ªæ•°ç»„åˆ é™¤å™¨ï¼Œå°è¯•\u0008ä»¥æ•°ç»„æŒ‡é’ˆåˆå§‹åŒ–UniquePointerç±»å¯¹è±¡\nclass ArrayDeleter {\rpublic:\rtemplate\u0026lt;typename T\u0026gt;\rvoid operator()(T *p) {\rif (p)\rdelete[] p;\r}\r};\rint main() {\rArrayDeleter array_deleter;\rObj *o = new Obj[3];\rUniquePointer\u0026lt;Obj, ArrayDeleter\u0026gt; u(o, array_deleter);\rreturn 0;\r}\r/*\routput:\rConstruct\rConstruct\rConstruct\rUniquePointer 0x7ffeed926a08 constructor called.\rUniquePointer 0x7ffeed926a08 destructor called.\rDestruct\rDestruct\rDestruct\r*/\rä½œä¸ºå¯¹æ¯”ï¼Œå¦‚æœä½¿ç”¨é»˜è®¤åˆ é™¤å™¨ä½œä¸ºæ•°ç»„æŒ‡é’ˆçš„åˆ é™¤å™¨\nclass Deleter {\rpublic:\rtemplate\u0026lt;typename T\u0026gt;\rvoid operator()(T *p) {\rif (p)\rdelete p;\r}\r};\rint main() {\rDeleter deleter;\rObj *o = new Obj[3];\rUniquePointer\u0026lt;Obj, Deleter\u0026gt; u(o, deleter);\rreturn 0;\r}\r/*\routput:\rConstruct\rConstruct\rConstruct\rUniquePointer 0x7ffee8f85a10 constructor called.\rUniquePointer 0x7ffee8f85a10 destructor called.\rDestruct\r*/\rè¯´æ˜åˆ é™¤å™¨èƒ½å¤Ÿæ­£ç¡®åœ°ä¿®å¤å†…å­˜æ³„æ¼çš„é—®é¢˜ã€‚\nå°è¯•å°†ä¸¤ä¸ªUniquePointerçš„å¯¹è±¡æŒ‡å‘åŒä¸€ä¸ªæŒ‡é’ˆ\nint main() {\rDeleter deleter;\rObj *o = new Obj();\rUniquePointer\u0026lt;Obj, Deleter\u0026gt; u1(o, deleter);\rUniquePointer\u0026lt;Obj, Deleter\u0026gt; u2(o, deleter);\rreturn 0;\r}\r/*\routput:\r(19576,0x10e00a5c0) malloc: *** error for object 0x7fcfe8c02ab0: pointer being freed was not allocated\r(19576,0x10e00a5c0) malloc: *** set a breakpoint in malloc_error_break to debug\rConstruct\rUniquePointer 0x7ffee28a9a10 constructor called.\rUniquePointer 0x7ffee28a9a00 constructor called.\rUniquePointer 0x7ffee28a9a00 destructor called.\rDestruct\rUniquePointer 0x7ffee28a9a10 destructor called.\rDestruct\r*/\rè¿˜æ˜¯äº§ç”Ÿè°ƒç”¨ä¸¤æ¬¡ææ„å‡½æ•°çš„é”™è¯¯ã€‚\næ€»ç»“ UniquePointeræˆåŠŸåœ°è§£å†³äº†æ‰€æœ‰æƒè½¬ç§»å’Œå†…å­˜æ³„æ¼çš„é—®é¢˜ï¼Œä½†è¿˜æœ‰è¯¸å¦‚é‡å¤ææ„çš„é—®é¢˜å­˜åœ¨ã€‚\nunique_ptræºç  template \u0026lt;class _Tp, class _Dp = default_delete\u0026lt;_Tp\u0026gt; \u0026gt;\rclass _LIBCPP_TEMPLATE_VIS unique_ptr {\rpublic:\rtypedef _Tp element_type;\rtypedef _Dp deleter_type;\rtypedef typename __pointer_type\u0026lt;_Tp, deleter_type\u0026gt;::type pointer;\rstatic_assert(!is_rvalue_reference\u0026lt;deleter_type\u0026gt;::value,\r\u0026quot;the specified deleter type cannot be an rvalue reference\u0026quot;);\rprivate:\r__compressed_pair\u0026lt;pointer, deleter_type\u0026gt; __ptr_;\rstruct __nat { int __for_bool_; };\r#ifndef _LIBCPP_CXX03_LANG\rtypedef __unique_ptr_deleter_sfinae\u0026lt;_Dp\u0026gt; _DeleterSFINAE;\rtemplate \u0026lt;bool _Dummy\u0026gt;\rusing _LValRefType =\rtypename __dependent_type\u0026lt;_DeleterSFINAE, _Dummy\u0026gt;::__lval_ref_type;\rtemplate \u0026lt;bool _Dummy\u0026gt;\rusing _GoodRValRefType =\rtypename __dependent_type\u0026lt;_DeleterSFINAE, _Dummy\u0026gt;::__good_rval_ref_type;\rtemplate \u0026lt;bool _Dummy\u0026gt;\rusing _BadRValRefType =\rtypename __dependent_type\u0026lt;_DeleterSFINAE, _Dummy\u0026gt;::__bad_rval_ref_type;\rtemplate \u0026lt;bool _Dummy, class _Deleter = typename __dependent_type\u0026lt;\r__identity\u0026lt;deleter_type\u0026gt;, _Dummy\u0026gt;::type\u0026gt;\rusing _EnableIfDeleterDefaultConstructible =\rtypename enable_if\u0026lt;is_default_constructible\u0026lt;_Deleter\u0026gt;::value \u0026amp;\u0026amp;\r!is_pointer\u0026lt;_Deleter\u0026gt;::value\u0026gt;::type;\rtemplate \u0026lt;class _ArgType\u0026gt;\rusing _EnableIfDeleterConstructible =\rtypename enable_if\u0026lt;is_constructible\u0026lt;deleter_type, _ArgType\u0026gt;::value\u0026gt;::type;\rtemplate \u0026lt;class _UPtr, class _Up\u0026gt;\rusing _EnableIfMoveConvertible = typename enable_if\u0026lt;\ris_convertible\u0026lt;typename _UPtr::pointer, pointer\u0026gt;::value \u0026amp;\u0026amp;\r!is_array\u0026lt;_Up\u0026gt;::value\r\u0026gt;::type;\rtemplate \u0026lt;class _UDel\u0026gt;\rusing _EnableIfDeleterConvertible = typename enable_if\u0026lt;\r(is_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp; is_same\u0026lt;_Dp, _UDel\u0026gt;::value) ||\r(!is_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;_UDel, _Dp\u0026gt;::value)\r\u0026gt;::type;\rtemplate \u0026lt;class _UDel\u0026gt;\rusing _EnableIfDeleterAssignable = typename enable_if\u0026lt;\ris_assignable\u0026lt;_Dp\u0026amp;, _UDel\u0026amp;\u0026amp;\u0026gt;::value\r\u0026gt;::type;\rpublic:\rtemplate \u0026lt;bool _Dummy = true,\rclass = _EnableIfDeleterDefaultConstructible\u0026lt;_Dummy\u0026gt;\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rconstexpr unique_ptr() noexcept : __ptr_(pointer()) {}\rtemplate \u0026lt;bool _Dummy = true,\rclass = _EnableIfDeleterDefaultConstructible\u0026lt;_Dummy\u0026gt;\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rconstexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}\rtemplate \u0026lt;bool _Dummy = true,\rclass = _EnableIfDeleterDefaultConstructible\u0026lt;_Dummy\u0026gt;\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rexplicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {}\rtemplate \u0026lt;bool _Dummy = true,\rclass = _EnableIfDeleterConstructible\u0026lt;_LValRefType\u0026lt;_Dummy\u0026gt;\u0026gt;\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\runique_ptr(pointer __p, _LValRefType\u0026lt;_Dummy\u0026gt; __d) noexcept\r: __ptr_(__p, __d) {}\rtemplate \u0026lt;bool _Dummy = true,\rclass = _EnableIfDeleterConstructible\u0026lt;_GoodRValRefType\u0026lt;_Dummy\u0026gt;\u0026gt;\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\runique_ptr(pointer __p, _GoodRValRefType\u0026lt;_Dummy\u0026gt; __d) noexcept\r: __ptr_(__p, _VSTD::move(__d)) {\rstatic_assert(!is_reference\u0026lt;deleter_type\u0026gt;::value,\r\u0026quot;rvalue deleter bound to reference\u0026quot;);\r}\rtemplate \u0026lt;bool _Dummy = true,\rclass = _EnableIfDeleterConstructible\u0026lt;_BadRValRefType\u0026lt;_Dummy\u0026gt;\u0026gt;\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\runique_ptr(pointer __p, _BadRValRefType\u0026lt;_Dummy\u0026gt; __d) = delete;\r_LIBCPP_INLINE_VISIBILITY\runique_ptr(unique_ptr\u0026amp;\u0026amp; __u) noexcept\r: __ptr_(__u.release(), _VSTD::forward\u0026lt;deleter_type\u0026gt;(__u.get_deleter())) {\r}\rtemplate \u0026lt;class _Up, class _Ep,\rclass = _EnableIfMoveConvertible\u0026lt;unique_ptr\u0026lt;_Up, _Ep\u0026gt;, _Up\u0026gt;,\rclass = _EnableIfDeleterConvertible\u0026lt;_Ep\u0026gt;\r\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\runique_ptr(unique_ptr\u0026lt;_Up, _Ep\u0026gt;\u0026amp;\u0026amp; __u) _NOEXCEPT\r: __ptr_(__u.release(), _VSTD::forward\u0026lt;_Ep\u0026gt;(__u.get_deleter())) {}\r#if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\rtemplate \u0026lt;class _Up\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\runique_ptr(auto_ptr\u0026lt;_Up\u0026gt;\u0026amp;\u0026amp; __p,\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Up*, _Tp*\u0026gt;::value \u0026amp;\u0026amp;\ris_same\u0026lt;_Dp, default_delete\u0026lt;_Tp\u0026gt;\u0026gt;::value,\r__nat\u0026gt;::type = __nat()) _NOEXCEPT\r: __ptr_(__p.release()) {}\r#endif\r_LIBCPP_INLINE_VISIBILITY\runique_ptr\u0026amp; operator=(unique_ptr\u0026amp;\u0026amp; __u) _NOEXCEPT {\rreset(__u.release());\r__ptr_.second() = _VSTD::forward\u0026lt;deleter_type\u0026gt;(__u.get_deleter());\rreturn *this;\r}\rtemplate \u0026lt;class _Up, class _Ep,\rclass = _EnableIfMoveConvertible\u0026lt;unique_ptr\u0026lt;_Up, _Ep\u0026gt;, _Up\u0026gt;,\rclass = _EnableIfDeleterAssignable\u0026lt;_Ep\u0026gt;\r\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\runique_ptr\u0026amp; operator=(unique_ptr\u0026lt;_Up, _Ep\u0026gt;\u0026amp;\u0026amp; __u) _NOEXCEPT {\rreset(__u.release());\r__ptr_.second() = _VSTD::forward\u0026lt;_Ep\u0026gt;(__u.get_deleter());\rreturn *this;\r}\r#else // _LIBCPP_CXX03_LANG\rprivate:\runique_ptr(unique_ptr\u0026amp;);\rtemplate \u0026lt;class _Up, class _Ep\u0026gt; unique_ptr(unique_ptr\u0026lt;_Up, _Ep\u0026gt;\u0026amp;);\runique_ptr\u0026amp; operator=(unique_ptr\u0026amp;);\rtemplate \u0026lt;class _Up, class _Ep\u0026gt; unique_ptr\u0026amp; operator=(unique_ptr\u0026lt;_Up, _Ep\u0026gt;\u0026amp;);\rpublic:\r_LIBCPP_INLINE_VISIBILITY\runique_ptr() : __ptr_(pointer())\r{\rstatic_assert(!is_pointer\u0026lt;deleter_type\u0026gt;::value,\r\u0026quot;unique_ptr constructed with null function pointer deleter\u0026quot;);\rstatic_assert(is_default_constructible\u0026lt;deleter_type\u0026gt;::value,\r\u0026quot;unique_ptr::deleter_type is not default constructible\u0026quot;);\r}\r_LIBCPP_INLINE_VISIBILITY\runique_ptr(nullptr_t) : __ptr_(pointer())\r{\rstatic_assert(!is_pointer\u0026lt;deleter_type\u0026gt;::value,\r\u0026quot;unique_ptr constructed with null function pointer deleter\u0026quot;);\r}\r_LIBCPP_INLINE_VISIBILITY\rexplicit unique_ptr(pointer __p)\r: __ptr_(_VSTD::move(__p)) {\rstatic_assert(!is_pointer\u0026lt;deleter_type\u0026gt;::value,\r\u0026quot;unique_ptr constructed with null function pointer deleter\u0026quot;);\r}\r_LIBCPP_INLINE_VISIBILITY\roperator __rv\u0026lt;unique_ptr\u0026gt;() {\rreturn __rv\u0026lt;unique_ptr\u0026gt;(*this);\r}\r_LIBCPP_INLINE_VISIBILITY\runique_ptr(__rv\u0026lt;unique_ptr\u0026gt; __u)\r: __ptr_(__u-\u0026gt;release(),\r_VSTD::forward\u0026lt;deleter_type\u0026gt;(__u-\u0026gt;get_deleter())) {}\rtemplate \u0026lt;class _Up, class _Ep\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rtypename enable_if\u0026lt;\r!is_array\u0026lt;_Up\u0026gt;::value \u0026amp;\u0026amp;\ris_convertible\u0026lt;typename unique_ptr\u0026lt;_Up, _Ep\u0026gt;::pointer,\rpointer\u0026gt;::value \u0026amp;\u0026amp;\ris_assignable\u0026lt;deleter_type\u0026amp;, _Ep\u0026amp;\u0026gt;::value,\runique_ptr\u0026amp;\u0026gt;::type\roperator=(unique_ptr\u0026lt;_Up, _Ep\u0026gt; __u) {\rreset(__u.release());\r__ptr_.second() = _VSTD::forward\u0026lt;_Ep\u0026gt;(__u.get_deleter());\rreturn *this;\r}\r_LIBCPP_INLINE_VISIBILITY\runique_ptr(pointer __p, deleter_type __d)\r: __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\r#endif // _LIBCPP_CXX03_LANG\r#if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\rtemplate \u0026lt;class _Up\u0026gt;\r_LIBCPP_INLINE_VISIBILITY\rtypename enable_if\u0026lt;is_convertible\u0026lt;_Up*, _Tp*\u0026gt;::value \u0026amp;\u0026amp;\ris_same\u0026lt;_Dp, default_delete\u0026lt;_Tp\u0026gt; \u0026gt;::value,\runique_ptr\u0026amp;\u0026gt;::type\roperator=(auto_ptr\u0026lt;_Up\u0026gt; __p) {\rreset(__p.release());\rreturn *this;\r}\r#endif\r_LIBCPP_INLINE_VISIBILITY\r~unique_ptr() { reset(); }\r_LIBCPP_INLINE_VISIBILITY\runique_ptr\u0026amp; operator=(nullptr_t) _NOEXCEPT {\rreset();\rreturn *this;\r}\r_LIBCPP_INLINE_VISIBILITY\rtypename add_lvalue_reference\u0026lt;_Tp\u0026gt;::type\roperator*() const {\rreturn *__ptr_.first();\r}\r_LIBCPP_INLINE_VISIBILITY\rpointer operator-\u0026gt;() const _NOEXCEPT {\rreturn __ptr_.first();\r}\r_LIBCPP_INLINE_VISIBILITY\rpointer get() const _NOEXCEPT {\rreturn __ptr_.first();\r}\r_LIBCPP_INLINE_VISIBILITY\rdeleter_type\u0026amp; get_deleter() _NOEXCEPT {\rreturn __ptr_.second();\r}\r_LIBCPP_INLINE_VISIBILITY\rconst deleter_type\u0026amp; get_deleter() const _NOEXCEPT {\rreturn __ptr_.second();\r}\r_LIBCPP_INLINE_VISIBILITY\r_LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {\rreturn __ptr_.first() != nullptr;\r}\r_LIBCPP_INLINE_VISIBILITY\rpointer release() _NOEXCEPT {\rpointer __t = __ptr_.first();\r__ptr_.first() = pointer();\rreturn __t;\r}\r_LIBCPP_INLINE_VISIBILITY\rvoid reset(pointer __p = pointer()) _NOEXCEPT {\rpointer __tmp = __ptr_.first();\r__ptr_.first() = __p;\rif (__tmp)\r__ptr_.second()(__tmp);\r}\r_LIBCPP_INLINE_VISIBILITY\rvoid swap(unique_ptr\u0026amp; __u) _NOEXCEPT {\r__ptr_.swap(__u.__ptr_);\r}\r};\r","permalink":"http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-2/","summary":"C++æ™ºèƒ½æŒ‡é’ˆï¼ˆ2ï¼‰ï¼šunique_ptr åˆ†æ åœ¨ä½¿ç”¨ AutoPointer çš„æ—¶å€™ä¼šå‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»å’Œå†…å­˜æ³„æ¼çš„é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹ AutoPointer ç±»ç¨åŠ ä¿®æ”¹ï¼Œä¿®å¤è¿™ä¸¤ä¸ªé—®é¢˜\u0008ã€‚\næ‰€æœ‰æƒè½¬ç§» ä¸ºäº†è§„é¿å¯èƒ½å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»çš„æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ç¦æ­¢å®ƒä½¿ç”¨æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ“ä½œç¬¦ã€‚\nUniquePointer(UniquePointer\u0026lt;T\u0026gt; \u0026amp;other) = delete; UniquePointer\u0026lt;T\u0026gt; \u0026amp;operator=(const UniquePointer\u0026lt;T\u0026gt; \u0026amp;other) = delete; \u0008ä½†å¾ˆå¤šæ—¶å€™æˆ‘ä»¬éƒ½éœ€è¦ä½¿ç”¨åˆ°ä¼ é€’æŒ‡é’ˆçš„æ“ä½œï¼Œå¦‚æœåªæ˜¯ä½¿ç”¨ deleted å‡½æ•°ç¦æ­¢æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ“ä½œç¬¦ï¼Œé‚£ä¹ˆè¿™ä¸ªæ™ºèƒ½æŒ‡é’ˆå­˜åœ¨çš„æ„ä¹‰å°±ä¸å¤§äº†ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ move è¯­ä¹‰æ¥å®ç°ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦ï¼Œä»è€Œåœ¨ä½¿ç”¨ UniquePointer çš„æ—¶å€™å¯ä»¥åœ¨ç‰¹å®šæƒ…å†µä¸‹è¿›è¡Œæ‰€æœ‰æƒè½¬ç§»ã€‚\nUniquePointer(UniquePointer\u0026lt;T\u0026gt; \u0026amp;\u0026amp;other) noexcept; UniquePointer \u0026amp;operator=(UniquePointer \u0026amp;\u0026amp;other) noexcept; å†…å­˜æ³„æ¼ ä¸ºäº†é˜²æ­¢å‘ç”Ÿå†…å­˜æ³„æ¼ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨UniquePointerçš„ç§æœ‰æˆå‘˜ä¸­å¢åŠ ä¸€ä¸ªåˆ é™¤å™¨ï¼Œå¹¶\u0008æ ¹æ®å½“å‰æŒ‡é’ˆå¯¹è±¡çš„ç±»å‹æŒ‡å®šåˆ é™¤å™¨ï¼Œä»è€Œé˜²æ­¢å‘ç”Ÿå†…å­˜æ³„æ¼ã€‚\nclass Deleter { template\u0026lt;typename T\u0026gt; void operator()(T *p) { if (p) delete p; } }; template\u0026lt;typename T, typename D\u0026gt; class UniquePointer { ... private: T *pointer; Deleter deleter; }; å®ç° æ ¹æ®unique_ptrçš„æºç ï¼Œèƒ½å¤Ÿå¤§è‡´å®ç°UniquePointerç±»\ntemplate\u0026lt;typename T, typename D\u0026gt; class UniquePointer { public: explicit UniquePointer(T *t, const D \u0026amp;d); ~UniquePointer(); T \u0026amp;operator*(); T *operator-\u0026gt;(); T *release(); void reset(T *p); UniquePointer(UniquePointer \u0026amp;\u0026amp;other) noexcept; UniquePointer \u0026amp;operator=(UniquePointer \u0026amp;\u0026amp;other) noexcept; UniquePointer(const UniquePointer \u0026amp;other) = delete; UniquePointer \u0026amp;operator=(const UniquePointer \u0026amp;other) = delete; private: T *pointer; D deleter; }; template\u0026lt;typename T, typename D\u0026gt; UniquePointer\u0026lt;T, D\u0026gt;::UniquePointer(T *t, const D \u0026amp;d) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; constructor called.","title":"C++ æ™ºèƒ½æŒ‡é’ˆï¼ˆ2ï¼‰ï¼šunique_ptr"},{"content":"Cookieå’ŒSession ä¸ºäº†è·å–æˆ‘ä»¬è‡ªå·±çš„æäº¤è®°å½•ï¼Œæˆ‘ä»¬é¦–å…ˆè¦è¿›è¡Œç™»å½•çš„æ“ä½œã€‚ä½†æˆ‘ä»¬éƒ½çŸ¥é“HTTPæ˜¯ä¸€ç§æ— çŠ¶æ€çš„åè®®ï¼Œå®ƒçš„æ¯ä¸ªè¯·æ±‚éƒ½æ˜¯ç‹¬ç«‹çš„ã€‚æ— è®ºæ˜¯GETè¿˜æ˜¯POSTè¯·æ±‚ï¼Œéƒ½åŒ…å«äº†å¤„ç†å½“å‰è¿™ä¸€æ¡è¯·æ±‚çš„æ‰€æœ‰ä¿¡æ¯ï¼Œ\u0008ä½†å®ƒå¹¶ä¸ä¼šæ¶‰åŠåˆ°çŠ¶æ€çš„å˜åŒ–ã€‚å› æ­¤ï¼Œä¸ºäº†åœ¨æ— çŠ¶æ€çš„HTTPåè®®ä¸Šç»´æŠ¤ä¸€ä¸ªæŒä¹…çš„çŠ¶æ€ï¼Œå¼•å…¥äº†Cookieå’ŒSessionçš„æ¦‚å¿µï¼Œä¸¤è€…éƒ½æ˜¯ä¸ºäº†è¾¨è¯†ç”¨æˆ·ç›¸å…³ä¿¡æ¯è€Œå‚¨å­˜åœ¨å†…å­˜æˆ–ç¡¬ç›˜ä¸Šçš„åŠ å¯†æ•°æ®ã€‚\nCookieæ˜¯ç”±å®¢æˆ·ç«¯æµè§ˆå™¨ç»´æŠ¤çš„ã€‚å®¢æˆ·ç«¯æµè§ˆå™¨ä¼šåœ¨éœ€è¦æ—¶æŠŠCookieä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œå½“å…¶å†æ¬¡å‘è¯¥åŸŸåç›¸å…³çš„ç½‘ç«™å‘å‡ºrequestæ—¶ï¼Œæµè§ˆå™¨ä¼šæŠŠurlå’ŒCookieä¸€èµ·ä½œä¸ºrequestçš„ä¸€éƒ¨åˆ†å‘é€ç»™æœåŠ¡å™¨ã€‚æœåŠ¡å™¨é€šè¿‡\u0008è§£æè¯¥Cookieæ¥ç¡®è®¤ç”¨æˆ·çš„çŠ¶æ€ï¼Œå¹¶å¯¹Cookieçš„å†…å®¹ä½œå‡ºç›¸åº”çš„ä¿®æ”¹ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœä¸è®¾ç½®è¿‡æœŸæ—¶é—´ï¼ŒéæŒä¹…\u0008Cookieä¼šä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œæµè§ˆå™¨å…³é—­åå°±è¢«åˆ é™¤äº†ã€‚\nSessionæ˜¯ç”±æœåŠ¡å™¨ç»´æŠ¤çš„ã€‚å½“å®¢æˆ·ç«¯ç¬¬ä¸€æ¬¡å‘æœåŠ¡å™¨å‘å‡ºrequeståï¼ŒæœåŠ¡å™¨ä¼šä¸ºè¯¥å®¢æˆ·ç«¯åˆ›å»ºä¸€ä¸ªSessionã€‚å½“è¯¥å®¢æˆ·ç«¯å†æ¬¡è®¿é—®æœåŠ¡å™¨æ—¶ï¼ŒæœåŠ¡å™¨ä¼šæ ¹æ®è¯¥Sessionæ¥\u0008è·å–ç›¸å…³ä¿¡æ¯ã€‚ä¸€èˆ¬æ¥è¯´ï¼ŒæœåŠ¡å™¨ä¼šä¸ºSeesionè®¾ç½®ä¸€ä¸ªå¤±æ•ˆæ—¶é—´ï¼Œå½“è·ç¦»æ¥æ”¶åˆ°å®¢æˆ·ç«¯ä¸Šä¸€æ¬¡å‘é€request\u0008çš„æ—¶é—´è¶…è¿‡è¿™ä¸ªå¤±æ•ˆæ—¶é—´åï¼ŒæœåŠ¡å™¨ä¼šä¸»åŠ¨åˆ é™¤Sessionã€‚\nä¸¤ç§æ–¹æ³•éƒ½å¯ä»¥ç”¨æ¥ç»´æŠ¤ç™»å½•çš„çŠ¶æ€ã€‚ä¸ºäº†ç®€ä¾¿èµ·è§ï¼Œæœ¬é¡¹ç›®ç›®å‰ä½¿ç”¨Sessionä½œä¸ºç»´æŠ¤ç™»å½•çŠ¶æ€çš„æ–¹æ³•ã€‚\nè·å–æ•°æ® åˆ†æ é¦–å…ˆæˆ‘ä»¬è¿›å…¥ç™»å½•é¡µé¢ï¼Œæ‰“å¼€å¼€å‘è€…å·¥å…·ï¼Œå‹¾é€‰Preserve logã€‚ä¸ºäº†çŸ¥é“åœ¨ç™»å½•æ—¶æµè§ˆå™¨å‘æœåŠ¡å™¨æäº¤äº†å“ªäº›æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆè¾“å…¥ä¸€ä¸ªé”™è¯¯çš„ç”¨æˆ·åå’Œå¯†ç ï¼Œ\u0008\u0008ä¾¿äºæŠ“åŒ…ã€‚\né€šè¿‡åˆ†æ\u0026quot;login/\u0026ldquo;è¿™æ¡requestï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“æˆ‘ä»¬æ‰€éœ€è¦çš„ä¸€äº›å…³é”®ä¿¡æ¯ï¼Œä¾‹å¦‚headersä¸­çš„user-agentå’Œrefererï¼Œè¡¨å•æ•°æ®ï¼ˆform dataï¼‰ä¸­çš„csrfmiddlewaretokenï¼Œloginå’Œpasswordã€‚æ˜¾ç„¶ï¼Œuser-agentå’Œrefereræˆ‘ä»¬å¯ä»¥ç›´æ¥å¤åˆ¶ä¸‹æ¥ï¼Œloginå’Œpasswordæ˜¯æˆ‘ä»¬å¡«å†™çš„ç”¨æˆ·åå’Œå¯†ç ã€‚è¿˜æœ‰ä¸€ä¸ªå¾ˆé™Œç”Ÿçš„csrfmiddlewaretokenã€‚è¿™æ˜¯CSRFçš„ä¸­é—´ä»¶tokenï¼ŒCSRFæ˜¯Cross-Site Request Forgeryï¼Œç›¸å…³çŸ¥è¯†å¯ä»¥æŸ¥è¯¢è·¨ç«™è¯·æ±‚ä¼ªé€ çš„ç»´åŸºç™¾ç§‘ã€‚é‚£ä¹ˆç°åœ¨æˆ‘ä»¬å°±è¦åˆ†æè¿™ä¸ªtokenæ˜¯ä»ä½•è€Œæ¥ã€‚\nè·å–csrfmiddlewaretoken æˆ‘ä»¬å°†åˆšæ‰è·å–åˆ°çš„csrfmiddlewaretokenå¤åˆ¶ä¸‹æ¥ï¼Œåœ¨å¼€å‘è€…å·¥å…·ä¸­ä½¿ç”¨æœç´¢åŠŸèƒ½ï¼Œå¯ä»¥å‘ç°è¿™ä¸ªcsrfmiddlewaretokenå‡ºç°åœ¨äº†ç™»å½•ä¹‹å‰çš„ä¸€äº›requestå¯¹åº”çš„responseä¸­ã€‚ä¾‹å¦‚åœ¨åˆšæ‰æ‰“å¼€ç™»å½•é¡µé¢ï¼Œå‘é€GETè¯·æ±‚æ—¶ï¼Œresponseçš„headersçš„set-cookie\u0008ä¸­å‡ºç°äº†\u0026quot;csrftoken=\u0026hellip;\u0026ldquo;\u0008ï¼Œè€Œè¿™é‡Œcsrftokençš„å€¼ä¸æˆ‘ä»¬éœ€è¦åœ¨ç™»å½•è¡¨å•ä¸­æäº¤çš„å€¼å®Œå…¨ç›¸åŒã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è·å–åˆšæ‰çš„responseä¸­çš„Cookiesæ¥è·å–csrfmiddlewaretokençš„å€¼ã€‚\né¦–å…ˆæˆ‘ä»¬\u0008é€šè¿‡å‘é€GETè¯·æ±‚æ¥åˆ†æä¸€ä¸‹Cookiesçš„æ„æˆ\nlogin_url = \u0026quot;https://leetcode.com/accounts/login/\u0026quot;\rsession = requests.session()\rresult = session.get(login_url)\rprint(result)\rprint(type(result.cookies))\rfor cookie in result.cookies:\rprint(type(cookie))\rprint(cookie)\rå¾—åˆ°çš„ç»“æœæ˜¯\n \u0026lt;Response [200]\u0026gt; çŠ¶æ€ç 200ï¼Œè¡¨ç¤ºè¯·æ±‚æˆåŠŸ \u0026lt;class 'requests.cookies.RequestsCookieJar'\u0026gt; cookiesçš„ç±»å‹æ˜¯CookieJar \u0026lt;class 'http.cookiejar.Cookie'\u0026gt; ç¬¬ä¸€æ¡cookieçš„ç±»å‹æ˜¯Cookie \u0026lt;Cookie__cfduid=d3e02d4309b848f9369e21671fabbce571548041181 for .leetcode.com/\u0026gt; ç¬¬ä¸€æ¡\u0008cookieçš„ä¿¡æ¯ \u0026lt;class 'http.cookiejar.Cookie'\u0026gt; ç¬¬äºŒæ¡cookieçš„ç±»å‹æ˜¯Cookie \u0026lt;Cookie csrftoken=13mQWE9tYN6g2IrlKY8oMLRc4VhVNoet4j328YdDapW2WC2nf93y5iCuzorovTDl for leetcode.com/\u0026gt; ç¬¬äºŒæ¡cookieçš„ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬æ‰€éœ€è¦çš„csrftoken  è¿™æ ·ä¸€æ¥æˆ‘ä»¬ä¾¿è·å–åˆ°äº†åœ¨æäº¤è¡¨å•ä¿¡æ¯æ—¶æ‰€éœ€è¦çš„csrfmiddlewaretokenï¼Œä¹‹åæˆ‘ä»¬ä¾¿å¯ä»¥å¼€å§‹ç€æ‰‹å†™ç™»å½•çš„ç›¸å…³ä»£ç äº†ã€‚\u0008é¡ºä¾¿ä¸€æï¼Œåœ¨ä½¿ç”¨Djangoè¿›è¡Œåç«¯å¼€å‘çš„æ—¶å€™è‡ªåŠ¨ç”Ÿæˆçš„\u0008csrf tokençš„é”®ä¹Ÿå«csrfmiddlewaretokenï¼Œä¸çŸ¥é“LeetCodeæ˜¯ä¸æ˜¯ç”¨\u0008Djangoä½œä¸ºåç«¯å¼€å‘æ¡†æ¶çš„ã€‚\nå®ç° é¦–å…ˆæˆ‘ä»¬éœ€è¦åœ¨çˆ¬è™«å¼€å§‹è¿è¡Œä¹‹å‰è·å–ç™»å½•ä¿¡æ¯ï¼Œå°†Sessionä½œä¸ºç±»çš„æˆå‘˜å˜é‡ä¿å­˜ä¸‹æ¥ï¼Œæ–¹ä¾¿åœ¨è·å–submissionsæ—¶ä½¿ç”¨ã€‚åŒæ—¶æˆ‘ä»¬éœ€è¦åœ¨ä¸çˆ¬è™«æ–‡ä»¶\u0008\u0008ç›¸åŒçš„ç›®å½•ä¸‹æ–°å»ºconfig.jsonï¼Œå°†è‡ªå·±çš„ç”¨æˆ·åå’Œå¯†ç ä¿å­˜åœ¨\u0008è¯¥jsonæ–‡ä»¶é‡Œï¼Œè¿™æ ·å°±èƒ½é¡ºåˆ©ç™»é™†äº†ã€‚\n def start_requests(self):\rself.Login() # ç™»å½•\rquestionset_url = \u0026quot;https://leetcode.com/api/problems/all/\u0026quot;\ryield scrapy.Request(url=questionset_url, callback=self.ParseQuestionSet)\rdef Login(self):\rlogin_url = \u0026quot;https://leetcode.com/accounts/login/\u0026quot;\rlogin_headers = {\r\u0026quot;user_agent\u0026quot;: \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'\u0026quot;,\r\u0026quot;referer\u0026quot;: \u0026quot;https://leetcode.com/accounts/login/\u0026quot;,\r# \u0026quot;content-type\u0026quot;: \u0026quot;multipart/form-data; boundary=----WebKitFormBoundary70YlQBtroATwu9Jx\u0026quot;\r}\rself.session = requests.session()\rresult = self.session.get(login_url)\rfile = open('./config.json', 'r')\rinfo = json.load(file)\rdata = {\u0026quot;login\u0026quot;: info[\u0026quot;username\u0026quot;], \u0026quot;password\u0026quot;: inf[\u0026quot;password\u0026quot;],\r\u0026quot;csrfmiddlewaretoken\u0026quot;: self.session.cookies['csrftoken']}\rself.session.post(login_url, data=data,headers=login_headers)\rprint(\u0026quot;login info: \u0026quot; + str(result))\ræ³¨æ„å¦‚æœåœ¨headersä¸­å¡«å†™äº†content-typeçš„å€¼ï¼Œå¯èƒ½ä¼šäº§ç”Ÿä¸€äº›å¥‡æ€ªçš„é”™è¯¯ä¿¡æ¯ï¼Œå¹¶ä¸”åç»­ä¸èƒ½æ­£ç¡®åœ°è·å–è‡ªå·±çš„submissionsï¼Œ\u0008åªéœ€è¦user_agentå’Œrefereçš„ä¿¡æ¯å³å¯ã€‚\u0008\nå¦‚æœçœ‹åˆ°è¾“å‡ºlogin info: \u0026lt;Response [200]\u0026gt;\u0008å°±ä»£è¡¨ç™»å½•æˆåŠŸäº†ï¼\nå‚è€ƒèµ„æ–™ Scrapyå®˜æ–¹æ–‡æ¡£","permalink":"http://zintrulcre.github.io/posts/leetcode-archiver/leetcode-archiver3/","summary":"Cookieå’ŒSession ä¸ºäº†è·å–æˆ‘ä»¬è‡ªå·±çš„æäº¤è®°å½•ï¼Œæˆ‘ä»¬é¦–å…ˆè¦è¿›è¡Œç™»å½•çš„æ“ä½œã€‚ä½†æˆ‘ä»¬éƒ½çŸ¥é“HTTPæ˜¯ä¸€ç§æ— çŠ¶æ€çš„åè®®ï¼Œå®ƒçš„æ¯ä¸ªè¯·æ±‚éƒ½æ˜¯ç‹¬ç«‹çš„ã€‚æ— è®ºæ˜¯GETè¿˜æ˜¯POSTè¯·æ±‚ï¼Œéƒ½åŒ…å«äº†å¤„ç†å½“å‰è¿™ä¸€æ¡è¯·æ±‚çš„æ‰€æœ‰ä¿¡æ¯ï¼Œ\u0008ä½†å®ƒå¹¶ä¸ä¼šæ¶‰åŠåˆ°çŠ¶æ€çš„å˜åŒ–ã€‚å› æ­¤ï¼Œä¸ºäº†åœ¨æ— çŠ¶æ€çš„HTTPåè®®ä¸Šç»´æŠ¤ä¸€ä¸ªæŒä¹…çš„çŠ¶æ€ï¼Œå¼•å…¥äº†Cookieå’ŒSessionçš„æ¦‚å¿µï¼Œä¸¤è€…éƒ½æ˜¯ä¸ºäº†è¾¨è¯†ç”¨æˆ·ç›¸å…³ä¿¡æ¯è€Œå‚¨å­˜åœ¨å†…å­˜æˆ–ç¡¬ç›˜ä¸Šçš„åŠ å¯†æ•°æ®ã€‚\nCookieæ˜¯ç”±å®¢æˆ·ç«¯æµè§ˆå™¨ç»´æŠ¤çš„ã€‚å®¢æˆ·ç«¯æµè§ˆå™¨ä¼šåœ¨éœ€è¦æ—¶æŠŠCookieä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œå½“å…¶å†æ¬¡å‘è¯¥åŸŸåç›¸å…³çš„ç½‘ç«™å‘å‡ºrequestæ—¶ï¼Œæµè§ˆå™¨ä¼šæŠŠurlå’ŒCookieä¸€èµ·ä½œä¸ºrequestçš„ä¸€éƒ¨åˆ†å‘é€ç»™æœåŠ¡å™¨ã€‚æœåŠ¡å™¨é€šè¿‡\u0008è§£æè¯¥Cookieæ¥ç¡®è®¤ç”¨æˆ·çš„çŠ¶æ€ï¼Œå¹¶å¯¹Cookieçš„å†…å®¹ä½œå‡ºç›¸åº”çš„ä¿®æ”¹ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœä¸è®¾ç½®è¿‡æœŸæ—¶é—´ï¼ŒéæŒä¹…\u0008Cookieä¼šä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œæµè§ˆå™¨å…³é—­åå°±è¢«åˆ é™¤äº†ã€‚\nSessionæ˜¯ç”±æœåŠ¡å™¨ç»´æŠ¤çš„ã€‚å½“å®¢æˆ·ç«¯ç¬¬ä¸€æ¬¡å‘æœåŠ¡å™¨å‘å‡ºrequeståï¼ŒæœåŠ¡å™¨ä¼šä¸ºè¯¥å®¢æˆ·ç«¯åˆ›å»ºä¸€ä¸ªSessionã€‚å½“è¯¥å®¢æˆ·ç«¯å†æ¬¡è®¿é—®æœåŠ¡å™¨æ—¶ï¼ŒæœåŠ¡å™¨ä¼šæ ¹æ®è¯¥Sessionæ¥\u0008è·å–ç›¸å…³ä¿¡æ¯ã€‚ä¸€èˆ¬æ¥è¯´ï¼ŒæœåŠ¡å™¨ä¼šä¸ºSeesionè®¾ç½®ä¸€ä¸ªå¤±æ•ˆæ—¶é—´ï¼Œå½“è·ç¦»æ¥æ”¶åˆ°å®¢æˆ·ç«¯ä¸Šä¸€æ¬¡å‘é€request\u0008çš„æ—¶é—´è¶…è¿‡è¿™ä¸ªå¤±æ•ˆæ—¶é—´åï¼ŒæœåŠ¡å™¨ä¼šä¸»åŠ¨åˆ é™¤Sessionã€‚\nä¸¤ç§æ–¹æ³•éƒ½å¯ä»¥ç”¨æ¥ç»´æŠ¤ç™»å½•çš„çŠ¶æ€ã€‚ä¸ºäº†ç®€ä¾¿èµ·è§ï¼Œæœ¬é¡¹ç›®ç›®å‰ä½¿ç”¨Sessionä½œä¸ºç»´æŠ¤ç™»å½•çŠ¶æ€çš„æ–¹æ³•ã€‚\nè·å–æ•°æ® åˆ†æ é¦–å…ˆæˆ‘ä»¬è¿›å…¥ç™»å½•é¡µé¢ï¼Œæ‰“å¼€å¼€å‘è€…å·¥å…·ï¼Œå‹¾é€‰Preserve logã€‚ä¸ºäº†çŸ¥é“åœ¨ç™»å½•æ—¶æµè§ˆå™¨å‘æœåŠ¡å™¨æäº¤äº†å“ªäº›æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆè¾“å…¥ä¸€ä¸ªé”™è¯¯çš„ç”¨æˆ·åå’Œå¯†ç ï¼Œ\u0008\u0008ä¾¿äºæŠ“åŒ…ã€‚\né€šè¿‡åˆ†æ\u0026quot;login/\u0026ldquo;è¿™æ¡requestï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“æˆ‘ä»¬æ‰€éœ€è¦çš„ä¸€äº›å…³é”®ä¿¡æ¯ï¼Œä¾‹å¦‚headersä¸­çš„user-agentå’Œrefererï¼Œè¡¨å•æ•°æ®ï¼ˆform dataï¼‰ä¸­çš„csrfmiddlewaretokenï¼Œloginå’Œpasswordã€‚æ˜¾ç„¶ï¼Œuser-agentå’Œrefereræˆ‘ä»¬å¯ä»¥ç›´æ¥å¤åˆ¶ä¸‹æ¥ï¼Œloginå’Œpasswordæ˜¯æˆ‘ä»¬å¡«å†™çš„ç”¨æˆ·åå’Œå¯†ç ã€‚è¿˜æœ‰ä¸€ä¸ªå¾ˆé™Œç”Ÿçš„csrfmiddlewaretokenã€‚è¿™æ˜¯CSRFçš„ä¸­é—´ä»¶tokenï¼ŒCSRFæ˜¯Cross-Site Request Forgeryï¼Œç›¸å…³çŸ¥è¯†å¯ä»¥æŸ¥è¯¢è·¨ç«™è¯·æ±‚ä¼ªé€ çš„ç»´åŸºç™¾ç§‘ã€‚é‚£ä¹ˆç°åœ¨æˆ‘ä»¬å°±è¦åˆ†æè¿™ä¸ªtokenæ˜¯ä»ä½•è€Œæ¥ã€‚\nè·å–csrfmiddlewaretoken æˆ‘ä»¬å°†åˆšæ‰è·å–åˆ°çš„csrfmiddlewaretokenå¤åˆ¶ä¸‹æ¥ï¼Œåœ¨å¼€å‘è€…å·¥å…·ä¸­ä½¿ç”¨æœç´¢åŠŸèƒ½ï¼Œå¯ä»¥å‘ç°è¿™ä¸ªcsrfmiddlewaretokenå‡ºç°åœ¨äº†ç™»å½•ä¹‹å‰çš„ä¸€äº›requestå¯¹åº”çš„responseä¸­ã€‚ä¾‹å¦‚åœ¨åˆšæ‰æ‰“å¼€ç™»å½•é¡µé¢ï¼Œå‘é€GETè¯·æ±‚æ—¶ï¼Œresponseçš„headersçš„set-cookie\u0008ä¸­å‡ºç°äº†\u0026quot;csrftoken=\u0026hellip;\u0026ldquo;\u0008ï¼Œè€Œè¿™é‡Œcsrftokençš„å€¼ä¸æˆ‘ä»¬éœ€è¦åœ¨ç™»å½•è¡¨å•ä¸­æäº¤çš„å€¼å®Œå…¨ç›¸åŒã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è·å–åˆšæ‰çš„responseä¸­çš„Cookiesæ¥è·å–csrfmiddlewaretokençš„å€¼ã€‚\né¦–å…ˆæˆ‘ä»¬\u0008é€šè¿‡å‘é€GETè¯·æ±‚æ¥åˆ†æä¸€ä¸‹Cookiesçš„æ„æˆ\nlogin_url = \u0026quot;https://leetcode.com/accounts/login/\u0026quot;\rsession = requests.session()\rresult = session.get(login_url)\rprint(result)\rprint(type(result.cookies))\rfor cookie in result.cookies:\rprint(type(cookie))\rprint(cookie)\rå¾—åˆ°çš„ç»“æœæ˜¯\n \u0026lt;Response [200]\u0026gt; çŠ¶æ€ç 200ï¼Œè¡¨ç¤ºè¯·æ±‚æˆåŠŸ \u0026lt;class 'requests.cookies.RequestsCookieJar'\u0026gt; cookiesçš„ç±»å‹æ˜¯CookieJar \u0026lt;class 'http.cookiejar.Cookie'\u0026gt; ç¬¬ä¸€æ¡cookieçš„ç±»å‹æ˜¯Cookie \u0026lt;Cookie__cfduid=d3e02d4309b848f9369e21671fabbce571548041181 for .leetcode.com/\u0026gt; ç¬¬ä¸€æ¡\u0008cookieçš„ä¿¡æ¯ \u0026lt;class 'http.cookiejar.Cookie'\u0026gt; ç¬¬äºŒæ¡cookieçš„ç±»å‹æ˜¯Cookie \u0026lt;Cookie csrftoken=13mQWE9tYN6g2IrlKY8oMLRc4VhVNoet4j328YdDapW2WC2nf93y5iCuzorovTDl for leetcode.com/\u0026gt; ç¬¬äºŒæ¡cookieçš„ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬æ‰€éœ€è¦çš„csrftoken  è¿™æ ·ä¸€æ¥æˆ‘ä»¬ä¾¿è·å–åˆ°äº†åœ¨æäº¤è¡¨å•ä¿¡æ¯æ—¶æ‰€éœ€è¦çš„csrfmiddlewaretokenï¼Œä¹‹åæˆ‘ä»¬ä¾¿å¯ä»¥å¼€å§‹ç€æ‰‹å†™ç™»å½•çš„ç›¸å…³ä»£ç äº†ã€‚\u0008é¡ºä¾¿ä¸€æï¼Œåœ¨ä½¿ç”¨Djangoè¿›è¡Œåç«¯å¼€å‘çš„æ—¶å€™è‡ªåŠ¨ç”Ÿæˆçš„\u0008csrf tokençš„é”®ä¹Ÿå«csrfmiddlewaretokenï¼Œä¸çŸ¥é“LeetCodeæ˜¯ä¸æ˜¯ç”¨\u0008Djangoä½œä¸ºåç«¯å¼€å‘æ¡†æ¶çš„ã€‚\nå®ç° é¦–å…ˆæˆ‘ä»¬éœ€è¦åœ¨çˆ¬è™«å¼€å§‹è¿è¡Œä¹‹å‰è·å–ç™»å½•ä¿¡æ¯ï¼Œå°†Sessionä½œä¸ºç±»çš„æˆå‘˜å˜é‡ä¿å­˜ä¸‹æ¥ï¼Œæ–¹ä¾¿åœ¨è·å–submissionsæ—¶ä½¿ç”¨ã€‚åŒæ—¶æˆ‘ä»¬éœ€è¦åœ¨ä¸çˆ¬è™«æ–‡ä»¶\u0008\u0008ç›¸åŒçš„ç›®å½•ä¸‹æ–°å»ºconfig.jsonï¼Œå°†è‡ªå·±çš„ç”¨æˆ·åå’Œå¯†ç ä¿å­˜åœ¨\u0008è¯¥jsonæ–‡ä»¶é‡Œï¼Œè¿™æ ·å°±èƒ½é¡ºåˆ©ç™»é™†äº†ã€‚\n def start_requests(self):\rself.Login() # ç™»å½•\rquestionset_url = \u0026quot;https://leetcode.com/api/problems/all/\u0026quot;\ryield scrapy.","title":"LeetCode Archiver(3)ï¼š ç™»å½•"},{"content":"C++æ™ºèƒ½æŒ‡é’ˆï¼ˆ1.5ï¼‰ï¼šmoveè¯­ä¹‰ moveè¯­ä¹‰ å®šä¹‰ å³å€¼å¼•ç”¨ï¼ˆRvalue Refereneï¼‰æ˜¯ C++ 11ä¸­å¼•å…¥çš„æ–°ç‰¹æ€§ï¼Œå®ƒå®ç°äº†è½¬ç§»è¯­ä¹‰ï¼ˆMove Sementicsï¼‰å’Œç²¾ç¡®ä¼ é€’ï¼ˆPerfect Forwardingï¼‰ï¼Œå…¶ä¸»è¦ç›®çš„æœ‰\n æ¶ˆé™¤ä¸¤ä¸ªå¯¹è±¡äº¤äº’æ—¶ä¸å¿…è¦çš„å¯¹è±¡æ‹·è´ï¼ŒèŠ‚çœè¿ç®—å­˜å‚¨èµ„æºï¼Œæé«˜æ•ˆç‡ã€‚ èƒ½å¤Ÿæ›´ç®€æ´æ˜ç¡®åœ°å®šä¹‰æ³›å‹å‡½æ•°ã€‚  å®ç° move è¯­ä¹‰çš„å®ç°éå¸¸ç®€å•ï¼Œå®ƒå°†ä¼ å…¥çš„å‚æ•° _Tp\u0026amp;\u0026amp; __t ä½¿ç”¨é™æ€ç±»å‹è½¬æ¢ static_cast\u0026lt;_Up\u0026amp;\u0026amp;\u0026gt;(__t) è½¬å˜æˆäº†æˆäº†å¯¹åº”ç±»å‹çš„å³å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´ä½¿ç”¨ move è¯­ä¹‰ä¹‹åï¼Œç¼–è¯‘å™¨çªƒå–ï¼ˆä¸€èˆ¬ä¼šåœ¨ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦é‡Œå°†åŸæœ‰å¯¹è±¡æŒ‡å‘ nullptrï¼‰äº†åŸæœ‰å¯¹è±¡çš„å³å€¼ï¼Œå¹¶å»¶é•¿äº†è¿™ä¸ªå³å€¼çš„ç”Ÿå‘½å‘¨æœŸå¹¶å°†å…¶ç”¨æ¥èµ‹å€¼ç»™å…¶ä»–çš„å¯¹è±¡ï¼Œè€Œæ²¡æœ‰\u0008å¯¹å³å€¼åšä»»ä½•æ‹·è´æ“ä½œã€‚\ntemplate \u0026lt;class _Tp\u0026gt; typename remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp; move(_Tp\u0026amp;\u0026amp; __t) _NOEXCEPT { typedef typename remove_reference\u0026lt;_Tp\u0026gt;::type _Up; return static_cast\u0026lt;_Up\u0026amp;\u0026amp;\u0026gt;(__t); } æµ‹è¯• \u0008å®šä¹‰ä¸€ä¸ª Object ç±»å’Œä¸€ä¸ª MoveObject å‡½æ•°ä½¿ç”¨ move è¯­ä¹‰è¿”å›ä¸€ä¸ª Object çš„ç±»å¯¹è±¡ï¼Œå¯ä»¥çœ‹åˆ°åœ¨ MoveObject å‡½æ•°è¿”å›å³å€¼åï¼Œobj å¯¹è±¡è°ƒç”¨äº†ç§»åŠ¨æ„é€ å‡½æ•°ã€‚\nclass Object { public: Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Construct\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(const Object \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(Object \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Destruct\u0026#34; \u0026lt;\u0026lt; std::endl; } void Print() { std::cout \u0026lt;\u0026lt; \u0026#34;Print\u0026#34; \u0026lt;\u0026lt; std::endl; } }; Object MoveObject() { Object obj; return move(obj); } int main() { Object obj = MoveObject(); return 0; } /* output: Construct Move Destruct Destruct */ è¿”å›å€¼ä¼˜åŒ–ï¼ˆRVOï¼ŒReturn value optimisationï¼‰ è¿”å›å€¼ä¼˜åŒ–æ˜¯ä¸€ç§ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯ï¼Œå…è®¸ç¼–è¯‘å™¨åœ¨è°ƒç”¨ç‚¹ï¼ˆcall siteï¼‰ç›´æ¥æ„é€ å‡½æ•°çš„è¿”å›å€¼ã€‚\nå®šä¹‰ä¸€ä¸ª CopyObject å‡½æ•°è¿”å›ä¸€ä¸ª Object çš„ç±»å¯¹è±¡ï¼ŒåŸæœ¬ Function å‡½æ•°åœ¨è¿”å›æ—¶åº”è¯¥ä¼šè¿›è¡Œä¸€æ¬¡æ‹·è´ï¼Œç„¶è€Œè°ƒè¯•ç»“æœå´æ˜¾ç¤º obj å¯¹è±¡åªåœ¨ Function å‡½æ•°ä¸­è¢«æ„é€ äº†ä¸€æ¬¡ï¼Œåœ¨ç¨‹åºç»“æŸæ—¶è¢«ææ„äº†ä¸€æ¬¡ã€‚è¿™æ˜¯å› ä¸ºç¼–è¯‘å™¨ä½¿ç”¨äº† RVO æœºåˆ¶ï¼Œè¿™é‡Œ Function å‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ªå·¦å€¼ï¼Œ\u0008æ‰€ä»¥åˆç§°å‘½åè¿”å›å€¼ä¼˜åŒ–ï¼ˆNRVOï¼‰ï¼Œåœ¨ C++ 11 é‡Œè¢«ç§°ä¸ºæ‹·è´çœç•¥ï¼ˆCopy Elisionï¼‰ã€‚\nObject CopyObject() { Object obj; return obj; // NRVO (named return value optimisation) } int main() { Obj obj = Function(); return 0; } /* output: Construct Destruct */ å¦‚æœåœ¨ MoveObject å‡½æ•°ä¸­ä½¿ç”¨moveè¯­ä¹‰è¿›è¡Œè¿”å›ï¼Œå‡½æ•°å®é™…è¿”å›çš„\u0008æ˜¯ä¸€ä¸ªå³å€¼\u0008å¼•ç”¨ï¼ˆObj\u0026amp;\u0026amp;ï¼‰ï¼Œè€Œä¸æ˜¯å‡½æ•°å®šä¹‰ä¸­çš„å¯¹è±¡ï¼ˆObjï¼‰ï¼Œæ²¡æœ‰è§¦å‘ RVOã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦è§¦å‘ RVO æœºåˆ¶ï¼Œå¿…é¡»ä¿è¯å‡½æ•°å®é™…çš„è¿”å›å€¼ç±»å‹å’Œå‡½æ•°å®šä¹‰ä¸­çš„è¿”å›å€¼ç±»å‹ä¸€è‡´ã€‚\nObject MoveObject() { Object obj; return move(obj); } int main() { Object obj = MoveObject(); return 0; } /* output: Construct Move Destruct Destruct */ å¦‚æœæŠŠå‡½æ•°è¿”å›å€¼ç±»å‹ä¹Ÿæ”¹ä¸ºå³å€¼å¼•ç”¨ï¼Œé‚£ä¹ˆ main å‡½æ•°ä¸­çš„ obj å¯¹è±¡ä¹Ÿä¼šä½¿ç”¨ç§»åŠ¨æ„é€ å‡½æ•°ï¼Œè§¦å‘ RVO æœºåˆ¶ã€‚\nObject \u0026amp;\u0026amp;MoveObject() { Object obj; return move(obj); } int main() { Object obj = MoveObject(); return 0; } /* output: Construct Destruct Move Destruct */ åœ¨ CopyObject å‡½æ•°è¿”å›æ—¶å¢åŠ åˆ¤æ–­æ¡ä»¶ï¼Œä¼šå‘ç°å…¶è¿”å›æ—¶ä¹Ÿä¼šè°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°ï¼Œè€Œæ²¡æœ‰è§¦å‘ RVO æœºåˆ¶ã€‚æ²¡æœ‰è§¦å‘ RVO æœºåˆ¶æ˜¯å› ä¸ºç¼–è¯‘å™¨ä¼šä½¿ç”¨çˆ¶å †æ ˆå¸§ï¼ˆparent stack frameï¼‰æ¥é¿å…è¿”å›å€¼æ‹·è´ï¼Œä½†å¦‚æœåœ¨è¿”å›æ—¶ä½¿ç”¨äº†åˆ¤æ–­è¯­å¥ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶å°†ä¸èƒ½ç¡®å®šå°†å“ªä¸€ä¸ªä½œä¸ºè¿”å›å€¼ï¼Œå› æ­¤ä¸ä¼šè§¦å‘ RVO æœºåˆ¶ï¼›è€Œè°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°æ˜¯å› ä¸ºåœ¨ä½¿ç”¨å·¦å€¼è¿”å›æ—¶ç¼–è¯‘å™¨ä¼šä¼˜å…ˆä½¿ç”¨ç§»åŠ¨æ„é€ å‡½æ•°ï¼Œä¸æ”¯æŒç§»åŠ¨æ„é€ æ—¶æ‰è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ã€‚\nObject CopyObject(bool flag) { Object obj1, obj2; if (flag) return obj1; return obj2; } int main() { Object obj = CopyObject(true); return 0; } /* output: Construct Construct Move Destruct Destruct Destruct */ å‚è€ƒ RVO V.S. std::move\nå³å€¼å¼•ç”¨ä¸è½¬ç§»è¯­ä¹‰\n","permalink":"http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-1.5/","summary":"C++æ™ºèƒ½æŒ‡é’ˆï¼ˆ1.5ï¼‰ï¼šmoveè¯­ä¹‰ moveè¯­ä¹‰ å®šä¹‰ å³å€¼å¼•ç”¨ï¼ˆRvalue Refereneï¼‰æ˜¯ C++ 11ä¸­å¼•å…¥çš„æ–°ç‰¹æ€§ï¼Œå®ƒå®ç°äº†è½¬ç§»è¯­ä¹‰ï¼ˆMove Sementicsï¼‰å’Œç²¾ç¡®ä¼ é€’ï¼ˆPerfect Forwardingï¼‰ï¼Œå…¶ä¸»è¦ç›®çš„æœ‰\n æ¶ˆé™¤ä¸¤ä¸ªå¯¹è±¡äº¤äº’æ—¶ä¸å¿…è¦çš„å¯¹è±¡æ‹·è´ï¼ŒèŠ‚çœè¿ç®—å­˜å‚¨èµ„æºï¼Œæé«˜æ•ˆç‡ã€‚ èƒ½å¤Ÿæ›´ç®€æ´æ˜ç¡®åœ°å®šä¹‰æ³›å‹å‡½æ•°ã€‚  å®ç° move è¯­ä¹‰çš„å®ç°éå¸¸ç®€å•ï¼Œå®ƒå°†ä¼ å…¥çš„å‚æ•° _Tp\u0026amp;\u0026amp; __t ä½¿ç”¨é™æ€ç±»å‹è½¬æ¢ static_cast\u0026lt;_Up\u0026amp;\u0026amp;\u0026gt;(__t) è½¬å˜æˆäº†æˆäº†å¯¹åº”ç±»å‹çš„å³å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´ä½¿ç”¨ move è¯­ä¹‰ä¹‹åï¼Œç¼–è¯‘å™¨çªƒå–ï¼ˆä¸€èˆ¬ä¼šåœ¨ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦é‡Œå°†åŸæœ‰å¯¹è±¡æŒ‡å‘ nullptrï¼‰äº†åŸæœ‰å¯¹è±¡çš„å³å€¼ï¼Œå¹¶å»¶é•¿äº†è¿™ä¸ªå³å€¼çš„ç”Ÿå‘½å‘¨æœŸå¹¶å°†å…¶ç”¨æ¥èµ‹å€¼ç»™å…¶ä»–çš„å¯¹è±¡ï¼Œè€Œæ²¡æœ‰\u0008å¯¹å³å€¼åšä»»ä½•æ‹·è´æ“ä½œã€‚\ntemplate \u0026lt;class _Tp\u0026gt; typename remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp; move(_Tp\u0026amp;\u0026amp; __t) _NOEXCEPT { typedef typename remove_reference\u0026lt;_Tp\u0026gt;::type _Up; return static_cast\u0026lt;_Up\u0026amp;\u0026amp;\u0026gt;(__t); } æµ‹è¯• \u0008å®šä¹‰ä¸€ä¸ª Object ç±»å’Œä¸€ä¸ª MoveObject å‡½æ•°ä½¿ç”¨ move è¯­ä¹‰è¿”å›ä¸€ä¸ª Object çš„ç±»å¯¹è±¡ï¼Œå¯ä»¥çœ‹åˆ°åœ¨ MoveObject å‡½æ•°è¿”å›å³å€¼åï¼Œobj å¯¹è±¡è°ƒç”¨äº†ç§»åŠ¨æ„é€ å‡½æ•°ã€‚\nclass Object { public: Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Construct\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(const Object \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(Object \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Destruct\u0026#34; \u0026lt;\u0026lt; std::endl; } void Print() { std::cout \u0026lt;\u0026lt; \u0026#34;Print\u0026#34; \u0026lt;\u0026lt; std::endl; } }; Object MoveObject() { Object obj; return move(obj); } int main() { Object obj = MoveObject(); return 0; } /* output: Construct Move Destruct Destruct */ è¿”å›å€¼ä¼˜åŒ–ï¼ˆRVOï¼ŒReturn value optimisationï¼‰ è¿”å›å€¼ä¼˜åŒ–æ˜¯ä¸€ç§ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯ï¼Œå…è®¸ç¼–è¯‘å™¨åœ¨è°ƒç”¨ç‚¹ï¼ˆcall siteï¼‰ç›´æ¥æ„é€ å‡½æ•°çš„è¿”å›å€¼ã€‚","title":"C++ æ™ºèƒ½æŒ‡é’ˆï¼ˆ1.5ï¼‰ï¼šmove è¯­ä¹‰"},{"content":"C++æ™ºèƒ½æŒ‡é’ˆï¼ˆ1ï¼‰ï¼šauto_ptr åˆ†æ C++ ä¸­ç»å¸¸ä¼šå‡ºç°å› ä¸ºæ²¡æœ‰ delete æŒ‡é’ˆè€Œé€ æˆçš„å†…å­˜æ³„æ¼ï¼Œä¾‹å¦‚æœ‰ä¸€ä¸ª Object ç±»\nclass Object { public: Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Construct\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(const Object \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(Object \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Destruct\u0026#34; \u0026lt;\u0026lt; std::endl; } void Print() { std::cout \u0026lt;\u0026lt; \u0026#34;Print\u0026#34; \u0026lt;\u0026lt; std::endl; } }; åˆ›å»ºä¸€ä¸ªæŒ‡å‘ Object ç±»å‹çš„æŒ‡é’ˆ\nint main() { Object *o = new Object(); o-\u0026gt;Print(); return 0; } /* output: Construct Print */ æˆ‘ä»¬æ²¡æœ‰è¿›è¡Œdelete oçš„æ“ä½œï¼Œå¯¼è‡´oæ²¡æœ‰è¢«æ­£ç¡®åœ°ææ„ï¼Œé€ æˆäº†å†…å­˜æ³„æ¼ã€‚ä½œä¸ºå¯¹æ¯”ï¼Œåˆ›å»ºä¸€ä¸ªObjç±»å‹çš„å¯¹è±¡\nint main() { Object *o1 = new Object(); o1-\u0026gt;Print(); Object o2 = Object(); o2.Print(); return 0; } /* output: Construct Print Construct Print Destruct */ äº§ç”Ÿè¿™æ ·çš„ç»“æœæ˜¯å› ä¸ºå¯¹è±¡åˆ›å»ºåœ¨æ ˆï¼ˆstackï¼‰ä¸Šï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è¿›è¡Œå¯¹è±¡çš„åˆ›å»ºå’Œé”€æ¯ï¼Œè€ŒæŒ‡é’ˆæ˜¯åˆ›å»ºåœ¨å †ï¼ˆheapï¼‰ä¸Šï¼Œéœ€è¦æ‰‹åŠ¨è¿›è¡Œåˆ›å»ºå’Œé”€æ¯ã€‚ä¸ºäº†è§„é¿è¿™æ ·çš„é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥å°è£…ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆç±»ï¼Œç”¨ç±»æ¥ç®¡ç†æŒ‡é’ˆï¼Œé˜²æ­¢é€ æˆå†…å­˜æ³„æ¼ï¼Œå¹¶ä¸”å°½å¯èƒ½çš„æ¨¡ä»¿æŒ‡é’ˆçš„ç”¨æ³•ã€‚\nå®ç° æ ¹æ®auto_ptrçš„æºç ï¼Œèƒ½å¤Ÿå¤§è‡´å®ç° AutoPointer ç±»\ntemplate\u0026lt;typename T\u0026gt; class AutoPointer { public: explicit AutoPointer(T *t); ~AutoPointer(); T \u0026amp;operator*(); T *operator-\u0026gt;(); T *release(); void reset(T *p); AutoPointer(AutoPointer\u0026lt;T\u0026gt; \u0026amp;other); AutoPointer\u0026lt;T\u0026gt; \u0026amp;operator=(AutoPointer\u0026lt;T\u0026gt; const \u0026amp;other); private: T *pointer; }; template\u0026lt;typename T\u0026gt; AutoPointer\u0026lt;T\u0026gt;::AutoPointer(T *t) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; this-\u0026gt;pointer = t; } template\u0026lt;typename T\u0026gt; AutoPointer\u0026lt;T\u0026gt;::~AutoPointer() { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; delete this-\u0026gt;pointer; } template\u0026lt;typename T\u0026gt; T \u0026amp;AutoPointer\u0026lt;T\u0026gt;::operator*() { return *this-\u0026gt;pointer; } template\u0026lt;typename T\u0026gt; T *AutoPointer\u0026lt;T\u0026gt;::operator-\u0026gt;() { return this-\u0026gt;pointer; } template\u0026lt;typename T\u0026gt; T *AutoPointer\u0026lt;T\u0026gt;::release() { T *new_pointer = this-\u0026gt;pointer; this-\u0026gt;pointer = nullptr; return new_pointer; } template\u0026lt;typename T\u0026gt; void AutoPointer\u0026lt;T\u0026gt;::reset(T *p) { if (this-\u0026gt;pointer != p) { delete this-\u0026gt;pointer; this-\u0026gt;pointer = p; } } template\u0026lt;typename T\u0026gt; AutoPointer\u0026lt;T\u0026gt;::AutoPointer(AutoPointer\u0026lt;T\u0026gt; \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; copy constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; this-\u0026gt;pointer = other.release(); } template\u0026lt;typename T\u0026gt; AutoPointer\u0026lt;T\u0026gt; \u0026amp;AutoPointer\u0026lt;T\u0026gt;::operator=(AutoPointer\u0026lt;T\u0026gt; const \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; assignment operator called.\u0026#34; \u0026lt;\u0026lt; std::endl; if (this-\u0026gt;pointer != other.pointer) this-\u0026gt;reset(other.release()); return *this; }  æ„é€ å‡½æ•°ç›´æ¥å°† AutoPointer ç±»çš„ pointer æŒ‡é’ˆæŒ‡å‘ä¼ å…¥çš„å‚æ•°æŒ‡é’ˆæ‰€æŒ‡å‘çš„åœ°å€ æ‹·è´æ„é€ å‡½æ•°å…ˆå¯¹å‚æ•°å¯¹è±¡çš„æŒ‡é’ˆè¿›è¡Œ release æ“ä½œï¼Œä¹Ÿå°±æ˜¯å°†å‚æ•°å¯¹è±¡çš„ç§æœ‰æˆå‘˜ pointer æŒ‡é’ˆç½®ä¸º nullptr å¹¶è¿”å›å…¶åŸæœ¬æŒ‡å‘çš„åœ°å€ï¼Œç„¶åå°†è‡ªèº«çš„ pointer æŒ‡å‘è¿™ä¸ªåœ°å€ èµ‹å€¼æ“ä½œç¬¦å…ˆåˆ¤æ–­ä¼ å…¥çš„å‚æ•°æ˜¯å¦æ˜¯å½“å‰çš„ AutoPointer ç±»å¯¹è±¡æœ¬èº«ï¼Œå¦‚æœæ˜¯çš„è¯ç›´æ¥è¿”å› this æŒ‡é’ˆï¼Œå¦åˆ™å…ˆå¯¹å‚æ•°å¯¹è±¡çš„æŒ‡é’ˆè¿›è¡Œ release æ“ä½œï¼Œå¹¶ delete æ‰å½“å‰å¯¹è±¡çš„ pointerï¼Œå†å°† pointer æŒ‡å‘å‚æ•°å¯¹è±¡çš„ pointer åŸæœ¬æŒ‡å‘çš„åœ°å€ï¼Œè¿™æ ·çš„å®ç°æœ‰æ•ˆåœ°è§„é¿äº†è¿·é€”æŒ‡é’ˆï¼ˆä¹Ÿç§°æ‚¬ç©ºæŒ‡é’ˆæˆ–é‡æŒ‡é’ˆï¼‰ã€‚  æµ‹è¯• åˆ›å»ºå•ä¸ª AutoPointer ç±»å¯¹è±¡æ—¶èƒ½å¤Ÿæ­£å¸¸ä½¿ç”¨ã€‚\nint main() { Object *o = new Object(); AutoPointer\u0026lt;Object\u0026gt; a1(o); (*a1).Print(); a1-\u0026gt;Print(); return 0; } /* output: Construct AutoPointer 0x7fe680c02ab0 constructor called. Print Print AutoPointer 0x7fe680c02ab0 destructor called. Destruct */ åˆ›å»ºä¸¤ä¸ª AutoPointer ç±»å¯¹è±¡æ—¶å¦‚æœä½¿ç”¨åŒä¸€ä¸ª Object æŒ‡é’ˆè¿›è¡Œåˆå§‹åŒ–ï¼Œé‚£ä¹ˆåœ¨ç¨‹åºé€€å‡ºæ—¶ Object å¯¹è±¡ä¼šè¢«ä¸¤ä¸ª AutoPointer ç±»å¯¹è±¡å„ææ„ä¸€æ¬¡ï¼Œä¹Ÿå°±æ˜¯è¯´åŒä¸€å—åœ°å€ä¼šè¢« delete ä¸¤æ¬¡ï¼Œé€ æˆè¿è¡Œæ—¶æŠ¥é”™ã€‚\nint main() { Object *o = new Object(); AutoPointer\u0026lt;Object\u0026gt; a1(o); AutoPointer\u0026lt;Object\u0026gt; a2(o); return 0; } /* output: Construct AutoPointer 0x7ffee3fa0178 constructor called. AutoPointer 0x7ffee3fa0170 constructor called. AutoPointer 0x7ffee3fa0170 destructor called. Destruct AutoPointer 0x7ffee3fa0178 destructor called. Destruct cpp(9015,0x1197a25c0) malloc: *** error for object 0x7fe9dec02b40: pointer being freed was not allocated cpp(9015,0x1197a25c0) malloc: *** set a breakpoint in malloc_error_break to debug */ ä½¿ç”¨æ‹·è´æ„é€ å‡½æ•°å°†ä¸€ä¸ª AutoPointer ç±»å¯¹è±¡ a1 æ‹·è´ç»™å¦ä¸€ä¸ª AutoPointer ç±»å¯¹è±¡ a2 æ—¶ï¼ŒObject æŒ‡é’ˆ o åŸæœ¬æ˜¯å±äº a1 çš„ï¼Œåœ¨ a2 è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ä¹‹åï¼Œa1 çš„ pointer å˜æˆäº†ç©ºæŒ‡é’ˆï¼Œè€Œ s2 æ‹¥æœ‰äº†æŒ‡é’ˆ oï¼Œé€ æˆäº†æ‰€æœ‰æƒè½¬ç§»ã€‚\nint main() { Object *o = new Object(); AutoPointer\u0026lt;Object\u0026gt; a1(o); AutoPointer\u0026lt;Object\u0026gt; a2(a1); return 0; } /* output: Construct AutoPointer 0x7fd15bc02ab0 constructor called. AutoPointer 0x7fd15bc02ab0 copy constructor called. AutoPointer 0x7fd15bc02ab0 destructor called. Destruct AutoPointer 0x0 destructor called. */ ä½¿ç”¨èµ‹å€¼æ“ä½œç¬¦ä¹Ÿä¼šæœ‰æ‰€æœ‰æƒè½¬ç§»çš„é—®é¢˜ã€‚\nint main() { Object *o = new Object(); AutoPointer\u0026lt;Object\u0026gt; a1(o); AutoPointer\u0026lt;Object\u0026gt; a2 = a1; return 0; } /* output: Construct AutoPointer 0x7ff5d5402ab0 constructor called. AutoPointer 0x7ff5d5402ab0 copy constructor called. AutoPointer 0x7ff5d5402ab0 destructor called. Destruct AutoPointer 0x0 destructor called. */ æ€»ç»“ AutoPointer æœ‰æ•ˆåœ°è§£å†³äº†é‡æŒ‡é’ˆé—®é¢˜ï¼Œä½†åˆä¼šå¼•å…¥ä¸€äº›å…¶ä»–çš„é—®é¢˜ï¼Œä¾‹å¦‚\n  æ‰€æœ‰æƒè½¬ç§»\n å°† AutoPointer ä½œä¸ºå‚æ•°è¿›è¡Œæ‹·è´æ„é€ æˆ–èµ‹å€¼æ“ä½œæ—¶é€ æˆæ‰€æœ‰æƒè½¬ç§»    å†…å­˜æ³„æ¼\n åœ¨ææ„å‡½æ•°ä¸­ä½¿ç”¨äº†deleteè¿›è¡ŒæŒ‡é’ˆçš„é”€æ¯ï¼Œä½†å¦‚æœä»¥æ•°ç»„æŒ‡é’ˆè¿›è¡Œåˆå§‹åŒ– AutoPointer\u0026lt;int\u0026gt; s1(new int[10]) ä¼šå› ä¸ºæ²¡æœ‰é”€æ¯æ•°ç»„\u0008çš„å…¶å®ƒå…ƒç´ è€Œé€ æˆå†…å­˜æ³„æ¼\u0008    auto_ptræºç  template\u0026lt;class _Tp\u0026gt; class _LIBCPP_TEMPLATE_VIS auto_ptr { private: _Tp* __ptr_; public: typedef _Tp element_type; _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {} _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr\u0026amp; __p) throw() : __ptr_(__p.release()) {} template\u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr\u0026lt;_Up\u0026gt;\u0026amp; __p) throw() : __ptr_(__p.release()) {} _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026amp; operator=(auto_ptr\u0026amp; __p) throw() {reset(__p.release()); return *this;} template\u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026amp; operator=(auto_ptr\u0026lt;_Up\u0026gt;\u0026amp; __p) throw() {reset(__p.release()); return *this;} _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026amp; operator=(auto_ptr_ref\u0026lt;_Tp\u0026gt; __p) throw() {reset(__p.__ptr_); return *this;} _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp\u0026amp; operator*() const throw() {return *__ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* operator-\u0026gt;() const throw() {return __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* release() throw() { _Tp* __t = __ptr_; __ptr_ = 0; return __t; } _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw() { if (__ptr_ != __p) delete __ptr_; __ptr_ = __p; } _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref\u0026lt;_Tp\u0026gt; __p) throw() : __ptr_(__p.__ptr_) {} template\u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref\u0026lt;_Up\u0026gt;() throw() {auto_ptr_ref\u0026lt;_Up\u0026gt; __t; __t.__ptr_ = release(); return __t;} template\u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY operator auto_ptr\u0026lt;_Up\u0026gt;() throw() {return auto_ptr\u0026lt;_Up\u0026gt;(release());} }; ","permalink":"http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-1/","summary":"C++æ™ºèƒ½æŒ‡é’ˆï¼ˆ1ï¼‰ï¼šauto_ptr åˆ†æ C++ ä¸­ç»å¸¸ä¼šå‡ºç°å› ä¸ºæ²¡æœ‰ delete æŒ‡é’ˆè€Œé€ æˆçš„å†…å­˜æ³„æ¼ï¼Œä¾‹å¦‚æœ‰ä¸€ä¸ª Object ç±»\nclass Object { public: Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Construct\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(const Object \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(Object \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Destruct\u0026#34; \u0026lt;\u0026lt; std::endl; } void Print() { std::cout \u0026lt;\u0026lt; \u0026#34;Print\u0026#34; \u0026lt;\u0026lt; std::endl; } }; åˆ›å»ºä¸€ä¸ªæŒ‡å‘ Object ç±»å‹çš„æŒ‡é’ˆ\nint main() { Object *o = new Object(); o-\u0026gt;Print(); return 0; } /* output: Construct Print */ æˆ‘ä»¬æ²¡æœ‰è¿›è¡Œdelete oçš„æ“ä½œï¼Œå¯¼è‡´oæ²¡æœ‰è¢«æ­£ç¡®åœ°ææ„ï¼Œé€ æˆäº†å†…å­˜æ³„æ¼ã€‚ä½œä¸ºå¯¹æ¯”ï¼Œåˆ›å»ºä¸€ä¸ªObjç±»å‹çš„å¯¹è±¡","title":"C++ æ™ºèƒ½æŒ‡é’ˆï¼ˆ1ï¼‰ï¼šauto_ptr"},{"content":"åˆ›å»ºçˆ¬è™« åœ¨æ–°å»ºå¥½é¡¹ç›®åï¼Œç”¨PyCharmæˆ–å…¶ä»–IDEæ‰“å¼€è¯¥é¡¹ç›®ã€‚è¿›å…¥è¯¥é¡¹ç›®æ–‡ä»¶å¤¹ï¼Œä½¿ç”¨genspiderå‘½ä»¤æ–°å»ºä¸€ä¸ªçˆ¬è™«ï¼š\ncd scrapy_project\rscrapy genspider QuestionSetSpider leetcode.com\rå…¶ä¸­QuestionSetSpideræ˜¯çˆ¬è™«çš„åå­—ï¼Œleetcode.comæ˜¯æˆ‘ä»¬æ‰“ç®—çˆ¬å–çš„ç½‘ç«™çš„åŸŸåã€‚\u0008\næ–°å»ºå¥½çˆ¬è™«ä¹‹åå¯ä»¥çœ‹åˆ°åœ¨é¡¹ç›®çš„spidersæ–‡ä»¶å¤¹ä¸‹æ–°å¢äº†ä¸€ä¸ªåä¸º QuestionSetSpider.pyçš„æ–‡ä»¶ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬åˆšæ‰æ–°å»ºçš„çˆ¬è™«æ–‡ä»¶ã€‚è¿™ä¸ªçˆ¬è™«æ–‡ä»¶ä¼šè‡ªåŠ¨ç”Ÿæˆä»¥ä¸‹ä»£ç \n# -*- coding: utf-8 -*-\rimport scrapy\rclass QuestionSetSpider(scrapy.Spider):\rname = 'QuestionSetSpider'\rallowed_domains = ['leetcode.com']\rstart_urls = ['http://leetcode.com/']\rdef parse(self, response):\rpass\r QuestionSetSpiderç±»ç»§æ‰¿è‡ªscrapy.Spiderï¼Œä¹Ÿå°±æ˜¯scrapyæ¡†æ¶ä¸­æ‰€æœ‰çˆ¬è™«çš„åŸºç±»ï¼› self.nameå±æ€§æ˜¯è¯¥çˆ¬è™«çš„åå­—ï¼Œåœ¨è¯¥çˆ¬è™«æ–‡ä»¶çš„å¤–éƒ¨å¯ä»¥é€šè¿‡è¿™ä¸ªå±æ€§è·å–\u0008å½“å‰çˆ¬è™«ï¼› self.allowed_domainsæ˜¯å½“å‰çˆ¬è™«æ–‡ä»¶å¯ä»¥è®¿é—®çš„åŸŸååˆ—è¡¨ï¼Œå¦‚æœåœ¨çˆ¬å–é¡µé¢æ—¶è¿›å…¥äº†ä¸€ä¸ªè¯¥åŸŸåä»¥å¤–çš„urlä¼šæŠ›å‡ºé”™è¯¯ï¼› self.start_urlsæ˜¯ä¸€ä¸ªurlåˆ—è¡¨ï¼ŒåŸºç±»ä¸­å®šä¹‰äº†start_requestså‡½æ•°ï¼Œå®ƒä¼šéå†self.start_urlsï¼Œå¹¶å¯¹æ¯ä¸€ä¸ªurlè°ƒç”¨scrapy.Request(url, dont_filter=True)ï¼Œä¸ºäº†å®ç°çˆ¬å–é¢˜ç›®çš„éœ€æ±‚ï¼Œæˆ‘ä»¬éœ€è¦é‡å†™self.start_urlså‡½æ•°  è·å–é¢˜ç›®è¯¦ç»†ä¿¡æ¯ åˆ†æ LeetCodeä½¿ç”¨äº†GraphQLè¿›è¡Œæ•°æ®çš„æŸ¥è¯¢å’Œä¼ è¾“ï¼Œå¤§éƒ¨åˆ†é¡µé¢éƒ½æ˜¯é€šè¿‡JSæ¸²æŸ“ç”Ÿæˆçš„åŠ¨æ€é¡µé¢ï¼Œæ‰€ä»¥æ— æ³•ç›´æ¥ä»é¡µé¢ä¸Šè·å–æ ‡ç­¾ï¼Œå³ä½¿ä½¿ç”¨æä¾›JavaScriptæ¸²æŸ“æœåŠ¡çš„åº“ï¼ˆä¾‹å¦‚Splashï¼‰ä¹Ÿæ— æ³•è·å–å…¨éƒ¨çš„æ•°æ®ï¼Œæ‰€ä»¥\u0008åªèƒ½é€šè¿‡å‘é€è¯·æ±‚æ¥è·å–æ•°æ®ã€‚\nä¸ºäº†çˆ¬å–é¢˜ç›®çš„è¯¦ç»†ä¿¡æ¯ï¼Œæˆ‘ä»¬é¦–å…ˆè¦ä»é¢˜ç›®åˆ—è¡¨è¿›å…¥æ¯ä¸ªé¢˜ç›®å¯¹åº”çš„é“¾æ¥ã€‚\né¦–å…ˆæ‰“å¼€leetcodeçš„problemåˆ—è¡¨ï¼ŒæŒ‰F12æ‰“å¼€Chromeçš„å¼€å‘è€…å·¥å…·ï¼Œè¿›å…¥Networkæ ‡ç­¾æ ï¼Œå‹¾é€‰ä¸ŠPreserve logï¼Œåˆ·æ–°è¯¥é¡µé¢ã€‚\nå¯ä»¥çœ‹åˆ°ï¼Œç½‘é¡µå‘ https://leetcode.com/api/problems/all/ å‘é€äº†ä¸€ä¸ªåä¸º\u0026quot;all/\u0026ldquo;çš„GETç±»å‹çš„Requestï¼Œè¿™å°±æ˜¯è·å–æ‰€æœ‰é¢˜ç›®é“¾æ¥å’Œç›¸å…³ä¿¡æ¯çš„è¯·æ±‚ã€‚å¦‚æœæ­¤æ—¶å·²ç»å®‰è£…äº†Toggle JavaScriptæ’ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥å³é”®ç‚¹å‡»â€œOpen in new tabâ€ï¼ŒæŸ¥çœ‹è¯¥è¯·æ±‚è¿”å›çš„Responseã€‚\næ›´æ–¹ä¾¿çš„æ–¹æ³•æ˜¯ä½¿ç”¨postmanå‘æœåŠ¡å™¨å‘é€ä¸€ä¸ªç›¸åŒçš„Requestï¼Œå¹¶å°†å…¶ä¿å­˜ä¸‹æ¥ï¼Œè¿™æ ·å¦‚æœæˆ‘ä»¬ä¸‹æ¬¡éœ€è¦æŸ¥çœ‹ç›¸åº”çš„Responseçš„æ—¶å€™å°±ä¸éœ€è¦å†ä½¿ç”¨å¼€å‘è€…å·¥å…·äº†ã€‚\nè¿”å›çš„Responseæ˜¯ä¸€ä¸ªjsonå¯¹è±¡ï¼Œå…¶ä¸­çš„\u0026quot;stat_status_pairs\u0026quot;\u0008é”®æ‰€å¯¹åº”çš„å€¼æ˜¯æ‰€æœ‰åŒ…å«é¢˜ç›®ä¿¡æ¯\u0008çš„listï¼Œè€Œåˆ—è¡¨ä¸­çš„[\u0026ldquo;stat\u0026rdquo;][\u0026ldquo;question__title_slug\u0026rdquo;]å°±æ˜¯é¢˜ç›®æ‰€åœ¨çš„é¡µé¢ã€‚ä»¥Largest Perimeter Triangleä¸ºä¾‹ï¼Œå°†å…¶title_slugæ‹¼æ¥åˆ°https://leetcode.com/problems/ åï¼Œè¿›å…¥é¡µé¢https://leetcode.com/problems/largest-perimeter-triangle/ ã€‚åŒæ ·åœ°ï¼Œæ‰“å¼€å¼€å‘è€…å·¥å…·ï¼Œ\u0008åˆ·æ–°é¡µé¢ï¼Œå¯ä»¥çœ‹åˆ°æœåŠ¡å™¨è¿”å›äº†å¾ˆå¤šé¡¹graphqlçš„æŸ¥è¯¢æ•°æ®ï¼Œé€šè¿‡æŸ¥çœ‹Request Payloadå¯ä»¥æ‰¾åˆ°å…¶ä¸­operationNameä¸º\u0026quot;questionData\u0026quot;çš„ä¸€é¡¹ï¼Œè¿™å°±æ˜¯å½“å‰é¢˜ç›®çš„è¯¦ç»†ä¿¡æ¯ã€‚\nå°†Payloadå¤åˆ¶ç²˜è´´åˆ°postmançš„Bodyä¸­ï¼Œåœ¨Headersä¸­\u0008è®¾ç½®Content-Typeä¸ºapplication/jsonï¼Œå‘é€è¯·æ±‚ï¼Œå¯ä»¥çœ‹åˆ°è¿”å›çš„æ˜¯ä¸€ä¸ªjsonå¯¹è±¡ï¼Œ\u0008åŒ…å«äº†è¯¥é¢˜ç›®æ‰€å¯¹åº”çš„æ‰€æœ‰ä¿¡æ¯ã€‚\næ¥ä¸‹æ¥æˆ‘ä»¬å°±å¯ä»¥å¯¹è¯¥é¢˜ç›®çš„ä¿¡æ¯è¿›è¡Œå¤„ç†äº†ã€‚\nå®ç° ä¸ºäº†è·å–é¢˜ç›®åˆ—è¡¨çš„jsonå¯¹è±¡ï¼Œæˆ‘ä»¬éœ€è¦å…ˆé‡å†™start_requestså‡½æ•°ã€‚\ndef start_requests(self):\rself.Login() # ç”¨æˆ·ç™»å½•ï¼Œ\u0008åç»­ä¼šç”¨åˆ°\rquestionset_url = \u0026quot;https://leetcode.com/api/problems/all/\u0026quot;\ryield scrapy.Request(url=questionset_url, callback=self.ParseQuestionSet)\rRequestæ˜¯scrapyçš„ä¸€ä¸ªç±»å¯¹è±¡ï¼ŒåŠŸèƒ½ç±»ä¼¼äºrequestsåº“ä¸­çš„getå‡½æ•°ï¼Œå¯ä»¥è®©scrapyæ¡†æ¶ä¸­çš„Downloaderå‘urlå‘é€ä¸€ä¸ªgetè¯·æ±‚ï¼Œå¹¶å°†è·å–çš„responseäº¤ç»™æŒ‡å®šçš„çˆ¬è™«æ–‡ä»¶ä¸­çš„å›è°ƒå‡½æ•°è¿›è¡Œç›¸åº”çš„å¤„ç†ï¼Œå…¶æ„é€ å‡½æ•°å¦‚ä¸‹\nclass Request(object_ref):\rdef __init__(self, url, callback=None, method='GET', headers=None, body=None, cookies=None, meta=None, encoding='utf-8', priority=0, dont_filter=False, errback=None, flags=None):\r...\råœ¨è·å–åˆ°jsonå¯¹è±¡ä¹‹åï¼Œå¯ä»¥é€šè¿‡éå†\u0026quot;stat_status_pairs\u0026quot;é”®æ‰€å¯¹åº”çš„åˆ—è¡¨ï¼Œå¹¶å–å‡º[\u0026ldquo;stat\u0026rdquo;][\u0026ldquo;question__title_slug\u0026rdquo;]çš„å€¼ï¼Œå¾—åˆ°é¢˜ç›®çš„title_slugã€‚æ­¤æ—¶æˆ‘ä»¬ä¸å†éœ€è¦è¿›è¡Œ\u0008æ‰“å¼€é¢˜ç›®ç›¸å…³é¡µé¢çš„æ“ä½œï¼Œç›´æ¥å‘\u0008GraphQLå‘é€æŸ¥è¯¢è¯¦ç»†ä¿¡æ¯çš„\u0008requestå³å¯ã€‚\næˆ‘ä»¬å¯ä»¥ä»postmanç›´æ¥è·å–åˆ°å‘é€è¯·æ±‚ç›¸å…³çš„ä»£ç ã€‚å› ä¸ºæ¯ä¸ªé¢˜ç›®çš„title_slugä¸åŒï¼Œæˆ‘ä»¬å¯ä»¥å°†Payloadä¸­titleSlugåçš„å­—æ®µæ”¹ä¸ºä¸€ä¸ªä¸ä¼šé‡å¤çš„ç‹¬ç‰¹çš„å­—ç¬¦ä¸²ï¼Œåœ¨æ¯ä¸€æ¬¡è·å–åˆ°æ–°çš„title_slugä¹‹åç”¨replaceå‡½æ•°æ›¿æ¢å®ƒï¼Œ\u0008å‘é€æ–°çš„è¯·æ±‚ï¼Œç„¶åå†å°†å…¶æ›¿æ¢å›ç‹¬ç‰¹çš„å­—ç¬¦ä¸²ã€‚\nå‡†å¤‡å¥½Payloadå’ŒHeadersä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨FormRequestå‘é€POSTè¯·æ±‚å‘GraphQLæŸ¥è¯¢æ•°æ®ã€‚FormRequestæ˜¯scrapyçš„ä¸€ä¸ªç±»å¯¹è±¡ï¼ŒåŠŸèƒ½ç±»ä¼¼äºrequestsåº“ä¸­çš„postå‡½æ•°ï¼Œè®©scrapyæ¡†æ¶ä¸­çš„Downloaderå‘urlå‘é€ä¸€ä¸ªpostè¯·æ±‚ï¼Œå¹¶å°†è·å–çš„responseäº¤ç»™æŒ‡å®šçš„çˆ¬è™«æ–‡ä»¶ä¸­çš„å›è°ƒå‡½æ•°è¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚æ­¤å¤„åœ¨å‘é€\u0008POSTè¯·æ±‚ä¹‹åresponseè¢«äº¤ç»™ParseQuestionDataå‡½æ•°è¿›è¡Œå¤„ç†ã€‚\n question_payload = \u0026quot;{\\n \\\u0026quot;operationName\\\u0026quot;: \\\u0026quot;questionData\\\u0026quot;,\\n \\\u0026quot;variables\\\u0026quot;: {\\n \\\u0026quot;titleSlug\\\u0026quot;: \\\u0026quot;QuestionName\\\u0026quot;\\n },\\n \\\u0026quot;query\\\u0026quot;: \\\u0026quot;query questionData($titleSlug: String!) {\\\\n question(titleSlug: $titleSlug) {\\\\n questionId\\\\n questionFrontendId\\\\n boundTopicId\\\\n title\\\\n titleSlug\\\\n content\\\\n translatedTitle\\\\n translatedContent\\\\n isPaidOnly\\\\n difficulty\\\\n likes\\\\n dislikes\\\\n isLiked\\\\n similarQuestions\\\\n contributors {\\\\n username\\\\n profileUrl\\\\n avatarUrl\\\\n __typename\\\\n }\\\\n langToValidPlayground\\\\n topicTags {\\\\n name\\\\n slug\\\\n translatedName\\\\n __typename\\\\n }\\\\n companyTagStats\\\\n codeSnippets {\\\\n lang\\\\n langSlug\\\\n code\\\\n __typename\\\\n }\\\\n stats\\\\n hints\\\\n solution {\\\\n id\\\\n canSeeDetail\\\\n __typename\\\\n }\\\\n status\\\\n sampleTestCase\\\\n metaData\\\\n judgerAvailable\\\\n judgeType\\\\n mysqlSchemas\\\\n enableRunCode\\\\n enableTestMode\\\\n envInfo\\\\n __typename\\\\n }\\\\n}\\\\n\\\u0026quot;\\n}\\n\u0026quot;\rgraphql_url = \u0026quot;https://leetcode.com/graphql\u0026quot;\rdef ParseQuestionSet(self, response):\rheaders = {\r\u0026quot;user_agent\u0026quot;: \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'\u0026quot;,\r\u0026quot;content-type\u0026quot;: \u0026quot;application/json\u0026quot; # necessary\r}\rquestionSet = json.loads(response.text)\rquestionSet = questionSet[\u0026quot;stat_status_pairs\u0026quot;]\rfor question in questionSet:\rtitle_slug = question[\u0026quot;stat\u0026quot;][\u0026quot;question__title_slug\u0026quot;]\rself.question_payload = self.question_payload.replace(\u0026quot;QuestionName\u0026quot;, title_slug)\ryield scrapy.FormRequest(url=self.graphql_url, callback=self.ParseQuestionData,\rheaders=headers, body=self.question_payload)\rself.question_payload = self.question_payload.replace(title_slug, \u0026quot;QuestionName\u0026quot;)\rç°åœ¨æ•°æ®å·²ç»è·å–åˆ°äº†ï¼Œæˆ‘ä»¬éœ€è¦åœ¨items.pyæ–‡ä»¶ä¸­å®šä¹‰ä¸€ä¸ªç±»ç”¨æ¥å­˜å‚¨é¢˜ç›®çš„è¯¦ç»†ä¿¡æ¯ã€‚\u0008items.pyæ–‡ä»¶ä¸­çš„ç±»ç»§æ‰¿è‡ªscrapy.Itemç±»ï¼Œæ˜¯æä¾›ç»™scrapyæ¡†æ¶ä¸­çš„ç»„ä»¶Item Pipelineè¿›è¡Œå¤„ç†çš„ç»Ÿä¸€çš„çš„æ•°æ®ç»“æ„ã€‚\nimport scrapy\rclass QuestionDataItem(scrapy.Item):\r# define the fields for your item here like:\r# name = scrapy.Field()\rid = scrapy.Field()\rtitle = scrapy.Field()\rcontent = scrapy.Field()\rsubmission_list = scrapy.Field()\rtopics = scrapy.Field()\rdifficulty = scrapy.Field()\rac_rate = scrapy.Field()\rlikes = scrapy.Field()\rdislikes = scrapy.Field()\rslug = scrapy.Field()\r\u0008å®šä¹‰äº†QuestionDataItemç±»ä¹‹åå¯ä»¥è¿›\u0008å…¥ParseQuestionDataå‡½æ•°å¼€å§‹å¯¹é¢˜ç›®è¯¦ç»†ä¿¡æ¯çš„æå–ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®éœ€æ±‚æå–å‡ºé¢˜ç›®çš„idï¼Œtitleï¼Œcontentï¼Œtopicsï¼Œdifficultyç­‰ä¿¡æ¯ï¼Œç”¨ä¸€ä¸ªQuestionDataItemå¯¹è±¡æ¥å­˜å‚¨è¿™äº›æ•°æ®ï¼Œç„¶å\u0008è¿›è¡Œyield questionDataItemæ“ä½œï¼Œå°†è¿™ä¸ªå¯¹è±¡\u0008äº¤ç»™Item Pipelineè¿›è¡Œå¤„ç†ã€‚\n def ParseQuestionData(self, response):\rquestionData = json.loads(response.text)[\u0026quot;data\u0026quot;][\u0026quot;question\u0026quot;]\rquestionDataItem = QuestionDataItem()\rquestionDataItem[\u0026quot;id\u0026quot;] = questionData[\u0026quot;questionFrontendId\u0026quot;]\rquestionDataItem[\u0026quot;title\u0026quot;] = questionData[\u0026quot;title\u0026quot;]\rquestionDataItem[\u0026quot;content\u0026quot;] = questionData[\u0026quot;content\u0026quot;]\rtopics = []\rfor topic in questionData[\u0026quot;topicTags\u0026quot;]:\rtopics.append(topic[\u0026quot;name\u0026quot;])\rif len(topics) == 0:\rtopics.append(\u0026quot;None\u0026quot;)\rquestionDataItem[\u0026quot;topics\u0026quot;] = topics\rquestionDataItem[\u0026quot;difficulty\u0026quot;] = questionData[\u0026quot;difficulty\u0026quot;]\rstats = json.loads(questionData[\u0026quot;stats\u0026quot;])\rquestionDataItem[\u0026quot;ac_rate\u0026quot;] = stats[\u0026quot;acRate\u0026quot;]\rquestionDataItem[\u0026quot;likes\u0026quot;] = questionData[\u0026quot;likes\u0026quot;]\rquestionDataItem[\u0026quot;dislikes\u0026quot;] = questionData[\u0026quot;dislikes\u0026quot;]\rquestionDataItem[\u0026quot;slug\u0026quot;] = questionData[\u0026quot;titleSlug\u0026quot;]\rsubmission_list = self.GetSubmissionList(questionDataItem[\u0026quot;slug\u0026quot;])\rquestionDataItem[\u0026quot;submission_list\u0026quot;] = submission_list\ryield questionDataItem\rè‡³æ­¤é¢˜ç›®ä¿¡æ¯çš„çˆ¬å–å°±å®Œæˆäº†ã€‚\nå‚è€ƒèµ„æ–™ Scrapyå®˜æ–¹æ–‡æ¡£Postmanå®˜æ–¹æ–‡æ¡£","permalink":"http://zintrulcre.github.io/posts/leetcode-archiver/leetcode-archiver2/","summary":"åˆ›å»ºçˆ¬è™« åœ¨æ–°å»ºå¥½é¡¹ç›®åï¼Œç”¨PyCharmæˆ–å…¶ä»–IDEæ‰“å¼€è¯¥é¡¹ç›®ã€‚è¿›å…¥è¯¥é¡¹ç›®æ–‡ä»¶å¤¹ï¼Œä½¿ç”¨genspiderå‘½ä»¤æ–°å»ºä¸€ä¸ªçˆ¬è™«ï¼š\ncd scrapy_project\rscrapy genspider QuestionSetSpider leetcode.com\rå…¶ä¸­QuestionSetSpideræ˜¯çˆ¬è™«çš„åå­—ï¼Œleetcode.comæ˜¯æˆ‘ä»¬æ‰“ç®—çˆ¬å–çš„ç½‘ç«™çš„åŸŸåã€‚\u0008\næ–°å»ºå¥½çˆ¬è™«ä¹‹åå¯ä»¥çœ‹åˆ°åœ¨é¡¹ç›®çš„spidersæ–‡ä»¶å¤¹ä¸‹æ–°å¢äº†ä¸€ä¸ªåä¸º QuestionSetSpider.pyçš„æ–‡ä»¶ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬åˆšæ‰æ–°å»ºçš„çˆ¬è™«æ–‡ä»¶ã€‚è¿™ä¸ªçˆ¬è™«æ–‡ä»¶ä¼šè‡ªåŠ¨ç”Ÿæˆä»¥ä¸‹ä»£ç \n# -*- coding: utf-8 -*-\rimport scrapy\rclass QuestionSetSpider(scrapy.Spider):\rname = 'QuestionSetSpider'\rallowed_domains = ['leetcode.com']\rstart_urls = ['http://leetcode.com/']\rdef parse(self, response):\rpass\r QuestionSetSpiderç±»ç»§æ‰¿è‡ªscrapy.Spiderï¼Œä¹Ÿå°±æ˜¯scrapyæ¡†æ¶ä¸­æ‰€æœ‰çˆ¬è™«çš„åŸºç±»ï¼› self.nameå±æ€§æ˜¯è¯¥çˆ¬è™«çš„åå­—ï¼Œåœ¨è¯¥çˆ¬è™«æ–‡ä»¶çš„å¤–éƒ¨å¯ä»¥é€šè¿‡è¿™ä¸ªå±æ€§è·å–\u0008å½“å‰çˆ¬è™«ï¼› self.allowed_domainsæ˜¯å½“å‰çˆ¬è™«æ–‡ä»¶å¯ä»¥è®¿é—®çš„åŸŸååˆ—è¡¨ï¼Œå¦‚æœåœ¨çˆ¬å–é¡µé¢æ—¶è¿›å…¥äº†ä¸€ä¸ªè¯¥åŸŸåä»¥å¤–çš„urlä¼šæŠ›å‡ºé”™è¯¯ï¼› self.start_urlsæ˜¯ä¸€ä¸ªurlåˆ—è¡¨ï¼ŒåŸºç±»ä¸­å®šä¹‰äº†start_requestså‡½æ•°ï¼Œå®ƒä¼šéå†self.start_urlsï¼Œå¹¶å¯¹æ¯ä¸€ä¸ªurlè°ƒç”¨scrapy.Request(url, dont_filter=True)ï¼Œä¸ºäº†å®ç°çˆ¬å–é¢˜ç›®çš„éœ€æ±‚ï¼Œæˆ‘ä»¬éœ€è¦é‡å†™self.start_urlså‡½æ•°  è·å–é¢˜ç›®è¯¦ç»†ä¿¡æ¯ åˆ†æ LeetCodeä½¿ç”¨äº†GraphQLè¿›è¡Œæ•°æ®çš„æŸ¥è¯¢å’Œä¼ è¾“ï¼Œå¤§éƒ¨åˆ†é¡µé¢éƒ½æ˜¯é€šè¿‡JSæ¸²æŸ“ç”Ÿæˆçš„åŠ¨æ€é¡µé¢ï¼Œæ‰€ä»¥æ— æ³•ç›´æ¥ä»é¡µé¢ä¸Šè·å–æ ‡ç­¾ï¼Œå³ä½¿ä½¿ç”¨æä¾›JavaScriptæ¸²æŸ“æœåŠ¡çš„åº“ï¼ˆä¾‹å¦‚Splashï¼‰ä¹Ÿæ— æ³•è·å–å…¨éƒ¨çš„æ•°æ®ï¼Œæ‰€ä»¥\u0008åªèƒ½é€šè¿‡å‘é€è¯·æ±‚æ¥è·å–æ•°æ®ã€‚\nä¸ºäº†çˆ¬å–é¢˜ç›®çš„è¯¦ç»†ä¿¡æ¯ï¼Œæˆ‘ä»¬é¦–å…ˆè¦ä»é¢˜ç›®åˆ—è¡¨è¿›å…¥æ¯ä¸ªé¢˜ç›®å¯¹åº”çš„é“¾æ¥ã€‚\né¦–å…ˆæ‰“å¼€leetcodeçš„problemåˆ—è¡¨ï¼ŒæŒ‰F12æ‰“å¼€Chromeçš„å¼€å‘è€…å·¥å…·ï¼Œè¿›å…¥Networkæ ‡ç­¾æ ï¼Œå‹¾é€‰ä¸ŠPreserve logï¼Œåˆ·æ–°è¯¥é¡µé¢ã€‚\nå¯ä»¥çœ‹åˆ°ï¼Œç½‘é¡µå‘ https://leetcode.com/api/problems/all/ å‘é€äº†ä¸€ä¸ªåä¸º\u0026quot;all/\u0026ldquo;çš„GETç±»å‹çš„Requestï¼Œè¿™å°±æ˜¯è·å–æ‰€æœ‰é¢˜ç›®é“¾æ¥å’Œç›¸å…³ä¿¡æ¯çš„è¯·æ±‚ã€‚å¦‚æœæ­¤æ—¶å·²ç»å®‰è£…äº†Toggle JavaScriptæ’ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥å³é”®ç‚¹å‡»â€œOpen in new tabâ€ï¼ŒæŸ¥çœ‹è¯¥è¯·æ±‚è¿”å›çš„Responseã€‚\næ›´æ–¹ä¾¿çš„æ–¹æ³•æ˜¯ä½¿ç”¨postmanå‘æœåŠ¡å™¨å‘é€ä¸€ä¸ªç›¸åŒçš„Requestï¼Œå¹¶å°†å…¶ä¿å­˜ä¸‹æ¥ï¼Œè¿™æ ·å¦‚æœæˆ‘ä»¬ä¸‹æ¬¡éœ€è¦æŸ¥çœ‹ç›¸åº”çš„Responseçš„æ—¶å€™å°±ä¸éœ€è¦å†ä½¿ç”¨å¼€å‘è€…å·¥å…·äº†ã€‚\nè¿”å›çš„Responseæ˜¯ä¸€ä¸ªjsonå¯¹è±¡ï¼Œå…¶ä¸­çš„\u0026quot;stat_status_pairs\u0026quot;\u0008é”®æ‰€å¯¹åº”çš„å€¼æ˜¯æ‰€æœ‰åŒ…å«é¢˜ç›®ä¿¡æ¯\u0008çš„listï¼Œè€Œåˆ—è¡¨ä¸­çš„[\u0026ldquo;stat\u0026rdquo;][\u0026ldquo;question__title_slug\u0026rdquo;]å°±æ˜¯é¢˜ç›®æ‰€åœ¨çš„é¡µé¢ã€‚ä»¥Largest Perimeter Triangleä¸ºä¾‹ï¼Œå°†å…¶title_slugæ‹¼æ¥åˆ°https://leetcode.com/problems/ åï¼Œè¿›å…¥é¡µé¢https://leetcode.com/problems/largest-perimeter-triangle/ ã€‚åŒæ ·åœ°ï¼Œæ‰“å¼€å¼€å‘è€…å·¥å…·ï¼Œ\u0008åˆ·æ–°é¡µé¢ï¼Œå¯ä»¥çœ‹åˆ°æœåŠ¡å™¨è¿”å›äº†å¾ˆå¤šé¡¹graphqlçš„æŸ¥è¯¢æ•°æ®ï¼Œé€šè¿‡æŸ¥çœ‹Request Payloadå¯ä»¥æ‰¾åˆ°å…¶ä¸­operationNameä¸º\u0026quot;questionData\u0026quot;çš„ä¸€é¡¹ï¼Œè¿™å°±æ˜¯å½“å‰é¢˜ç›®çš„è¯¦ç»†ä¿¡æ¯ã€‚\nå°†Payloadå¤åˆ¶ç²˜è´´åˆ°postmançš„Bodyä¸­ï¼Œåœ¨Headersä¸­\u0008è®¾ç½®Content-Typeä¸ºapplication/jsonï¼Œå‘é€è¯·æ±‚ï¼Œå¯ä»¥çœ‹åˆ°è¿”å›çš„æ˜¯ä¸€ä¸ªjsonå¯¹è±¡ï¼Œ\u0008åŒ…å«äº†è¯¥é¢˜ç›®æ‰€å¯¹åº”çš„æ‰€æœ‰ä¿¡æ¯ã€‚\næ¥ä¸‹æ¥æˆ‘ä»¬å°±å¯ä»¥å¯¹è¯¥é¢˜ç›®çš„ä¿¡æ¯è¿›è¡Œå¤„ç†äº†ã€‚\nå®ç° ä¸ºäº†è·å–é¢˜ç›®åˆ—è¡¨çš„jsonå¯¹è±¡ï¼Œæˆ‘ä»¬éœ€è¦å…ˆé‡å†™start_requestså‡½æ•°ã€‚\ndef start_requests(self):\rself.Login() # ç”¨æˆ·ç™»å½•ï¼Œ\u0008åç»­ä¼šç”¨åˆ°\rquestionset_url = \u0026quot;https://leetcode.","title":"LeetCode Archiver(2)ï¼šè·å–é¢˜ç›®ä¿¡æ¯"},{"content":"åœ¨Google Cloud Platformä¸Šè¿è¡ŒJupyter Notebook ç®€ä»‹ æœ¬æ–‡å–æè‡ª Amulya Aankul å‘å¸ƒåœ¨ Medium çš„ Running Jupyter Notebook on Google Cloud Platform in 15 minï¼Œä¸»è¦ä»‹ç»å¦‚ä½•åœ¨Google Cloud Platformä¸Šæ­å»ºæœåŠ¡å™¨ï¼Œå¹¶åœ¨æœåŠ¡å™¨ä¸Šå®‰è£…å’Œè¿è¡ŒJupyter Notebookã€‚\næœåŠ¡å™¨æ­å»º \u0008åˆ›å»ºè´¦å· é¦–å…ˆåœ¨Google Cloud Platformä¸Šåˆ›å»ºä¸€ä¸ªè´¦å·ã€‚\nåˆ›å»ºæ–°é¡¹ç›® ç‚¹å‡»å·¦ä¸Šè§’\u0026quot;Google Cloud Platform\u0026quot;å³è¾¹çš„ä¸‰ä¸ªç‚¹ï¼Œç‚¹å‡»\u0026quot;NEW PROJECT\u0026quot;åˆ›å»ºæ–°é¡¹ç›®ã€‚\nåˆ›å»ºè™šæ‹Ÿæœº è¿›å…¥åˆšæ‰åˆ›å»ºçš„é¡¹ç›®ï¼Œä»å·¦ä¾§è¾¹æ ç‚¹å‡» Compute Engine -\u0026gt; VM instances è¿›å…¥è™šæ‹Ÿæœºé¡µé¢ã€‚ç‚¹å‡»Createåˆ›å»ºä¸€ä¸ªæ–°çš„è™šæ‹Ÿæœºå®ä¾‹ï¼ˆVM instanceï¼‰\n)\næ ¹æ®éœ€æ±‚å¡«å†™å’Œé€‰æ‹© Name, Region, Zone, Machine Typeå’ŒBoot Diskã€‚åœ¨\u0008 Firewall é€‰é¡¹ä¸­é€‰ä¸­ Allow HTTP traffic å’Œ Allow HTTPS traffic, åœ¨ä¸‹æ–¹çš„ Disks é€‰é¡¹å¡ä¸­å–æ¶ˆå‹¾é€‰ Delete boot disk when instance is deletedã€‚æœ€åç‚¹å‡»\u0008 Createï¼Œè™šæ‹Ÿæœºå®ä¾‹å°±åˆ›å»ºå¥½äº†ã€‚\nè®¾ç½®é™æ€IP é»˜è®¤æƒ…å†µä¸‹ï¼Œå¤–ç½‘IPæ˜¯åŠ¨æ€å˜åŒ–çš„ï¼Œä¸ºäº†æ–¹ä¾¿è®¿é—®æœåŠ¡å™¨ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è®¾ç½®ä¸ºé™æ€çš„ã€‚\nä»å·¦ä¾§è¾¹æ ç‚¹å‡» VPC Network -\u0026gt; External IP Addressï¼Œå¯ä»¥çœ‹åˆ°å½“å‰é¡¹ç›®ä¸‹çš„æ‰€æœ‰è™šæ‹Ÿæœºï¼Œä¾æ¬¡ç‚¹å‡»è™šæ‹Ÿæœºå®ä¾‹å¯¹åº”çš„Typeæ ‡ç­¾å’ŒStaticæ ‡ç­¾ï¼Œå°†å¤–ç½‘IPè®¾ç½®ä¸ºé™æ€çš„ã€‚\nè®¾ç½®é˜²ç«å¢™ ä»å·¦ä¾§è¾¹æ ç‚¹å‡» VPC Network -\u0026gt; Firewall rulesï¼Œç‚¹å‡»ä¸Šæ–¹çš„ CREATE FIREWALL RULEï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„é˜²ç«å¢™è§„åˆ™ã€‚\næ ¹æ®éœ€æ±‚å¡«å†™ Nameï¼Œå°† Targets å‹¾é€‰ä¸º All instances in the networkï¼Œåœ¨ Source IP ranges ä¸­å¡«å†™ 0.0.0.0/0ï¼Œåœ¨ Protocols and ports ä¸­å‹¾é€‰ tcpï¼Œå¡«å†™ä¸€ä¸ªç«¯å£èŒƒå›´ï¼Œç”¨äºä¹‹åè®¿é—® Jupyter Notebookã€‚\nè¿æ¥è™šæ‹Ÿæœº å›åˆ°VM instancesï¼Œæ ¹æ®å¤–ç½‘IP\u0008è¿æ¥ä¸Šåˆšæ‰åˆ›å»ºçš„è™šæ‹Ÿæœºã€‚å¯ä»¥ç›´æ¥ä»è°·æ­Œæä¾›çš„webç»ˆç«¯è¿æ¥ï¼Œä¹Ÿå¯ä»¥é€šè¿‡å…¶ä»–é€”å¾„è¿æ¥ã€‚Windows ä¸‹å¯ä»¥ä½¿ç”¨Puttyï¼Œ\u0008Linux \u0008å’Œ Unix ç³»ç»Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨SSHè¿æ¥ã€‚\né…ç½® Jupyter Notebook å®‰è£… Jupyter Notebook åœ¨ç»ˆç«¯ä¸­è¾“å…¥wget http://repo.continuum.io/archive/Anaconda3-4.0.0-Linux-x86_64.sh è·å– Anaconda 3 \u0008çš„å®‰è£…æ–‡ä»¶\næ¥ä¸‹æ¥è¾“å…¥bash Anaconda3-4.0.0-Linux-x86_64.sh è¿è¡Œè¯¥æ–‡ä»¶ï¼Œå¹¶æ ¹æ®å±å¹•æç¤ºå®‰è£… Anaconda 3ã€‚\nå®‰è£…å¥½ä¹‹åè¯»å–å¯åŠ¨æ–‡ä»¶source ~/.bashrc ä»¥ä½¿ç”¨ Anaconda 3\nä¿®æ”¹é…ç½®æ–‡ä»¶ åˆ›å»º Jupyter Notebook çš„é…ç½®æ–‡ä»¶jupyter notebook --generate-config\nä½¿ç”¨Vimæˆ–å…¶ä»–ç¼–è¾‘å™¨æ‰“å¼€è¯¥é…ç½®æ–‡ä»¶vi ~/.jupyter/jupyter_notebook_config.py\nåœ¨è¯¥æ–‡ä»¶ä¸­åŠ å…¥ç›¸åº”çš„è®¾ç½®\nc = get_config()\rc.NotebookApp.ip = '*'\rc.NotebookApp.open_browser = False\rc.NotebookApp.port = \u0026lt;Port Number\u0026gt;\råœ¨ \u0026lt;Port Number\u0026gt; å¤„å¡«å†™ Jupyter Notebook ä½¿ç”¨çš„ç«¯å£å·ï¼Œ\u0008è¯¥ç«¯å£å·åº”è¯¥æ˜¯åœ¨é˜²ç«å¢™è§„åˆ™çš„ç«¯å£èŒƒå›´ä¹‹å†…çš„ï¼Œå¦åˆ™å°†ä¸èƒ½å¤Ÿé€šè¿‡å¤–ç½‘IPå’Œç«¯å£å·è®¿é—® Jupyter Notebookã€‚å¡«å†™å®Œä¹‹åä½¿ç”¨:wqå‘½ä»¤ä¿å­˜è¯¥æ–‡ä»¶ã€‚\nå¯åŠ¨ Jupyter Notebook æœ€åï¼Œåœ¨ç»ˆç«¯ä¸­è¾“å…¥ jupyter-notebook --no-browser --port=\u0026lt;Port Number\u0026gt; \u0008æ¥å¯åŠ¨\u0008 Jupyter Notebookï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨ nohup jupyter-notebook --no-browser --port=\u0026lt;Port Number\u0026gt; \u0026gt; jupyter.log \u0026amp; æŒ‡ä»¤å¿½ç•¥æŒ‚èµ·ä¿¡å·ï¼Œè®© Jupyter Notebook ä¸€ç›´åœ¨åå°è¿è¡Œï¼Œå¹¶å°†æ§åˆ¶å°ä¿¡æ¯è¾“å‡ºåˆ° jupyter.log æ–‡ä»¶ä¸­ã€‚\næœ€ååœ¨æµè§ˆå™¨ä¸­è¾“å…¥ IP\u0008 åœ°å€å’Œç«¯å£å·ï¼ˆä¾‹å¦‚156.73.83.51:4813ï¼‰å°±èƒ½æ‰“å¼€ Jupyter Notebook äº†ï¼\nå‚è€ƒèµ„æ–™ Running Jupyter Notebook on Google Cloud Platform in 15 min\n","permalink":"http://zintrulcre.github.io/posts/cloud/run-jupyter-notebook-on-gcp/","summary":"åœ¨Google Cloud Platformä¸Šè¿è¡ŒJupyter Notebook ç®€ä»‹ æœ¬æ–‡å–æè‡ª Amulya Aankul å‘å¸ƒåœ¨ Medium çš„ Running Jupyter Notebook on Google Cloud Platform in 15 minï¼Œä¸»è¦ä»‹ç»å¦‚ä½•åœ¨Google Cloud Platformä¸Šæ­å»ºæœåŠ¡å™¨ï¼Œå¹¶åœ¨æœåŠ¡å™¨ä¸Šå®‰è£…å’Œè¿è¡ŒJupyter Notebookã€‚\næœåŠ¡å™¨æ­å»º \u0008åˆ›å»ºè´¦å· é¦–å…ˆåœ¨Google Cloud Platformä¸Šåˆ›å»ºä¸€ä¸ªè´¦å·ã€‚\nåˆ›å»ºæ–°é¡¹ç›® ç‚¹å‡»å·¦ä¸Šè§’\u0026quot;Google Cloud Platform\u0026quot;å³è¾¹çš„ä¸‰ä¸ªç‚¹ï¼Œç‚¹å‡»\u0026quot;NEW PROJECT\u0026quot;åˆ›å»ºæ–°é¡¹ç›®ã€‚\nåˆ›å»ºè™šæ‹Ÿæœº è¿›å…¥åˆšæ‰åˆ›å»ºçš„é¡¹ç›®ï¼Œä»å·¦ä¾§è¾¹æ ç‚¹å‡» Compute Engine -\u0026gt; VM instances è¿›å…¥è™šæ‹Ÿæœºé¡µé¢ã€‚ç‚¹å‡»Createåˆ›å»ºä¸€ä¸ªæ–°çš„è™šæ‹Ÿæœºå®ä¾‹ï¼ˆVM instanceï¼‰\n)\næ ¹æ®éœ€æ±‚å¡«å†™å’Œé€‰æ‹© Name, Region, Zone, Machine Typeå’ŒBoot Diskã€‚åœ¨\u0008 Firewall é€‰é¡¹ä¸­é€‰ä¸­ Allow HTTP traffic å’Œ Allow HTTPS traffic, åœ¨ä¸‹æ–¹çš„ Disks é€‰é¡¹å¡ä¸­å–æ¶ˆå‹¾é€‰ Delete boot disk when instance is deletedã€‚æœ€åç‚¹å‡»\u0008 Createï¼Œè™šæ‹Ÿæœºå®ä¾‹å°±åˆ›å»ºå¥½äº†ã€‚","title":"åœ¨Google Cloud Platformä¸Šè¿è¡ŒJupyter Notebook"},{"content":"ç®€ä»‹ Scrapyå®˜æ–¹æ–‡æ¡£å¯¹Scrapyçš„ä»‹ç»å¦‚ä¸‹ï¼š\nScrapyæ˜¯ä¸€ä¸ªä¸ºäº†çˆ¬å–ç½‘ç«™æ•°æ®ï¼Œæå–ç»“æ„æ€§æ•°æ®è€Œç¼–å†™çš„åº”ç”¨æ¡†æ¶ã€‚å¯ä»¥åº”ç”¨åœ¨åŒ…æ‹¬æ•°æ®æŒ–æ˜ï¼Œä¿¡æ¯å¤„ç†æˆ–å­˜å‚¨å†å²æ•°æ®ç­‰ä¸€ç³»åˆ—çš„ç¨‹åºä¸­ã€‚å…¶æœ€åˆæ˜¯ä¸ºäº†é¡µé¢æŠ“å–ï¼ˆæ›´ç¡®åˆ‡æ¥è¯´, ç½‘ç»œæŠ“å–ï¼‰æ‰€è®¾è®¡çš„ï¼Œä¹Ÿå¯ä»¥åº”ç”¨åœ¨è·å–APIæ‰€è¿”å›çš„æ•°æ®ï¼ˆä¾‹å¦‚ Amazon Associates Web Services ï¼‰æˆ–è€…é€šç”¨çš„ç½‘ç»œçˆ¬è™«ã€‚\nç®€è€Œè¨€ä¹‹ï¼ŒScrapyæ˜¯åŸºäºTwistedåº“å¼€å‘çš„ï¼Œå°è£…äº†httpè¯·æ±‚ã€ä»£ç†ä¿¡æ¯ã€æ•°æ®å­˜å‚¨ç­‰åŠŸèƒ½çš„Pythonçˆ¬è™«æ¡†æ¶ã€‚\nç»„ä»¶å’Œæ•°æ®æµ ä¸‹å›¾æ˜¯Scrapyå®˜æ–¹æ–‡æ¡£ä¸­çš„æ¶æ„æ¦‚è§ˆå›¾ï¼š\nå›¾ä¸­ç»¿è‰²ç®­å¤´è¡¨ç¤ºæ•°æ®æµï¼Œå…¶ä»–å‡ä¸ºç»„ä»¶ã€‚\nScrapy Engineï¼ˆå¼•æ“ï¼‰ å¼•æ“è´Ÿè´£æ§åˆ¶æ•°æ®æµåœ¨ç³»ç»Ÿçš„ç»„ä»¶ä¸­æµåŠ¨ï¼Œå¹¶åœ¨ç›¸åº”åŠ¨ä½œå‘ç”Ÿæ—¶è§¦å‘äº‹ä»¶ã€‚\u0008\nSchedulerï¼ˆè°ƒåº¦å™¨ï¼‰ è°ƒåº¦å™¨ä»å¼•æ“æ¥æ”¶requestå¹¶å°†å…¶ä¿å­˜ï¼Œä»¥ä¾¿åœ¨å¼•æ“è¯·æ±‚æ—¶æä¾›ç»™å¼•æ“ã€‚\nDownloaderï¼ˆä¸‹è½½å™¨ï¼‰ ä¸‹è½½å™¨è´Ÿè´£ä¸‹è½½é¡µé¢æ•°æ®ï¼Œå¹¶å°†å…¶æä¾›ç»™å¼•æ“ï¼Œè€Œåå†ç”±å¼•æ“æä¾›ç»™çˆ¬è™«ã€‚\nSpidersï¼ˆçˆ¬è™«ï¼‰ Spideræ˜¯ç”±ç”¨æˆ·ç¼–å†™çš„ç”¨äºåˆ†æresponseå¹¶æå–itemæˆ–é¢å¤–è·Ÿè¿›urlçš„ç±»ã€‚\u0008ä¸€ä¸ªScrapyé¡¹ç›®ä¸­å¯ä»¥æœ‰å¾ˆå¤šSpiderï¼Œä»–ä»¬åˆ†åˆ«è¢«ç”¨äºçˆ¬å–ä¸åŒçš„é¡µé¢å’Œç½‘ç«™ã€‚\nItem Pipelineï¼ˆç®¡é“ï¼‰ Item Pipelineè´Ÿè´£å¤„ç†è¢«çˆ¬è™«æå–å‡ºæ¥çš„itemã€‚\u0008å¯ä»¥å¯¹å…¶è¿›è¡Œæ•°æ®æ¸…æ´—ï¼ŒéªŒè¯å’ŒæŒä¹…åŒ–ï¼ˆä¾‹å¦‚å­˜å‚¨åˆ°æ•°æ®åº“ä¸­ï¼‰ã€‚\nDownloader middlewaresï¼ˆä¸‹è½½å™¨ä¸­é—´ä»¶ï¼‰ ä¸‹è½½å™¨ä¸­é—´ä»¶æ˜¯åœ¨å¼•æ“åŠä¸‹è½½å™¨ä¹‹é—´çš„ç»„ä»¶ï¼Œç”¨äºå¤„ç†ä¸‹è½½å™¨ä¼ é€’ç»™å¼•æ“çš„responseã€‚æ›´å¤šå†…å®¹è¯·å‚è€ƒä¸‹è½½å™¨ä¸­é—´ä»¶ã€‚\nSpider middlewaresï¼ˆçˆ¬è™«ä¸­é—´ä»¶ï¼‰ Spiderä¸­é—´ä»¶æ˜¯åœ¨å¼•æ“åŠSpiderä¹‹é—´çš„ç»„ä»¶ï¼Œç”¨äºå¤„ç†çˆ¬è™«çš„è¾“å…¥ï¼ˆresponseï¼‰å’Œè¾“å‡ºï¼ˆitemså’Œrequestsï¼‰ã€‚æ›´å¤šå†…å®¹è¯·å‚è€ƒçˆ¬è™«ä¸­é—´ä»¶ã€‚\nData flowï¼ˆæ•°æ®æµï¼‰ Scrapyä¸­çš„æ•°æ®æµç”±å¼•æ“æ§åˆ¶ï¼Œå…¶è¿‡ç¨‹å¦‚ä¸‹:1.å¼•æ“æ‰“å¼€ä¸€ä¸ªç½‘ç«™ï¼Œæ‰¾åˆ°å¤„ç†è¯¥ç½‘ç«™çš„çˆ¬è™«å¹¶å‘è¯¥çˆ¬è™«è¯·æ±‚è¦çˆ¬å–çš„urlã€‚2.å¼•æ“ä»çˆ¬è™«ä¸­è·å–åˆ°è¦çˆ¬å–çš„urlå¹¶å°†å…¶ä½œä¸ºrequestå‘é€ç»™è°ƒåº¦å™¨ã€‚3.å¼•æ“å‘è°ƒåº¦å™¨è¯·æ±‚ä¸‹ä¸€ä¸ªè¦çˆ¬å–çš„urlã€‚4.è°ƒåº¦å™¨è¿”å›ä¸‹ä¸€ä¸ªè¦çˆ¬å–çš„urlç»™å¼•æ“ï¼Œå¼•æ“å°†urlé€šè¿‡ä¸‹è½½å™¨ä¸­é—´ä»¶å‘é€ç»™ä¸‹è½½å™¨ã€‚5.ä¸‹è½½å™¨ä¸‹è½½é¡µé¢æˆåŠŸåï¼Œç”Ÿæˆä¸€ä¸ªè¯¥é¡µé¢çš„responseå¯¹è±¡ï¼Œå¹¶å°†å…¶é€šè¿‡ä¸‹è½½å™¨ä¸­é—´ä»¶å‘é€ç»™å¼•æ“ã€‚6.å¼•æ“æ¥æ”¶ä»ä¸‹è½½å™¨ä¸­é—´ä»¶å‘é€è¿‡æ¥çš„responseï¼Œå¹¶å°†å…¶é€šè¿‡çˆ¬è™«ä¸­é—´ä»¶å‘é€ç»™çˆ¬è™«å¤„ç†ã€‚7.çˆ¬è™«å¤„ç†responseï¼Œå¹¶å°†çˆ¬å–åˆ°çš„itemåŠè·Ÿè¿›çš„æ–°çš„requestå‘é€ç»™å¼•æ“ã€‚8.å¼•æ“å°†çˆ¬è™«è¿”å›çš„itemå‘é€ç»™ç®¡é“ï¼Œå°†çˆ¬è™«è¿”å›çš„æ–°çš„requestå‘é€ç»™è°ƒåº¦å™¨ã€‚9.ç®¡é“\u0008å¯¹itemè¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚10.é‡å¤ç¬¬äºŒæ­¥ï¼Œç›´åˆ°è°ƒåº¦å™¨ä¸­æ²¡æœ‰æ›´å¤šçš„requestï¼Œæ­¤æ—¶å¼•æ“å…³é—­è¯¥ç½‘ç«™ã€‚å®‰è£… 1.ä¸‹è½½\u0008å®‰è£…æœ€æ–°ç‰ˆçš„Python3\n\u00082.ä½¿ç”¨pipæŒ‡ä»¤å®‰è£…Scrapy\npip3 install scrapy\råˆ›å»ºé¡¹ç›® é¦–å…ˆè¿›å…¥ä½ çš„ä»£ç å­˜å‚¨ç›®å½•ï¼Œåœ¨å‘½ä»¤è¡Œä¸­è¾“å…¥ä»¥ä¸‹å‘½ä»¤ï¼š\nscrapy startproject LeetCode_Crawler\ræ³¨æ„é¡¹ç›®åç§°æ˜¯ä¸èƒ½åŒ…å«è¿å­—ç¬¦ \u0026lsquo;-\u0026rsquo; çš„\næ–°å»ºæˆåŠŸåï¼Œå¯ä»¥çœ‹åˆ°åœ¨å½“å‰ç›®å½•ä¸‹æ–°å»ºäº†ä¸€ä¸ªåä¸ºLeetCode_Crawlerçš„Scrapyé¡¹ç›®ï¼Œè¿›å…¥è¯¥ç›®å½•ï¼Œå…¶é¡¹ç›®ç»“æ„å¦‚ä¸‹ï¼š\nscrapy.cfg #\u0008è¯¥é¡¹ç›®çš„é…ç½®æ–‡ä»¶\rscrapy_project #è¯¥é¡¹ç›®çš„Pythonæ¨¡å—\r__init__.py\ritems.py #å¯è‡ªå®šä¹‰çš„itemç±»æ–‡ä»¶\rmiddlewares.py #ä¸­é—´ä»¶æ–‡ä»¶\rpipelines.py #ç®¡é“æ–‡ä»¶\rsettings.py #è®¾ç½®æ–‡ä»¶\r__pycache__\rspiders #çˆ¬è™«æ–‡ä»¶å¤¹ï¼Œæ‰€æœ‰çˆ¬è™«æ–‡ä»¶éƒ½åº”åœ¨è¯¥æ–‡ä»¶å¤¹ä¸‹\r__init__.py\r__pycache__\rè‡³æ­¤Scrapyé¡¹ç›®çš„åˆ›å»ºå°±å®Œæˆäº†ã€‚\nå‚è€ƒèµ„æ–™ Scrapyå®˜æ–¹æ–‡æ¡£","permalink":"http://zintrulcre.github.io/posts/leetcode-archiver/leetcode-archiver1/","summary":"ç®€ä»‹ Scrapyå®˜æ–¹æ–‡æ¡£å¯¹Scrapyçš„ä»‹ç»å¦‚ä¸‹ï¼š\nScrapyæ˜¯ä¸€ä¸ªä¸ºäº†çˆ¬å–ç½‘ç«™æ•°æ®ï¼Œæå–ç»“æ„æ€§æ•°æ®è€Œç¼–å†™çš„åº”ç”¨æ¡†æ¶ã€‚å¯ä»¥åº”ç”¨åœ¨åŒ…æ‹¬æ•°æ®æŒ–æ˜ï¼Œä¿¡æ¯å¤„ç†æˆ–å­˜å‚¨å†å²æ•°æ®ç­‰ä¸€ç³»åˆ—çš„ç¨‹åºä¸­ã€‚å…¶æœ€åˆæ˜¯ä¸ºäº†é¡µé¢æŠ“å–ï¼ˆæ›´ç¡®åˆ‡æ¥è¯´, ç½‘ç»œæŠ“å–ï¼‰æ‰€è®¾è®¡çš„ï¼Œä¹Ÿå¯ä»¥åº”ç”¨åœ¨è·å–APIæ‰€è¿”å›çš„æ•°æ®ï¼ˆä¾‹å¦‚ Amazon Associates Web Services ï¼‰æˆ–è€…é€šç”¨çš„ç½‘ç»œçˆ¬è™«ã€‚\nç®€è€Œè¨€ä¹‹ï¼ŒScrapyæ˜¯åŸºäºTwistedåº“å¼€å‘çš„ï¼Œå°è£…äº†httpè¯·æ±‚ã€ä»£ç†ä¿¡æ¯ã€æ•°æ®å­˜å‚¨ç­‰åŠŸèƒ½çš„Pythonçˆ¬è™«æ¡†æ¶ã€‚\nç»„ä»¶å’Œæ•°æ®æµ ä¸‹å›¾æ˜¯Scrapyå®˜æ–¹æ–‡æ¡£ä¸­çš„æ¶æ„æ¦‚è§ˆå›¾ï¼š\nå›¾ä¸­ç»¿è‰²ç®­å¤´è¡¨ç¤ºæ•°æ®æµï¼Œå…¶ä»–å‡ä¸ºç»„ä»¶ã€‚\nScrapy Engineï¼ˆå¼•æ“ï¼‰ å¼•æ“è´Ÿè´£æ§åˆ¶æ•°æ®æµåœ¨ç³»ç»Ÿçš„ç»„ä»¶ä¸­æµåŠ¨ï¼Œå¹¶åœ¨ç›¸åº”åŠ¨ä½œå‘ç”Ÿæ—¶è§¦å‘äº‹ä»¶ã€‚\u0008\nSchedulerï¼ˆè°ƒåº¦å™¨ï¼‰ è°ƒåº¦å™¨ä»å¼•æ“æ¥æ”¶requestå¹¶å°†å…¶ä¿å­˜ï¼Œä»¥ä¾¿åœ¨å¼•æ“è¯·æ±‚æ—¶æä¾›ç»™å¼•æ“ã€‚\nDownloaderï¼ˆä¸‹è½½å™¨ï¼‰ ä¸‹è½½å™¨è´Ÿè´£ä¸‹è½½é¡µé¢æ•°æ®ï¼Œå¹¶å°†å…¶æä¾›ç»™å¼•æ“ï¼Œè€Œåå†ç”±å¼•æ“æä¾›ç»™çˆ¬è™«ã€‚\nSpidersï¼ˆçˆ¬è™«ï¼‰ Spideræ˜¯ç”±ç”¨æˆ·ç¼–å†™çš„ç”¨äºåˆ†æresponseå¹¶æå–itemæˆ–é¢å¤–è·Ÿè¿›urlçš„ç±»ã€‚\u0008ä¸€ä¸ªScrapyé¡¹ç›®ä¸­å¯ä»¥æœ‰å¾ˆå¤šSpiderï¼Œä»–ä»¬åˆ†åˆ«è¢«ç”¨äºçˆ¬å–ä¸åŒçš„é¡µé¢å’Œç½‘ç«™ã€‚\nItem Pipelineï¼ˆç®¡é“ï¼‰ Item Pipelineè´Ÿè´£å¤„ç†è¢«çˆ¬è™«æå–å‡ºæ¥çš„itemã€‚\u0008å¯ä»¥å¯¹å…¶è¿›è¡Œæ•°æ®æ¸…æ´—ï¼ŒéªŒè¯å’ŒæŒä¹…åŒ–ï¼ˆä¾‹å¦‚å­˜å‚¨åˆ°æ•°æ®åº“ä¸­ï¼‰ã€‚\nDownloader middlewaresï¼ˆä¸‹è½½å™¨ä¸­é—´ä»¶ï¼‰ ä¸‹è½½å™¨ä¸­é—´ä»¶æ˜¯åœ¨å¼•æ“åŠä¸‹è½½å™¨ä¹‹é—´çš„ç»„ä»¶ï¼Œç”¨äºå¤„ç†ä¸‹è½½å™¨ä¼ é€’ç»™å¼•æ“çš„responseã€‚æ›´å¤šå†…å®¹è¯·å‚è€ƒä¸‹è½½å™¨ä¸­é—´ä»¶ã€‚\nSpider middlewaresï¼ˆçˆ¬è™«ä¸­é—´ä»¶ï¼‰ Spiderä¸­é—´ä»¶æ˜¯åœ¨å¼•æ“åŠSpiderä¹‹é—´çš„ç»„ä»¶ï¼Œç”¨äºå¤„ç†çˆ¬è™«çš„è¾“å…¥ï¼ˆresponseï¼‰å’Œè¾“å‡ºï¼ˆitemså’Œrequestsï¼‰ã€‚æ›´å¤šå†…å®¹è¯·å‚è€ƒçˆ¬è™«ä¸­é—´ä»¶ã€‚\nData flowï¼ˆæ•°æ®æµï¼‰ Scrapyä¸­çš„æ•°æ®æµç”±å¼•æ“æ§åˆ¶ï¼Œå…¶è¿‡ç¨‹å¦‚ä¸‹:1.å¼•æ“æ‰“å¼€ä¸€ä¸ªç½‘ç«™ï¼Œæ‰¾åˆ°å¤„ç†è¯¥ç½‘ç«™çš„çˆ¬è™«å¹¶å‘è¯¥çˆ¬è™«è¯·æ±‚è¦çˆ¬å–çš„urlã€‚2.å¼•æ“ä»çˆ¬è™«ä¸­è·å–åˆ°è¦çˆ¬å–çš„urlå¹¶å°†å…¶ä½œä¸ºrequestå‘é€ç»™è°ƒåº¦å™¨ã€‚3.å¼•æ“å‘è°ƒåº¦å™¨è¯·æ±‚ä¸‹ä¸€ä¸ªè¦çˆ¬å–çš„urlã€‚4.è°ƒåº¦å™¨è¿”å›ä¸‹ä¸€ä¸ªè¦çˆ¬å–çš„urlç»™å¼•æ“ï¼Œå¼•æ“å°†urlé€šè¿‡ä¸‹è½½å™¨ä¸­é—´ä»¶å‘é€ç»™ä¸‹è½½å™¨ã€‚5.ä¸‹è½½å™¨ä¸‹è½½é¡µé¢æˆåŠŸåï¼Œç”Ÿæˆä¸€ä¸ªè¯¥é¡µé¢çš„responseå¯¹è±¡ï¼Œå¹¶å°†å…¶é€šè¿‡ä¸‹è½½å™¨ä¸­é—´ä»¶å‘é€ç»™å¼•æ“ã€‚6.å¼•æ“æ¥æ”¶ä»ä¸‹è½½å™¨ä¸­é—´ä»¶å‘é€è¿‡æ¥çš„responseï¼Œå¹¶å°†å…¶é€šè¿‡çˆ¬è™«ä¸­é—´ä»¶å‘é€ç»™çˆ¬è™«å¤„ç†ã€‚7.çˆ¬è™«å¤„ç†responseï¼Œå¹¶å°†çˆ¬å–åˆ°çš„itemåŠè·Ÿè¿›çš„æ–°çš„requestå‘é€ç»™å¼•æ“ã€‚8.å¼•æ“å°†çˆ¬è™«è¿”å›çš„itemå‘é€ç»™ç®¡é“ï¼Œå°†çˆ¬è™«è¿”å›çš„æ–°çš„requestå‘é€ç»™è°ƒåº¦å™¨ã€‚9.ç®¡é“\u0008å¯¹itemè¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚10.é‡å¤ç¬¬äºŒæ­¥ï¼Œç›´åˆ°è°ƒåº¦å™¨ä¸­æ²¡æœ‰æ›´å¤šçš„requestï¼Œæ­¤æ—¶å¼•æ“å…³é—­è¯¥ç½‘ç«™ã€‚å®‰è£… 1.ä¸‹è½½\u0008å®‰è£…æœ€æ–°ç‰ˆçš„Python3\n\u00082.ä½¿ç”¨pipæŒ‡ä»¤å®‰è£…Scrapy\npip3 install scrapy\råˆ›å»ºé¡¹ç›® é¦–å…ˆè¿›å…¥ä½ çš„ä»£ç å­˜å‚¨ç›®å½•ï¼Œåœ¨å‘½ä»¤è¡Œä¸­è¾“å…¥ä»¥ä¸‹å‘½ä»¤ï¼š\nscrapy startproject LeetCode_Crawler\ræ³¨æ„é¡¹ç›®åç§°æ˜¯ä¸èƒ½åŒ…å«è¿å­—ç¬¦ \u0026lsquo;-\u0026rsquo; çš„\næ–°å»ºæˆåŠŸåï¼Œå¯ä»¥çœ‹åˆ°åœ¨å½“å‰ç›®å½•ä¸‹æ–°å»ºäº†ä¸€ä¸ªåä¸ºLeetCode_Crawlerçš„Scrapyé¡¹ç›®ï¼Œè¿›å…¥è¯¥ç›®å½•ï¼Œå…¶é¡¹ç›®ç»“æ„å¦‚ä¸‹ï¼š\nscrapy.cfg #\u0008è¯¥é¡¹ç›®çš„é…ç½®æ–‡ä»¶\rscrapy_project #è¯¥é¡¹ç›®çš„Pythonæ¨¡å—\r__init__.py\ritems.py #å¯è‡ªå®šä¹‰çš„itemç±»æ–‡ä»¶\rmiddlewares.py #ä¸­é—´ä»¶æ–‡ä»¶\rpipelines.py #ç®¡é“æ–‡ä»¶\rsettings.py #è®¾ç½®æ–‡ä»¶\r__pycache__\rspiders #çˆ¬è™«æ–‡ä»¶å¤¹ï¼Œæ‰€æœ‰çˆ¬è™«æ–‡ä»¶éƒ½åº”åœ¨è¯¥æ–‡ä»¶å¤¹ä¸‹\r__init__.py\r__pycache__\rè‡³æ­¤Scrapyé¡¹ç›®çš„åˆ›å»ºå°±å®Œæˆäº†ã€‚\nå‚è€ƒèµ„æ–™ Scrapyå®˜æ–¹æ–‡æ¡£","title":"LeetCode Archiver(1)ï¼šScrapyæ¡†æ¶å’ŒRequestsåº“"},{"content":"C++ åŸºç¡€çŸ¥è¯† const ç›¸å…³   #defineï¼Œtypedefï¼Œconst\n # æ˜¯å®ï¼Œå®ä¸åšç±»å‹æ£€æŸ¥ï¼Œåªè¿›è¡Œç®€å•æ›¿æ¢ï¼›åœ¨ç¼–è¯‘å‰è¢«å¤„ç†ï¼Œç¼–è¯‘é˜¶æ®µçš„ç¨‹åºæ˜¯å®å¤„ç†åçš„ç»“æœ typedef ç”¨äºå£°æ˜è‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼Œç®€åŒ–ä»£ç  const ç”¨äºå®šä¹‰å¸¸é‡ï¼Œæœ‰æ•°æ®ç±»å‹ï¼Œç¼–è¯‘å™¨ä¼šå¯¹è¿›è¡Œç±»å‹æ£€æŸ¥    const å’ŒæŒ‡é’ˆ\n const char *p: p is a pointer to const char char const *p: p is a pointer to char constï¼ˆåŒä¸Šï¼‰ char *const p: p is a const pointer to char  int main() { const char *p1 = new char(\u0026#39;a\u0026#39;); char const *p2 = new char(\u0026#39;b\u0026#39;); char *const p3 = new char(\u0026#39;c\u0026#39;); *p1 = \u0026#39;d\u0026#39;; // error: read-only variable is notassignable *p2 = \u0026#39;e\u0026#39;; // error: read-only variable is notassignable p3 = new char(\u0026#39;f\u0026#39;); // error: cannot assign tovariable \u0026#39;p3\u0026#39; with const-qualified type \u0026#39;char *const\u0026#39; p3 = nullptr; // error: cannot assign to variable\u0026#39;p3\u0026#39; with const-qualified type \u0026#39;char *const\u0026#39; }   const å’Œç±»\n const ä¿®é¥°ç±»çš„æˆå‘˜å‡½æ•°æ—¶ï¼Œè¯¥æˆå‘˜å‡½æ•°ä¸èƒ½ä¿®æ”¹ç±»çš„æˆå‘˜å˜é‡ï¼Œä¸èƒ½è°ƒç”¨ç±»çš„é const æˆå‘˜å‡½æ•° const ä¿®é¥°å‡½æ•°å‚æ•°æ—¶ï¼Œåœ¨å‡½æ•°å†…éƒ¨ä¸èƒ½ä¿®æ”¹å‚æ•°çš„å€¼ const ä¿®é¥°å‡½æ•°è¿”å›å€¼æ—¶ï¼Œæ¥æ”¶è¿”å›å€¼çš„å˜é‡ä¹Ÿè¦ç”¨ const ä¿®é¥°  class Base { public: int i = 1; const int *Func(const int \u0026amp;j) const { const int *k = new int(1); i = 1; // error: cannot assign to non-static data member within const member function \u0026#39;Func\u0026#39;  j = 1; // error: cannot assign to variable \u0026#39;j\u0026#39; with const-qualified type \u0026#39;const int \u0026amp;\u0026#39;  return k; } void Test() { i = 2; } }; int main() { Base obj; int j = 1; int *k = obj.Func(j); // error: cannot initialize a variable of type \u0026#39;int *\u0026#39; with an rvalue of type \u0026#39;const int *\u0026#39;  return 0; }   static ç›¸å…³ 1. é¢å‘è¿‡ç¨‹  ä¿®é¥°å…¨å±€å˜é‡æ—¶ï¼Œè¯¥é™æ€å…¨å±€å˜é‡çš„ä½œç”¨åŸŸåªåœ¨å½“å‰æºæ–‡ä»¶  å…¨å±€å˜é‡çš„æ„é€ åœ¨ main å‡½æ•°ä¹‹å‰æ‰§è¡Œ   ä¿®é¥°å…¨å±€å‡½æ•°æ—¶ï¼Œè¯¥é™æ€å…¨å±€å‡½æ•°çš„ä½œç”¨åŸŸåªåœ¨å½“å‰æºæ–‡ä»¶ ä¿®é¥°å±€éƒ¨å˜é‡æ—¶ï¼Œè¯¥é™æ€å±€éƒ¨å˜é‡çš„ä½œç”¨åŸŸåªåœ¨å½“å‰å‡½æ•°ä¸­ï¼›è¯¥å˜é‡åªåœ¨ç¬¬ä¸€æ¬¡æ‰§è¡Œåˆ°å£°æ˜æ—¶è¢«åˆå§‹åŒ–ï¼Œå…¶å†…å­˜è¢«åˆ†é…åœ¨å…¨å±€æ•°æ®åŒºï¼Œå½“ç¨‹åºç»“æŸæ—¶æ‰è¢«å›æ”¶  2. é¢å‘å¯¹è±¡  ä¿®é¥°ç±»çš„æˆå‘˜å˜é‡æ—¶ï¼Œè¯¥é™æ€æˆå‘˜å˜é‡ä½œç”¨äºç±»çš„æ‰€æœ‰å®ä¾‹å¯¹è±¡ï¼Œå…¶å†…å­˜è¢«åˆ†é…åœ¨å…¨å±€æ•°æ®åŒºï¼›è¯¥å˜é‡å¯ä»¥ç›´æ¥é€šè¿‡ç±»åè°ƒç”¨ ä¿®é¥°ç±»çš„æˆå‘˜å‡½æ•°æ—¶ï¼Œè¯¥é™æ€æˆå‘˜å‡½æ•°ä¸èƒ½æ“ä½œç±»ä¸­çš„å…¶ä»–éé™æ€æˆå‘˜å‡½æ•°ï¼›è¯¥å‡½æ•°å¯ä»¥ç›´æ¥é€šè¿‡ç±»åè°ƒç”¨  3. ç±»å‹è½¬æ¢   static_cast\n ä¸æ‰§ç±»å‹æ£€æŸ¥ï¼›æ¥è¿‘äº C çš„å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œé€šå¸¸ç”¨äºæ•°å€¼æ•°æ®ç±»å‹çš„è½¬æ¢ï¼Œä¾‹å¦‚æŠŠ int è½¬æ¢æˆ charï¼Œæˆ–æŠŠ void* è½¬æ¢æˆå…¶ä»–ç±»å‹çš„æŒ‡é’ˆï¼ˆä¸å®‰å…¨ï¼‰ ï¼ŒåŸºæœ¬æ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œå¦‚æŠŠ int è½¬æ¢æˆ char å¯ä»¥åœ¨æ•´ä¸ªç±»å±‚æ¬¡ç»“æ„ä¸­ç§»åŠ¨æŒ‡é’ˆï¼Œå­ç±»è½¬åŒ–ä¸ºçˆ¶ç±»å®‰å…¨ï¼ˆå‘ä¸Šè½¬æ¢ï¼‰ï¼Œçˆ¶ç±»è½¬åŒ–ä¸ºå­ç±»ä¸å®‰å…¨ï¼ˆå› ä¸ºå­ç±»å¯èƒ½æœ‰ä¸åœ¨çˆ¶ç±»çš„å­—æ®µæˆ–æ–¹æ³•ï¼‰    dynamic_cast\n è¿è¡Œæ—¶æ‰§è¡Œç±»å‹æ£€æŸ¥ åªé€‚ç”¨äºæŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œå¯¹ä¸æ˜ç¡®çš„æŒ‡é’ˆçš„è½¬æ¢å°†å¤±è´¥ï¼ˆè¿”å› nullptrï¼‰ï¼Œä½†ä¸å¼•å‘å¼‚å¸¸ å¦‚æœå¼ºåˆ¶è½¬æ¢ä¸ºå¼•ç”¨ç±»å‹å¤±è´¥ï¼Œdynamic_cast è¿ç®—ç¬¦ä¼šå¼•å‘ bad_cast å¼‚å¸¸ ç”¨äºå¤šæ€ç±»å‹çš„è½¬æ¢ï¼Œå¯ä»¥åœ¨æ•´ä¸ªç±»å±‚æ¬¡ç»“æ„ä¸­ç§»åŠ¨æŒ‡é’ˆï¼ŒåŒ…æ‹¬å‘ä¸Šè½¬æ¢ã€å‘ä¸‹è½¬æ¢    const_cast\n ç”¨äºåˆ é™¤ constï¼Œvolatileï¼Œ__unaligned ç‰¹æ€§ï¼Œæ¯”å¦‚å°† const int ç±»å‹è½¬æ¢ä¸º int ç±»å‹    reinterpret_cast\n ç”¨äºä½çš„ç®€å•é‡æ–°è§£é‡Š å…è®¸å°†ä»»ä½•æŒ‡é’ˆè½¬æ¢ä¸ºä»»ä½•å…¶ä»–æŒ‡é’ˆç±»å‹ï¼Œæ¯”å¦‚ char* åˆ° int* å…è®¸å°†ä»»ä½•æ•´æ•°ç±»å‹è½¬æ¢ä¸ºä»»ä½•æŒ‡é’ˆç±»å‹ä»¥åŠåå‘è½¬æ¢ ä¸€ä¸ªå®é™…ç”¨é€”æ˜¯åœ¨å“ˆå¸Œå‡½æ•°ä¸­ï¼Œé€šè¿‡è®©ä¸¤ä¸ªä¸åŒçš„å€¼å‡ ä¹ä¸ä»¥ç›¸åŒçš„ç´¢å¼•ç»“å°¾çš„æ–¹å¼å°†å€¼æ˜ å°„åˆ°ç´¢å¼•    å†…å­˜åˆ†é…   æ ˆåŒº stack\n ç”±ç¼–è¯‘å™¨åˆ†é…å’Œé‡Šæ”¾ï¼Œå­˜å‚¨å‡½æ•°å‚æ•°ï¼Œå±€éƒ¨å˜é‡ç­‰ å½“ç³»ç»Ÿå‰©ä½™ç©ºé—´å°äºç”³è¯·ç©ºé—´æ—¶ï¼ŒæŠ›å‡ºå¼‚å¸¸æç¤ºæ ˆæº¢å‡º åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ï¼Œä½äºç”¨æˆ·è™šæ‹Ÿåœ°å€ç©ºé—´é¡¶éƒ¨çš„æ˜¯ç”¨æˆ·æ ˆï¼Œç¼–è¯‘å™¨ç”¨å®ƒæ¥å®ç°å‡½æ•°çš„è°ƒç”¨    å †åŒº heap\n ç”±ç¨‹åºåˆ†é…å’Œé‡Šæ”¾ï¼Œä¾‹å¦‚ä½¿ç”¨ malloc, new å †å‘é«˜åœ°å€æ‰©å±•ï¼Œæ˜¯ä¸è¿ç»­çš„å†…å­˜åŒºåŸŸï¼Œå¤§å°å¯ä»¥çµæ´»è°ƒæ•´ è‹¥ç¨‹åºä¸è¿›è¡Œé‡Šæ”¾ï¼Œåˆ™åœ¨ç¨‹åºç»“æŸæ—¶è¢«å›æ”¶ ç³»ç»Ÿç»´æŠ¤ä¸€ä¸ªè®°å½•ç©ºé—²å†…å­˜åœ°å€çš„é“¾è¡¨ï¼›ç”³è¯·å†…å­˜æ—¶ï¼Œç³»ç»Ÿéå†è¯¥é“¾è¡¨ï¼Œå¯»æ‰¾ç¬¬ä¸€ä¸ªç©ºé—´å¤§äºæ‰€ç”³è¯·å†…å­˜çš„å †ç»“ç‚¹ï¼Œå°†è¯¥ç»“ç‚¹ä»é“¾è¡¨ä¸­åˆ é™¤ï¼Œå¹¶åˆ†é…æ­¤èŠ‚ç‚¹çš„ç©ºé—´ï¼›è¿™å—å†…å­˜çš„é¦–åœ°å€ä¼šè®°å½•æœ¬æ¬¡åˆ†é…çš„å¤§å°ï¼Œæ‰§è¡Œ delete è¯­å¥çš„æ—¶å€™æ ¹æ®è®°å½•é‡Šæ”¾å†…å­˜ç©ºé—´ï¼›å› ä¸ºå †ç»“ç‚¹ç©ºé—´ä¸€èˆ¬ä¼šå¤§äºç”³è¯·çš„ç©ºé—´ï¼Œç³»ç»Ÿä¼šå°†å¤šä½™çš„ç©ºé—´æ”¾å…¥ç©ºé—²çš„é“¾è¡¨ä¸­    è‡ªç”±å­˜å‚¨åŒºï¼Œå­˜å‚¨ç”± malloc ç­‰åˆ†é…çš„å†…å­˜ï¼Œç”¨ free æ¥å›æ”¶\n  å…¨å±€/é™æ€å­˜å‚¨åŒºï¼Œå­˜å‚¨å…¨å±€å˜é‡å’Œé™æ€å˜é‡\n åœ¨ C è¯­è¨€ä¸­ï¼Œå…¨å±€å˜é‡åˆ†ä¸ºåˆå§‹åŒ–çš„å’Œæœªåˆå§‹åŒ–çš„ï¼Œæœªè¢«åˆå§‹åŒ–çš„å¯¹è±¡å­˜å‚¨åŒºå¯ä»¥é€šè¿‡ void* æ¥è®¿é—® åœ¨ C++ ä¸­å®ƒä»¬å…±åŒå ç”¨åŒä¸€å—å†…å­˜åŒºåŸŸ    å¸¸é‡å­˜å‚¨åŒºï¼Œå­˜å‚¨å¸¸é‡\n  new åˆ†é…å¤±è´¥\n int* p = new (std::nothrow) int(1); è¿”å›ç©ºæŒ‡é’ˆ ç”¨ try {} catch (const bad_alloc \u0026amp;b) {} æ•æ‰å¼‚å¸¸    å†…å­˜åˆ†é…æ–¹å¼  mallocï¼šç”³è¯·æŒ‡å®šå­—èŠ‚æ•°çš„å†…å­˜ã€‚ç”³è¯·åˆ°çš„å†…å­˜ä¸­çš„åˆå§‹å€¼ä¸ç¡®å®š callocï¼šä¸ºæŒ‡å®šé•¿åº¦çš„å¯¹è±¡ï¼Œåˆ†é…èƒ½å®¹çº³å…¶æŒ‡å®šä¸ªæ•°çš„å†…å­˜ã€‚ç”³è¯·åˆ°çš„å†…å­˜çš„æ¯ä¸€ä½ï¼ˆbitï¼‰éƒ½åˆå§‹åŒ–ä¸º 0 reallocï¼šæ›´æ”¹ä»¥å‰åˆ†é…çš„å†…å­˜é•¿åº¦ï¼ˆå¢åŠ æˆ–å‡å°‘ï¼‰ã€‚å½“å¢åŠ é•¿åº¦æ—¶ï¼Œå¯èƒ½éœ€å°†ä»¥å‰åˆ†é…åŒºçš„å†…å®¹ç§»åˆ°å¦ä¸€ä¸ªè¶³å¤Ÿå¤§çš„åŒºåŸŸï¼Œè€Œæ–°å¢åŒºåŸŸå†…çš„åˆå§‹å€¼åˆ™ä¸ç¡®å®šã€‚ allocaï¼šåœ¨æ ˆä¸Šç”³è¯·å†…å­˜ã€‚ç¨‹åºåœ¨å‡ºæ ˆçš„æ—¶å€™ï¼Œä¼šè‡ªåŠ¨é‡Šæ”¾å†…å­˜ï¼›alloca ä¸å…·å¯ç§»æ¤æ€§, è€Œä¸”åœ¨æ²¡æœ‰ä¼ ç»Ÿå †æ ˆçš„æœºå™¨ä¸Šå¾ˆéš¾å®ç°ã€‚alloca ä¸å®œä½¿ç”¨åœ¨å¿…é¡»å¹¿æ³›ç§»æ¤çš„ç¨‹åºä¸­ã€‚  æŒ‡é’ˆå’Œå¼•ç”¨   void *\n void * æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå®ƒæŒ‡å‘äº†å†…å­˜é‡Œçš„æŸä¸ªåŒºåŸŸï¼Œä½†æ˜¯å®ƒæ‰€æŒ‡å‘çš„å†…å­˜åŒºåŸŸæ²¡æœ‰ä»»ä½•ç±»å‹ä¿¡æ¯æˆ–è¾…åŠ©ä¿¡æ¯ï¼Œæ‰€ä»¥å®ƒå¯ä»¥éšæ„åœ°è§£è¯»å…¶æŒ‡å‘çš„å†…å­˜åŒºåŸŸå†…çš„æ•°æ®ï¼Œå®ƒå¯ä»¥æŒ‰ int ç±»å‹æ¥è§£è¯»ï¼Œä¹Ÿå¯ä»¥æŒ‰ç…§ double ç±»å‹æ¥è§£è¯»ï¼›åœ¨ä½¿ç”¨å‰éœ€è¦å‘ŠçŸ¥ç³»ç»Ÿä»å…¶æŒ‡å‘çš„å†…å­˜åŒºåŸŸå–å‡ºå¤šå°‘ä¸ªå­—èŠ‚ ä¸èƒ½å¯¹void * è¿›è¡Œè§£å¼•ç”¨æ“ä½œ    åŒºåˆ†æŒ‡é’ˆç±»å‹\n int *p[10]  int *p[10] è¡¨ç¤ºæŒ‡é’ˆæ•°ç»„ï¼Œå¼ºè°ƒæ•°ç»„æ¦‚å¿µï¼Œæ˜¯ä¸€ä¸ªæ•°ç»„å˜é‡ï¼Œæ•°ç»„å¤§å°ä¸º 10ï¼Œæ•°ç»„å†…æ¯ä¸ªå…ƒç´ éƒ½æ˜¯æŒ‡å‘ int ç±»å‹çš„æŒ‡é’ˆå˜é‡   int (*p)[10]  int (*p)[10] è¡¨ç¤ºæ•°ç»„æŒ‡é’ˆï¼Œå¼ºè°ƒæ˜¯æŒ‡é’ˆï¼Œåªæœ‰ä¸€ä¸ªå˜é‡ï¼Œæ˜¯æŒ‡é’ˆç±»å‹ï¼Œä¸è¿‡æŒ‡å‘çš„æ˜¯ä¸€ä¸ª int ç±»å‹çš„æ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„å¤§å°æ˜¯ 10   int *p(int)  int *p(int) æ˜¯å‡½æ•°å£°æ˜ï¼Œå‡½æ•°åæ˜¯ pï¼Œå‚æ•°æ˜¯ int ç±»å‹çš„ï¼Œè¿”å›å€¼æ˜¯ int * ç±»å‹çš„   int (*p)(int)  int (*p)(int) æ˜¯å‡½æ•°æŒ‡é’ˆï¼Œå¼ºè°ƒæ˜¯æŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘çš„å‡½æ•°å…·æœ‰ int ç±»å‹å‚æ•°ï¼Œå¹¶ä¸”è¿”å›å€¼æ˜¯ int ç±»å‹çš„      æ•°ç»„å’ŒæŒ‡é’ˆ\nint a[10];\rint (*p)[10] = \u0026amp;a;\r aæ˜¯æ•°ç»„åï¼Œä¹Ÿæ˜¯æ•°ç»„é¦–å…ƒç´ çš„åœ°å€ï¼Œ+1 è¡¨ç¤ºåœ°å€å€¼åŠ ä¸Šä¸€ä¸ªintç±»å‹çš„å¤§å°ï¼Œå¦‚æœ a çš„å€¼æ˜¯ 0x00000001ï¼ŒåŠ  1 æ“ä½œåå˜ä¸º 0x00000005ï¼Œ*(a + 1) = a[1] \u0026amp;a æ˜¯æ•°ç»„çš„åœ°å€ï¼Œå…¶ç±»å‹ä¸ºint (*)[10]ï¼Œ+1 è¡¨ç¤ºæ•°ç»„é¦–åœ°å€åŠ ä¸Šæ•´ä¸ªæ•°ç»„çš„åç§»ï¼ˆ10ä¸ªintå‹å˜é‡ï¼‰ï¼Œå€¼ä¸ºæ•°ç»„aå°¾å…ƒç´ åä¸€ä¸ªå…ƒç´ çš„åœ°å€ è‹¥ (int *)p ï¼Œæ­¤æ—¶è¾“å‡º *p æ—¶ï¼Œå…¶å€¼ä¸º a[0] çš„å€¼ï¼Œå› ä¸ºè¢«è½¬ä¸ºint * ç±»å‹ï¼Œè§£å¼•ç”¨æ—¶æŒ‰ç…§intç±»å‹å¤§å°æ¥è¯»å–    æ•°ç»„åå’ŒæŒ‡å‘æ•°ç»„é¦–å…ƒç´ çš„æŒ‡é’ˆçš„åŒºåˆ«\n å‡å¯é€šè¿‡å¢å‡åç§»é‡æ¥è®¿é—®æ•°ç»„ä¸­çš„å…ƒç´  æ•°ç»„åä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„æŒ‡é’ˆï¼Œå¯ä»¥ç†è§£ä¸ºå¸¸æŒ‡é’ˆï¼Œæ‰€ä»¥æ•°ç»„åæ²¡æœ‰è‡ªå¢ã€è‡ªå‡ç­‰æ“ä½œ å½“æ•°ç»„åå½“åšå½¢å‚ä¼ é€’ç»™è°ƒç”¨å‡½æ•°åï¼Œå°±å¤±å»äº†åŸæœ‰ç‰¹æ€§ï¼Œé€€åŒ–æˆä¸€èˆ¬æŒ‡é’ˆï¼Œå¤šäº†è‡ªå¢ã€è‡ªå‡æ“ä½œï¼Œä½†sizeofè¿ç®—ç¬¦ä¸èƒ½å†å¾—åˆ°åŸæ•°ç»„çš„å¤§å°äº†    é‡æŒ‡é’ˆ\n ç©ºæ‚¬æŒ‡é’ˆï¼Œæ˜¯æŒ‡å‘åƒåœ¾å†…å­˜çš„æŒ‡é’ˆ äº§ç”ŸåŸå›   æŒ‡é’ˆå˜é‡æœªåˆå§‹åŒ– æŒ‡é’ˆ free æˆ– delete ä¹‹åæ²¡æœ‰ç½®ç©º      å¸¸å¼•ç”¨\n å¸¸å¼•ç”¨ç±»ä¼¼äºå¸¸é‡æŒ‡é’ˆï¼Œconst typename \u0026amp;refname = varname ä½¿ç”¨å¸¸å¼•ç”¨æ—¶ï¼ŒåŸå˜é‡çš„å€¼ä¸ä¼šè¢«å¸¸å¼•ç”¨æ‰€ä¿®æ”¹ å¸¸å¼•ç”¨é€šå¸¸ç”¨ä½œåªè¯»å˜é‡åˆ«åæˆ–æ˜¯å½¢å‚ä¼ é€’    æ™ºèƒ½æŒ‡é’ˆ unique_ptr  unique_ptr å®ç°ç‹¬å å¼æ‹¥æœ‰ï¼ˆexclusive ownershipï¼‰æˆ–ä¸¥æ ¼æ‹¥æœ‰ï¼ˆstrict ownershipï¼‰æ¦‚å¿µï¼Œä¿è¯åŒä¸€æ—¶é—´å†…åªæœ‰ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆå¯ä»¥æŒ‡å‘è¯¥å¯¹è±¡ ä¸€æ—¦æ‹¥æœ‰è€…è¢«é”€æ¯ï¼Œæˆ–æ‹¥æœ‰äº†å¦ä¸€ä¸ªå¯¹è±¡ï¼Œä¹‹å‰æ‹¥æœ‰çš„é‚£ä¸ªæŒ‡é’ˆå¯¹è±¡å°±ä¼šè¢«é”€æ¯ï¼Œç›¸åº”çš„èµ„æºä¼šè¢«é‡Šæ”¾ å¯ä»¥ç§»äº¤æ‹¥æœ‰æƒ ç”¨äºé¿å…å†…å­˜æ³„æ¼ï¼ˆresource leakï¼‰ï¼Œæ¯”å¦‚ new åå¿˜è®° delete  shared_ptr  shared_ptr å®ç°å…±äº«å¼æ‹¥æœ‰ï¼ˆshared ownershipï¼‰æ¦‚å¿µ å¤šä¸ªæ™ºèƒ½æŒ‡é’ˆæŒ‡å‘ç›¸åŒå¯¹è±¡ï¼Œè¯¥å¯¹è±¡å’Œå…¶ç›¸å…³èµ„æºä¼šåœ¨æœ€åä¸€ä¸ª reference è¢«é”€æ¯æ—¶è¢«é‡Šæ”¾ï¼›éœ€è¦ä½¿ç”¨ weak_ptrã€bad_weak_ptr å’Œ enable_shared_from_this ç­‰è¾…åŠ©ç±»æ¥å®ç° æ”¯æŒå®šåˆ¶å‹åˆ é™¤å™¨ï¼ˆcustom deleterï¼‰ å¯é˜²èŒƒ Cross-DLL é—®é¢˜ï¼ˆå¯¹è±¡åœ¨åŠ¨æ€é“¾æ¥åº“ DLL ä¸­è¢« new åˆ›å»ºï¼Œå´åœ¨å¦ä¸€ä¸ª DLL å†…è¢« delete é”€æ¯ï¼‰ï¼Œè‡ªåŠ¨è§£é™¤äº’æ–¥é”  weak_ptr  weak_ptr å…è®¸å…±äº«ä½†ä¸æ‹¥æœ‰æŸå¯¹è±¡ ä¸€æ—¦æœ€æœ«ä¸€ä¸ªæ‹¥æœ‰è¯¥å¯¹è±¡çš„æ™ºèƒ½æŒ‡é’ˆå¤±å»äº†æ‰€æœ‰æƒï¼Œä»»ä½• weak_ptr éƒ½ä¼šè‡ªåŠ¨æˆç©ºï¼ˆemptyï¼‰ å› æ­¤ï¼Œåœ¨ default å’Œ copy æ„é€ å‡½æ•°ä¹‹å¤–ï¼Œweak_ptr åªæä¾› æ¥å—ä¸€ä¸ª shared_ptr çš„æ„é€ å‡½æ•° å¯æ‰“ç ´ç¯çŠ¶å¼•ç”¨ï¼ˆcycles of referencesï¼Œä¸¤ä¸ªå…¶å®å·²ç»æ²¡æœ‰è¢«ä½¿ç”¨çš„å¯¹è±¡å½¼æ­¤äº’æŒ‡ï¼Œä½¿ä¹‹çœ‹ä¼¼è¿˜åœ¨ â€œè¢«ä½¿ç”¨â€ çš„çŠ¶æ€ï¼‰çš„é—®é¢˜  auto_ptr  ç¼ºä¹è¯­è¨€ç‰¹æ€§ï¼Œæ¯”å¦‚é’ˆå¯¹æ„é€ å’Œèµ‹å€¼çš„ std::move è¯­ä¹‰ auto_ptr ä¸ unique_ptr å¯¹æ¯”  auto_ptr å¯ä»¥èµ‹å€¼æ‹·è´ï¼Œå¤åˆ¶æ‹·è´åæ‰€æœ‰æƒè½¬ç§»ï¼›unqiue_ptr æ— æ‹·è´èµ‹å€¼è¯­ä¹‰ï¼Œä½†å®ç°äº†move è¯­ä¹‰ auto_ptr å¯¹è±¡ä¸èƒ½ç®¡ç†æ•°ç»„ï¼ˆææ„è°ƒç”¨ deleteï¼‰ï¼Œunique_ptr å¯ä»¥ç®¡ç†æ•°ç»„ï¼ˆææ„è°ƒç”¨ delete[] ï¼‰    Lambda è¡¨è¾¾å¼ 1. Lambda è¡¨è¾¾å¼çš„å½¢å¼ [capture list] (params list) mutable exception-\u0026gt; return type { function body }\n capture listï¼šæ•è·å¤–éƒ¨å˜é‡åˆ—è¡¨ params listï¼šå½¢å‚åˆ—è¡¨ mutableï¼šæŒ‡ç¤ºç¬¦ï¼Œç”¨æ¥æŒ‡æ˜æ˜¯å¦å¯ä»¥ä¿®æ”¹æ•è·çš„å˜é‡ exceptionï¼šå¼‚å¸¸è®¾å®š return typeï¼šè¿”å›ç±»å‹ function bodyï¼šå‡½æ•°ä½“ åªæœ‰æ•è·å¤–éƒ¨å˜é‡åˆ—è¡¨å’Œå‡½æ•°é¢˜æ˜¯å¿…é¡»æœ‰çš„  2. æ•è·å¤–éƒ¨å˜é‡åˆ—è¡¨  Lambda è¡¨è¾¾å¼å¯ä»¥ä½¿ç”¨å…¶å¯è§èŒƒå›´å†…çš„å¤–éƒ¨å˜é‡ï¼Œä½†å¿…é¡»æ˜ç¡®å£°æ˜å“ªäº›å¤–éƒ¨å˜é‡å¯ä»¥è¢«è¯¥ Lambda è¡¨è¾¾å¼ä½¿ç”¨ Lambda è¡¨è¾¾å¼é€šè¿‡åœ¨æœ€å‰é¢çš„æ–¹æ‹¬å· [] æ¥æŒ‡æ˜å…¶å†…éƒ¨å¯ä»¥è®¿é—®çš„å¤–éƒ¨å˜é‡ï¼Œè¿™ä¸€è¿‡ç¨‹ä¹Ÿç§°ä¸º Lambda è¡¨è¾¾å¼æ•è·äº†å¤–éƒ¨å˜é‡ï¼Œç±»ä¼¼äºå‚æ•°ä¼ é€’ å¤–éƒ¨å˜é‡çš„æ•è·æ–¹å¼æœ‰ä¸‰ç§  å€¼æ•è·  å€¼æ•è·å’Œå‚æ•°ä¼ é€’ä¸­çš„å€¼ä¼ é€’ç±»ä¼¼ï¼Œè¢«æ•è·çš„å˜é‡çš„å€¼åœ¨ Lambda è¡¨è¾¾å¼åˆ›å»ºæ—¶é€šè¿‡å€¼æ‹·è´çš„æ–¹å¼ä¼ å…¥ï¼Œåœ¨å‡½æ•°ä½“å†…å¯¹è¯¥å˜é‡çš„ä¿®æ”¹ä¸ä¼šå½±å“å¤–éƒ¨çš„å€¼   å¼•ç”¨æ•è·  ä½¿ç”¨ \u0026amp;a çš„æ–¹å¼ä¼ é€’å¼•ç”¨ï¼Œå€¼æ•è·å’Œå¼•ç”¨æ•è·éƒ½è¦æ˜¾å¼åœ°åˆ—å‡ºå¤–éƒ¨å˜é‡   éšå¼æ•è·  è®©ç¼–è¯‘å™¨æ ¹æ®å‡½æ•°ä½“ä¸­çš„ä»£ç æ¥æ¨æ–­éœ€è¦æ•è·å“ªäº›å˜é‡ï¼Œè¿™ç§æ–¹å¼ç§°ä¹‹ä¸ºéšå¼æ•è· éšå¼æ•è·æœ‰ä¸¤ç§æ–¹å¼ï¼Œåˆ†åˆ«æ˜¯ [=] å’Œ [\u0026amp;]ï¼›[=] è¡¨ç¤ºä»¥å€¼æ•è·çš„æ–¹å¼æ•è·å¤–éƒ¨å˜é‡ï¼Œ[\u0026amp;] è¡¨ç¤ºä»¥å¼•ç”¨æ•è·çš„æ–¹å¼æ•è·å¤–éƒ¨å˜é‡ã€‚     ä¿®æ”¹æ•è·å˜é‡  å¦‚æœä»¥ä¼ å€¼æ–¹å¼æ•è·å¤–éƒ¨å˜é‡ï¼Œåœ¨å‡½æ•°ä½“ä¸­å°†ä¸èƒ½ä¿®æ”¹è¯¥å¤–éƒ¨å˜é‡ï¼Œå¦åˆ™ä¼šå¼•å‘ç¼–è¯‘é”™è¯¯ ä½¿ç”¨ mutable å…³é”®å­—å¯ä»¥ä¿®æ”¹å€¼æ•è·çš„å˜é‡    3. å½¢å‚åˆ—è¡¨  Lambda è¡¨è¾¾å¼ä¸­ä¼ é€’å‚æ•°æ—¶æœ‰ä¸€äº›é™åˆ¶  å‚æ•°åˆ—è¡¨ä¸­ä¸èƒ½æœ‰é»˜è®¤å‚æ•° ä¸æ”¯æŒå¯å˜å‚æ•° æ‰€æœ‰å‚æ•°å¿…é¡»æœ‰å‚æ•°å    RTTI  Runtime Type Identification è¿è¡Œæ—¶ç±»å‹è¯†åˆ«  1. ç›®çš„  è®©ç¨‹åºåœ¨è¿è¡Œæ—¶æ ¹æ®åŸºç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨æ¥è·å¾—è¯¥æŒ‡é’ˆæˆ–å¼•ç”¨æ‰€æŒ‡çš„å¯¹è±¡çš„å®é™…ç±»å‹ é€šè¿‡ typeid æ“ä½œç¬¦è¯†åˆ«å‡ºæ‰€æœ‰çš„åŸºæœ¬ç±»å‹çš„å˜é‡å¯¹åº”çš„ç±»å‹  2. ä½¿ç”¨  typeid è¿ç®—ç¬¦ï¼Œè¯¥è¿ç®—ç¬¦è¿”å›å…¶è¡¨è¾¾å¼æˆ–ç±»å‹åçš„å®é™…ç±»å‹ dynamic_cast è¿ç®—ç¬¦ï¼Œè¯¥è¿ç®—ç¬¦å°†åŸºç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨å®‰å…¨åœ°è½¬æ¢ä¸ºæ´¾ç”Ÿç±»ç±»å‹çš„æŒ‡é’ˆæˆ–å¼•ç”¨  æ¨¡æ¿   å®ç°èŒƒå‹ç¼–ç¨‹ template \u0026lt;class type\u0026gt; ret-type func-name(parameter list) { }\n  æ¨¡æ¿ç±»ä¸­å¯ä»¥ä½¿ç”¨è™šå‡½æ•°\n  æ¨¡æ¿ç±»çš„æˆå‘˜å‡½æ•°ä¸èƒ½æ˜¯è™šå‡½æ•°\n  å…³é”®å­—   volatile\n ç”¨ volatile å…³é”®å­—å£°æ˜çš„å˜é‡å¯èƒ½ä¼šè¢«æŸäº›æœªçŸ¥çš„å› ç´ æ›´æ”¹ volatile å˜é‡åœ¨è¢«è®¿é—®æ—¶ï¼Œç¼–è¯‘å™¨éƒ½ä¼šä»å†…å­˜åœ°å€ä¸­å–å‡ºå®ƒçš„å€¼ï¼›é volatile ä¿®é¥°çš„å˜é‡ç”±äºç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œå¯ä»¥ç›´æ¥ä» CPU å¯„å­˜å™¨ä¸­å–å€¼ æ²¡æœ‰ç”¨ volatile å…³é”®å­—å£°æ˜çš„å˜é‡åœ¨è¢«è®¿é—®æ—¶ï¼Œç¼–è¯‘å™¨å¯èƒ½ç›´æ¥ä» CPU çš„å¯„å­˜å™¨ä¸­å–å€¼ï¼ˆå› ä¸ºå˜é‡ä¹‹å‰è¢«è®¿é—®è¿‡ï¼Œä¹‹å‰ä»å†…å­˜ä¸­å€¼ä¿å­˜åœ¨æŸä¸ªå¯„å­˜å™¨ä¸­ï¼‰    inline\n å†…è”å‡½æ•°åœ¨ç¼–è¯‘æ—¶è¢«å±•å¼€ï¼Œä¸æ‰§è¡Œè¿›å…¥å‡½æ•°çš„æ­¥éª¤ï¼Œç›´æ¥æ‰§è¡Œå‡½æ•°ä½“ ç¼–è¯‘å™¨ä¸€èˆ¬ä¸å†…è”åŒ…å«å¾ªç¯ã€é€’å½’ã€switch ç­‰å¤æ‚æ“ä½œçš„å†…è”å‡½æ•° åœ¨ç±»å£°æ˜ä¸­å®šä¹‰çš„å‡½æ•°ï¼Œé™¤äº†è™šå‡½æ•°çš„å…¶ä»–å‡½æ•°éƒ½ä¼šè‡ªåŠ¨éšå¼åœ°å½“æˆå†…è”å‡½æ•° ä¼˜ç‚¹  å†…è”å‡½æ•°åœ¨è°ƒç”¨å¤„è¿›è¡Œå±•å¼€ï¼Œçœå»äº†å‚æ•°å‹æ ˆã€æ ˆå¸§å¼€è¾Ÿä¸å›æ”¶ï¼Œç»“æœè¿”å›ç­‰ å†…è”å‡½æ•°å®‰å…¨æ£€æŸ¥æˆ–è‡ªåŠ¨ç±»å‹è½¬æ¢ï¼Œè€Œå®ä¸ä¼š åœ¨ç±»ä¸­å£°æ˜å¹¶å®šä¹‰çš„æˆå‘˜å‡½æ•°ï¼Œä¼šè¢«éšå¼åœ°è½¬åŒ–ä¸ºå†…è”å‡½æ•°   ç¼ºç‚¹  ä»£ç è†¨èƒ€ï¼›å†…è”æ˜¯ä»¥ä»£ç è†¨èƒ€ï¼ˆå¤åˆ¶ï¼‰ä¸ºä»£ä»·ï¼Œå°†ä½¿ç¨‹åºçš„æ€»ä»£ç é‡å¢å¤§ï¼Œæ¶ˆè€—æ›´å¤šçš„å†…å­˜ç©ºé—´ inline å‡½æ•°æ— æ³•éšç€å‡½æ•°åº“å‡çº§è€Œå‡çº§ã€‚inlineå‡½æ•°çš„æ”¹å˜éœ€è¦é‡æ–°ç¼–è¯‘ï¼Œä¸åƒ non-inline å¯ä»¥ç›´æ¥é“¾æ¥      friend å‹å…ƒ\n å‹å…ƒç±»å’Œå‹å…ƒå‡½æ•°èƒ½è®¿é—®å…¶ä»–ç±»åœ°ç§æœ‰æˆå‘˜ ç ´åå°è£…æ€§ï¼Œä¸å¯ä¼ é€’ï¼Œå•å‘æ€§    decltype\n è·å–å˜é‡ç±»å‹ æ£€æŸ¥å®ä½“çš„å£°æ˜ç±»å‹æˆ–è¡¨è¾¾å¼çš„ç±»å‹åŠå€¼åˆ†ç±»    C++ ç¼–è¯‘  ç¼–è¯‘é¢„å¤„ç†ï¼ˆ.iï¼‰ ç¼–è¯‘ä¼˜åŒ–ï¼ˆ.sï¼‰ æ±‡ç¼–ç¨‹åºï¼ˆ.objã€.oï¼‰ é“¾æ¥ï¼ˆå¯æ‰§è¡Œæ–‡ä»¶ï¼‰  1. ç¼–è¯‘ï¼šæŠŠæ–‡æœ¬å½¢å¼çš„æºä»£ç ç¿»è¯‘æˆæœºå™¨è¯­è¨€ï¼Œå¹¶å½¢æˆç›®æ ‡æ–‡ä»¶   ç¼–è¯‘é¢„\n ç¼–è¯‘å™¨æ‰§è¡Œé¢„å¤„ç†æŒ‡ä»¤ï¼ˆä»¥#å¼€å¤´ï¼Œä¾‹å¦‚#includeï¼‰ï¼ŒåŒ…æ‹¬æ‹·è´ #include åŒ…å«çš„æ–‡ä»¶ä»£ç ï¼Œè¿›è¡Œ #define å®å®šä¹‰çš„æ›¿æ¢ï¼Œå¤„ç†æ¡ä»¶ç¼–è¯‘æŒ‡ä»¤ï¼ˆ#ifndef #ifdef #endifï¼‰ç­‰ ç”Ÿæˆ .i æ–‡ä»¶    ç¼–è¯‘\n è¯­æ³•åˆ†æï¼Œè¯æ³•åˆ†æï¼Œè¯­ä¹‰åˆ†æï¼Œä¸­é—´ä»£ç ç”Ÿæˆï¼Œä»£ç ä¼˜åŒ–ï¼Œä»£ç ç”Ÿæˆç­‰ ç¿»è¯‘æˆæ±‡ç¼–ä»£ç  ç”Ÿæˆ .s æ–‡ä»¶    æ±‡ç¼–\n ç¿»è¯‘æˆæœºå™¨æŒ‡ä»¤ ç”Ÿæˆ .o ç›®æ ‡æ–‡ä»¶ ç›®æ ‡æ–‡ä»¶é€šå¸¸è‡³å°‘æœ‰ä¸¤ä¸ªæ®µ  ä»£ç æ®µï¼šåŒ…æ¢ä¸»è¦ç¨‹åºçš„æŒ‡ä»¤ã€‚è¯¥æ®µæ˜¯å¯è¯»å’Œå¯æ‰§è¡Œçš„ï¼Œä¸€èˆ¬ä¸å¯å†™ æ•°æ®æ®µï¼šå­˜æ”¾ç¨‹åºç”¨åˆ°çš„å…¨å±€å˜é‡æˆ–é™æ€æ•°æ®ã€‚å¯è¯»ã€å¯å†™ã€å¯æ‰§è¡Œ      2. é“¾æ¥ ï¼šæŠŠç›®æ ‡æ–‡ä»¶å’Œæ“ä½œç³»ç»Ÿçš„å¯åŠ¨ä»£ç å’Œåº“æ–‡ä»¶ç»„ç»‡èµ·æ¥å½¢æˆå¯æ‰§è¡Œç¨‹åº  å°†æœ‰å…³çš„ç›®æ ‡æ–‡ä»¶è¿æ¥èµ·æ¥ åŸå›   åœ¨ç¨‹åºä¸­è°ƒç”¨äº†æŸä¸ªåº“å‡½æ•° æŸä¸ªæºæ–‡ä»¶è°ƒç”¨äº†å¦ä¸€ä¸ªæºæ–‡ä»¶ä¸­çš„å‡½æ•°æˆ–å¸¸é‡   ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶  C++ å‡½æ•°è°ƒç”¨  å‚æ•°å…¥æ ˆ  æŠŠå‚æ•°ä»å³å¾€å·¦ push è¿›å…¥æ ˆä¸­   ä¿å­˜ç°åœºï¼ˆè¿”å›åœ°å€å…¥æ ˆï¼‰  å°†å½“å‰ä»£ç åŒºè°ƒç”¨æŒ‡ä»¤çš„ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€ push å…¥æ ˆä¸­ï¼Œä¾›å‡½æ•°è¿”å›æ—¶ç»§ç»­æ‰§è¡Œ   æ‰§è¡Œå­å‡½æ•°  ä»£ç åŒºè·³è½¬ï¼šå¤„ç†å™¨ä»å½“å‰ä»£ç åŒºè·³è½¬åˆ°è¢«è°ƒç”¨å‡½æ•°çš„å…¥å£å¤„ æ ˆå¸§è°ƒæ•´ï¼ŒåŒ…æ‹¬  ä¿å­˜å½“å‰æ ˆå¸§çŠ¶æ€å€¼ï¼Œå·²å¤‡åé¢æ¢å¤æœ¬æ ˆå¸§æ—¶ä½¿ç”¨ï¼ˆEBPå…¥æ ˆï¼‰ å°†å½“å‰æ ˆå¸§åˆ‡æ¢åˆ°æ–°æ ˆå¸§ï¼ˆå°†ESPå€¼è£…å…¥EBPï¼Œæ›´æ–°æ ˆå¸§åº•éƒ¨ï¼‰ ç»™æ–°æ ˆå¸§åˆ†é…ç©ºé—´ï¼ˆæŠŠESPå‡å»æ‰€éœ€ç©ºé—´çš„å¤§å°ï¼ŒæŠ¬é«˜æ ˆé¡¶ï¼‰     æ¢å¤ç°åœº  STL å®¹å™¨ æ‰€æœ‰å®¹å™¨    å®¹å™¨ å®ç° æŸ¥è¯¢ æ’å…¥åˆ é™¤ ç‰¹ç‚¹     array æ•°ç»„ O(1) O(1) å¤§å°å›ºå®š   vector æ•°ç»„ O(1) å°¾éƒ¨ O(1)ï¼Œå…¶ä»– O(n) å¤§å°å¯å˜ï¼Œæ‰©å®¹è€—æ—¶   deque åŒç«¯é˜Ÿåˆ— O(n) å¤´å°¾ O(1)ï¼Œå…¶ä»– O(n) ä¸€ä¸ªä¸­å¤®æ§åˆ¶å™¨ï¼Œå¤šä¸ªç¼“å†²åŒº   list åŒå‘é“¾è¡¨ O(n) O(1)    forward_list å•å‘é“¾è¡¨ O(n) O(1)    stack deque / list / O(1) å…ˆè¿›åå‡º   queue deque / list / O(1) å…ˆè¿›å…ˆå‡º   priority_queue vector / O(logn) å †ï¼Œå®Œå…¨äºŒå‰æ ‘   set çº¢é»‘æ ‘ O(logn) O(logn)    multiset çº¢é»‘æ ‘ O(logn) O(logn)    map çº¢é»‘æ ‘ O(logn) O(logn)    multimap çº¢é»‘æ ‘ O(logn) O(logn)    unordered_set å“ˆå¸Œè¡¨ å¹³å‡ O(1) å¹³å‡ O(1)    unordered_multiset å“ˆå¸Œè¡¨ å¹³å‡ O(1) å¹³å‡ O(1)    unordered_map å“ˆå¸Œè¡¨ å¹³å‡ O(1) å¹³å‡ O(1)    unordered_multimap å“ˆå¸Œè¡¨ å¹³å‡ O(1) å¹³å‡ O(1)     vector   vector çš„å†…å­˜é‡Šæ”¾\n å¯¹äºvectorï¼Œstring ç­‰å®¹å™¨ï¼Œæ‰§è¡Œ clear() å‡½æ•°ååªä¼šå°†å…¶ size ç½®ä¸º 0ï¼Œè€Œä¸ä¼šæ”¹å˜å®ƒä»¬çš„ capacity å¯ä»¥ç”¨ swap() å‡½æ•°æ¥æ¸…ç† vector å’Œ string å®¹å™¨çš„å†…å­˜ï¼Œç”¨ä¸€ä¸ªå³å€¼ vector æ¥æ›¿æ¢éœ€è¦æ¸…ç†çš„å®¹å™¨ å…¶å®ƒçš„ stl å®¹å™¨è°ƒç”¨ clear() æ—¶ä¼šæ¸…ç©ºå†…å­˜ æµ‹è¯•  vector\u0026lt;int\u0026gt; v; printf(\u0026#34;v.size() = %d, v.capacity() = %d\\n\u0026#34;, v.size(), v.capacity()); for (int i = 0; i \u0026lt; 100000; ++i) v.push_back(i); printf(\u0026#34;v.size() = %d, v.capacity() = %d\\n\u0026#34;, v.size(), v.capacity()); vector\u0026lt;int\u0026gt;().swap(v); printf(\u0026#34;v.size() = %d, v.capacity() = %d\\n\u0026#34;, v.size(), v.capacity()); /* output: v.size() = 0, v.capacity() = 0 v.size() = 100000, v.capacity() = 131072 v.size() = 0, v.capacity() = 0 */   resize æŠ¥é”™\n vector çš„ç±»å‹æ˜¯è‡ªå®šä¹‰ç±»æˆ–ç»“æ„ä½“çš„æ—¶å€™ï¼Œåœ¨æ‰§è¡Œ resize() çš„æ—¶å€™å¦‚æœå‚æ•°å¤§äºå½“å‰çš„ sizeï¼Œç¼–è¯‘å™¨ä¼šå°†è¶…è¿‡å½“å‰ size çš„éƒ¨åˆ†åˆå§‹åŒ–ï¼›å¦‚æœè‡ªå®šä¹‰çš„ç±»æ²¡æœ‰æ„é€ å‡½æ•°é‚£ä¹ˆç¼–è¯‘å™¨ä¼šæŠ¥é”™    çº¢é»‘æ ‘   ç‰¹å¾\n èŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰² æ ¹æ˜¯é»‘è‰² æ‰€æœ‰å¶å­ï¼ˆç©ºèŠ‚ç‚¹ï¼‰éƒ½æ˜¯é»‘è‰² æ¯ä¸ªçº¢è‰²èŠ‚ç‚¹å¿…é¡»æœ‰ä¸¤ä¸ªé»‘è‰²çš„å­èŠ‚ç‚¹ï¼›ä»æ¯ä¸ªå¶å­åˆ°æ ¹çš„æ‰€æœ‰è·¯å¾„ä¸Šä¸èƒ½æœ‰ä¸¤ä¸ªè¿ç»­çš„çº¢è‰²èŠ‚ç‚¹ ä»ä»»ä¸€èŠ‚ç‚¹åˆ°å…¶æ¯ä¸ªå¶å­çš„æ‰€æœ‰ç®€å•è·¯å¾„éƒ½åŒ…å«ç›¸åŒæ•°ç›®çš„é»‘è‰²èŠ‚ç‚¹    éä¸¥æ ¼å¹³è¡¡ï¼Œé€šè¿‡å˜è‰²ï¼Œå·¦æ—‹ï¼Œå³æ—‹æ¥è°ƒæ•´\n  å·¦å€¼å’Œå³å€¼   å·¦å€¼å¯ä»¥å–åœ°å€ï¼›å³å€¼æ˜¯å°†è¦é”€æ¯çš„ä¸´æ—¶å˜é‡\n  å³å€¼çš„ç”Ÿå‘½å‘¨æœŸåœ¨è¡¨è¾¾å¼ç»“æŸæ—¶ç»“æŸï¼Œå¸¸é‡å·¦å€¼å¼•ç”¨ä¼šå»¶é•¿ä¸´æ—¶å˜é‡çš„ç”Ÿå‘½\n  å·¦å€¼å¼•ç”¨\n æ™®é€šå¼•ç”¨ï¼Œä¸€èˆ¬è¡¨ç¤ºå¯¹è±¡çš„èº«ä»½/åˆ«å    å³å€¼å¼•ç”¨\n å¿…é¡»ç»‘å®šåˆ°å³å€¼çš„å¼•ç”¨ï¼Œä¸€èˆ¬è¡¨ç¤ºå¯¹è±¡çš„å€¼ å³å€¼å¼•ç”¨å¯å®ç°è½¬ç§»è¯­ä¹‰ï¼ˆMove Sementicsï¼‰å’Œç²¾ç¡®ä¼ é€’ï¼ˆPerfect Forwardingï¼‰ ä¸»è¦ç›®çš„æ˜¯æ¶ˆé™¤ä¸¤ä¸ªå¯¹è±¡äº¤äº’æ—¶ä¸å¿…è¦çš„å¯¹è±¡æ‹·è´ï¼ŒèŠ‚çœè¿ç®—å­˜å‚¨èµ„æºï¼Œæé«˜æ•ˆç‡ èƒ½å¤Ÿæ›´ç®€æ´æ˜ç¡®åœ°å®šä¹‰æ³›å‹å‡½æ•°    æ’åº    æ’åºç®—æ³• å¹³å‡æ—¶é—´å¤æ‚åº¦ æœ€å·®æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ æ•°æ®å¯¹è±¡ç¨³å®šæ€§     å†’æ³¡æ’åº O(n2) O(n2) O(1) ç¨³å®š   é€‰æ‹©æ’åº O(n2) O(n2) O(1) æ•°ç»„å®ç°ä¸ç¨³å®š   æ’å…¥æ’åº O(n2) O(n2) O(1) ç¨³å®š   å¿«é€Ÿæ’åº O(n*log2n) O(n2) O(log2n) ä¸ç¨³å®š   å †æ’åº O(n*log2n) O(n*log2n) O(1) ä¸ç¨³å®š   å½’å¹¶æ’åº O(n*log2n) O(n*log2n) O(n) ç¨³å®š   å¸Œå°”æ’åº O(n*log2n) O(n2) O(1) ä¸ç¨³å®š   è®¡æ•°æ’åº O(n+m) O(n+m) O(n+m) ç¨³å®š   æ¡¶æ’åº O(n) O(n) O(m) ç¨³å®š   åŸºæ•°æ’åº O(k*n) O(n2)  ç¨³å®š    å…¶ä»– é‡è½½æ“ä½œç¬¦   new\nvoid *operator new(size_t size) { cout \u0026lt;\u0026lt; \u0026#34;in threee_d new\\n\u0026#34;; return malloc(size); }  throw(std::bad_alloc) const std::nothrow_t\u0026amp; ä¸æŠ›å‡ºå¼‚å¸¸    å‚è€ƒ   ã€ŠC++ Primerã€‹\n  ã€ŠEffective C++ã€‹\n  ã€ŠMore Effective C++ã€‹\n  ã€Šæ·±åº¦æ¢ç´¢ C++ å¯¹è±¡æ¨¡å‹ã€‹\n  ã€Šæ·±å…¥ç†è§£ C++11ã€‹\n  ã€ŠSTL æºç å‰–æã€‹\n  ã€Šå‰‘æŒ‡ Offerã€‹\n  ã€Šç¼–ç¨‹ç ç‘ã€‹\n  ã€Šç¨‹åºå‘˜é¢è¯•å®å…¸ã€‹\n  ã€Šæ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿã€‹\n  ã€ŠWindows æ ¸å¿ƒç¼–ç¨‹ã€‹\n  ã€ŠUnix ç¯å¢ƒé«˜çº§ç¼–ç¨‹ã€‹\n  ã€ŠUnix ç½‘ç»œç¼–ç¨‹ã€‹\n  ã€ŠTCP/IP è¯¦è§£ã€‹\n  ã€Šç¨‹åºå‘˜çš„è‡ªæˆ‘ä¿®å…»ã€‹\n  ","permalink":"http://zintrulcre.github.io/posts/c++/basics/basics/","summary":"C++ åŸºç¡€çŸ¥è¯† const ç›¸å…³   #defineï¼Œtypedefï¼Œconst\n # æ˜¯å®ï¼Œå®ä¸åšç±»å‹æ£€æŸ¥ï¼Œåªè¿›è¡Œç®€å•æ›¿æ¢ï¼›åœ¨ç¼–è¯‘å‰è¢«å¤„ç†ï¼Œç¼–è¯‘é˜¶æ®µçš„ç¨‹åºæ˜¯å®å¤„ç†åçš„ç»“æœ typedef ç”¨äºå£°æ˜è‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼Œç®€åŒ–ä»£ç  const ç”¨äºå®šä¹‰å¸¸é‡ï¼Œæœ‰æ•°æ®ç±»å‹ï¼Œç¼–è¯‘å™¨ä¼šå¯¹è¿›è¡Œç±»å‹æ£€æŸ¥    const å’ŒæŒ‡é’ˆ\n const char *p: p is a pointer to const char char const *p: p is a pointer to char constï¼ˆåŒä¸Šï¼‰ char *const p: p is a const pointer to char  int main() { const char *p1 = new char(\u0026#39;a\u0026#39;); char const *p2 = new char(\u0026#39;b\u0026#39;); char *const p3 = new char(\u0026#39;c\u0026#39;); *p1 = \u0026#39;d\u0026#39;; // error: read-only variable is notassignable *p2 = \u0026#39;e\u0026#39;; // error: read-only variable is notassignable p3 = new char(\u0026#39;f\u0026#39;); // error: cannot assign tovariable \u0026#39;p3\u0026#39; with const-qualified type \u0026#39;char *const\u0026#39; p3 = nullptr; // error: cannot assign to variable\u0026#39;p3\u0026#39; with const-qualified type \u0026#39;char *const\u0026#39; }   const å’Œç±»","title":"C++ åŸºç¡€çŸ¥è¯†æ•´ç†"},{"content":"æŸ¥çœ‹ container çš„ log file æ‰€åœ¨çš„ç›®å½•ï¼šdocker inspect \u0026lt;containername\u0026gt; | grep log\n","permalink":"http://zintrulcre.github.io/posts/cloud-computing/docker/","summary":"æŸ¥çœ‹ container çš„ log file æ‰€åœ¨çš„ç›®å½•ï¼šdocker inspect \u0026lt;containername\u0026gt; | grep log","title":""},{"content":"Linux:\næˆ‘å¹³æ—¶çš„å­¦ä¹ åŸºæœ¬ä¸Šéƒ½åœ¨Linuxä¸‹å®Œæˆçš„ï¼Œæˆ‘ç°åœ¨æœ‰ä¸¤å°ç”µè„‘ï¼Œä¸€å°iMacï¼Œä¸€å°ç¬”è®°æœ¬ï¼Œç¬”è®°æœ¬ä¸Šå°±è£…çš„Linuxï¼Œç„¶åæ¯å¤©éƒ½ä¼šç”¨å¾ˆå¤šæŒ‡ä»¤ï¼Œ æ¯”å¦‚è¯´ç”¨pipelineç®¡é“è¾“å‡ºåç”¨grepåšæ­£åˆ™æœç´¢ï¼Œç”¨ifconfigå’ŒnetstatæŸ¥çœ‹ç½‘ç»œçŠ¶æ€ï¼Œç”¨topçœ‹è¿›ç¨‹èµ„æºï¼Œç”¨iostatçœ‹cpuå’Œç¡¬ç›˜çŠ¶æ€ è¿˜æœ‰å°±æ˜¯æœ€åŸºç¡€çš„cd ls cp rm mkdir find whereisï¼Œè¿˜æœ‰è¿œç¨‹çš„scp è¿˜æœ‰ä¸€ä¸ªæŸ¥çœ‹ç¨‹åºè¿è¡Œæ—¶çš„ç³»ç»Ÿè°ƒç”¨ï¼Œåœ¨Linuxä¸‹æ˜¯straceï¼ŒMacä¸‹æ˜¯dtrussï¼Œæœ‰äº›å‘½ä»¤åœ¨ä¸¤ä¸ªå¹³å°ä¸ä¸€æ · Linuxä¸‹å¯¹æ–‡ä»¶æ“ä½œæœ‰ä¸¤ç§æ–¹å¼ï¼šç³»ç»Ÿè°ƒç”¨ï¼ˆåº•å±‚è°ƒç”¨ï¼Œé¢å‘ç¡¬ä»¶ï¼‰ï¼Œå’Œåº“å‡½æ•°è°ƒç”¨ï¼ˆåº”ç”¨ï¼‰ã€‚ç³»ç»Ÿè°ƒç”¨ï¼šopen, close, read, write, ioctlç­‰ï¼Œç”¨äºåº•å±‚æ–‡ä»¶è®¿é—®\nè°ƒè¯•ï¼š ç”¨vimç¼–è¾‘ï¼ˆä¼šä¸€äº›vimçš„å¿«æ·é”®ï¼Œæ¯”å¦‚ddåˆ é™¤ä¸€è¡Œï¼Œggå®šä½åˆ°å¤´éƒ¨ï¼Œ6$å®šä½åˆ°æŸä¸€è¡Œï¼‰ï¼Œç”¨gdbè°ƒè¯•ï¼Œæ‰“logå‡ºæ¥çœ‹ï¼Œç”¨è¿‡æœ‰ä¸ªå«log4cplusçš„æ¡†æ¶ï¼Œæœ‰å†…å­˜é”™è¯¯æˆ–è€…å†…å­˜æ³„æ¼çš„é—®é¢˜å°±ç”¨valgrindè°ƒè¯•ã€‚è¿˜æœ‰ç”¨GNU profileræ¥æŸ¥çœ‹ä¸€äº›å‡½æ•°çš„è°ƒç”¨æ¬¡æ•°ï¼Œè°ƒç”¨ç‚¹ç›¸å…³çš„ä¿¡æ¯ï¼ˆç¼–è¯‘å™¨çš„è¯åœ¨Linuxä¸ŠGCCï¼Œåœ¨MACä¸Šç”¨è‡ªå¸¦çš„clangï¼Œå•å…ƒæµ‹è¯•ç”¨gtestã€‚ï¼‰\nC++ å†…å­˜åˆ†é…\n æ ˆåŒºï¼šå‚æ•°ï¼Œå±€éƒ¨å˜é‡ 2.å †åŒºï¼šnewï¼Œå‘é«˜åœ°å€æ‰©å±•ï¼Œä¸è¿ç»­ 3.è‡ªç”±å­˜å‚¨åŒºï¼Œmalloc 4.å…¨å±€/é™æ€å­˜å‚¨åŒºï¼Œå­˜å‚¨å…¨å±€å˜é‡å’Œé™æ€å˜é‡ 5.å¸¸é‡å­˜å‚¨åŒºï¼Œå­˜å‚¨å¸¸é‡ new åˆ†é…å¤±è´¥ï¼š 1. int* p = new (std::nothrow) int(1); è¿”å›ç©ºæŒ‡é’ˆ 2. ç”¨ try {} catch (const bad_alloc \u0026amp;b) {} æ•æ‰å¼‚å¸¸  auto_ptrï¼šæœ‰æ‹·è´æ„é€ å’Œèµ‹å€¼æ“ä½œï¼Œæ‰€æœ‰æƒè½¬ç§» unique_ptrï¼šç‹¬å å¼æ‹¥æœ‰ï¼Œä¿è¯åŒä¸€æ—¶é—´å†…åªæœ‰ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆå¯ä»¥æŒ‡å‘ç‰¹å®šæŒ‡é’ˆï¼ŒåŒæ—¶é”€æ¯ï¼Œå¯ä»¥ç§»äº¤æ‹¥æœ‰æƒ shared_ptrï¼šå¤šä¸ªæ™ºèƒ½æŒ‡é’ˆæŒ‡å‘ç›¸åŒæŒ‡é’ˆå¯¹è±¡ï¼Œåœ¨æœ€åä¸€ä¸ªshared_ptrè¢«é”€æ¯æ—¶å¯¹è±¡è¢«é‡Šæ”¾ï¼›æ­é… weak_ptrã€bad_weak_ptrç­‰è¾…åŠ©ç±»æ¥å®ç°ï¼Œå¯ä»¥å®šåˆ¶å‹åˆ é™¤å™¨ï¼Œå› ä¸ºé»˜è®¤åªä¼šæŠŠæŒ‡é’ˆåˆ æ‰ï¼Œå¦‚æœæ˜¯ä¸ªæ•°ç»„ä¸ä¼šåˆ åé¢çš„ å¾ªç¯å¼•ç”¨å°±æ˜¯è¯´æœ‰ä¸¤ä¸ªç±»å¯¹è±¡çš„æ™ºèƒ½æŒ‡é’ˆï¼Œä»–ä»¬åˆ†åˆ«æœ‰ä¸€ä¸ªæˆå‘˜å˜é‡æ˜¯å¯¹æ–¹çš„ç±»å‹ï¼Œå¹¶ä¸”æŒ‡å‘äº†å¯¹æ–¹çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå½¢æˆäº†ä¸€ä¸ªç¯çŠ¶ï¼Œé‚£ä¹ˆä»–ä»¬å°±æ— æ³•è¢«æ­£ç¡®çš„é‡Šæ”¾æ‰ weak_ptrï¼šåªå¼•ç”¨ï¼Œä¸è®¡æ•°ï¼Œå¦‚æœä¸€ä¸ªæŒ‡é’ˆè¢«ä¸€äº›shared_ptrå’Œweak_ptråŒæ—¶å¼•ç”¨ï¼Œå½“è¿™äº›shared_ptréƒ½é‡Šæ”¾æ‰ï¼Œä¸ç®¡è¿˜æœ‰æ²¡æœ‰weak_ptrå¼•ç”¨è¯¥å†…å­˜ï¼Œå†…å­˜éƒ½ä¼šè¢«é‡Šæ”¾ï¼Œè§£å†³äº†å¾ªç¯å¼•ç”¨\nçº¿ç¨‹é€šä¿¡ï¼šé”ï¼ˆäº’æ–¥é”ï¼Œè¯»å†™æ‰€ï¼Œè‡ªæ—‹é”ï¼Œæ¡ä»¶å˜é‡ï¼ŒåŸå­å˜é‡ï¼Œä¸´ç•ŒåŒºï¼‰ï¼Œä¿¡å·é‡ï¼Œä¿¡å·ï¼Œå±éšœ\n","permalink":"http://zintrulcre.github.io/posts/computer-science/temp/","summary":"Linux:\næˆ‘å¹³æ—¶çš„å­¦ä¹ åŸºæœ¬ä¸Šéƒ½åœ¨Linuxä¸‹å®Œæˆçš„ï¼Œæˆ‘ç°åœ¨æœ‰ä¸¤å°ç”µè„‘ï¼Œä¸€å°iMacï¼Œä¸€å°ç¬”è®°æœ¬ï¼Œç¬”è®°æœ¬ä¸Šå°±è£…çš„Linuxï¼Œç„¶åæ¯å¤©éƒ½ä¼šç”¨å¾ˆå¤šæŒ‡ä»¤ï¼Œ æ¯”å¦‚è¯´ç”¨pipelineç®¡é“è¾“å‡ºåç”¨grepåšæ­£åˆ™æœç´¢ï¼Œç”¨ifconfigå’ŒnetstatæŸ¥çœ‹ç½‘ç»œçŠ¶æ€ï¼Œç”¨topçœ‹è¿›ç¨‹èµ„æºï¼Œç”¨iostatçœ‹cpuå’Œç¡¬ç›˜çŠ¶æ€ è¿˜æœ‰å°±æ˜¯æœ€åŸºç¡€çš„cd ls cp rm mkdir find whereisï¼Œè¿˜æœ‰è¿œç¨‹çš„scp è¿˜æœ‰ä¸€ä¸ªæŸ¥çœ‹ç¨‹åºè¿è¡Œæ—¶çš„ç³»ç»Ÿè°ƒç”¨ï¼Œåœ¨Linuxä¸‹æ˜¯straceï¼ŒMacä¸‹æ˜¯dtrussï¼Œæœ‰äº›å‘½ä»¤åœ¨ä¸¤ä¸ªå¹³å°ä¸ä¸€æ · Linuxä¸‹å¯¹æ–‡ä»¶æ“ä½œæœ‰ä¸¤ç§æ–¹å¼ï¼šç³»ç»Ÿè°ƒç”¨ï¼ˆåº•å±‚è°ƒç”¨ï¼Œé¢å‘ç¡¬ä»¶ï¼‰ï¼Œå’Œåº“å‡½æ•°è°ƒç”¨ï¼ˆåº”ç”¨ï¼‰ã€‚ç³»ç»Ÿè°ƒç”¨ï¼šopen, close, read, write, ioctlç­‰ï¼Œç”¨äºåº•å±‚æ–‡ä»¶è®¿é—®\nè°ƒè¯•ï¼š ç”¨vimç¼–è¾‘ï¼ˆä¼šä¸€äº›vimçš„å¿«æ·é”®ï¼Œæ¯”å¦‚ddåˆ é™¤ä¸€è¡Œï¼Œggå®šä½åˆ°å¤´éƒ¨ï¼Œ6$å®šä½åˆ°æŸä¸€è¡Œï¼‰ï¼Œç”¨gdbè°ƒè¯•ï¼Œæ‰“logå‡ºæ¥çœ‹ï¼Œç”¨è¿‡æœ‰ä¸ªå«log4cplusçš„æ¡†æ¶ï¼Œæœ‰å†…å­˜é”™è¯¯æˆ–è€…å†…å­˜æ³„æ¼çš„é—®é¢˜å°±ç”¨valgrindè°ƒè¯•ã€‚è¿˜æœ‰ç”¨GNU profileræ¥æŸ¥çœ‹ä¸€äº›å‡½æ•°çš„è°ƒç”¨æ¬¡æ•°ï¼Œè°ƒç”¨ç‚¹ç›¸å…³çš„ä¿¡æ¯ï¼ˆç¼–è¯‘å™¨çš„è¯åœ¨Linuxä¸ŠGCCï¼Œåœ¨MACä¸Šç”¨è‡ªå¸¦çš„clangï¼Œå•å…ƒæµ‹è¯•ç”¨gtestã€‚ï¼‰\nC++ å†…å­˜åˆ†é…\n æ ˆåŒºï¼šå‚æ•°ï¼Œå±€éƒ¨å˜é‡ 2.å †åŒºï¼šnewï¼Œå‘é«˜åœ°å€æ‰©å±•ï¼Œä¸è¿ç»­ 3.è‡ªç”±å­˜å‚¨åŒºï¼Œmalloc 4.å…¨å±€/é™æ€å­˜å‚¨åŒºï¼Œå­˜å‚¨å…¨å±€å˜é‡å’Œé™æ€å˜é‡ 5.å¸¸é‡å­˜å‚¨åŒºï¼Œå­˜å‚¨å¸¸é‡ new åˆ†é…å¤±è´¥ï¼š 1. int* p = new (std::nothrow) int(1); è¿”å›ç©ºæŒ‡é’ˆ 2. ç”¨ try {} catch (const bad_alloc \u0026amp;b) {} æ•æ‰å¼‚å¸¸  auto_ptrï¼šæœ‰æ‹·è´æ„é€ å’Œèµ‹å€¼æ“ä½œï¼Œæ‰€æœ‰æƒè½¬ç§» unique_ptrï¼šç‹¬å å¼æ‹¥æœ‰ï¼Œä¿è¯åŒä¸€æ—¶é—´å†…åªæœ‰ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆå¯ä»¥æŒ‡å‘ç‰¹å®šæŒ‡é’ˆï¼ŒåŒæ—¶é”€æ¯ï¼Œå¯ä»¥ç§»äº¤æ‹¥æœ‰æƒ shared_ptrï¼šå¤šä¸ªæ™ºèƒ½æŒ‡é’ˆæŒ‡å‘ç›¸åŒæŒ‡é’ˆå¯¹è±¡ï¼Œåœ¨æœ€åä¸€ä¸ªshared_ptrè¢«é”€æ¯æ—¶å¯¹è±¡è¢«é‡Šæ”¾ï¼›æ­é… weak_ptrã€bad_weak_ptrç­‰è¾…åŠ©ç±»æ¥å®ç°ï¼Œå¯ä»¥å®šåˆ¶å‹åˆ é™¤å™¨ï¼Œå› ä¸ºé»˜è®¤åªä¼šæŠŠæŒ‡é’ˆåˆ æ‰ï¼Œå¦‚æœæ˜¯ä¸ªæ•°ç»„ä¸ä¼šåˆ åé¢çš„ å¾ªç¯å¼•ç”¨å°±æ˜¯è¯´æœ‰ä¸¤ä¸ªç±»å¯¹è±¡çš„æ™ºèƒ½æŒ‡é’ˆï¼Œä»–ä»¬åˆ†åˆ«æœ‰ä¸€ä¸ªæˆå‘˜å˜é‡æ˜¯å¯¹æ–¹çš„ç±»å‹ï¼Œå¹¶ä¸”æŒ‡å‘äº†å¯¹æ–¹çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå½¢æˆäº†ä¸€ä¸ªç¯çŠ¶ï¼Œé‚£ä¹ˆä»–ä»¬å°±æ— æ³•è¢«æ­£ç¡®çš„é‡Šæ”¾æ‰ weak_ptrï¼šåªå¼•ç”¨ï¼Œä¸è®¡æ•°ï¼Œå¦‚æœä¸€ä¸ªæŒ‡é’ˆè¢«ä¸€äº›shared_ptrå’Œweak_ptråŒæ—¶å¼•ç”¨ï¼Œå½“è¿™äº›shared_ptréƒ½é‡Šæ”¾æ‰ï¼Œä¸ç®¡è¿˜æœ‰æ²¡æœ‰weak_ptrå¼•ç”¨è¯¥å†…å­˜ï¼Œå†…å­˜éƒ½ä¼šè¢«é‡Šæ”¾ï¼Œè§£å†³äº†å¾ªç¯å¼•ç”¨\nçº¿ç¨‹é€šä¿¡ï¼šé”ï¼ˆäº’æ–¥é”ï¼Œè¯»å†™æ‰€ï¼Œè‡ªæ—‹é”ï¼Œæ¡ä»¶å˜é‡ï¼ŒåŸå­å˜é‡ï¼Œä¸´ç•ŒåŒºï¼‰ï¼Œä¿¡å·é‡ï¼Œä¿¡å·ï¼Œå±éšœ","title":""}]