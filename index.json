[{"content":"Redis 持久化机制: RDB 和 AOF Redis 持久化 为什么需要持久化? Redis 是基于内存的数据库, 服务一旦宕机, 内存中的数据将全部丢失. 通常来说可以通过数据库来恢复这些数据, 但这会给数据库带来非常大的读压力, 并且这个过程会非常缓慢, 并导致程序响应慢, 因此 Redis 提供了把内存数据持久化到硬盘, 并通过备份文件来恢复数据的功能, 即持久化机制.\n持久化的方式 目前 Redis Documentation 上对持久化的支持有以下几种方案:\nRDB (Redis Database): 将某个时间点上的数据生成快照 (snapshot) 并保存到硬盘上 AOF (Append Only File): 将每个接收到的写操作记录到硬盘上, 这些操作可以在 Redis 重启时被重放, 并用于重新构建 Redis 数据库 RDB + AOF: AOF 和 RDB 的混合模式 RDB RDB 指对整个数据集在特定时间点生成快照 (point-to-time snapshot), 可用于Redis的数据备份, 转移和恢复. 它是 Redis 默认使用的持久化方案.\n工作原理 RDB 利用操作系统提供的写时复制 (Copy-on-Write) 机制来进行持久化, 即当主进程 P fork 出子进程时 Q 时, Q 和 P 共享同一块内存空间, 当 P 准备对某块内存进行写操作时, P 会将这块内存页进行复制, 并在新的副本上对数据进行修改, 而 Q 仍然读取原先的内存页. 这样既能够保证 Redis 实例继续服务外部流量, 又能够以最小的成本完成数据的持久化. 但正因如此, 持久化过程中的写操作是不会被记录的.\n触发方式 触发rdb持久化的方式有2种:\n手动触发. 包含两个命令: save: 阻塞 Redis 进程, 并进行 RDB 持久化, 直到其完成为止, 对于内存占用大的实例会造成长时间阻塞. bgsave: background save, 让 Redis 进程通过 fork 操作创建子进程, 并在子进程进行 RDB 持久化, 只在 fork 阶段阻塞 Redis 进程 自动触发, 通过配置中的 save 命令实现. Redis 服务有一个周期性维护函数 serverCron, 默认每 100 ms 执行一次, 它的其中一项功能就是检查所有 save 命令的条件里是否有任意一条被满足. 如果不想使用自动触发, 把所有的 save 命令注释即可. save x y # 在 x 秒内如果至少有 y 个 key 值发生变化, 则触发RDB save 60 900 # 在 60 秒内如果至少有 900 个 key 值发生变化, 则触发RDB 总结 是否应该以尽可能高的频率来触发 RDB? 为了保证宕机时丢失的数据尽量少, 我们也许可以每分钟出发一次 RDB 进行数据备份. 虽然 bgsave 在子进程中执行, 不会阻塞主线程, 但仍然有一些问题：\nbgsave 需要通过 fork 操作来创建子进程, fork 操作本身是会阻塞主进程的, 并且主线程占用内存越多, fork 操作的阻塞时间越长 将全量数据写入硬盘的操作会占用大量的带宽, 给硬盘带来很大的压力, 从而影响 Redis 实例的性能, 并且如果上一次的写入操作尚未完成, 就开始了下一次的写入操作, 更有可能会造成恶性循环 从这两点出发可以认为触发 RDB 的频率并不是越高越好, 我们需要考虑 Redis 实例占用内存的大小以及全量数据写入硬盘的速度.\n优点 RDB文件是某个时间节点的快照, 默认使用 LZF 算法进行压缩, 压缩后的文件体积远远小于内存大小, 适用于定期执行（例如每一小时进行一次）, 并将 RDB 文件上传到数据中心进行容灾备份 与AOF相比, 使用 RDB 恢复大型数据集更快 缺点 RDB 方式实时性不够, 无法做到秒级的持久化； RDB 需要 fork 子进程, 而 fork 进程执行成本非常高； RDB 文件是二进制编码的, 没有可读性 AOF AOF (Append Only File) 通过写日志的方式, 在 Redis 每次写操作完成后在日志里记录下此次执行的命令, 当服务器重启的时候通过顺序地重放这些日志来恢复数据.\n配置\nAOF 功能默认是关闭的, 需要通过修改 redis.conf 并重启 Redis 来开启.\n# no by default appendonly yes appendfilename appendonly.aof 写后日志\n和 MySQL 的写前日志 (Write-Ahead Logging) 不同, AOF 会在写操作完成后记录日志, 这样既能够保证 Redis 不阻塞并及时响应写操作, 还可以避免运行时检查出写操作命令不合法再回滚这条日志. 但如果在命令执行完之后, 写日志完成之前, 服务器发生了宕机, 也有可能会丢失数据.\n工作流程\nAOF的工作原理可以概括为几个步骤：命令追加（append）、文件写入与同步（fsync）、文件重写（rewrite）、重启加载（load）.\n1 追加命令 append 当 AOF 持久化功能开启时, Redis 执行完一个写命令后, 会按照 RESP (Redis Serialization Protocol) 协议规定的格式把这条写命令追加到其维护的 AOF 缓冲区末尾.\nAOF缓冲区 (aof_buf) 采用 Redis 特有的数据结构 SDS (Simple Dynamic String), 根据命令的类型, 使用不同的方法（catAppendOnlyGenericCommand, catAppendOnlyExpireAtCommand等）, 来对命令进行处理, 最后写入缓冲区.\n如果命令追加时正在进行 AOF 重写, 这些命令还会追加到重写缓冲区 aof_rewrite_buffer.\n2 写入文件以及同步 fsync 由于硬盘的 I/O 性能较差, 文件读写速度远远比不上 CPU 的处理速度, 那么如果每次文件写入都等待数据写入硬盘, 会整体拉低操作系统的性能. 为了解决这个问题, 操作系统提供了**延迟写（delayed write）**机制来提高硬盘的I/O性能.\nRedis 每次事件轮询结束前（beforeSleep）都会调用函数 flushAppendOnlyFile, 它会把 AOF 缓冲区中的数据写入内核缓冲区, 并且根据 appendfsync 的配置来决定采用何种策略把内核缓冲区中的数据写入磁盘, 即调用 fsync() , 有三个可选项：\nalways：每次都调用fsync(), 安全性最高, 但性能最差 no：不会调用fsync(). 性能最好, 安全性最差. everysec：仅在满足同步条件时调用fsync(). 这是官方推荐的策略, 也是默认配置, 能够兼顾性能和数据安全性, 只有在系统突然宕机的情况下会丢失 1 秒的数据. 3 重写 rewrite 随着时间的增加, AOF 文件体积会越来越大, 导致磁盘占用空间更多, 数据恢复时间更长. 为了解决这个问题, Redis 引入了 AOF 重写 (AOF Rewrite) 机制, 通过创建新的 AOF 文件, 将旧文件中的多条命令整合成为新文件中的单条命令, 并替换旧文件, 来减少 AOF 文件的体积.\n重写在何时发生? 和 RDB 的触发方式类似, AOF重写可以通过手动或自动触发.\n手动触发：调用bgrewriteaof命令, 如果当前不存在正在执行的 bgsave 或 bgrewriteaof 子进程, 那么重写会立即执行, 否则会等待子进程操作结束后再执行. 自动触发由两个配置项控制, 只有这两个指标同时满足的时候才会发生重写： auto-aof-rewrite-percentage: 当前AOF文件（aof_current_size）和上一次重写发生后AOF文件大小（aof_base_size）相比, 其增加的比例, 默认为100, 即当 aof_current_size == 2 * aof_base_size 时触发 auto-aof-rewrite-min-size: 运行BGREWRITEAOF时AOF文件占用空间最小值, 默认为64MB 重写的流程是怎么样的? bgrewriteaof 触发重写, 判断是否存在 bgsave 或者 bgrewriteaof 正在执行, 如果存在则等待其执行结束再执行 主进程fork子进程, 防止主进程阻塞无法提供服务 子进程遍历 Redis 内存快照中数据写入临时 AOF 文件, 同时会将新的写指令写入 aof_buf 和 aof_rewrite_buf 两个重写缓冲区, 前者是为了写回旧的 AOF 文件, 后者是为了后续刷新到临时 AOF 文件中, 防止快照内存遍历时新的写入操作丢失 子进程结束临时AOF文件写入后, 通知主进程 主进程会将 aof_rewirte_buf 中的数据写到子进程生成的临时 AOF log 中 主进程使用临时AOF文件替换旧AOF文件, 完成整个重写过程 整个过程可以参考下图：\nRedis启动时把aof_base_size初始化为当时aof文件的大小, Redis运行过程中, 当AOF文件重写操作完成时, 会对其进行更新；aof_current_size为serverCron执行时AOF文件的实时大小. 当满足以下两个条件时, AOF文件重写就会触发：\nAOF重写会阻塞吗? AOF 的重写过程是由后台进程 bgrewriteaof 来完成的. 主线程 fork 出后台的 bgrewriteaof 子进程, fork 操作会把主线程的内存拷贝一份给 bgrewriteaof 子进程, 这里面就包含了数据库的最新数据. 然后, bgrewriteaof 子进程逐一把拷贝的数据写成操作, 并记入重写日志, 因此在重写过程中, 只有当 fork 操作发生时会阻塞主线程.\n4 重启并加载 load Redis启动后通过loadDataFromDisk函数执行数据加载, 流程大致如下：\n未开启 AOF 的情况下, 只使用 RDB 文件加载数据 开启 AOF 的情况下, 如果 AOF 文件使用 RDB 头, 那么先使用 RDB, 再使用 AOF , 否则只使用 AOF 加载数据 总结 AOF能保证数据完整性么? 如果在对AOF文件进行写操作时发生了宕机, 或磁盘满了, 由于延迟写的特点, AOF的RESP命令可能会因为被截断而不完整. 发生这种情况时, Redis会按照配置项aof-load-truncated 的值来进行不同的操作：\nyes：尽可能多的加载数据, 并以日志的方式通知用户； no：以系统错误的方式产生崩溃, 并禁止重启, 需要用户手动修复文件 优点 AOF持久化有更好的实时性, 因为使用 every second 作为 fsyn从的默认策略, 极端情况下可能只会丢失一秒的数据 对 AOF log 的操作只有 append, 不会导致文件损坏；即使最后写入数据被截断, 也很容易使用redis-check-aof工具修复 重写机制可以保证 AOF log 不占用太大空间, 并且重写过程中新的写操作也会记录到旧的 log 中, 防止数据丢失 AOF log 具有更高的可读性, 并且可以轻易导出 缺点 对于相同的数据集, AOF 文件通常会比 RDB 文件大 在写操作较多时, AOF 的延迟会更高 Reference https://redis.io/docs/management/persistence/\n","permalink":"https://prov1dence.top/posts/data/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-rdb-%E5%92%8C-aof-72a88c70207a4518824d1fe4be7ebb9e/","summary":"\u003ch1 id=\"redis-持久化机制-rdb-和-aof\"\u003eRedis 持久化机制: RDB 和 AOF\u003c/h1\u003e\n\u003ch1 id=\"redis-持久化\"\u003eRedis 持久化\u003c/h1\u003e\n\u003ch3 id=\"为什么需要持久化\"\u003e为什么需要持久化?\u003c/h3\u003e\n\u003cp\u003eRedis 是基于内存的数据库, 服务一旦宕机, 内存中的数据将全部丢失. 通常来说可以通过数据库来恢复这些数据, 但这会给数据库带来非常大的读压力, 并且这个过程会非常缓慢, 并导致程序响应慢, 因此 Redis 提供了把内存数据持久化到硬盘, 并通过备份文件来恢复数据的功能, 即持久化机制.\u003c/p\u003e\n\u003ch3 id=\"持久化的方式\"\u003e持久化的方式\u003c/h3\u003e\n\u003cp\u003e目前 \u003ca href=\"https://redis.io/docs/management/persistence/\"\u003eRedis Documentation\u003c/a\u003e 上对持久化的支持有以下几种方案:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eRDB (Redis Database): 将某个时间点上的数据生成快照 (snapshot) 并保存到硬盘上\u003c/li\u003e\n\u003cli\u003eAOF (Append Only File): 将每个接收到的写操作记录到硬盘上, 这些操作可以在 Redis 重启时被重放, 并用于重新构建 Redis 数据库\u003c/li\u003e\n\u003cli\u003eRDB + AOF: AOF 和 RDB 的混合模式\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"rdb\"\u003eRDB\u003c/h1\u003e\n\u003cp\u003eRDB 指对整个数据集在特定时间点生成快照 (point-to-time snapshot), 可用于Redis的数据备份, 转移和恢复. 它是 Redis 默认使用的持久化方案.\u003c/p\u003e\n\u003ch2 id=\"工作原理\"\u003e工作原理\u003c/h2\u003e\n\u003cp\u003eRDB 利用操作系统提供的\u003ca href=\"https://en.wikipedia.org/wiki/Copy-on-write\"\u003e写时复制\u003c/a\u003e (Copy-on-Write) 机制来进行持久化, 即当主进程 P fork 出子进程时 Q 时, Q 和 P 共享同一块内存空间, 当 P 准备对某块内存进行写操作时, P 会将这块内存页进行复制, 并在新的副本上对数据进行修改, 而 Q 仍然读取原先的内存页. 这样既能够保证 Redis 实例继续服务外部流量, 又能够以最小的成本完成数据的持久化. 但正因如此, 持久化过程中的写操作是不会被记录的.\u003c/p\u003e","title":"Redis 持久化机制: RDB 和 AOF"},{"content":"Disaster Recovery Architecture on AWS [TOC]\nThe downtime of software systems could have a significant impact on business, customer satisfaction, reputation, or income of the company. Thus maintaining the availability and durability must be the most crucial part of a software system. Disaster recovery (DR) helps engineers prepare for disaster events. This post summaries the architecture for DR on AWS.\nDR objectives There are two key objectives:\nRecovery time objective (RTO): The maximum time range between service collapse and service restoration. It represents how quickly the service could be restarted.\nRecovery point objective (RPO): The maximum time range between data being last backed up and the disaster happening. It represents how much loss of data is acceptable.\nWe can observe from the figure above that the lower RTO and RPO are, the less recovery time and less loss of data could be. But in the meanwhile, lower RTO and RPO also take more resources, e.g, redundancy, money, and operational complexity. Therefore we need to decide on the appropriate RTO and RPO values that suites the best for our services.\nDR strategies AWS offers four strategies for DR, as shown below.\nWe can observe from the figure that there are 3 types of active/passive strategies: Backup \u0026amp; Restore, Pilot Light, Warm Standby, and 1 type of active/active strategy: Multi-site active/active.\nActive/passive vs. active/active DR strategies Active/passive strategy From the figure below, we can see how active/passive DR strategy works.\nAll traffic goes to a single AWS region called Active Region. If a disaster event occurs and the Active Region goes down, then the region where standby servers are located becomes the Recovery Region. All traffic will be switched to be routed to Recovery Region, and the workload can now operate from Recovery Region. This process is called failover.\nThe 3 types of active-passive strategies are distinguished by how tight the RTO/RPO objectives should be, but for any type, the infrastructure should be fully or partially deployed in the Recovery Region before failover.\nActive/active strategy From the figure below, we can see how active/active DR strategy works.\nTwo or more regions are actively accepting requests, and data is replicated between these two regions. When any region undergoes a disaster event, failover happens and the traffic for that Region is routed to the remaining regions.\nStrategies Backup \u0026amp; Restore Backup and Restore strategy is a suitable approach for mitigating against data loss/corruption. This approach confronts a regional disaster event by replicating/mirroring data to other AWS Regions periodically, e.g. each 1 hour. For utilizing the data backup, the data layer and the application layer in the service architecture should be separated.\nThis strategy lowers cost and is relatively easy to implement, and these features make it a good choice for many AWS workloads.\nPilot Light and Warm Standby Pilot Light and Warm Standby strategies both offer a good balance of benefits and costs. The traffic is routed to Active Region originally, and fallback turns the traffic to Recovery Region when disaster event occurs.\nThe similarity between these two strategies is that both include an environment in the Recovery Region with copies of Active Region assets. The distinctions are that pilot light cannot process requests without additional action taken first, whereas warm standby can handle traffic immediately. The pilot light approach requires manual operations to turn on servers, and possibly deploy additional infrastructure, whereas for warm standby everything is already deployed and running, and what we need to consider is whether we should scale up or not. Use RTO and RPO objectives to help choose between these approaches.\nMulti-Site Active/Active With Multi-Site Active/Active strategy, each Region hosts a highly available workload stack, and each stack serves production traffic from where it is deployed. With a multi-site active/active approach, users are able to access the workload in any of the Regions in which it is deployed. This approach is the most complex and costly one, but it can reduce recovery time to an extremely low level.\nIf the workload cannot operate in a region, failover will route traffic away from the impacted Region to healthy Regions. We can use Route 53 or Global Accelerator for routing and failover. Consider the multi-site active/active strategy for our workload if we require the lowest RTO lowest the RPO objectives.\nConclusion There is no absolute best strategy to handle disaster events for any circumstance, we may need to analyze the business needs, the expenditure, the benefits, and the risks of applying each strategy to our business.\nFor more about DR, refer to Disaster recovery options in the cloud\n","permalink":"https://prov1dence.top/posts/disaster-recovery-architecture-on-aws/disaster-recovery-architecture-on-aws-9b3dc135d29c47acbfe19084c57035d5/","summary":"\u003ch1 id=\"disaster-recovery-architecture-on-aws\"\u003eDisaster Recovery Architecture on AWS\u003c/h1\u003e\n\u003cp\u003e[TOC]\u003c/p\u003e\n\u003cp\u003eThe downtime of software systems could have a significant impact on business, customer satisfaction, reputation, or income of the company. Thus maintaining the availability and durability must be the most crucial part of a software system. Disaster recovery (DR) helps engineers prepare for disaster events. This post summaries the architecture for DR on AWS.\u003c/p\u003e\n\u003ch2 id=\"dr-objectives\"\u003eDR objectives\u003c/h2\u003e\n\u003cp\u003eThere are two key objectives:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eRecovery time objective (RTO)\u003c/strong\u003e: The maximum time range between service \u003cstrong\u003ecollapse\u003c/strong\u003e and service \u003cstrong\u003erestoration\u003c/strong\u003e. It represents \u003cstrong\u003ehow quickly the service could be restarted\u003c/strong\u003e.\u003c/p\u003e","title":"Disaster Recovery Architecture on AWS"},{"content":"Git Reference HEAD 用法 HEAD 最后一次 commit\nHEAD^ 倒数第二次 commit\nHEAD^^ 倒数第三次 commit，以此类推\nHEAD~0 最后一次 commit\nHEAD~1 倒数第二次 commit\nHEAD^2 倒数第三次 commit，以此类推\n回到以前的某次 commit git reflog # Reference logs 记录了本地仓库每一次更新分支的操作 git reset HEAD@{index} # 回到某一次提交，把文件修改留在工作区 git reset hash --hard # 加上 --hard 可以忽略掉所有文件修改 在最后一次 commit 的基础上添加部分改动 git add . # 把改动添加到暂存区 git commit --amend # git commit --amend --no-edit # 加上 --no-edit 如果最后一次 commit 已经 push 到 remote，那么在再次 push 的时候需要加上 -f\n在以前的某次 commit 的基础上添加部分改动 git log # 找到要修改的 commit 的前一次 git rebase -i hash # 将 HEAD 移到需要修改的 commit 上 (vim) R edit # 将首行的 pick 改成 edit，保存退出 # 修改文件 git add . git commit --amend # 追加改动到这次 commit 上 git rebase --continue # 恢复 HEAD 把未 commit 的修改移动到其他分支上 git reset HEAD~ --soft # 撤销最后一次 commit 操作，但是保留文件修改 git stash git checkout another-branch git stash pop git add . git commit -m \u0026#34;your message here\u0026#34; 把某一次 commit 添加到其他分支上 git log # 找到需要移动的 commit 的 hash git checkout another-branch git cherry-pick hash # 把对应的 commit 应用到当前的 branch 撤销某次 commit git log # 找到需要撤销的 commit 的 hash git revert hash # 撤销对应的改动并直接 commit 撤销某次 commit 的某个文件 git log # 找到需要撤销的 commit 的 hash git checkout hash -- path/to/file # 把修改之前的文件添加到工作区 git commit -m \u0026#34;your message here\u0026#34; 放弃治疗 git fetch origin git checkout master git reset --hard origin/master git clean -d --force # 删除工作区所有 untracked 的文件和目录 或者\ncd .. rm -r repo-name git clone https://some.github.url/repo-name cd repo-name 删除 branch git branch -d branch-name # 删除本地分支 git push origin -d branch-name # 删除 origin 的分支 ","permalink":"https://prov1dence.top/posts/version-control/git/","summary":"\u003ch1 id=\"git-reference\"\u003eGit Reference\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"git-basic\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/version-control/git-basic.jpeg\"\u003e\u003c/p\u003e\n\u003ch2 id=\"head-用法\"\u003eHEAD 用法\u003c/h2\u003e\n\u003cp\u003eHEAD 最后一次 commit\u003c/p\u003e\n\u003cp\u003eHEAD^ 倒数第二次 commit\u003c/p\u003e\n\u003cp\u003eHEAD^^ 倒数第三次 commit，以此类推\u003c/p\u003e\n\u003cp\u003eHEAD~0 最后一次 commit\u003c/p\u003e\n\u003cp\u003eHEAD~1 倒数第二次 commit\u003c/p\u003e\n\u003cp\u003eHEAD^2 倒数第三次 commit，以此类推\u003c/p\u003e\n\u003ch2 id=\"回到以前的某次-commit\"\u003e回到以前的某次 commit\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit reflog \u003cspan style=\"color:#75715e\"\u003e# Reference logs 记录了本地仓库每一次更新分支的操作\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit reset HEAD@\u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003eindex\u003cspan style=\"color:#f92672\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 回到某一次提交，把文件修改留在工作区\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit reset hash --hard \u003cspan style=\"color:#75715e\"\u003e# 加上 --hard 可以忽略掉所有文件修改\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"在最后一次-commit-的基础上添加部分改动\"\u003e在最后一次 commit 的基础上添加部分改动\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit add . \u003cspan style=\"color:#75715e\"\u003e# 把改动添加到暂存区\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit commit --amend \u003cspan style=\"color:#75715e\"\u003e#\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit commit --amend --no-edit \u003cspan style=\"color:#75715e\"\u003e# 加上 --no-edit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果最后一次 commit 已经 push 到 remote，那么在再次 push 的时候需要加上 -f\u003c/p\u003e\n\u003ch2 id=\"在以前的某次-commit-的基础上添加部分改动\"\u003e在以前的某次 commit 的基础上添加部分改动\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit log \u003cspan style=\"color:#75715e\"\u003e# 找到要修改的 commit 的前一次\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit rebase -i hash \u003cspan style=\"color:#75715e\"\u003e# 将 HEAD 移到需要修改的 commit 上\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003evim\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e R edit \u003cspan style=\"color:#75715e\"\u003e# 将首行的 pick 改成 edit，保存退出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 修改文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit add .\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit commit --amend \u003cspan style=\"color:#75715e\"\u003e# 追加改动到这次 commit 上\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit rebase --continue \u003cspan style=\"color:#75715e\"\u003e# 恢复 HEAD\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"把未-commit-的修改移动到其他分支上\"\u003e把未 commit 的修改移动到其他分支上\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit reset HEAD~ --soft \u003cspan style=\"color:#75715e\"\u003e# 撤销最后一次 commit 操作，但是保留文件修改\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit stash\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit checkout another-branch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit stash pop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit add .\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit commit -m \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;your message here\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"把某一次-commit-添加到其他分支上\"\u003e把某一次 commit 添加到其他分支上\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit log \u003cspan style=\"color:#75715e\"\u003e# 找到需要移动的 commit 的 hash\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit checkout another-branch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit cherry-pick hash \u003cspan style=\"color:#75715e\"\u003e# 把对应的 commit 应用到当前的 branch\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"撤销某次-commit\"\u003e撤销某次 commit\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit log \u003cspan style=\"color:#75715e\"\u003e# 找到需要撤销的 commit 的 hash\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit revert hash \u003cspan style=\"color:#75715e\"\u003e# 撤销对应的改动并直接 commit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"撤销某次-commit-的某个文件\"\u003e撤销某次 commit 的某个文件\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit log \u003cspan style=\"color:#75715e\"\u003e# 找到需要撤销的 commit 的 hash\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit checkout hash -- path/to/file \u003cspan style=\"color:#75715e\"\u003e# 把修改之前的文件添加到工作区\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit commit -m \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;your message here\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"放弃治疗\"\u003e放弃治疗\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit fetch origin\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit checkout master\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit reset --hard origin/master\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit clean -d --force \u003cspan style=\"color:#75715e\"\u003e# 删除工作区所有 untracked 的文件和目录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e或者\u003c/p\u003e","title":"Git Reference"},{"content":"使用 Mac Mini M1 作为软路由让全家设备出国 [TOC]\n本文介绍如何将功耗超低的 Mac Mini M1 改造为软路由，让局域网内连上 Wi-Fi 的所有家庭设备都可以免设置直接出国。\n代理客户端 首先需要下载一个可以运行在 M1 上的代理客户端，推荐使用 Surge 或者 ClashX Pro，前者买断价格较贵（每个 Mac 设备 $49.99），后者免费，本文以后者为例。\n配置 一般机场会提供 Clash 的订阅链接，如果没有可以自行搜索 ssr/v2ray 转 clash 的第三方订阅转换服务，生成 Clash 订阅链接。\n有了订阅链接之后，点击顶部菜单栏的 Clash 图标 -\u0026gt; Config -\u0026gt; Remote config -\u0026gt; Manage 管理订阅。\n点击 Add，在 Url 中输入订阅链接，Config Name 可以任意填。\n除此之外还要勾选 Clash 图标里的 Set as system proxy 和 Enhanced Mode 两个选项，这样才能保证 Mac Mini M1 能够成为网关。\n设置网关 到此 Mac Mini M1 已经可以成功地出国了，现在将 Mac Mini M1 作为网管，对路由器上的所有流量进行代理。\n首先将路由器和 Mac Mini M1 使用网线连接，用 Wi-Fi 连接会不太稳定。\n现在打开 System Preference -\u0026gt; Network -\u0026gt; Ethernet，在 Configure IPv4 中关闭 DHCP，选择 Manually 为 Mac Mini M1 设置一个固定 IP，这个 IP 必须和路由器在同一个网段，例如路由器的 IP 是 192.168.0.1，那么 Mac Mini M1 的 IP 就只需要将最后一位改为 2～255 里的数字，并且要避免和其他开启 DHCP 的设备冲突。\n现在打开路由器的设置页面，每个厂商的页面地址都不相同，例如小米路由器的后台 URL 是 miwifi.com，TP-Link 的 URL 是 tplogin.cn，以后者为例。选择路由设置 -\u0026gt; DHCP 服务器，将网关、首选 DNS 服务器、备用 DNS 服务器都修改为刚才设置的 Mac Mini M1 的 IPv4 地址。\n点击保存之后，局域网 Mesh 下的所有设备都可以成功出国了。\nOne more thing Mac Mini M1 作为路由器网关在休眠后，整个 Wi-Fi 都会瘫痪，所以要勾选 System Preference -\u0026gt; Energy Saver 里的 Prevent your Mac from automatically sleeping when the display is off。\n","permalink":"https://prov1dence.top/posts/proxy/soft-router/","summary":"\u003ch1 id=\"使用-mac-mini-m1-作为软路由让全家设备出国\"\u003e使用 Mac Mini M1 作为软路由让全家设备出国\u003c/h1\u003e\n\u003cp\u003e[TOC]\u003c/p\u003e\n\u003cp\u003e本文介绍如何将功耗超低的 Mac Mini M1 改造为软路由，让局域网内连上 Wi-Fi 的所有家庭设备都可以免设置直接出国。\u003c/p\u003e\n\u003ch2 id=\"代理客户端\"\u003e代理客户端\u003c/h2\u003e\n\u003cp\u003e首先需要下载一个可以运行在 M1 上的代理客户端，推荐使用 Surge 或者 \u003ca href=\"https://install.appcenter.ms/users/clashx/apps/clashx-pro/distribution_groups/public\"\u003eClashX Pro\u003c/a\u003e，前者买断价格较贵（每个 Mac 设备 $49.99），后者免费，本文以后者为例。\u003c/p\u003e\n\u003ch2 id=\"配置\"\u003e配置\u003c/h2\u003e\n\u003cp\u003e一般机场会提供 Clash 的订阅链接，如果没有可以自行搜索 ssr/v2ray 转 clash 的第三方订阅转换服务，生成 Clash 订阅链接。\u003c/p\u003e\n\u003cp\u003e有了订阅链接之后，点击顶部菜单栏的 Clash 图标 -\u0026gt; Config -\u0026gt; Remote config -\u0026gt; Manage 管理订阅。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"ClashX Pro config manage\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/proxy/ClashX-Pro-config-manage.png\"\u003e\u003c/p\u003e\n\u003cp\u003e点击 Add，在 Url 中输入订阅链接，Config Name 可以任意填。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Add a remote config\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/proxy/Add-a-remote-config.png\"\u003e\u003c/p\u003e\n\u003cp\u003e除此之外还要勾选 Clash 图标里的 Set as system proxy 和 Enhanced Mode 两个选项，这样才能保证 Mac Mini M1 能够成为网关。\u003c/p\u003e","title":"使用 Mac Mini M1 作为软路由让全家设备科学上网"},{"content":"工作两年总结 2019 年参加腾讯的暑期实习面试认识了现在的总监，那段时间退租了原有的公寓寄宿在同学家里，面试当天又刚参加完 GoogleCloudOnBoard 在回去的路上，整个面试的过程非常仓促，气喘吁吁地拿着手机跟面试官打了两小时微信语音，虽然后来计划有变并没有在假期回国实习，但也因此获得了之后校招被总监直接内推到现在项目组的机会。于是后来在经历了四轮技术面试之后，某天在图书馆突然接到总监的微信语音，接着又是 HR 的沟通电话，才在回国的几个月前确定了要来深圳的天美。\n两年的时间里经历了很多工作和生活上的试错和反馈，在此尝试总结和反思。\nimpact 刚上班的时候，认为工作无非就是做好老板安排的事情，月底的时候老板为你在这个月完成工作所付出的时间支付等价的薪资。那么理所应当地，如果你每天花更多的时间在工作上，每天加班到晚上 10 点，周六周日不间断工作，为老板创造更多的收益，那么老板就会更乐意为你支付更高的薪资，这也是为什么国内会有那么多人乐此不疲地内卷的原因。\n实际上有些人虽然每天从不加班到点就走，不仅能拿到高绩效和更多的奖金，还能创造出很大的 impact。用李开复的话来说，impact 就是世界有你和没有你之间的区别。举个例子，你女朋友很爱去图书馆自习室，需要每天晚上 9 点登录学校图书馆网站，预约第二天的自习室名额，如果你花几小时写个脚本放在服务器上每天定时自动抢名额，为她省下了每天那几分钟的时间和精力，那么（为她每天省下的时间和精力 * 天数）就是你写脚本这件事的 impact；同时你还可以顺带把脚本给你爱学习的朋友们用，那么这个数值还可以乘上使用的人数。套用李沐大神的定义，impact 等于（受益人数 * 人均时间 * 单位时间价值差），单位时间价值差取决于你对这件事完成的好坏，如果有人写了一个更易用，响应更快的新的脚本，你的朋友们都去用这个新脚本了，那么这个脚本开发者创造的单位时间价值差就比你高。无论是工作产出、技术分享、指导新人、为团队规划和确定方向，都可以套用这个公式，来评判自己创造的 impact，提高创造 impact 的能力比不断付出劳动时间更能带来持续性收益。\n后台开发 后台开发无非两部分：增删改查和高并发架构，前者需要数据结构和算法的知识，后者需要系统设计的能力，包括缓存设计、云原生、异步存储、数据拆分之类的。而游戏后台相较于互联网还多出了有状态服务和延迟敏感两个特点，并且在系统设计方面也有很大的细分差异。\n游戏后台习惯于先在内存上读写数据，再把有状态的内存数据持久化到 db，而不是每次都去操作 cache / db，这和现在的互联网后台架构的“业务逻辑和数据分离”的指导思想有很大的区别。\n服务器上云依靠 service mesh 进行通信，sidecar 注入和劫持流量，拿到数据包之后还要考虑做零拷贝来降低单机延迟，经过这些步骤之后如果延迟是 100ms ，对互联网业务来说或许是可以接受的，但对手游来说已经几乎高到无法容忍了；除此之外把功能不同的模块拆分成微服务后，还会极大地增加不同模块间通信的网络开销。\n游戏后台进行云上扩缩容还要考虑 k8s 资源调度的效率，有状态服务的迁移流程，迁移时要保证不可服务的时间和粒度尽量小。\n不同的业务有各自的刚需和痛点，把这些互联网时代催生的技术应用到游戏业务上时也要结合其对产品的价值来进行相应的调整，而不是生搬硬套。\n游戏行业 2021 年的未成年人保护法和版号停发让国内各家游戏公司都在推进所谓精品化和出海两个方案。\n因为版号少了，游戏公司一方面要投入更多资源到长线运营，也就是氪金上来保证现金流，另一方面只能保守地复制成功经验（moba，卡牌，打枪）来抢存量市场保证新游戏不会没人玩。长此以往玩家逐渐审美疲劳，也就遏制了青少年玩家对于游戏的兴趣，有关部门也能逐步加大力度断绝国内游戏行业的前途，最后再将其连根拔起，从此没了教培和游戏，年轻人也就能专心谈恋爱，从而提高生育率，解决人口危机了。\n至于出海，目前有资金和技术储备跟海外厂商直接竞争的国内游戏公司也就只有腾讯了，不过对有关部门来说，制裁一个公司可比监管整个行业简单多了。\n技术和产品 游戏后台最重视 n 个 9 的高可用，最害怕上线之后出现 bug。这两年里印象最深的外网 bug 有两次，一次是入职半年做 crud 时，因为没有仔细阅读文件里的多个名称相近的接口导致调用了错误的一个；另一次是某个元旦凌晨上线的功能，因为错误地估计了某个途径获取的数据条目数量导致预留的数组长度不够，后者在当时登陆高峰的时间段内造成了短暂的不可用。这些当然都不是因为技术水平不够，但确实会对个人口碑造成实实在在的打击。以前刷题或者竞赛时如果遇到这种小问题，最严重的后果无非是 ac 率降低和 5 分钟的罚时，但一旦转换到工作上，由于对技术审查的不严谨则会非常严重的影响产品和整个团队。\n员工和公司 刚上班时会把公司当作学校，把工位当作图书馆或者实验室，手头没工作并且又没其他私事的时候，包括工作日晚上和周末，就喜欢在工位上看书学习。长此以往会牺牲不少个人生活的时间，同时也会让同事和经理都认为你是一个非常卷的人，从而影响对你工作态度和结果的评价，所以只要跟工作无关的活动一律不应在公司进行。\n员工与公司之间的劳资关系也会影响工作效率。在互联网企业里劳资关系无非是简单的雇佣或合作关系，但腾讯的很多部门，尤其是在司庆到春节的一段时间里，喜欢以“家人们”来互相称呼，听到的时候会让人非常反感，这并不是健康的劳资关系。\n刚入职的时候毛星云大神坐在离我不到 10 米的地方，经常和客户端开发的同事们有说有笑，或是讨论技术。他出事之后办公室里的几百号人却像无事发生过一样，大都自顾自地重复着前一天的动作，不免让人感到残酷和凄凉。大二的时候要不是偶然间搜到浅墨在 CSDN 上的 DX 教程，可能我的计算机图形学也就挂了。引用 Youtuber Vincent Chan 的一段想法：\nOne day he stopped showing up. I thought he was just on vacation, but then a week went by, a month went by, and there\u0026#39;s still nothing. I have no idea what happened. He could quit, he could have been fired. What was weird was that nothing changed, everything was exactly the same. People went to the office, people left the office. It was as if he never existed within these walls ever. I knew in the back of my head that a company is not going to stop running just because someone isn\u0026#39;t there anymore but I felt really weird to witness this firsthand that someone that you\u0026#39;ve seen every day just disappeared and nothing changed. We are all replaceable, every single one of us. You\u0026#39;re really only as good as the hours of life that you can give to the company. Once you can\u0026#39;t give them any more hours, they\u0026#39;ll find someone else who can. 生活和房价 在深圳谈生活确实是件挺滑稽的事，这里的人从不像上海人一样讨论茂悦大酒店楼上酒吧看到的陆家嘴夕阳和夜景，或是约着周末去乍浦路桥的机位拍片。2020 年时大家只会讨论股票、基金、房地产，现在几乎已经闭口不谈了，大多只关心本地和香港的疫情，以及比以往更冷的寒冬。\n深圳的房产均价是高于北京和上海的，大部分深圳人都无法通过不吃不喝 30 年来购置一套房产，离开福田 CBD 走几步就能进入旁边均价十万的城中村，非常魔幻。但随着棚改货币化跟涨价去库存的结束和货币政策的转向，房产这种长线期货的价格也已经过了本轮经济周期的顶峰，不过政府当然不会放任这个对国内经济起决定性带动作用的市场崩盘从而引发金融危机，所以一定会持续通过行政手段，例如限购、限贷、房产税等来尝试消化泡沫，不过这种尝试就连美国和日本都没能成功，祝愿我们的伟大祖国能够实现。\n总结 做阶段性总结的时候一个比较具有指导意义的问题就是如果重来一遍，哪些选择会做出改变？改变之后会带来什么影响？想明白之后就可以翻篇继续向前了。\n希望未来能够专注在学习和成长上，做出新的突破吧。\n","permalink":"https://prov1dence.top/posts/experience/2022/","summary":"\u003ch1 id=\"工作两年总结\"\u003e工作两年总结\u003c/h1\u003e\n\u003cp\u003e2019 年参加腾讯的暑期实习面试认识了现在的总监，那段时间退租了原有的公寓寄宿在同学家里，面试当天又刚参加完 GoogleCloudOnBoard 在回去的路上，整个面试的过程非常仓促，气喘吁吁地拿着手机跟面试官打了两小时微信语音，虽然后来计划有变并没有在假期回国实习，但也因此获得了之后校招被总监直接内推到现在项目组的机会。于是后来在经历了四轮技术面试之后，某天在图书馆突然接到总监的微信语音，接着又是 HR 的沟通电话，才在回国的几个月前确定了要来深圳的天美。\u003c/p\u003e\n\u003cp\u003e两年的时间里经历了很多工作和生活上的试错和反馈，在此尝试总结和反思。\u003c/p\u003e\n\u003ch2 id=\"impact\"\u003eimpact\u003c/h2\u003e\n\u003cp\u003e刚上班的时候，认为工作无非就是做好老板安排的事情，月底的时候老板为你在这个月完成工作所付出的时间支付等价的薪资。那么理所应当地，如果你每天花更多的时间在工作上，每天加班到晚上 10 点，周六周日不间断工作，为老板创造更多的收益，那么老板就会更乐意为你支付更高的薪资，这也是为什么国内会有那么多人乐此不疲地内卷的原因。\u003c/p\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/experience/1.PNG\" alt=\"1\" width=\"400\"/\u003e\n\u003cp\u003e实际上有些人虽然每天从不加班到点就走，不仅能拿到高绩效和更多的奖金，还能创造出很大的 impact。用李开复的话来说，impact 就是世界有你和没有你之间的区别。举个例子，你女朋友很爱去图书馆自习室，需要每天晚上 9 点登录学校图书馆网站，预约第二天的自习室名额，如果你花几小时写个脚本放在服务器上每天定时自动抢名额，为她省下了每天那几分钟的时间和精力，那么（为她每天省下的时间和精力 * 天数）就是你写脚本这件事的 impact；同时你还可以顺带把脚本给你爱学习的朋友们用，那么这个数值还可以乘上使用的人数。套用李沐大神的定义，impact 等于（受益人数 * 人均时间 * 单位时间价值差），单位时间价值差取决于你对这件事完成的好坏，如果有人写了一个更易用，响应更快的新的脚本，你的朋友们都去用这个新脚本了，那么这个脚本开发者创造的单位时间价值差就比你高。无论是工作产出、技术分享、指导新人、为团队规划和确定方向，都可以套用这个公式，来评判自己创造的 impact，提高创造 impact 的能力比不断付出劳动时间更能带来持续性收益。\u003c/p\u003e\n\u003ch2 id=\"后台开发\"\u003e后台开发\u003c/h2\u003e\n\u003cp\u003e后台开发无非两部分：增删改查和高并发架构，前者需要数据结构和算法的知识，后者需要系统设计的能力，包括缓存设计、云原生、异步存储、数据拆分之类的。而游戏后台相较于互联网还多出了有状态服务和延迟敏感两个特点，并且在系统设计方面也有很大的细分差异。\u003c/p\u003e\n\u003cp\u003e游戏后台习惯于先在内存上读写数据，再把有状态的内存数据持久化到 db，而不是每次都去操作 cache / db，这和现在的互联网后台架构的“业务逻辑和数据分离”的指导思想有很大的区别。\u003c/p\u003e\n\u003cp\u003e服务器上云依靠 service mesh 进行通信，sidecar 注入和劫持流量，拿到数据包之后还要考虑做零拷贝来降低单机延迟，经过这些步骤之后如果延迟是 100ms ，对互联网业务来说或许是可以接受的，但对手游来说已经几乎高到无法容忍了；除此之外把功能不同的模块拆分成微服务后，还会极大地增加不同模块间通信的网络开销。\u003c/p\u003e\n\u003cp\u003e游戏后台进行云上扩缩容还要考虑 k8s 资源调度的效率，有状态服务的迁移流程，迁移时要保证不可服务的时间和粒度尽量小。\u003c/p\u003e\n\u003cp\u003e不同的业务有各自的刚需和痛点，把这些互联网时代催生的技术应用到游戏业务上时也要结合其对产品的价值来进行相应的调整，而不是生搬硬套。\u003c/p\u003e\n\u003ch2 id=\"游戏行业\"\u003e游戏行业\u003c/h2\u003e\n\u003cp\u003e2021 年的未成年人保护法和版号停发让国内各家游戏公司都在推进所谓精品化和出海两个方案。\u003c/p\u003e\n\u003cp\u003e因为版号少了，游戏公司一方面要投入更多资源到长线运营，也就是氪金上来保证现金流，另一方面只能保守地复制成功经验（moba，卡牌，打枪）来抢存量市场保证新游戏不会没人玩。长此以往玩家逐渐审美疲劳，也就遏制了青少年玩家对于游戏的兴趣，有关部门也能逐步加大力度断绝国内游戏行业的前途，最后再将其连根拔起，从此没了教培和游戏，年轻人也就能专心谈恋爱，从而提高生育率，解决人口危机了。\u003c/p\u003e\n\u003cp\u003e至于出海，目前有资金和技术储备跟海外厂商直接竞争的国内游戏公司也就只有腾讯了，不过对有关部门来说，制裁一个公司可比监管整个行业简单多了。\u003c/p\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/experience/2.PNG\" alt=\"2\" width=\"400\"/\u003e\n\u003ch2 id=\"技术和产品\"\u003e技术和产品\u003c/h2\u003e\n\u003cp\u003e游戏后台最重视 n 个 9 的高可用，最害怕上线之后出现 bug。这两年里印象最深的外网 bug 有两次，一次是入职半年做 crud 时，因为没有仔细阅读文件里的多个名称相近的接口导致调用了错误的一个；另一次是某个元旦凌晨上线的功能，因为错误地估计了某个途径获取的数据条目数量导致预留的数组长度不够，后者在当时登陆高峰的时间段内造成了短暂的不可用。这些当然都不是因为技术水平不够，但确实会对个人口碑造成实实在在的打击。以前刷题或者竞赛时如果遇到这种小问题，最严重的后果无非是 ac 率降低和 5 分钟的罚时，但一旦转换到工作上，由于对技术审查的不严谨则会非常严重的影响产品和整个团队。\u003c/p\u003e\n\u003ch2 id=\"员工和公司\"\u003e员工和公司\u003c/h2\u003e\n\u003cp\u003e刚上班时会把公司当作学校，把工位当作图书馆或者实验室，手头没工作并且又没其他私事的时候，包括工作日晚上和周末，就喜欢在工位上看书学习。长此以往会牺牲不少个人生活的时间，同时也会让同事和经理都认为你是一个非常卷的人，从而影响对你工作态度和结果的评价，所以只要跟工作无关的活动一律不应在公司进行。\u003c/p\u003e\n\u003cp\u003e员工与公司之间的劳资关系也会影响工作效率。在互联网企业里劳资关系无非是简单的雇佣或合作关系，但腾讯的很多部门，尤其是在司庆到春节的一段时间里，喜欢以“家人们”来互相称呼，听到的时候会让人非常反感，这并不是健康的劳资关系。\u003c/p\u003e\n\u003cp\u003e刚入职的时候毛星云大神坐在离我不到 10 米的地方，经常和客户端开发的同事们有说有笑，或是讨论技术。他出事之后办公室里的几百号人却像无事发生过一样，大都自顾自地重复着前一天的动作，不免让人感到残酷和凄凉。大二的时候要不是偶然间搜到浅墨在 CSDN 上的 DX 教程，可能我的计算机图形学也就挂了。引用 Youtuber \u003ca href=\"https://www.youtube.com/c/Vincentc\"\u003eVincent Chan\u003c/a\u003e 的一段想法：\u003c/p\u003e","title":"工作两年总结"},{"content":"《深入理解 RPC 框架原理与实现》读书笔记 概念 RPC (Remote Procedure Call) 叫作远程过程调用，它是利用网络从远程计算机上请求服务：可以理解为把程序的一部分放到其他远程计算机上执行。通过网络通信将调用请求发送至远程计算机后，利用远程计算机的系统资源执行这部分程序，最终返回远程计算机上的执行结果。\n将“远程过程调用”概念分解为“远程过程”和“过程调用”来理解更加直观：\n远程过程：远程过程是相对于本地过程而言的，本地过程也可以认为是本地函数调用，发起调用的方法和被调用的方法都在同一个地址空间或者内存空间内。而远程过程是指把进程内的部分程序逻辑放到其他机器上，也就是现在常说的业务拆解，让每个服务仅对单个业务负责，让每个服务具备独立的可扩展性、可升级性，易维护。在每个机器上提供的服务被称为远程过程，这个概念使正确地构建分布式计算更加容易，为后续的服务化架构风格奠定了基础\n过程调用：这个概念非常通俗易懂，它包含我们平时见到的方法调用、函数调用，并且用于程序的控制和数据的传输。而当“过程调用”遇到 “远程过程”时，意味着过程调用可以跨越机器、网络进行程序的控制和数据的传输\n选型 RPC 选型的衡量角度\n使用 RPC 框架无非三个选择\n自研RPC框架，可以从投开始设计一款符合业务特征和场景的 RPC 框架，但是自研框架需要有足够的资金和人力支持 基于开源的 RPC框架进行改造，让改造后的 RPC 框架更加适合业务场景。这种做法相较于第一种做法，人力成本没有那么高。但是这种做法需要经常与开源社区保持同步更新，一旦不再和社区版本同步，也许到某一个版本后，公司内部改造的 RPC 框架再也不能合并社区最新版本的特性，这种现象最终会导致慢慢向第一种选择选择靠近 完全使用开源的 RPC框架，并且定期与社区版本进行同步。这种选择的好处在于要投人的人力威本最低，一些问题可以借助社区的力量进行解决。但是由于业务场景的不同直接将开源的 RPC 框架拿过来用，这种选择往往存在很多局限性。框架各部分的设计都是为了更加优雅地解决业务场景的问题，而不是反过来让业务场景去适应 RPC 框架。而且 RPC 框架有自己的定位及未来的规划，所以很多规模不是太小的公司都选择在 RPC 框架上做些许改造来适应自己的业务场景 Java 对 I/O 模型的封装 NIO Java NIO 中最核心的就是 selector， 每当连接事件、接收连接事件、读事件和写事件中的一种事件就绪时，相关的事件处理器就会执行对应的逻辑，这种基于事件驱动的模式叫作 Reactor 模式。Reactor模式的核心思想就是减少线程的等待。当遇到需要等待的 IO 操作时，先释放资源，而在 IO 操作完成时，再通过事件驱动的方式，继续接下来的处理，这样从整体上减少了资源的消耗。\n以下是 Reactor模式的五种重要角色：\nHandle（在 Linux 下称为描述符）：它是资源在操作系统层面上的一种抽象，表示一种由操作系统提供的资源，比如前面提到的网络编程中的 socket 描达符或者文件描达符。该资源与事件绑定在一起，也可用于表示一个个事件，比如前面提到的客户端的连接事件、服务端的接收连接事件、写数据事件等 Synchronous Event Demultiplexer（同步事件分离器）：Handle 代表的事件会被班注册到同步事件分离器上，当事件就绪时，同步事件分离器会分发和处理这些事件。它的本质是一个系统调用，用于等待事件的发生。调用方在调用它的时候会被阻塞，一直到同步事件分离器上有时间就绪为止。在 Linux 中，同步事件分离器就是常用的 I/O 多路复用，比如 select, poll, epoll 等系统调用，用来等待一个或多个事件发生。在 Java NIO 领域中，同步事件分离器对应的组件就是 Selector，对应的阻塞方法就是 select 方法 Event Handler（事件处理器）：它由多个回调方法构成，这些回调方法就是对某个事件的逻辑反馈，事件处理器一般都是抽象接口。比如当 Channel 被注册到 Selector 时的回调方法、连接事件发生时的回调方法、写事件发生时的回调方法等都是事件处理器，我们可以实现这些回调方法来达到对某一个事件进行特定反馈的目的。在 Java NIO 中，并没有提供事件处理器的抽象供我们使用 Concrete Event Handler（具体的事件处理器)：它是事件处理器的实现。它本身实现了事件处理器所提供的各种回调方法，从而实现了特定的业务逻辑。比如针对连接事件需要打印一条日志，就可以在连接事件的回调方法里实现打印日志的逻辑 Initiation Dispatcher（初始分发器）：可以把它看作 Reactor， 它规定了事件的调度策略，并且用于管理事件处理器，提供了事件处理器的注册、删除等方法，事件处理器需要注册到 Initiation Dispatcher 上才能生效。它是整个事件处理器的核心，Initiation Dispatcher 会通过 Synchronous Event Demultiplexer来等待事件的发生。一旦事件发生，Initiation Dispatcher 首先会分离出每一个事件，然后找到相应的事件处理器，最后调用相关的回调方法处理这些事件 Reactor 的三种模型 单 Reactor 单线程模型 单 Reactor 单线程模型就是在设计中只会有一个 Reactor，并且无论与 IO 相关的读/写，还 是与 IO 无关的编/解码或计算，都在一个 Handler 线程上完成。\n单 Reactor 多线程模型 单 Reactor 多线程模型中的多线程指的是处理除了 IO 操作以外的逻辑通过多线程来执行，而IO 的读/写和 Reactor 的处理还是由一个线程执行。\n相对于第一种模型来说，将业务逻辑交给线程池来处理，可以充分利用多核 CPU 的处理能 力，但是 Reactor 用一个线程处理了所有事件的监听和响应，在高并发应用场景下，容易出现性 能瓶颈，所以出现了主从 Rcactor 多线程模型。\n主从 Reactor 多线程模型 当客户端连接数很多，IO 操作频繁时，单 Reactor 就会暴露问题，因为单 Reactor 只能同 步处理 IO 操作，连接事件往往没有读/写事件频繁，当 Reactor 角色在处理读/写事件时，新客 户端的连接事件就会被阻塞，所以它会影响新客户端建立连接的请求，导致连接超时等情况。\n主从 Reactor 多线程模型中专门处理了这个问题。处理连接事件的线程与处理读/写事件的线程隔离，避免了在读/写事件发生较为频繁的情况下影响新客户端连接的问题。在主从 Reactor 多线程模型中存在多个 Reactor, Main Reactor 一般只有一个，它负责监听和处理连接请求，而 Sub Reactor 可以有多个， 用线程池进行管理，Sub Reactor 主要负责监听和处理读/写事件等。当然也可以将 Main Reactor 改为多个，通过线程池管理，但并不是Main Reactor 越多越好，Main Reactor 的数量主要取决 于客户端连接是否频繁。\nAIO AIO 是 Asynchronous I/O 的简称，是 JDK 1.7 之后引入的 Java I/O 新类库，它是 NIO 的升 级版本，提供了异步非阻塞的 IO 操作方式。异步 IO 是基于事件和回调机制实现的，也就是 应用程序发起请求之后会直接返回，不会阻塞，当后台处理完成时，操作系统会通知相应的线 程执行后续的操作。AIO 有两种使用方式：一种是简单的将来式，另一种是回调式。\n将来式：Java 用 Future 类实现将来式，将执行任务交给线程池执行后，执行任务的线程并不会阻塞，它会返回一个 Future 对象，在执行结束后，Future 对象的状态会变成完成。在 Future 对象中可以获得对应的返回值，但是需要调用 get 方法来获取结果。如果结果还没返回，则调用 get 方法的线程就会被阻塞，这无疑跟同步调用相差无几。如果需要及时得到结果，那么这种方式甚至可能比同步调用的效率更低 回调式：Java 提供了 CompletionHandler 作为回调接口，在调用 read, write 等方法时，可以传入 CompletionHandler 的实现作为事件完成的回调接口，这种方式需要用户自行编写回调后的业务逻辑。 因为 Future 的 get 方法会阻塞线程，并且 Future 接口无法实现自动回调，所以在 Java 8 中提供了 CompletableFuture，它既支持原来的 Future 的功能，也支持回调式。除此之外，CompletableFuture 还支持不同 CompletableFuture 间的相互协调或组合，方便了异步 I/O 的开发。\n协议 自定义协议 优势 在设计一个系统时，协议的选型或者设计是至关重要的，相对于 HTTP 这样应用广泛的标淮协议，自定义协议的优势主要在于：\n第一个优势是自定义协议有良好的可扩展性。系统是需要演进和迭代的，一旦后续的演进计划涉及协议层面的变动，扩展性差的协议就会阻塞系统的演进。而自定义协议可以做一些扩展性设计，这样就可以满足根据业务需求和发展进行扩展的需求。像 HTTP 这样的标准协议并不容易扩展，因为它设计的初衷是为了让该协议更加通 用，能够适应各类应用场景 第二个优势是自自定义协议的安全性更高。因为整个传输数据格式都是自定义的，而标准协议的数据格式都是透明且公开的，所以自定义协议可以增强通信的安全性，甚至可以对数据做一些加密处理来保证传输数据的安全性 第三个优势是自定义协议的传输效率更高。协议本身就是数据格式的规则，它会影响一次请求所携带的数据包大小及传输的速度，自定义协议可以根据需要制定高效的且最适合系统本身的协议。当然有的时候可扩展性和高效性会有冲突，这时就需要根据实际场景来做权衡。总体来说自定义协议更具灵活性，但是一个协议的设计和实现的难度是比较大的，如果系统场景比较简单，那么自定义协议反而会增加系统设计的复杂度，延长系统设计和开发的周期，协议自定义的收益可能并不大 步骤 第一步需要明确在设计通信协议时，有两方面需要设计，分别是协议头和协议体，协议头可以认为是携带协议特殊字段的部分，协议体则是我们需要传输的数据实体部分 第二步是设计协议头的必要字段，在设计协议头的必要字段时，需要考虑以下几个必要的字段（命名不是重点，可以随意更换）： version：这里的版本号是指协议版本号，传输携带协议版本号是为了加强协议的兼容性，如果没有该字段，当数据包被解析后，服务端就无法知道客户端用的是哪个版本的协议也就无法实行一些兼容措施 upgrade：该字段是参考 HTTP 中的协议协商机制，该机制是在 HTTP 1.1 中被引入的， 这种机制的灵活性非常大，完美地解决了多版本的协议之间的前后兼容问题。举个例子，HTTP 除了标准的协议，还行生出了其他基于 HTTP 改造的协议，比如 WebSocket 协议等 第三步是确定协议头的编码方式，一种是二进制编码方式，一种是文本编码方式 第四步是确定各个数据位以及每个字段的排列顺序 ","permalink":"https://prov1dence.top/posts/network/rpc/","summary":"\u003ch1 id=\"深入理解-rpc-框架原理与实现读书笔记\"\u003e《深入理解 RPC 框架原理与实现》读书笔记\u003c/h1\u003e\n\u003ch2 id=\"概念\"\u003e概念\u003c/h2\u003e\n\u003cp\u003eRPC (Remote Procedure Call) 叫作远程过程调用，它是利用网络从远程计算机上请求服务：可以理解为把程序的一部分放到其他远程计算机上执行。通过网络通信将调用请求发送至远程计算机后，利用远程计算机的系统资源执行这部分程序，最终返回远程计算机上的执行结果。\u003c/p\u003e\n\u003cp\u003e将“远程过程调用”概念分解为“远程过程”和“过程调用”来理解更加直观：\u003c/p\u003e\n\u003cp\u003e远程过程：远程过程是相对于本地过程而言的，本地过程也可以认为是本地函数调用，发起调用的方法和被调用的方法都在同一个地址空间或者内存空间内。而远程过程是指把进程内的部分程序逻辑放到其他机器上，也就是现在常说的业务拆解，让每个服务仅对单个业务负责，让每个服务具备独立的可扩展性、可升级性，易维护。在每个机器上提供的服务被称为远程过程，这个概念使正确地构建分布式计算更加容易，为后续的服务化架构风格奠定了基础\u003c/p\u003e\n\u003cp\u003e过程调用：这个概念非常通俗易懂，它包含我们平时见到的方法调用、函数调用，并且用于程序的控制和数据的传输。而当“过程调用”遇到 “远程过程”时，意味着过程调用可以跨越机器、网络进行程序的控制和数据的传输\u003c/p\u003e\n\u003ch2 id=\"选型\"\u003e选型\u003c/h2\u003e\n\u003cp\u003eRPC 选型的衡量角度\u003c/p\u003e\n\u003cp\u003e使用 RPC 框架无非三个选择\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e自研RPC框架，可以从投开始设计一款符合业务特征和场景的 RPC 框架，但是自研框架需要有足够的资金和人力支持\u003c/li\u003e\n\u003cli\u003e基于开源的 RPC框架进行改造，让改造后的 RPC 框架更加适合业务场景。这种做法相较于第一种做法，人力成本没有那么高。但是这种做法需要经常与开源社区保持同步更新，一旦不再和社区版本同步，也许到某一个版本后，公司内部改造的 RPC 框架再也不能合并社区最新版本的特性，这种现象最终会导致慢慢向第一种选择选择靠近\u003c/li\u003e\n\u003cli\u003e完全使用开源的 RPC框架，并且定期与社区版本进行同步。这种选择的好处在于要投人的人力威本最低，一些问题可以借助社区的力量进行解决。但是由于业务场景的不同直接将开源的 RPC 框架拿过来用，这种选择往往存在很多局限性。框架各部分的设计都是为了更加优雅地解决业务场景的问题，而不是反过来让业务场景去适应 RPC 框架。而且 RPC 框架有自己的定位及未来的规划，所以很多规模不是太小的公司都选择在 RPC 框架上做些许改造来适应自己的业务场景\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"java-对-io-模型的封装\"\u003eJava 对 I/O 模型的封装\u003c/h2\u003e\n\u003ch3 id=\"nio\"\u003eNIO\u003c/h3\u003e\n\u003cp\u003eJava NIO 中最核心的就是 selector， 每当连接事件、接收连接事件、读事件和写事件中的一种事件就绪时，相关的事件处理器就会执行对应的逻辑，这种基于事件驱动的模式叫作 Reactor 模式。Reactor模式的核心思想就是减少线程的等待。当遇到需要等待的 IO 操作时，先释放资源，而在 IO 操作完成时，再通过事件驱动的方式，继续接下来的处理，这样从整体上减少了资源的消耗。\u003c/p\u003e\n\u003cp\u003e以下是 Reactor模式的五种重要角色：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHandle（在 Linux 下称为描述符）：它是资源在操作系统层面上的一种抽象，表示一种由操作系统提供的资源，比如前面提到的网络编程中的 socket 描达符或者文件描达符。该资源与事件绑定在一起，也可用于表示一个个事件，比如前面提到的客户端的连接事件、服务端的接收连接事件、写数据事件等\u003c/li\u003e\n\u003cli\u003eSynchronous Event Demultiplexer（同步事件分离器）：Handle 代表的事件会被班注册到同步事件分离器上，当事件就绪时，同步事件分离器会分发和处理这些事件。它的本质是一个系统调用，用于等待事件的发生。调用方在调用它的时候会被阻塞，一直到同步事件分离器上有时间就绪为止。在 Linux 中，同步事件分离器就是常用的 I/O 多路复用，比如 select, poll, epoll 等系统调用，用来等待一个或多个事件发生。在 Java NIO 领域中，同步事件分离器对应的组件就是 Selector，对应的阻塞方法就是 select 方法\u003c/li\u003e\n\u003cli\u003eEvent Handler（事件处理器）：它由多个回调方法构成，这些回调方法就是对某个事件的逻辑反馈，事件处理器一般都是抽象接口。比如当 Channel 被注册到 Selector 时的回调方法、连接事件发生时的回调方法、写事件发生时的回调方法等都是事件处理器，我们可以实现这些回调方法来达到对某一个事件进行特定反馈的目的。在 Java NIO 中，并没有提供事件处理器的抽象供我们使用\u003c/li\u003e\n\u003cli\u003eConcrete Event Handler（具体的事件处理器)：它是事件处理器的实现。它本身实现了事件处理器所提供的各种回调方法，从而实现了特定的业务逻辑。比如针对连接事件需要打印一条日志，就可以在连接事件的回调方法里实现打印日志的逻辑\u003c/li\u003e\n\u003cli\u003eInitiation Dispatcher（初始分发器）：可以把它看作 Reactor， 它规定了事件的调度策略，并且用于管理事件处理器，提供了事件处理器的注册、删除等方法，事件处理器需要注册到 Initiation Dispatcher 上才能生效。它是整个事件处理器的核心，Initiation Dispatcher 会通过 Synchronous Event Demultiplexer来等待事件的发生。一旦事件发生，Initiation Dispatcher 首先会分离出每一个事件，然后找到相应的事件处理器，最后调用相关的回调方法处理这些事件\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"reactor-的三种模型\"\u003eReactor 的三种模型\u003c/h3\u003e\n\u003ch4 id=\"单-reactor-单线程模型\"\u003e单 Reactor 单线程模型\u003c/h4\u003e\n\u003cp\u003e单 Reactor 单线程模型就是在设计中只会有一个 Reactor，并且无论与 IO 相关的读/写，还\n是与 IO 无关的编/解码或计算，都在一个 Handler 线程上完成。\u003c/p\u003e","title":"《深入理解 RPC 框架原理与实现》读书笔记"},{"content":"2022 年初 | 后端开发两年经验社招面经 字节 一面 coding: 对于一个数组，仅用一次遍历，等概率地随机出一个元素（对于每一个元素，从全局看，他们被选择的概率都应该是 1/n）\n对于第 i 个元素，它在第 i 轮被选中的概率是 1/i 往后，只要选择了新的元素，它就会被淘汰；以第 i+1 轮为例，它被淘汰的概率是 1/(i+1)，那么反过来它被留下的概率就是 1 - 1/(i+1) 最终每一个元素被选择的概率如下，第一个 1/i 代表它在第 i 次被选中，其他数代表它在后续的每一轮被留下 followup：等概率地随机出 k 个元素\n对于第 i 个元素，它在第 i 轮被选中的概率是 k/i 往后，它唯一会被淘汰的场景是：选择了新的元素，同时从已有的选择中，等概率地选择到了它；以第 i+1 轮为例，它被淘汰的概率是 k/(i+1) * 1/k = 1/(i+1)，那么反过来它被留下的概率就是 1 - k/(i+1) * 1/k = 1 - 1/(i+1) 最终每一个元素被选择的概率如下，第一个 k/i 代表它在第 i 次被选中，其他数代表它在后续的每一轮被留下 coding: 实现 Fisher–Yates Suffle\nvoid shuffle(vector\u0026lt;int\u0026gt; v) { int n = v.size(); for (int i = n - 1; i \u0026gt;= 1; --i) { int j = rand() % (i + 1); swap(v[i], v[j]); } } 二面 system design：主播开播，如何把这个消息推送给他的千万级 follower 设计数据仓库（数据库也可以） 消息队列 followup：推送之后，主播已经下播，怎么处理 followup：怎么保证消息推送或被消费 followup：如何保证消息不重复 三面 DB 迁移流程\n设置快照，离线搬迁存量数据 双写，将快照后的新数据流写入新 DB 切换路由，将读的请求引入新 DB coding：写一个服务的大致框架\nHotstar 一面 对协程的理解 csrf token 是什么 Cross-site request forgery 跨站请求伪造；攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求，并获取注册凭证，绕过后台验证，冒充用户对被攻击网站执行某项操作 对启发式搜索的理解，对启发函数的研究和优化 coding：实现 Trie coding：实现 AC 自动机 二面 项目经历，讲细节 对 tf 的了解 coding：实现对象池 coding：实现内存池 三面 如何将一个长URL转换为一个短URL 用发号期为每个长地址分配一个短号码 0-9, a-z, A-Z 一共 62 个字符构成 62 进制，节省长度 分布式系统中不同发号期使用不同号码段（A 发号器用 0-999，B 发号器用 1000-1999） coding：设计模式 decorator pattern 实现 coding：一段可编译通过的 cpp 代码编码保存后，做字符串处理，去掉其中的所有注释 // 后注释的内容，/* */ 中的内容，都要去掉 \\ 换行要保留 四面 跳槽动机 未来长短期职业规划 没了 微软 一面 讲讲项目\ncoding：实现一个类 TextProcessor，包含以下函数\nvoid set_variable(string k, string v): 将 k 映射为 v void get_text(string s): 将字符串 s 中用 { 和 } 中间的内容进行格式化替换 例如： auto text_processor = new TextProcessor(); text_processor-\u0026gt;set_variable(\u0026#34;Name\u0026#34;, \u0026#34;abc\u0026#34;); text_processor-\u0026gt;set_variable(\u0026#34;Date\u0026#34;, \u0026#34;2021-11-23\u0026#34;); auto content = text_process-\u0026gt;get_text(\u0026#34;Dear {Name}, welcome! {Date}\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, content); // \u0026#34;Dear abc, welcome! 2021-11-23\u0026#34; 很简单的字符串处理，需要注意包含多个转义字符 \\ 的情况 二面 讲讲项目 Prometheus 原理，和 MySQL，ElasticSearch 的区别 对 kubernetes 的理解 coding：24 点游戏，参考 leetcode 679 题 三面 cpp 和 java 的区别 cpp 中动态绑定的机制，实现原理 构造函数能否调用虚函数，为什么 coding：一段可编译通过的 cpp 代码编码保存后，做字符串处理，去掉其中的所有注释（包括 // 和 /* */）；和 Hotstar 三面的 coding 一模一样 四面 闲聊 跳槽动机，未来规划 system design：地图导航 app 的后端设计 从立项到上线，过程中各个阶段需要考虑哪些方面 设计各个技术方案时需要考虑哪些细节 五面 面试官是印度人，还好口音不是很重\n自我介绍，教育背景 talk about the project you\u0026rsquo;ve done with the most sense of achievement, why coding: 计算一个图里面的矩形个数（没找到原题） Amazon 笔试 有两组剧，每组给出开始时间和持续时间，求每组各看一部剧的最快看完的时间点；举个例，A 组有 3 部，开始时间是 [1, 2, 3]，持续时间是 [1, 1, 1]；B 组有 3 部，开始时间是 [1, 2, 3]，持续时间是 [10, 5, 1]，那么最快看完的时间点是 4，其中 A 组看第一部，在 1+1=2 时间点结束，等到 3 点的时候看 B 组的第三部，3+1=4\n用贪心，先找到第一组最快看完的时间点，再从这个时间点往后找第二组最快看完的时间点。除此之外还要在先 B 后 A 再找一遍 有一组服务器，长度为 n，各个服务器的开机耗电为 A[n]，持续耗电为 B[n]；只有连续的服务器才能组成集群，集群的总开机耗电为 max(A[i\u0026hellip;j])，总持续耗电为 sum(A[i\u0026hellip;j]) * (j-i+1)；给出一个 p，求能够组成集群且总开机耗电加总持续耗电小于等于 p 的最大服务器个数。e.g. A[n] = {3,6,1,3,4}, B[n] = {2,1,3,4,5}, p = 25，那由第四个和第五个组成的集群总耗电是 4 + (4+5)*2 = 22，22 小于 25，所以是一个可行的解，返回这个集群的服务器数量 2 就可以了（不需要给出详细的方案）\n服务器需要连续，因此用滑动窗口确定范围；开机耗电用单调队列计算 一面 coding：leetcode 252 meeting-rooms，1 遍历，2 差分数组 coding：leetcode 103 zigzag tree，1 两个栈层序遍历，2 递归前序遍历，再反转偶数层数组 二面 system design: 购物网站 三面 system design: 设计浏览记录功能，考虑高并发 四面 coding：leetcode 101 对称二叉树 followup：对称多叉树 ","permalink":"https://prov1dence.top/posts/interview/interview/","summary":"\u003ch1 id=\"2022-年初--后端开发两年经验社招面经\"\u003e2022 年初 | 后端开发两年经验社招面经\u003c/h1\u003e\n\u003ch2 id=\"字节\"\u003e字节\u003c/h2\u003e\n\u003ch3 id=\"一面\"\u003e一面\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ecoding: 对于一个数组，仅用一次遍历，等概率地随机出一个元素（对于每一个元素，从全局看，他们被选择的概率都应该是 1/n）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于第 i 个元素，它在第 i 轮被选中的概率是 1/i\u003c/li\u003e\n\u003cli\u003e往后，只要选择了新的元素，它就会被淘汰；以第 i+1 轮为例，它被淘汰的概率是 1/(i+1)，那么反过来它被留下的概率就是 1 - 1/(i+1)\u003c/li\u003e\n\u003cli\u003e最终每一个元素被选择的概率如下，第一个 1/i 代表它在第 i 次被选中，其他数代表它在后续的每一轮被留下\u003c/li\u003e\n\u003cli\u003e\u003cimg alt=\"1\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/interview/1.png\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003efollowup：等概率地随机出 k 个元素\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于第 i 个元素，它在第 i 轮被选中的概率是 k/i\u003c/li\u003e\n\u003cli\u003e往后，它唯一会被淘汰的场景是：选择了新的元素，同时从已有的选择中，等概率地选择到了它；以第 i+1 轮为例，它被淘汰的概率是 k/(i+1) * 1/k = 1/(i+1)，那么反过来它被留下的概率就是 1 - k/(i+1) * 1/k = 1 - 1/(i+1)\u003c/li\u003e\n\u003cli\u003e最终每一个元素被选择的概率如下，第一个 k/i 代表它在第 i 次被选中，其他数代表它在后续的每一轮被留下\u003c/li\u003e\n\u003cli\u003e\u003cimg alt=\"2\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/interview/2.png\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ecoding: 实现 Fisher–Yates Suffle\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eshuffle\u003c/span\u003e(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e v)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e v.size();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; \u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003ei)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e rand() \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e (i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        swap(v[i], v[j]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"二面\"\u003e二面\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003esystem design：主播开播，如何把这个消息推送给他的千万级 follower\n\u003cul\u003e\n\u003cli\u003e设计数据仓库（数据库也可以）\u003c/li\u003e\n\u003cli\u003e消息队列\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003efollowup：推送之后，主播已经下播，怎么处理\u003c/li\u003e\n\u003cli\u003efollowup：怎么保证消息推送或被消费\u003c/li\u003e\n\u003cli\u003efollowup：如何保证消息不重复\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"三面\"\u003e三面\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eDB 迁移流程\u003c/p\u003e","title":"2022 年初 | 后端开发两年经验社招面经"},{"content":"小米 AX1800 使用 ShellClash 科学上网 本文介绍如何在小米 AX1800 上使用 ShellClash 科学上网。\n1 固件降级 小米 AX1800 1.0.336 版本固件\n在 MiWiFi 后台的常用设置 -\u0026gt; 系统状态中点击手动升级，使用 1.0.336 版本的固件对路由器进行降级，整个过程不需要任何额外的操作。\n完成后第一次进入后台配置时选择不自动更新，或在小米 Wi-Fi 手机 App 中关闭自动更新功能。\n更新完成后路由器会重置为路由器底部贴条的设置。\n2 解锁 SSH 首先登陆小米路由器后台 192.168.31.1，将浏览器地址栏中 stok= 后面的一部分的即为拷贝下来。\n获取 SSH 权限 在浏览器中打开一个新页签，在地址栏中输入下面的链接，将其中 stok=...... 中后半部分的六个点换成刚才拷贝的内容，页面上显示 {\u0026quot;code\u0026quot;:0} 即代表成功，这样就解锁了 SSH 到路由器上的权限。\nhttp://192.168.31.1/cgi-bin/luci/;stok=....../api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20\u0026#39;s%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg\u0026#39;%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B 修改 root 密码 在浏览器中打开一个新页签，在地址栏中输入下面的链接，将其中 stok=...... 中后半部分的六个点换成刚才拷贝的内容，页面上显示 {\u0026quot;code\u0026quot;:0} 即代表成功，这样就将路由器上 root 账户的密码改为了 admin。\nhttp://192.168.31.1/cgi-bin/luci/;stok=....../api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20echo%20-e%20\u0026#39;admin%5Cnadmin\u0026#39;%20%7C%20passwd%20root%3B 连接 SSH 打开 terminal 或者 powershell，ssh 到路由器的 root 账户上，密码是 admin。\nssh root@192.168.31.1 如果报错提示 Unable to negotiate with 192.168.31.1 port 22: no matching host key type found. Their offer: ssh-rsa，则需要指定 SSH 的 HostKeyAlgorithms。\nssh -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedKeyTypes=+ssh-rsa root@192.168.31.1 -p 22 3 使用 ShellClash 安装 ssh 到路由器上后，输入以下命令安装 ShellClash。\nsh -c \u0026#34;$(curl -kfsSl https://cdn.jsdelivr.net/gh/juewuy/ShellClash@master/install.sh)\u0026#34; \u0026amp;\u0026amp; source /etc/profile \u0026amp;\u0026gt; /dev/null 选择 1 安装到 /etc 目录下。\n配置 安装完成后，输入 clash 命令进行相关的配置，环境选择 1 主路由或旁路由，保证局域网流量都能通过 ShellClash 客户端。\nUDP 流量和 dashboard 面板根据需求选择，随后等待 clash 核心和 GeoIP 数据库下载完成。\n接下来选 1 开始导入配置文件，19如果有 Clash 订阅链接的话可以选 2 生成 Clash 配置文件，再粘贴订阅的 url；否则选 1 直接导入。\n最后选 1 启动 Clash 服务。\n启动完成后再次运行 clash，选 4 允许开机启动，这样以后每次路由器重启都不再需要手动 SSH 并重新启动 Clash 了。同时还可以在局域网内访问 http://192.168.31.1:9999/ui 来进行节点和规则的修改。\n","permalink":"https://prov1dence.top/posts/proxy/ax1800/","summary":"\u003ch1 id=\"小米-ax1800-使用-shellclash-科学上网\"\u003e小米 AX1800 使用 ShellClash 科学上网\u003c/h1\u003e\n\u003cp\u003e本文介绍如何在小米 AX1800 上使用 ShellClash 科学上网。\u003c/p\u003e\n\u003ch2 id=\"1-固件降级\"\u003e1 固件降级\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/chr1sc2y/warehouse-deprecated/raw/refs/heads/main/resources/proxy/miwifi_rm1800_firmware_fafda_1.0.336.bin\"\u003e小米 AX1800 1.0.336 版本固件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e在 MiWiFi 后台的常用设置 -\u0026gt; 系统状态中点击\u003cstrong\u003e手动升级\u003c/strong\u003e，使用 1.0.336 版本的固件对路由器进行降级，整个过程不需要任何额外的操作。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"firmware\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/proxy/firmware.png\"\u003e\u003c/p\u003e\n\u003cp\u003e完成后第一次进入后台配置时选择不自动更新，或在小米 Wi-Fi 手机 App 中关闭自动更新功能。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"firmware-update\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/proxy/firmware-update.png\"\u003e\u003c/p\u003e\n\u003cp\u003e更新完成后路由器会重置为路由器底部贴条的设置。\u003c/p\u003e\n\u003ch2 id=\"2-解锁-ssh\"\u003e2 解锁 SSH\u003c/h2\u003e\n\u003cp\u003e首先登陆小米路由器后台 192.168.31.1，将浏览器地址栏中 \u003ccode\u003estok=\u003c/code\u003e 后面的一部分的即为拷贝下来。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"firmware-update\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/proxy/stok.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"获取-ssh-权限\"\u003e获取 SSH 权限\u003c/h3\u003e\n\u003cp\u003e在浏览器中打开一个新页签，在地址栏中输入下面的链接，将其中 \u003ccode\u003estok=......\u003c/code\u003e 中后半部分的六个点换成刚才拷贝的内容，页面上显示 \u003ccode\u003e{\u0026quot;code\u0026quot;:0}\u003c/code\u003e 即代表成功，这样就解锁了 SSH 到路由器上的权限。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttp://192.168.31.1/cgi-bin/luci/;stok=....../api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20\u0026#39;s%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg\u0026#39;%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt=\"response\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/proxy/response.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"修改-root-密码\"\u003e修改 root 密码\u003c/h3\u003e\n\u003cp\u003e在浏览器中打开一个新页签，在地址栏中输入下面的链接，将其中 \u003ccode\u003estok=......\u003c/code\u003e 中后半部分的六个点换成刚才拷贝的内容，页面上显示 \u003ccode\u003e{\u0026quot;code\u0026quot;:0}\u003c/code\u003e 即代表成功，这样就将路由器上 root 账户的密码改为了 admin。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttp://192.168.31.1/cgi-bin/luci/;stok=....../api/misystem/set_config_iotdev?bssid=Xiaomi\u0026amp;user_id=longdike\u0026amp;ssid=-h%3B%20echo%20-e%20\u0026#39;admin%5Cnadmin\u0026#39;%20%7C%20passwd%20root%3B\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"连接-ssh\"\u003e连接 SSH\u003c/h3\u003e\n\u003cp\u003e打开 terminal 或者 powershell，ssh 到路由器的 root 账户上，密码是 admin。\u003c/p\u003e","title":"小米 AX1800 使用 ShellClash 科学上网"},{"content":"Hi there 👋 🇦🇺🇨🇳\nThis is Chris, Software Engineer at a start-up, previously at Amazon and Tencent.\nCheckout my resume:\nEnglish Simplified Chinese Cheers 🍻\n","permalink":"https://prov1dence.top/about/","summary":"\u003ch3 id=\"hi-there-\"\u003eHi there 👋\u003c/h3\u003e\n\u003cp\u003e🇦🇺🇨🇳\u003c/p\u003e\n\u003cp\u003eThis is Chris, Software Engineer at a start-up, previously at \u003cstrong\u003eAmazon\u003c/strong\u003e and \u003cstrong\u003eTencent\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eCheckout my resume:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://portfolio-website-resource.s3.ap-southeast-2.amazonaws.com/Resume_Zhengyu_Chen_EN_2025.pdf\"\u003eEnglish\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://portfolio-website-resource.s3.ap-southeast-2.amazonaws.com/%E9%99%88%E6%AD%A3%E5%AE%87_%E7%AE%80%E5%8E%86_2025.pdf\"\u003eSimplified Chinese\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCheers 🍻\u003c/p\u003e","title":"About"},{"content":"Kafka 入门 概述 Kafka 最初是为了解决 LinkedIn 数据管道问题应运而生的。它的设计目的是提供一个高性能的消息系统，可以处理多种数据类型，并能够实时提供纯净且结构化的用户活动数据和系统度量指标。\n它不只是一个数据存储系统（类似于传统的关系型数据库、键值存储引擎、搜索引擎或缓存系统），还是一个持续变化和不断增长的流处理系统。现在 Kafka 已经被广泛地应用在社交网络的实时数据流处理当中，成为了下一代数据架构的基础。Kafka 经常会被拿来与现有的企业级消息系统、大数据系统（如 Hadoop）和数据集成 ETL 工具等技术作比较。\n从发布和订阅消息流的角度来看，Kafka 类似于 ActiveMQ、RabbitMQ 或 IBM 的 MQSeries 等产品，其特点在于它以集群的方式运行，可以自由伸缩，处理大量的应用程序；其次，Kafka 可以按照要求持久化数据，即提供了数据传递的保证——可复制、持久化，保留多长时间完全可以由开发者决定。此外，消息系统只会传递消息，而 Kafka 的流式处理能力让我们只用很少的代码就能够动态地处理派生流和数据集。\n1 基础概念 消息代理 在一个基于发布与订阅的消息系统中，数据消息的发送者不直接把消息发送给接收者，而是通过一个消息代理 message broker 传递消息，接收者订阅消息代理，并以特定的方式接收消息。Kafka 就是一个消息代理。\n消息代理 message broker 是一种针对处理消息流而优化的数据库，它作为独立的中间服务运行，生产者和消费者作为客户端连接到消息代理服务，在使用消息代理的架构中主要有 3 种角色：\n生产者将消息写入消息代理；生产者一般是异步架构的，当生产者发送消息时，它只会等待消息代理确认消息已经被缓存，而不等待消息被消费者处理 消息代理负责消息的存储，发送、重传等，一般会包含多个消息队列 message queue 消费者从消息代理接收消息并进行处理；消费者只依赖于消息代理，与生产者完全隔离 消息代理的优势主要有以下几点：\n实现异步处理，提升性能\n把消息处理流程使用消息代理异步化，不会阻塞生产者服务，生产者服务可以在得到处理结果之前继续执行，并提高其并发处理的能力。\n提高系统的可伸缩性\n生产者将大量消息推送到消息代理中，消息代理可以将这些消息分发给不同的消费者，使得多个消费者并行地处理消息，当消费者负载变化时，可以很容易地对消费者服务进行水平伸缩\n削峰填谷\n当生产者推送消息的速度比消费者处理消息的速度更快时，可以使用消息队列作为消息的缓冲，来削弱峰值流量，防止系统被短时间内的流量冲垮\n应用解耦\n使用消息代理后，生产者和消费者即可解耦，不再需要有任何联系，也不需要受对方的影响，只要保持使用一致的消息格式即可。\n消息和批次 Kafka 的数据单元被称为消息，消息类似于关系型数据库里的一个数据行或一条记录；消息由字节数组组成，当消息以一种可控的方式写入不同的分区时，会用到 key，Kafka 会为 key 生成一个一致性散列值，然后使用散列值对主题分区数进行取模，为消息选取分区。这样可以保证具有相同 key 的消息总是被写到相同的分区上。\n如果每一个消息都单独发送，会导致大量的网络开销。为了提高效率，消息会被分批次写入Kafka；批次 batch 是一组消息，这些消息属于同一个主题和分区；批次数据在传输时会被压缩，这样可以提升数据的传输和存储能力；单个 batch 的消息数量越大，单位时间内处理的消息就越多，但单个 batch 的传输时间就越长，因此需要在时延和吞吐量之间作出权衡。\n主题和分区 Kafka 的消息通过主题 topic 进行分类，主题就好比关系型数据库的表，或者文件系统里的目录；同一个主题可以被分为若干个分区 partition，一个 partition 即一个提交日志，消息以追加的方式写入 partition，然后以先入先出的顺序读取。一个 topic 一般包含多个 partition，因此无法在整个 topic 的维度保证消息的顺序，只能保证消息在单个 partition 内的顺序。\n我们通常用流 stream 来描述 Kafka 中的数据，在一个 topic 中，无论它有多少个partition，其中的数据都被视为一个 stream。\n生产者和消费者 Kafka 的客户端有两种基本类型：生产者 producer和消费者 consumer。\n默认情况下，生产者生产的消息会被发布到一个特定的 topic 上。消息会被均衡地分布到这个 topic 的所有 partition 上，但我们也可以指定生产者的消息直接写到指定的 partition 上。\n消费者会订阅一个或多个 topic，并按照消息生成的顺序依次读取它们。消费者通过检查消息的偏移量 offset来区 分已经读取过的消息，offset 是一种元数据，它会不断递增；在给定的 partition 中，每个消息的 offset 都是唯一的，offset 值会被保存在 Zookeeper 或 Kafka 上，这样即使消费者停止或重启后它的读取状态依然不会丢失。\n在 Kafka 中，多个消费者可以组成一个消费者群组 consumer group，它们共同读取同一个 topic，group 会保证每个 partition 只能被一个消费者使用，并且这个群组的消费者对给定的消息只处理一次。\nbroker 和集群 一个独立的 Kafka 服务器被称为 broker；broker 会独立接收来自生产者的消息，为消息设置 offset，并将消息保存到磁盘，并处理消费者读取分区的请求，返回已经保存到磁盘上的消息；单个broker 最多可以处理数千个 partition 以及每秒百万级的消息量。\nbroker 是 Kafka 集群 cluster 的组成部分，每个集群都有一个 broker 充当集群控制器，负责管理工作，包括将 partition 分配给 broker，以及监控其他 broker。在集群中，一个 partition 从属于一个 broker。一个 partition 可能被分配给多个 broker，这个时候会发生分区复制 replication，这种复制机制为分区提供了消息冗余，如果有一个 broker 失效，其他 broker 可以接管领导权；同时，相关的消费者和生产者都要重新连接到新的首领。\nKafka broker 消息保留的默认策略是保留一段时间或保留消息达到一定大小的字节数，当消息的规模达到这些上限时，旧消息就会过期并被删除，每个 topic 可以配置自己的保留策略。基于这个机制，Kafka 允许消费者非实时地从磁盘读取消息。\n多集群 随着 Kafka 部署数量的增加，基于数据类型分离，安全需求隔离和多数据中心容灾等原因，建议使用多集群方案，但 Kafka 的消息复制机制只能在单个集群里进行，不能在多个集群之间进行。为此 Kafka 提供了一个叫作 MirrorMaker 的工具， 可以用它来实现集群间的消息复制。\nZookeeper ZooKeeper 是一个分布式协调框架，负责管理和协调 Kafka 集群的元数据，包括当前正在运行的 Broker，存在于集群中的 topic，每一个 topic 中的 partition，以及 partition 中的 leader 和 follower。\nKafka 使用 Zookeeper 来维护集群成员的信息，每个 broker 都有一个唯一的标识符 id，标识符可以通过配置文件指定，也可以自动生成。在 broker 启动的时候，它会将自己的 id 注册到 Zookeeper 上，Kafka 的其他组件组件通过订阅 Zookeeper 服务器的 /brokers/ids 路径来获取 broker 的信息和变化。当一个 broker 因为故障与 Zookeeper 断开连接时，Zookeeper 会将这个 broker 在的临时节点移除。所有监听了 broker 列表的其他组件会被通知该 broker 已经离线。虽然临时节点已经消失，不过它的 id 会继续存在于其他数据结构中，在完全关闭这个 broker 之后，如果使用相同的 id 启动另一个全新的 broker，它会立即加入集群，并拥有与这个 broker 相同的 topic 和 partition。\n2 生产者 一个应用程序在很多情况下需要往 Kafka 写入消息：记录用户活动（用于统计和分析）、记录度量指标、保存日志消息、与其他应用程序进行异步通信、缓存即将写入到数据库的数据等等。多样的使用场景意味着多样的需求，每种消息的重要性，时延和吞吐量各不相同。例如在信用卡事务处理系统里，消息丢失或重复是不被允许的，可以接受的延迟在 500 ms 左右，同时对吞吐量要求较高——我们希望每秒钟可以处理一百万个或更多的消息。保存网站的点击信息则是另一种场景，这时我们允许丢失少量的消息丢失或重复，延迟也可以高一些，只要不影响用户体验即可。\n下图展示了从生产者向 Kafka 发送消息的主要步骤。\n生产者发送消息的第一步是创建一个 ProducerRecord 对象；ProducerRecord 必须包含 topic 和要发送的 value，同时还可以指定 key 或 partition。在发送 ProducerRecord 前，序列化器 serializer 会把 key 和 value 序列化成字节数组。\n接下来，数据被传给分区器 partitioner，如果在 ProducerRecord 对象里指定了分区，那么会直接使用这个分区；如果没有指定分区，那么分区器会根据 ProducerRecord 对象的 key 来选择一个分区。选择好分区以后，生产者就知道该往哪个 topic 和 partition 发送这条消息了。\n紧接着，这条记录被添加到一个 batch 里，这个 batch 里的所有消息会被发送到相同的 topic 和 partition 上。生产者会使用一个独立的线程把整个 batch 发送到对应的 broker 上。\nKafka 服务器在收到这个 batch 后会返回一个响应。如果消息成功写入Kafka，就返回一个 RecordMetaData 对象，它包含了消息发送到的 topic 和 partition，以及记录在分区里的 offset。如果写入失败，则会返回一个错误。生产者在收到错误之后会尝试重新发送消息，几次之后如果仍然失败，就返回错误信息。\n2.1 序列化器 key 和 value 的序列化器在生产者 KafkaProducer 的构造函数中由不同的 Serializer 初始化，如果传入的 Serializer 为空，则使用配置中的序列化器名字，利用反射机制来创建对象；反射 reflection 是指在运行时，程序在对某个类型一无所知的情况下，直接创建该类型实例并调用其方法的机制：\npublic class KafkaProducer\u0026lt;K, V\u0026gt; implements Producer\u0026lt;K, V\u0026gt; { KafkaProducer(ProducerConfig config, Serializer\u0026lt;K\u0026gt; keySerializer, Serializer\u0026lt;V\u0026gt; valueSerializer, ProducerMetadata metadata, KafkaClient kafkaClient, ProducerInterceptors\u0026lt;K, V\u0026gt; interceptors, Time time) { // ... // key 的 serializer if (keySerializer == null) { // 利用反射构造配置类型的对象 this.keySerializer = config.getConfiguredInstance(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, Serializer.class); this.keySerializer.configure(config.originals(Collections.singletonMap(ProducerConfig.CLIENT_ID_CONFIG, clientId)), true); } else { config.ignore(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG); this.keySerializer = keySerializer; } // value 的 serializer if (valueSerializer == null) { // 利用反射构造配置类型的对象 this.valueSerializer = config.getConfiguredInstance(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, Serializer.class); this.valueSerializer.configure(config.originals(Collections.singletonMap(ProducerConfig.CLIENT_ID_CONFIG, clientId)), false); } else { config.ignore(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG); this.valueSerializer = valueSerializer; } // ... } } 以 StringSerializer 为例，它实现了 Serializer 接口，其中的 serialize 函数用来实现对数据的序列化，它实际上调用了 Java 中的 String.getBytes 函数进行字符串的序列化：\npublic class StringSerializer implements Serializer\u0026lt;String\u0026gt; { private String encoding = StandardCharsets.UTF_8.name(); @Override public void configure(Map\u0026lt;String, ?\u0026gt; configs, boolean isKey) { String propertyName = isKey ? \u0026#34;key.serializer.encoding\u0026#34; : \u0026#34;value.serializer.encoding\u0026#34;; Object encodingValue = configs.get(propertyName); if (encodingValue == null) encodingValue = configs.get(\u0026#34;serializer.encoding\u0026#34;); if (encodingValue instanceof String) encoding = (String) encodingValue; } @Override public byte[] serialize(String topic, String data) { try { if (data == null) return null; else return data.getBytes(encoding); } catch (UnsupportedEncodingException e) { throw new SerializationException(\u0026#34;Error when serializing string to byte[] due to unsupported encoding \u0026#34; + encoding); } } } 2.2 分区器 生产者 KafkaProducer 发送消息前，会调用 partition 接口来选择接收消息的 partition，如果在 record 中指定了 partition，那么会直接使用这个 partition，否则会调用分区器 partitioner 的 partition 接口来获取。\npublic class KafkaProducer\u0026lt;K, V\u0026gt; implements Producer\u0026lt;K, V\u0026gt; { private int partition(ProducerRecord\u0026lt;K, V\u0026gt; record, byte[] serializedKey, byte[] serializedValue, Cluster cluster) { Integer partition = record.partition(); return partition != null ? partition : partitioner.partition( record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster); } } KafkaProducer 使用的默认分区器是 DefaultPartitioner，它实现了 Partitioner 接口，其中的 partition 方法用来实现分配 partition 的逻辑：\npublic class DefaultPartitioner implements Partitioner { // 为每个 topic 维护一个计数值 private final ConcurrentMap\u0026lt;String, AtomicInteger\u0026gt; topicCounterMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) { List\u0026lt;PartitionInfo\u0026gt; partitions = cluster.partitionsForTopic(topic); int numPartitions = partitions.size(); // key 为空时 if (keyBytes == null) { // 获取自增值 nextValue int nextValue = nextValue(topic); List\u0026lt;PartitionInfo\u0026gt; availablePartitions = cluster.availablePartitionsForTopic(topic); // 对 nextValue 和 当前可用的 partition 数量取余 if (availablePartitions.size() \u0026gt; 0) { int part = Utils.toPositive(nextValue) % availablePartitions.size(); return availablePartitions.get(part).partition(); } else { return Utils.toPositive(nextValue) % numPartitions; } } else { // key 不为空时 return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; } } private int nextValue(String topic) { AtomicInteger counter = topicCounterMap.get(topic); if (null == counter) { counter = new AtomicInteger(ThreadLocalRandom.current().nextInt()); AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter); if (currentCounter != null) { counter = currentCounter; } } return counter.getAndIncrement(); } } 这段代码主要分为两部分：\n当 key 为空时，调用 nextValue 获取一个自增值，其中 topicCounterMap 为每一个 topic 维护一个计数值，每次调用 nextValue 时递增，再对 partition 的数量取余得到结果 当 key 不为空时，使用 murmur2 哈希算法对 key 进行 hash 操作得到结果 可以发现只有当指定 key 的时候，消息才会被分配到同一个 partition 中，从而保证被有序地消费。\nKafka 2.4.0 引入了新的粘性分区缓存类 StickyPartitionCache，当 key 为空时，不再为每个 topic 使用轮询的方法来分配 partition，而是会调用 StickyPartitionCache.partition 来从缓存中获取对应的 partition：\npublic class DefaultPartitioner implements Partitioner { private final StickyPartitionCache stickyPartitionCache = new StickyPartitionCache(); public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster, int numPartitions) { // key 为空时 if (keyBytes == null) { return stickyPartitionCache.partition(topic, cluster); } // key 不为空时 return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; } } // 实现粘性分区缓存的内部类，追踪每一个 topic 的粘性 partition public class StickyPartitionCache { // 从 topic 到 partition 的映射 private final ConcurrentMap\u0026lt;String, Integer\u0026gt; indexCache; public StickyPartitionCache() { this.indexCache = new ConcurrentHashMap\u0026lt;\u0026gt;(); } public int partition(String topic, Cluster cluster) { Integer part = indexCache.get(topic); if (part == null) { // 如果没有缓存则调用 nextPartition 选择一个分区并缓存 return nextPartition(topic, cluster, -1); } return part; } public int nextPartition(String topic, Cluster cluster, int prevPartition) { List\u0026lt;PartitionInfo\u0026gt; partitions = cluster.partitionsForTopic(topic); Integer oldPart = indexCache.get(topic); Integer newPart = oldPart; // 如果当前 topic 没有缓存，或创建了一个新的 batch if (oldPart == null || oldPart == prevPartition) { List\u0026lt;PartitionInfo\u0026gt; availablePartitions = cluster.availablePartitionsForTopic(topic); if (availablePartitions.size() \u0026lt; 1) { Integer random = Utils.toPositive(ThreadLocalRandom.current().nextInt()); newPart = random % partitions.size(); } else if (availablePartitions.size() == 1) { newPart = availablePartitions.get(0).partition(); } else { while (newPart == null || newPart.equals(oldPart)) { int random = Utils.toPositive(ThreadLocalRandom.current().nextInt()); newPart = availablePartitions.get(random % availablePartitions.size()).partition(); } } // 如果是 topic 没有缓存 if (oldPart == null) { indexCache.putIfAbsent(topic, newPart); } else { // 如果是创建了一个新的缓存 indexCache.replace(topic, prevPartition, newPart); } return indexCache.get(topic); } return indexCache.get(topic); } } StickyPartitionCache 类会维护一个从 topic 到 partition 的缓存，其本质也是轮询。在老版本的 partition 方法中，如果没有指定 key，那么同一个 topic 中的消息会被轮询到不同的 partition 中，这样不同的 partition 中就会产生很多的 batch，从而导致更多的网络请求。而 StickyPartitionCache 保证了这样的消息可以共同构成一个更大的 batch，投递到相同的 partition 中，发送给 Kafka 服务器，从而提高吞吐量。\n3 消费者 Kafka 的消费者服务经常会做一些高延迟的 IO 操作，比如把数据写到磁盘，数据库或 HDFS，或者使用数据进行比较耗时的计算。在这些情况下，单个消费者无法跟上数据生成的速度，所以只能通过横向伸缩的方式，增加更多的消费者，让它们分担负载，从而提高吞吐量。\n就像多个生产者可以同时向相同的 topic 写入消息一样，我们也可以使用多个消费者订阅并从同一个 topic 读取消息，对消息进行分流。Kafka 中的消费者从属于消费者群组 group，一个 group 订阅一个 topic，每个消费者则接收其中一部分 partition 的消息。\n3.1 消费过程 Kafka 中客户端的消费是基于 pull 模式的，这样做的优势在于，不同消费者客户端的消费能力和消费策略不同，它们可以调整 pull 的频率以适配自己的 IO 能力；如果使用 push 模式则有可能因为推送速度过快而造成消费者客户端崩溃。\n消费消息是一个不断轮询 poll 的过程，消费者所要做的就是不断地重复调用 poll ，并等待 Kafka 服务器返回其订阅的 partition 上的一组消息。\npublic class KafkaConsumerDemo { public static void main(String[] args) { Properties props = initConfig(); KafkaConsumer\u0026lt;String, String\u0026gt; consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(TOPIC)); try { while (IS_RUNNING.get()) { ConsumerRecords\u0026lt;String, String\u0026gt; records = consumer.poll(Duration.ofMillis(1000)); for (ConsumerRecord\u0026lt;String, String\u0026gt; record : records) { System.out.println(\u0026#34;topic=\u0026#34; + record.topic() + \u0026#34;, partition=\u0026#34; + record.partition() + \u0026#34;, offset=\u0026#34; + record.offset()); System.out.println(\u0026#34;key=\u0026#34; + record.key() + \u0026#34;, value=\u0026#34; + record.value()); } } } catch (Exception e) { e.printStackTrace(); } finally { consumer.close(); } } } poll 方法返回一个记录列表 ConsumerRecords，其中每条记录都包含了记录所属 topic 和 partition 的信息，记录所在 partition 的 offset，以及记录的 key-value。同时 poll 方法有一个超时 timeout 参数，无论有没有可用的数据，poll 的执行时间一旦超过 timeout 就会立刻返回。\n在消费者客户端退出之前应该调用 close 方法来将其关闭，并立即触发一次 group 的再平衡，而不是等待 group 协调器来发现这个客户端心跳超时并认定其已不再能提供服务。\n3.2 偏移量 消费者对象 KafkaConsumerRunner 运行时，通过先订阅 subscribe 然后轮询 poll 的方式来向 Kafka 服务器请求数据，每次调用 poll 方法后，服务器会返回 partition 中还没有被消费者读取过的记录，消费者可以追踪当前 partition 中的 offset，而更新 partition 当前 offset 的操作叫作提交 submit。\n如果消费者一直处于运行状态，那么 offset 就没有意义；而如果消费者失效或者有新的消费者加入 group，group 就会触发再平衡机制，每个消费者会被分配到新的 partition，为了能够继续之前的工作，消费者需要读取当前 partition 中最后一次提交的 offset，然后从 offset 所在位置继续处理消息。最后一次提交的 offset 的位置如果在最后实际处理的消息之后或之前，分别会造成消息丢失和消息重复的问题，因此提交的方式显得尤为重要。\n如果将消费者处理后的记录与 offset 都作为一个原子操作或事务都提交到其他数据库上，那么我们甚至可以不依赖于 Kafka 服务器提供的 offset，而是在消费者启动或分配到新分区后，直接调用 seek 方法，在 Kafka 服务器中查找这个特定 offset 位置的消息。\n自动提交 最简单的提交方式是让消费者自动提交 offset，这种情况下，每过 5s（默认情况下），消费者会自动把从 poll 方法接收到的最大 offset 进行提交。\n使用自动提交是存在隐患的，假设在设置的自动提交间隔之内，group 发生了再平衡，那么再平衡完成之后消费者获取到的 offset 则会落后于实际应该处理的消息位置，部分消息会被重复处理。虽然可以通过缩短提交间隔来更频繁地提交 offset，减少重复处理消息的数量，但这样的情况是无法避免的。\n同步提交 通过调用 KafkaConsumer.commitSync，可以对 offset 进行同步提交，不传递任何参数时默认提交的最大 offset。\npublic class KafkaConsumer\u0026lt;K, V\u0026gt; implements Consumer\u0026lt;K, V\u0026gt; { public void commitSync(final Map\u0026lt;TopicPartition, OffsetAndMetadata\u0026gt; offsets, final Duration timeout) { acquireAndEnsureOpen(); // Acquire the light lock and ensure that the consumer hasn\u0026#39;t been closed. long commitStart = time.nanoseconds(); try { maybeThrowInvalidGroupIdException(); offsets.forEach(this::updateLastSeenEpochIfNewer); // coordinator 管理消费者的提交过程 if (!coordinator.commitOffsetsSync(new HashMap\u0026lt;\u0026gt;(offsets), time.timer(timeout))) { throw new TimeoutException(\u0026#34;Timeout of \u0026#34; + timeout.toMillis() + \u0026#34;ms expired before successfully \u0026#34; + \u0026#34;committing offsets \u0026#34; + offsets); } } finally { kafkaConsumerMetrics.recordCommitSync(time.nanoseconds() - commitStart); release(); } } private void acquireAndEnsureOpen() { acquire(); if (this.closed) { release(); throw new IllegalStateException(\u0026#34;This consumer has already been closed.\u0026#34;); } } } acquireAndEnsureOpen 会尝试获取锁，并确保当前客户端尚未关闭，但实际上 KafkaConsumer 并不支持被并发访问，所以在被多个线程调用时会简单地抛出状态错误的异常。\npublic final class ConsumerCoordinator extends AbstractCoordinator { public boolean commitOffsetsSync(Map\u0026lt;TopicPartition, OffsetAndMetadata\u0026gt; offsets, Timer timer) { invokeCompletedOffsetCommitCallbacks(); if (offsets.isEmpty()) return true; do { if (coordinatorUnknown() \u0026amp;\u0026amp; !ensureCoordinatorReady(timer)) { return false; } RequestFuture\u0026lt;Void\u0026gt; future = sendOffsetCommitRequest(offsets); // 阻塞等待提交结果 client.poll(future, timer); invokeCompletedOffsetCommitCallbacks(); if (future.succeeded()) { if (interceptors != null) interceptors.onCommit(offsets); return true; } if (future.failed() \u0026amp;\u0026amp; !future.isRetriable()) throw future.exception(); timer.sleep(rebalanceConfig.retryBackoffMs); } while (timer.notExpired()); return false; } } ConsumerCoordinator.commitOffsetsSync 先通过 sendOffsetCommitRequest 获取到发送 request 后的 future 对象，然后再使用 poll(future) 阻塞地等待其执行完成；如果同步提交失败，但尚未超时，会在 函数中尝试重新提交，这可以最大程度地保证数据提交成功，但同时也会降低程序的吞吐量。\n异步提交 和同步提交相反，异步提交在执行的时候不会阻塞消费者线程，这样可以使得消费者客户端的性能和吞吐量得到一定的提升。\npublic class KafkaConsumer\u0026lt;K, V\u0026gt; implements Consumer\u0026lt;K, V\u0026gt; { public void commitAsync(final Map\u0026lt;TopicPartition, OffsetAndMetadata\u0026gt; offsets, OffsetCommitCallback callback) { acquireAndEnsureOpen(); try { maybeThrowInvalidGroupIdException(); log.debug(\u0026#34;Committing offsets: {}\u0026#34;, offsets); offsets.forEach(this::updateLastSeenEpochIfNewer); coordinator.commitOffsetsAsync(new HashMap\u0026lt;\u0026gt;(offsets), callback); } finally { release(); } } } 相较于同步提交 commitSync，异步提交 commitAsync 接口的唯一区别是在参数里增加了一个回调函数。\npublic final class ConsumerCoordinator extends AbstractCoordinator { private void doCommitOffsetsAsync(final Map\u0026lt;TopicPartition, OffsetAndMetadata\u0026gt; offsets, final OffsetCommitCallback callback) { this.subscriptions.needRefreshCommits(); RequestFuture\u0026lt;Void\u0026gt; future = sendOffsetCommitRequest(offsets); final OffsetCommitCallback cb = callback == null ? defaultOffsetCommitCallback : callback; // 添加监听 future.addListener(new RequestFutureListener\u0026lt;Void\u0026gt;() { @Override public void onSuccess(Void value) { if (interceptors != null) interceptors.onCommit(offsets); completedOffsetCommits.add(new OffsetCommitCompletion(cb, offsets, null)); } @Override public void onFailure(RuntimeException e) { Exception commitException = e; if (e instanceof RetriableException) commitException = RetriableCommitFailedException.withUnderlyingMessage(e.getMessage()); completedOffsetCommits.add(new OffsetCommitCompletion(cb, offsets, commitException)); } }); } } 类似地，ConsumerCoordinator.doCommitOffsetsAsync 会先通过 sendOffsetCommitRequest 获取到 future 对象，但只为其添加好监听事件就返回了。\n3.3 再平衡 再平衡指当 partition 的所属权从一个消费者转移到另一个消费者的行为，它为 group 的高可用性和伸缩性提供了保证；一般有三种时机会触发再平衡：\ngroup 订阅的 topic 中新增了 partition group 中新增或移除了部分消费者，对应的 partition 需要被分配给 group 内的其他消费者 group 订阅的 topic 发生了变化，例如 group 利用某个正则表达式（例如 \u0026ldquo;test.*\u0026quot;）订阅了特定的 topic，在某个时间集群内新增了一个符合正则表达式的 topic（例如 \u0026ldquo;test1\u0026rdquo;），那么该 topic 的所有 partition 也会被分配给当前的 group 在再平衡发生的期间，group 内的消费者无法读取消息，即整个 group 会变得不可用；并且当一个 partition 被重新分配给另一个消费者时，消费者的状态会丢失，即其 offset 有可能尚未提交。因此一般情况下应该尽量避免不必要的再平衡的发生。\nRangeAssignor RangeAssignor 是默认的，也是最简单的再平衡策略：\npublic class RangeAssignor extends AbstractPartitionAssignor { public static final String RANGE_ASSIGNOR_NAME = \u0026#34;range\u0026#34;; @Override public Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assign(Map\u0026lt;String, Integer\u0026gt; partitionsPerTopic, Map\u0026lt;String, Subscription\u0026gt; subscriptions) { Map\u0026lt;String, List\u0026lt;MemberInfo\u0026gt;\u0026gt; consumersPerTopic = consumersPerTopic(subscriptions); Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assignment = new HashMap\u0026lt;\u0026gt;(); for (String memberId : subscriptions.keySet()) assignment.put(memberId, new ArrayList\u0026lt;\u0026gt;()); for (Map.Entry\u0026lt;String, List\u0026lt;MemberInfo\u0026gt;\u0026gt; topicEntry : consumersPerTopic.entrySet()) { String topic = topicEntry.getKey(); List\u0026lt;MemberInfo\u0026gt; consumersForTopic = topicEntry.getValue(); // 每个 topic 的 partition 数量 Integer numPartitionsForTopic = partitionsPerTopic.get(topic); if (numPartitionsForTopic == null) continue; Collections.sort(consumersForTopic); // 每个消费者都会被分配到的 partition 数量 int numPartitionsPerConsumer = numPartitionsForTopic / consumersForTopic.size(); // 部分消费者会被分配到的额外 partition int consumersWithExtraPartition = numPartitionsForTopic % consumersForTopic.size(); List\u0026lt;TopicPartition\u0026gt; partitions = AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic); for (int i = 0, n = consumersForTopic.size(); i \u0026lt; n; i++) { int start = numPartitionsPerConsumer * i + Math.min(i, consumersWithExtraPartition); int length = numPartitionsPerConsumer + (i + 1 \u0026gt; consumersWithExtraPartition ? 0 : 1); assignment.get(consumersForTopic.get(i).memberId).addAll(partitions.subList(start, start + length)); } } return assignment; } } 可以看到 RangeAssignor.assign 函数中会计算 partition 数量 numPartitionsForTopic 与消费者数量 consumersForTopic 的整除结果 numPartitionsPerConsumer 和取余结果 consumersWithExtraPartition，并将连续的 partition 分配给同一个消费者。\nRoundRobinAssignor RoundRobinAssignor 策略的原理是将 group 内所有消费者以及所有 partition 按照字典序排序，然后通过轮询的方式逐个地进行分配：\npublic class RoundRobinAssignor extends AbstractPartitionAssignor { public static final String ROUNDROBIN_ASSIGNOR_NAME = \u0026#34;roundrobin\u0026#34;; @Override public Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assign(Map\u0026lt;String, Integer\u0026gt; partitionsPerTopic, Map\u0026lt;String, Subscription\u0026gt; subscriptions) { Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assignment = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;MemberInfo\u0026gt; memberInfoList = new ArrayList\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;String, Subscription\u0026gt; memberSubscription : subscriptions.entrySet()) { assignment.put(memberSubscription.getKey(), new ArrayList\u0026lt;\u0026gt;()); memberInfoList.add(new MemberInfo(memberSubscription.getKey(), memberSubscription.getValue().groupInstanceId())); } // 环形链表，存储所有的消费者 CircularIterator\u0026lt;MemberInfo\u0026gt; assigner = new CircularIterator\u0026lt;\u0026gt;(Utils.sorted(memberInfoList)); // 获取 group 当前订阅的所有 topic 的 partition for (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) { final String topic = partition.topic(); while (!subscriptions.get(assigner.peek().memberId).topics().contains(topic)) assigner.next(); assignment.get(assigner.next().memberId).add(partition); } return assignment; } } 以上两种方式都对所有的 partition 进行了全量重新分配。\nStickyAssignor StickyAssignor 策略的目的有两个：\npartition 的分配要尽可能的均匀，分配给各个消费者的 partition 数量最多只相差一个； partition 的分配尽可能的与再分配之前的保持相同； 当两者冲突的时候，第一个目标优先于第二个目标。\npublic abstract class AbstractStickyAssignor extends AbstractPartitionAssignor { public Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; assign(Map\u0026lt;String, Integer\u0026gt; partitionsPerTopic, Map\u0026lt;String, Subscription\u0026gt; subscriptions) { Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; consumerToOwnedPartitions = new HashMap\u0026lt;\u0026gt;(); Set\u0026lt;TopicPartition\u0026gt; partitionsWithMultiplePreviousOwners = new HashSet\u0026lt;\u0026gt;(); if (allSubscriptionsEqual(partitionsPerTopic.keySet(), subscriptions, consumerToOwnedPartitions, partitionsWithMultiplePreviousOwners)) { log.debug(\u0026#34;Detected that all consumers were subscribed to same set of topics, invoking the \u0026#34; + \u0026#34;optimized assignment algorithm\u0026#34;); partitionsTransferringOwnership = new HashMap\u0026lt;\u0026gt;(); return constrainedAssign(partitionsPerTopic, consumerToOwnedPartitions, partitionsWithMultiplePreviousOwners); } else { log.debug(\u0026#34;Detected that not all consumers were subscribed to same set of topics, falling back to the \u0026#34; + \u0026#34;general case assignment algorithm\u0026#34;); partitionsTransferringOwnership = null; return generalAssign(partitionsPerTopic, subscriptions, consumerToOwnedPartitions); } } } AbstractStickyAssignor 虚基类的 assign 函数中将再平衡分为了两种情况，分别是 group 里的消费者都订阅了相同的 topic，以及订阅的 topic 不尽相同。\n对于前者，需要获取上次的分配情况，并删除已经失效的 partition，这样就获取到了一份可用的，与之前尽可能相同的预分配名单，但是可能分配不均，因此进入 constrainedAssign 函数来进行进一步的公平分配：\npublic abstract class AbstractStickyAssignor extends AbstractPartitionAssignor { private Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; constrainedAssign(Map\u0026lt;String, Integer\u0026gt; partitionsPerTopic, Map\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; consumerToOwnedPartitions, Set\u0026lt;TopicPartition\u0026gt; partitionsWithMultiplePreviousOwners) { // ... // 消费者数量 int numberOfConsumers = consumerToOwnedPartitions.size(); // 分区数量 int totalPartitionsCount = partitionsPerTopic.values().stream().reduce(0, Integer::sum); // 每个消费者分配到的 partition 最小数量 int minQuota = (int) Math.floor(((double) totalPartitionsCount) / numberOfConsumers); // 每个消费者分配到的 partition 最大数量 int maxQuota = (int) Math.ceil(((double) totalPartitionsCount) / numberOfConsumers); // 会获得额外 partition 的消费者数量 int expectedNumMembersWithOverMinQuotaPartitions = totalPartitionsCount % numberOfConsumers; // ... // 验证预分配的数量与 minQuota 和 maxQuota 的关系，将超过的 maxQuota 的部分移除并记录，分配给低于 minQuota 的消费者 // 注意这一步只能保证能够将所有超过 maxQuota 的部分取出 for (Map.Entry\u0026lt;String, List\u0026lt;TopicPartition\u0026gt;\u0026gt; consumerEntry : consumerToOwnedPartitions.entrySet()) { List\u0026lt;TopicPartition\u0026gt; ownedPartitions = consumerEntry.getValue(); // 对于预分配时未达到 minQuota 的消费者，将多余的分配给它们 if (ownedPartitions.size() \u0026lt; minQuota) { if (ownedPartitions.size() \u0026gt; 0) { consumerAssignment.addAll(ownedPartitions); assignedPartitions.addAll(ownedPartitions); } unfilledMembersWithUnderMinQuotaPartitions.add(consumer); } else if (ownedPartitions.size() \u0026gt;= maxQuota \u0026amp;\u0026amp; currentNumMembersWithOverMinQuotaPartitions \u0026lt; expectedNumMembersWithOverMinQuotaPartitions) { // 对于预分配时超过 maxQuota 的消费者，将多余的移除并保存下来 currentNumMembersWithOverMinQuotaPartitions++; if (currentNumMembersWithOverMinQuotaPartitions == expectedNumMembersWithOverMinQuotaPartitions) { unfilledMembersWithExactlyMinQuotaPartitions.clear(); } List\u0026lt;TopicPartition\u0026gt; maxQuotaPartitions = ownedPartitions.subList(0, maxQuota); consumerAssignment.addAll(maxQuotaPartitions); assignedPartitions.addAll(maxQuotaPartitions); allRevokedPartitions.addAll(ownedPartitions.subList(maxQuota, ownedPartitions.size())); } else { // 对于预分配时恰好有 minQuota 的消费者，如果有剩余未分配的 partition，则分配一个给它们 List\u0026lt;TopicPartition\u0026gt; minQuotaPartitions = ownedPartitions.subList(0, minQuota); consumerAssignment.addAll(minQuotaPartitions); assignedPartitions.addAll(minQuotaPartitions); allRevokedPartitions.addAll(ownedPartitions.subList(minQuota, ownedPartitions.size())); // 如果没有分配，则记录下来 if (currentNumMembersWithOverMinQuotaPartitions \u0026lt; expectedNumMembersWithOverMinQuotaPartitions) { unfilledMembersWithExactlyMinQuotaPartitions.add(consumer); } } } // 使用轮询的方式，再将多余的 quota 分配给未达到 minQuota 的消费者 Iterator\u0026lt;String\u0026gt; unfilledConsumerIter = unfilledMembersWithUnderMinQuotaPartitions.iterator(); for (TopicPartition unassignedPartition : unassignedPartitions) { // ... unfilledConsumerIter = unfilledMembersWithUnderMinQuotaPartitions.iterator(); consumer = unfilledConsumerIter.next(); int currentAssignedCount = consumerAssignment.size(); if (currentAssignedCount == minQuota) { unfilledConsumerIter.remove(); unfilledMembersWithExactlyMinQuotaPartitions.add(consumer); } // ... } // ... } } 后者的实现与前者类似，有兴趣的朋友可以自行研究。\n4 服务器 4.1 复制和副本 复制 replication 是 Kafka 服务器架构具备数据冗余，高伸缩性，故障自动转移功能的核心机制，它能够保证当个别节点失效时，Kafka 服务器仍然能够正常提供服务。Kafka 服务器中的 topic 被分为若干个 partition，每个 partition 有 n 个副本 replica，n 是 topic 的复制因子 replication factor。\nreplica 分为两种类型，一种是首领 leader，每个 partition 有且仅有一个 leader，为了保证数据的一致性，所有来自生产者和消费者的请求都会到达 leader；另一种是跟随者 follower，它的主要功能是进行数据的备份，partition 中除了 leader 以外的所有 replica 都是 follower，follower 不会处理任何请求，它们只会向 leader 发送 pull 请求（类似于消费者客户端），进行消息的复制，并始终保持与 leader 一致的状态，如果 leader 发生了失效，其中的一个 follower 会被提升为新的 leader。\n对于客户端而言，follower 没有任何意义，它们既不像 MySQL 那样能够帮助 leader 分担承载读请求，也不能实现将就近读取来改善数据局部性，其原因有两点：第一是为了实现 RyW (read your write) / WfR (write follow read)，即每个写操作都依赖于上一个读操作，避免因多个节点写顺序不同导致的 dirty read，在粘滞会话 sticky sessions 的层面解决了一致性问题；第二是为了实现 monotonic read，即客户端在读到一个 value 之后，后续的所有读操作都要读到这个 value 或其之后更新。\n数据一致性 一般来说，有两种方案可以保证数据的强一致性：主备复制 primary-backup replication 和 分布式复制 quorum-based replication。\n分布式复制一般采用 paxos 和 raft 等共识算法 consensus algorithm 实现，其特点是在有 2n + 1个节点的情况下，最多可以容忍 n 个节点失败，它的优点在于延迟更低（因为只需要部分节点写入成功）。\n而主备复制需要等待所有的节点写入成功，在有 n 个节点的情况下，最多可以容忍 n-1 节点失败；它的优点在于可以容忍更多的节点失败（只要有一个节点存活就可以继续工作），并且最少只要有两个节点存在就可以提供服务，而前者需要有至少三个节点。\nKafka 使用了经典的主备复制方式来实现集群之间的日志复制，每个 replica 都在磁盘上维护了一个日志，他们会将接收到的日志按按顺序添加到日志中。当生产者将消息 push 到某个 partition 时，该消息首先会被转发到该 partition 的 leader 上，leader 将其追加到磁盘日志中，同时 partition 上的其他所有 follower 不断地向 leader 请求并同步这个消息，只有当有足够多的 follower 成功处理完消息后，leader 才会认为消息已经处理完成；但 leader 如果总是等待所有 follower 处理完消息，势必会提高系统的延迟，降低服务的可用性。\nISR 为了解决等待 follower 处理完消息的问题，Kafka引入了 ISR In-Sync Replica 的概念。partition 中的所有 replica 统称为AR Assigned Repllicas，所有与 leader 保持一定程度同步的 replica 组成了 ISR In-Sync Replicas，ISR 是 AR 的子集，ISR 包含了 leader。leader 接收到生产者发送的消息后，follower 才能从 leader 上拉取消息进行同步，同步期间内 follower 相对于 leader 会有一定程度的滞后，所谓的“一定程度”指可以忍受的滞后时间，这个滞后时间可以通过修改配置进行调整。相较于 leader 滞后过多的副本会组成 OSR Out-Sync Relipcas，AR = ISR + OSR。正常情况下，所有的 follower 都应该与 leader 保持一定程度的同步，即AR = ISR, OSR = Ø。\nLeader 负责维护和跟踪所有 follower 的滞后状态，当 follower 落后太多或者失效时，leader 会将其从 ISR 集合中剔除；如果 OSR 集合中的 follower 追上了 leader，leader 则会将其加入 ISR 集合。只有 ISR 集合中的 follower 才有资格被选举为leader。但如果当 ISR 集合变为空集，即 leader 失效，且没有其他任何一个 follower 与 leader 之前的状态一致时，可以通过修改配置开启 Unclean Leader Election，使得 OSR 集合中的 follower 可以成为新的 leader。这样可能会造成数据的重复消费，但好处是它使得 partition 至少有一个 leader 并可以继续提供服务，从而提高了高可用性。在这个问题上，Kafka 赋予了开发者选择 CAP 理论中一致性（Consistency）和可用性（Availability）的权利。\npartition 分配 在创建 topic 时，Kafka 服务器首先会决定如何在 broker 间分配 replica，分配有三个目标：\n尽可能在 broker 间平均地分布 replica 确保每个 replica 分布在不同的 broker 上 如果为 broker 指定了机架信息，那么尽可能把每个 replica 分配到不同机架的 broker 上，保证在一个机架不可用的情况下不会导致整个 partition 不可用 如下是分配的流程：\nobject AdminUtils extends Logging { def assignReplicasToBrokers(brokerMetadatas: Iterable[BrokerMetadata], nPartitions: Int, replicationFactor: Int, fixedStartIndex: Int = -1, startPartitionId: Int = -1): Map[Int, Seq[Int]] = { if (nPartitions \u0026lt;= 0) throw new InvalidPartitionsException(\u0026#34;Number of partitions must be larger than 0.\u0026#34;) if (replicationFactor \u0026lt;= 0) throw new InvalidReplicationFactorException(\u0026#34;Replication factor must be larger than 0.\u0026#34;) if (replicationFactor \u0026gt; brokerMetadatas.size) throw new InvalidReplicationFactorException(s\u0026#34;Replication factor: $replicationFactor larger than available brokers: ${brokerMetadatas.size}.\u0026#34;) // 没有指定机架 if (brokerMetadatas.forall(_.rack.isEmpty)) assignReplicasToBrokersRackUnaware(nPartitions, replicationFactor, brokerMetadatas.map(_.id), fixedStartIndex, startPartitionId) else { if (brokerMetadatas.exists(_.rack.isEmpty)) throw new AdminOperationException(\u0026#34;Not all brokers have rack information for replica rack aware assignment.\u0026#34;) // 指定机架 assignReplicasToBrokersRackAware(nPartitions, replicationFactor, brokerMetadatas, fixedStartIndex, startPartitionId) } } // 没有指定机架 private def assignReplicasToBrokersRackUnaware(nPartitions: Int, replicationFactor: Int, brokerList: Iterable[Int], fixedStartIndex: Int, startPartitionId: Int): Map[Int, Seq[Int]] = { val ret = mutable.Map[Int, Seq[Int]]() val brokerArray = brokerList.toArray // 随机选取一个 broker 作为起始位置 startIndex val startIndex = if (fixedStartIndex \u0026gt;= 0) fixedStartIndex else rand.nextInt(brokerArray.length) // 当前当前 partition 的 id 设置为 0 var currentPartitionId = math.max(0, startPartitionId) // 随机选取 broker 的位移 var nextReplicaShift = if (fixedStartIndex \u0026gt;= 0) fixedStartIndex else rand.nextInt(brokerArray.length) for (_ \u0026lt;- 0 until nPartitions) { // 在遍历过 broker 数目个 partition 后将位移加一 if (currentPartitionId \u0026gt; 0 \u0026amp;\u0026amp; (currentPartitionId % brokerArray.length == 0)) nextReplicaShift += 1 // 当前 partition 的 id 加上起始位置，对 brokersize 取余得到第一个副本的位置 val firstReplicaIndex = (currentPartitionId + startIndex) % brokerArray.length val replicaBuffer = mutable.ArrayBuffer(brokerArray(firstReplicaIndex)) for (j \u0026lt;- 0 until replicationFactor - 1) // 计算出每个副本的位置 replicaBuffer += brokerArray(replicaIndex(firstReplicaIndex, nextReplicaShift, j, brokerArray.length)) ret.put(currentPartitionId, replicaBuffer) //分区 id 加一 currentPartitionId += 1 } ret } } 举个例子，假设现在有 6 个broker，我们打算创建一个包含 10 个 partition 的topic，replication factor = 3，那么总共应该有 30 个 replica。为了实现这个目标，我们随机选择一个 broker（假设是 4），然后使用轮询的方式给每个 broker 分配 partition 来确定 leader 的位置，于是 leader0 会在 broker 4 上，leader 1 在 broker 5 上，leader 2 在 broker 0 上，以此类推。然后从 leader 开始，依次分配 follower，既然 leader 0 在 broker 4 上，那么它的 follower 就会依次分布在 broker 5, broker 0；leader 1 在 broker 5 上，那么它的 follower 就会依次分布在 broker 0, broker 1 上。如果配置了机架信息，那么就会按照交替机架的方式来选择 broker。\n4.2 消息处理 Kafka 服务器采用 Reactor 模式处理消息。Reactor 模式是事件驱动架构的一种实现方式，适用于处理多个客户端并发向服务器端发起请求的场景，多个客户端会发送请求给 Reactor，Reactor 的请求分发线程 Acceptor 将不同的请求分发给多个工作线程 worker thread 处理。\nbroker 上有一个 SocketServer 组件，类似于 Reactor 模式中的 Dispatcher，包括对应的 Acceptor 线程和工作线程池（在 Kafka 中叫做网络线程池，默认值为 3 个）。Acceptor 线程采用轮询的方式将流量公平地分发给所有网络线程，避免了请求处理的倾斜，有利于实现较为公平的请求处理调度。\n网络线程获取到请求后，并不会立即处理，而是将请求放入到共享请求队列中；随后，IO 线程池（默认有 8 个）负责从共享请求队列中取出请求，并执行真正的处理，如果是生产者发送的 push request，则将消息写入到底层的磁盘日志中，如果是消费者发送的 pull request，则从磁盘或页缓存中读取消息。IO 线程处理完请求后，会将生成的响应发送到网络线程池的响应队列中，然后由对应的网络线程将 response 返回给客户端；其中请求队列是所有网络线程共享的，而响应队列是每个网络线程专属的。在 IO 线程池和相应队列之间还有一个 Purgatory 组件，用于缓存延时请求。\n4.3 物理存储 Kafka 的基本存储单元是 partition，partition 无法在多个 broker 间再进行细分，也无法在同一个 broker 的多个磁盘上再进行细分。因此，partition 的大小受到单个挂载点可用空间的限制（一个挂载点由单个磁盘或多个磁盘组成，如果配置了JBOD 属于单个磁盘，RAID 属于多个磁盘）。在配置 Kafka 的时候，我们可以指定用于存储 partition 的目录。\n文件管理 我们可以单独为每一个 topic 配置数据保留规则，规定数据被删除之前可以保留多长时间，或者清理数据之前可以保留的数据量大小。\n因为在一个大文件里查找和删除消息是很耗时的，因此我们把 partition 分成若干个片段 segment。默认情况下，每个 segment 包含 1GB 或一周的数据（以较小的为准）。当 broker 往 partition 写入数据时，如果当前 segment 达到上限，则关闭当前文件并打开一个新文件进行写入，当前正在写入数据的 segment 叫作活跃片段 active segment，active segment 永远不会被删除。\nsegment 由索引文件 index file 和数据文件 data file 组成，两个文件一一对应，成对出现，后缀分别为 .index 和 .log；其命名规则为：partition 中全局的第一个 segment 从 0 开始，后续每个 segment 为上一个 segment 最后一条消息的 offset 值：\n$ ll 0000000000000000000.index 0000000000000000000.log 0000000000000368769.ndex 0000000000000368769.log 0000000000000737337.index 0000000000000737337.log 0000000000001105814.index 0000000000001105814.log broker 会为每个 segment 维护一个文件句柄，即使 segment 是不活跃的。\n因为 segment 中保存的数据格式与生产者发送过来，以及发送给消费者的数据格式都是一致的，因此可以使用零拷贝 zero copy 技术来将数据拷贝到页缓存 page cache 中，同时避免对生产者已经压缩过的消息进行解压和压缩。同时，接收数据时并不需要等待数据被写入磁盘，而是只要确认数据被写入到页缓存即可，随后操作系统会根据 LRU 算法定期将页缓存上的脏数据写到物理磁盘上，这里的定期时间间隔是由提交时间来确定的，默认是 5 秒。\n文件压缩 日志压缩是Kafka 的一个高级特性，因为有了这个特性，Kafka 可以用来长时间地保存数据。\n除了 key, value, offset 之外，生产者发送来的消息里还包含了消息大小、校验和、消息格式版本号、压缩算法和时间戳等信息，时间戳可以是生产者发送消息的时间，也可以是消息到达broker 的时间（可配置）；如果生产者发送的是压缩过的消息，那么同一个 batch 的消息会被压缩在一起，被当作包装消息 Wrapper message；此后，broker 再把这个消息组发送给消费者。\nKafka 将消息构造为递归的模式，外层是一个包装消息，其值又是一个消息集合，称为内层消息 Inner message，外层消息可能有多条，每条外层消息的值都包装了多条内层消息，在外层指定一个压缩方法，再对内层消息使用这种压缩方法进行解压缩即可。\n引用 Mirror of Apache Kafka - GitHub\nApache Kafka Documentation\nKafka 权威指南\n深入理解 Kafka\nApache Kafka实战\nKafka 分区机制产生的消息推送和消费逻辑 ","permalink":"https://prov1dence.top/posts/message-broker/kafka/","summary":"\u003ch1 id=\"kafka-入门\"\u003eKafka 入门\u003c/h1\u003e\n\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003eKafka 最初是为了解决 LinkedIn 数据管道问题应运而生的。它的设计目的是提供一个高性能的消息系统，可以处理多种数据类型，并能够实时提供纯净且结构化的用户活动数据和系统度量指标。\u003c/p\u003e\n\u003cp\u003e它不只是一个数据存储系统（类似于传统的关系型数据库、键值存储引擎、搜索引擎或缓存系统），还是一个持续变化和不断增长的流处理系统。现在 Kafka 已经被广泛地应用在社交网络的实时数据流处理当中，成为了下一代数据架构的基础。Kafka 经常会被拿来与现有的企业级消息系统、大数据系统（如 Hadoop）和数据集成 ETL 工具等技术作比较。\u003c/p\u003e\n\u003cp\u003e从发布和订阅消息流的角度来看，Kafka 类似于 ActiveMQ、RabbitMQ 或 IBM 的 MQSeries 等产品，其特点在于它以集群的方式运行，可以\u003cstrong\u003e自由伸缩\u003c/strong\u003e，处理大量的应用程序；其次，Kafka 可以按照要求持久化数据，即提供了数据传递的保证——可复制、持久化，保留多长时间完全可以由开发者决定。此外，消息系统只会传递消息，而 Kafka 的流式处理能力让我们只用很少的代码就能够动态地处理派生流和数据集。\u003c/p\u003e\n\u003ch2 id=\"1-基础概念\"\u003e1 基础概念\u003c/h2\u003e\n\u003ch4 id=\"消息代理\"\u003e消息代理\u003c/h4\u003e\n\u003cp\u003e在一个基于发布与订阅的消息系统中，数据消息的发送者不直接把消息发送给接收者，而是通过一个\u003cstrong\u003e消息代理 message broker\u003c/strong\u003e 传递消息，接收者订阅消息代理，并以特定的方式接收消息。Kafka 就是一个消息代理。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e消息代理 message broker\u003c/strong\u003e 是一种针对处理消息流而优化的数据库，它作为独立的中间服务运行，生产者和消费者作为客户端连接到消息代理服务，在使用消息代理的架构中主要有 3 种角色：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e生产者\u003c/strong\u003e将消息写入消息代理；生产者一般是异步架构的，当生产者发送消息时，它只会等待消息代理确认消息已经被缓存，而不等待消息被消费者处理\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e消息代理\u003c/strong\u003e负责消息的存储，发送、重传等，一般会包含多个\u003cstrong\u003e消息队列 message queue\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e消费者\u003c/strong\u003e从消息代理接收消息并进行处理；消费者只依赖于消息代理，与生产者完全隔离\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e消息代理的优势主要有以下几点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e实现异步处理，提升性能\u003c/p\u003e\n\u003cp\u003e把消息处理流程使用消息代理异步化，不会阻塞生产者服务，生产者服务可以在得到处理结果之前继续执行，并提高其并发处理的能力。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e提高系统的可伸缩性\u003c/p\u003e\n\u003cp\u003e生产者将大量消息推送到消息代理中，消息代理可以将这些消息分发给不同的消费者，使得多个消费者并行地处理消息，当消费者负载变化时，可以很容易地对消费者服务进行水平伸缩\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e削峰填谷\u003c/p\u003e\n\u003cp\u003e当生产者推送消息的速度比消费者处理消息的速度更快时，可以使用消息队列作为消息的缓冲，来削弱峰值流量，防止系统被短时间内的流量冲垮\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e应用解耦\u003c/p\u003e\n\u003cp\u003e使用消息代理后，生产者和消费者即可解耦，不再需要有任何联系，也不需要受对方的影响，只要保持使用一致的消息格式即可。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"消息和批次\"\u003e消息和批次\u003c/h4\u003e\n\u003cp\u003eKafka 的数据单元被称为消息，消息类似于关系型数据库里的一个数据行或一条记录；消息由字节数组组成，当消息以一种可控的方式写入不同的分区时，会用到 key，Kafka 会为 key 生成一个一致性散列值，然后使用散列值对主题分区数进行取模，为消息选取分区。这样可以保证具有相同 key 的消息总是被写到相同的分区上。\u003c/p\u003e\n\u003cp\u003e如果每一个消息都单独发送，会导致大量的网络开销。为了提高效率，消息会被分批次写入Kafka；\u003cstrong\u003e批次 batch\u003c/strong\u003e 是一组消息，这些消息属于同一个主题和分区；批次数据在传输时会被压缩，这样可以提升数据的传输和存储能力；单个 batch 的消息数量越大，单位时间内处理的消息就越多，但单个 batch 的传输时间就越长，因此需要在时延和吞吐量之间作出权衡。\u003c/p\u003e\n\u003ch4 id=\"主题和分区\"\u003e主题和分区\u003c/h4\u003e\n\u003cp\u003eKafka 的消息通过\u003cstrong\u003e主题 topic\u003c/strong\u003e 进行分类，主题就好比关系型数据库的表，或者文件系统里的目录；同一个主题可以被分为若干个\u003cstrong\u003e分区 partition\u003c/strong\u003e，一个 partition 即一个提交日志，消息以追加的方式写入 partition，然后以先入先出的顺序读取。一个 topic 一般包含多个 partition，因此无法在整个 topic 的维度保证消息的顺序，只能保证消息在单个 partition 内的顺序。\u003c/p\u003e","title":"Kafka 入门"},{"content":"Prometheus 入门 Prometheus 是一个开源的监控解决方案，也是云原生基金会 CNCF 的毕业项目，它能够提供指标数据的采集、存储、查询、告警等功能。本文主要介绍 Prometheus 的基础概念和应用中需要注意的一些问题。\n1 监控系统 1.1 监控模式 监控系统执行监控检查的模式有两种，分别是 pull 和 push。Prometheus 采用了 pull 模式进行数据收集，同时也支持使用 Pushgateway 的 push 模式进行数据中转。\npull 方式的特点是有拉取间隔，不能及时获取数值的变化，因此需要进一步的数据处理；它的优点是在告警时可以按照策略分片，仅拉取需要的数据，并且支持聚合场景；缺点是监控的数据量庞大，对存储有较高的要求，切需要考虑数据的冷热分离。\npush 方式的特点是由服务主动将数据推向监控系统，实时性更高；它的缺点是推送数据的不可预知性，因为当大量数据被推送到监控系统时，数据的缓存和解析会消耗大量资源，此时如果因为网络原因数据的收发没有得到确认，很容易产生数据的重发和重复，因此需要进行去重等操作。\npull 模式在云原生环境中更有优势，因为我们可以通过服务发现对所有需要进行监控的节点进行统一的数据拉取，如果使用 push 模式则需要在每个被监控的服务中部署上报数据的客户端，并配置监控服务器的信息，这会加大部署的难度。\n1.2 Prometheus Prometheus 是一套开源的数据采集与监控框架，可以做后台服务器的监控告警，此处用来采集被测服务的性能指标数据，包括CPU占用比率、内存消耗、网络IO等。\n特点 Prometheus 最主要的特点有 4 个：\n通过 PromQL 实现多维度数据模型的灵活查询；这使得监控指标可以关联到多个标签，并对时间序列进行切片和切块，以支持各种查询和告警场景 定义了开放指标数据的标准，可以方便地自定义探针（exporter） 利用 Pushgateway 组件可以以 push 的方式接收监控数据 提供了容器化版本 架构 Prometheus 的架构主要由以下部分组成：\nPrometheus Server\nPrometheus 服务器主要包含了使用 pull 模式抓取监控数据，通过本地存储（本地磁盘）和远程存储（OpenTSDB, InfluxDB, ElasticSearch 等）保存数据，使用 PromQL 查询数据三大功能。\nPromQL (Prometheus Query Language) 是 Prometheus 内置的数据查询语言，提供了对时间序列数据的查询，聚合和逻辑运算等操作的支持，被广泛地应用在数据的查询，可视化和告警中。关于 PromQL 的相关操作可以参考 探索PromQL。\nPushgateway\nPushgateway 是用来实现 push 模式监控的组件，一般应用于短作业，批处理作业，或当服务与 Prometheus 服务器之间有网络隔离时；它的主要问题是存在单点故障，一个 Pushgateway 的宕机会导致所有被推送到这个 Pushgateway 上的数据的丢失，如果使用多个 Pushgateway 实例组成的集群，那么每一次数据推送只会被分发到单个实例上，但 Prometheus Server 每次会在所有的 Pushgateway 实例上进行数据采集，这会导致数据错乱，目前官方对此并没有解决方案，一个比较好的开源方案是使用动态一致性哈希 + 基于 consul 的 service check；除此之外，Pushgateway 不会自动删除任何指标数据，即使在进行过 push 操作的 pod 被销毁之后，其上报的所有数据仍然残留在 Pushgateway 中，需要手动。\nJob/Exporter\nJob 和 Exporter 都是 Prometheus 的 target 监控对象；exporter 的机制是将监控数据暴露出来，Prometheus 对这些指标进行采集；每个 exporter 需要单独维护，如果数量过多可以考虑使用 Telegraf 进行统一管理。\nService Discovery\n相比于读取文件配置，在云原生和容器环境下被监控实例都是会动态变化的，而通过服务发现，我们可以在很方便地获取需要被检控的 target 的实例信息；服务发现中的 relabeling 机制可以从 target 实例中获取元标签数据，从而对不同开发环境进行区分。\nAlertmanager\nPrometheus 将数据采集和告警分离成了两个模块，告警模块叫做 Alertmanager，它是独立于 Prometheus 的一个组件，需要单独部署，多个 Alertmanager 可以配置为一个集群来避免单点问题。报警规则被配置在 Prometheus Servers 上，产生告警信息时会通知 AlertManger，AlertManager 会通过 silencing, inhibition 等方式聚合，并通过 email、PagerDuty、HipChat、Slack 等方式发送告警提示。\nDashboard\nWeb UI, Grafana, API Client 等统称为 Dashboard。\n局限性 Prometheus 是基于 metrics 的系统，不适合存储日志 Prometheus 认为只有近期的数据才需要被查询，因此本地存储只会保存短期数据；TB 级以上的历史数据需要搭配 OpenTSDB 等远端存储使用 Prometheus 的集群方案有 federation 和开源的 Thanos，但都存在各种细节上的技术问题（如耗尽 CPU 和机器资源），其成熟度都比不上在时序数据库中排名第一的 InfluxDB 2 数据模型 2.1 时序数据 Prometheus 存储的是时序数据，即由名称 name，标签 label 与值 value 定义的指标 metric；Prometheus 中所有的指标都是时序数据，并以名称和标签进行区分；具有相同名称和标签的数据属于相同时序，这些时序数据拥有不同的时间戳。\n指标命名 指标的名字由 ASCII 字符，数字，下划线，以及冒号组成，且满足正则表达式 [a-zA-Z0-9_:]*, 其命名应该具有语义化，用于表示一个可以度量的指标，例如 http_requests_total；时序的标签可以用于区分具体不同的方法和参数变量，例如 http_requests_total{method=\u0026quot;POST\u0026quot;}。\n一个 metric 的命名应该具有以下几个特点：\n以命名空间或应用名称作为前缀，避免不通作用域的相同名称产生冲突，例如 prometheus_notifications_total, http_request_duration_seconds\n以基本单位（秒，米，字节，个数等）作为后缀，例如 http_requests_total, node_memory_usage_bytes\n将所有标签的共同逻辑部分抽离作为名称，将可变量作为标签的一部分\n指标类型 指标是整个监控系统的核心，Prometheus 中的指标类型 Metrics Type 有以下四种：\nCounter Counter 是只增不减的计数器，一般用于记录服务请求，返回或错误的总量，它会在程序重启时被重置为 0。例如 Prometheus Server 中 http_requests_total 表示当前处理的 http 请求总数。\n为了能够直观地展示指标数据计数的变化情况，一般需要计算 Counter 数据的增长速率，建议 PromQL 中的 rate, topk, increase, irate 等函数使用。\nGauge Gauge 表示可以任意变化的快照数据，一般用于记录内存使用率，CPU 温度，程序中的 goroutine 数量等。例如 Prometheus Server 中 go_goroutines 表示当前 goroutines 的数量。\nGauge 经常结合 PromQL 中的最大值 max，最小值min，总和 sum 函数，或基于线性回归的时间序列预测函数 predict_linear ，获取指标在一段时间内的变化情况的 delta 等函数使用。\nHistogram Histogram 用于对一定时间范围内的数据进行采样，记录各个桶中的数据个数。例如 Prometheus Server 中 prometheus_local_storage_series_chunks_persisted 表示每个时间序列需要存储的 chunks 数量，我们可以使用 histogram_quantile 计算待持久化的数据的分位数 quantile 数据。\nSummary Summary 和 Histogram 类似，也用于表示一段时间范围内的数据采样结果，它直接存储了分位数 quantile 数据（通过客户端计算），而非根据统计区间计算。对于分位数的计算，Summary 在通过 PromQL 进行查询时有更好的性能表现，而 Histogram 则会消耗更多的资源。反之，对于客户端而言，Histogram 消耗的资源更少。\n2.2 数据采集 Prometheus server 的数据采集基于 Pull 模型，其工作流程大致为 Prometheus server 会定期地从 exporter 上通过 HTTP 接口获取 metrics 结构的数据，并进行存储，如果 Prometheus Server 与 Exporter 不能够直接进行通信，那么我们可以将 exporter 上的数据推送到 Pushgateway 上，并让 Prometheus Server 从 PushGateway 上获取数据。\n术语 Exporter：所有向 Prometheus server 提供数据的程序都可以被称为 exporter，Prometheus server 会周期性地从 exporter 提供的HTTP 服务 URL 拉取数据，我们只需要在 Prometheus server 的配置文件 /etc/prometheus/prometheus.yml 中添加一个target，并重启服务即可定位到 exporter 并拉取数据。\nInstance：任意一个独立的数据源 target 都可以被称为 Instance 实例，它是用来提供数据的最小单位。\nJob：包含相同类型的实例的集合叫做 Job，例如在 k8s 集群上被复制出的可弹性伸缩的一组 pod 中的相同进程。\n2.3 Pushgateway 由于 Prometheus server 采用 pull 模式获取数据，如果 Prometheus server 和 exporter 由于不在一个子网环境或由于防火墙原因导致两者无法直接通信，或在我们需要将多个 exporter 的数据汇总到一起时，我们可以主动将数据推送到 Pushgateway 上，间接地进行数据采集；但它的弊端也很明显，那就是单点故障，如果唯一的 Pushgateway 出现不可用的情况，那么所有的数据都无法被 Prometheus server 获取。\nPushgateway 不需要任何配置，直接启动 docker image 后即可使用。\ndocker pull prom/pushgateway docker run -d -p 9091:9091 prom/pushgateway 启动好 Pushgateway 之后，需要在 Prometheus server 的静态配置中添加 Pushgateway：\ndocker exec -it --user root f257794e5e3d sh vi /etc/prometheus/prometheus.yml scrape_configs: - job_name: \u0026#34;pushgateway\u0026#34; static_configs: - targets: [\u0026#34;ip:port\u0026#34;] 修改配置后，发送信号给 Prometheus Server 使其加载最新的配置：\nkill -HUP $pid 默认情况下，Pushgateway 将所有数据存储在内存中，因此一旦 Pushagateway 服务因为故障而停止运行，那么所有尚未被 Prometheus server 获取的数据都将会丢失，为此可以在启动 Pushgateway 服务时通过指定 persistence.file 参数将数据持久化：\npushgateway --persistence.file=\u0026#34;/tmp/pushgateway_persist\u0026#34; 默认情况下，文件每五分钟持久化写入一次，我们可以通过修改 persistence.interval 参数来进行调整。\n推送数据 向 Pushgateway 推送数据时可以使用 PUT 和 POST 两种方法，其中 PUT 会将实例中的所有 metrics 替换为新推送的 metrics，而 POST 则只会将 name 相同 metrics 替换（前提是这部分数据在相同的 job/instance 下）；\n假设将要进行推送的数据如下：\n$ cat req1.txt # TYPE foo GAUGE foo{id=\u0026#34;1\u0026#34;} 1 foo{id=\u0026#34;2\u0026#34;} 2 foo{id=\u0026#34;3\u0026#34;} 3 # TYPE bar GAUGE bar{id=\u0026#34;11\u0026#34;} 11 将其推送到 Pushgateway 上并检查：\n$ curl -X POST --data-binary @req1.txt localhost:9091/metrics/job/test $ curl localhost:9091/metrics | grep test bar{id=\u0026#34;11\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 11 foo{id=\u0026#34;1\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 1 foo{id=\u0026#34;2\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 2 foo{id=\u0026#34;3\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 3 使用 POST 方法推送另一组数据：\n$ cat req2.txt # TYPE foo GAUGE foo{id=\u0026#34;4\u0026#34;} 4 foo{id=\u0026#34;5\u0026#34;} 5 $ curl -X POST --data-binary @req2.txt localhost:9091/metrics/job/test $ curl localhost:9091/metrics | grep test bar{id=\u0026#34;11\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 11 foo{id=\u0026#34;4\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 4 foo{id=\u0026#34;5\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 5 可以看到原有的 name 为 foo 的数据都被覆盖了；\n使用 PUT 方法推送第二组数据：\n$ curl -X PUT --data-binary @req2.txt localhost:9091/metrics/job/test $ curl localhost:9091/metrics | grep test foo{id=\u0026#34;4\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 4 foo{id=\u0026#34;5\u0026#34;,instance=\u0026#34;\u0026#34;,job=\u0026#34;test\u0026#34;} 5 可以看到原有的所有数据（包括 name 不同的 bar 数据）都被覆盖了。\n推送不能包含时间戳\nPrometheus pull 数据时不会采集与当前时间差在 5 分钟以上的数据，官方认为 pushgateway 一般用在临时任务和批处理作业上，为了防止这些任务因为存在的时间不够长导致 Prometheus 还没来得及 pull 数据就结束了，所以不允许在向 pushgateway 推送数据时带上时间戳。\n删除数据 如果想要删除 Pushgateway 上特定的数据，可以使用官方提供的 http API：\n删除特定 job 和 instance 的所有数据： curl -X DELETE http://pushgateway.example.org:9091/metrics/job/some_job/instance/some_instance 删除特定 job ，且 instance=\u0026quot;\u0026quot; 下的所有数据，注意这不会删除其他 instance 的数据： curl -X DELETE http://pushgateway.example.org:9091/metrics/job/some_job 删除一个实例上的所有数据（需要在启动时加上参数 --web.enable-admin-api 才能用）： curl -X PUT http://pushgateway.example.org:9091/api/v1/admin/wipe ","permalink":"https://prov1dence.top/posts/cloud/intro-to-prometheus/","summary":"\u003ch1 id=\"prometheus-入门\"\u003ePrometheus 入门\u003c/h1\u003e\n\u003cp\u003ePrometheus 是一个开源的监控解决方案，也是云原生基金会 CNCF 的毕业项目，它能够提供指标数据的采集、存储、查询、告警等功能。本文主要介绍 Prometheus 的基础概念和应用中需要注意的一些问题。\u003c/p\u003e\n\u003ch2 id=\"1-监控系统\"\u003e1 监控系统\u003c/h2\u003e\n\u003ch3 id=\"11-监控模式\"\u003e1.1 监控模式\u003c/h3\u003e\n\u003cp\u003e监控系统执行监控检查的模式有两种，分别是 \u003cstrong\u003epull\u003c/strong\u003e 和 \u003cstrong\u003epush\u003c/strong\u003e。Prometheus 采用了 pull 模式进行数据收集，同时也支持使用 Pushgateway 的 push 模式进行数据中转。\u003c/p\u003e\n\u003cp\u003epull 方式的特点是有拉取间隔，不能及时获取数值的变化，因此需要进一步的数据处理；它的优点是在告警时可以按照策略分片，仅拉取需要的数据，并且支持聚合场景；缺点是监控的数据量庞大，对存储有较高的要求，切需要考虑数据的冷热分离。\u003c/p\u003e\n\u003cp\u003epush 方式的特点是由服务主动将数据推向监控系统，实时性更高；它的缺点是推送数据的不可预知性，因为当大量数据被推送到监控系统时，数据的缓存和解析会消耗大量资源，此时如果因为网络原因数据的收发没有得到确认，很容易产生数据的重发和重复，因此需要进行去重等操作。\u003c/p\u003e\n\u003cp\u003epull 模式在云原生环境中更有优势，因为我们可以通过服务发现对所有需要进行监控的节点进行统一的数据拉取，如果使用 push 模式则需要在每个被监控的服务中部署上报数据的客户端，并配置监控服务器的信息，这会加大部署的难度。\u003c/p\u003e\n\u003ch3 id=\"12-prometheus\"\u003e1.2 Prometheus\u003c/h3\u003e\n\u003cp\u003ePrometheus 是一套开源的数据采集与监控框架，可以做后台服务器的监控告警，此处用来采集被测服务的性能指标数据，包括CPU占用比率、内存消耗、网络IO等。\u003c/p\u003e\n\u003ch4 id=\"特点\"\u003e特点\u003c/h4\u003e\n\u003cp\u003ePrometheus 最主要的特点有 4 个：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e通过 PromQL 实现多维度数据模型的灵活查询；这使得监控指标可以关联到多个标签，并对时间序列进行切片和切块，以支持各种查询和告警场景\u003c/li\u003e\n\u003cli\u003e定义了开放指标数据的标准，可以方便地自定义探针（exporter）\u003c/li\u003e\n\u003cli\u003e利用 Pushgateway 组件可以以 push 的方式接收监控数据\u003c/li\u003e\n\u003cli\u003e提供了容器化版本\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"架构\"\u003e架构\u003c/h4\u003e\n\u003cp\u003e\u003cimg alt=\"prometheus-architecture\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/data/prometheus-architecture.png\"\u003e\u003c/p\u003e\n\u003cp\u003ePrometheus 的架构主要由以下部分组成：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003ePrometheus Server\u003c/p\u003e\n\u003cp\u003ePrometheus 服务器主要包含了使用 pull 模式抓取监控数据，通过本地存储（本地磁盘）和远程存储（OpenTSDB, InfluxDB, ElasticSearch 等）保存数据，使用 PromQL 查询数据三大功能。\u003c/p\u003e\n\u003cp\u003ePromQL (Prometheus Query Language) 是 Prometheus 内置的数据查询语言，提供了对时间序列数据的查询，聚合和逻辑运算等操作的支持，被广泛地应用在数据的查询，可视化和告警中。关于 PromQL 的相关操作可以参考 \u003ca href=\"https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language\"\u003e探索PromQL\u003c/a\u003e。\u003c/p\u003e","title":"Prometheus 入门"},{"content":"Python 源码学习（5）：协程 协程 coroutine 是一种用户态的轻量级线程，它可以在函数的特定位置暂停或恢复，同时调用者可以从协程中获取状态或将状态传递给协程；Python中的生成器 generator 就是一个典型的协程应用，本文简单地对 Python 中生成器的实现进行分析。\n1 生成器 如果 Python 中的函数含有 yield 关键字，那么在调用这个函数时，它不会如同普通的函数一样运行到 return 语句并返回一个变量，而是会立即返回一个生成器对象；以一个斐波那契数列生成函数为例：\ndef FibonacciSequenceGenerator(): a, b = 0, 1 while True: yield a + b a, b = b, a + b if __name__ == \u0026#34;__main__\u0026#34;: fsg = FibonacciSequenceGenerator() print(fsg) print(type(fsg)) $ python3 main.py \u0026lt;generator object FibonacciSequenceGenerator at 0x7fb4720b1ac0\u0026gt; \u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; 可以看到函数 FibonacciSequenceGenerator 返回了一个类型为 generator 的生成器对象 f；对于生成器对象，我们不能像操作普通函数一样直接进行函数调用，而是要使用 next() 或 fsg.send() 来进行函数切换，使得生成器函数开始或继续执行，直到 yield 所在行或是函数末尾再将执行权交还给调用方：\nfor i in range(100): print(next(fsg)) $ python3 main.py 1 2 3 5 # ... 218922995834555169026 354224848179261915075 573147844013817084101 生成器的这种行为与线程切换非常类似，它包含了执行，保存，恢复上下文的步骤，用生成器来模拟线程的行为可以避免从用户态到内核态的切换，从而提升效率。\n2 协程 2.1 生成器对象 通过类型对象的 tp_name 变量可以找到生成器 generator 对象在源码中对应的结构体是 PyGenObject，它的类型对象是 PyGen_Type：\n// Inlcude/genobject.h /* _PyGenObject_HEAD defines the initial segment of generator and coroutine objects. */ #define _PyGenObject_HEAD(prefix) \\ PyObject_HEAD \\ /* Note: gi_frame can be NULL if the generator is \u0026#34;finished\u0026#34; */ \\ PyFrameObject *prefix##_frame; \\ /* True if generator is being executed. */ \\ char prefix##_running; \\ /* The code object backing the generator */ \\ PyObject *prefix##_code; \\ /* List of weak reference. */ \\ PyObject *prefix##_weakreflist; \\ /* Name of the generator. */ \\ PyObject *prefix##_name; \\ /* Qualified name of the generator. */ \\ PyObject *prefix##_qualname; \\ _PyErr_StackItem prefix##_exc_state; typedef struct { /* The gi_ prefix is intended to remind of generator-iterator. */ _PyGenObject_HEAD(gi) } PyGenObject; // Inlcude/genobject.c PyTypeObject PyGen_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) \u0026#34;generator\u0026#34;, /* tp_name */ sizeof(PyGenObject), /* tp_basicsize */ 0, /* tp_itemsize */ /* methods */ (destructor)gen_dealloc, /* tp_dealloc */ // ... (iternextfunc)gen_iternext, /* tp_iternext */ _PyGen_Finalize, /* tp_finalize */ }; PyGenObject 结构体中的成员变量不多，分别是：\n定长对象公共头部 PyObject_HEAD，其中包括引用计数 ob_refcnt 和类型对象指针 ob_type； 生成器是否正在运行的标志 gi_running； 生成器运行时依赖的栈帧对象 gi_frame； 生成器对应的代码对象 gi_code； 生成器的弱引用列表 gi_weakreflist； 生成器的名称 gi_name 和 gi_qualname； 生成器的异常状态 gi_exec_state； 生成器在刚被创建时，并不会立即执行，并且其栈帧对象中最后一条执行过的指令也为空：\nprint(fsg.gi_running) print(fsg.gi_frame.f_lasti) $ python3 main.py False -1 当然它的栈帧对象也是和代码对象相关联的：\nprint(fsg.gi_code) print(fsg.gi_frame) print(fsg.gi_frame.f_code) $ python3 main.py \u0026lt;code object FibonacciSequenceGenerator at 0x7f8283e49c90, file \u0026#34;main.py\u0026#34;, line 89\u0026gt; \u0026lt;frame at 0x7f8283f17610, file \u0026#39;main.py\u0026#39;, line 89, code FibonacciSequenceGenerator\u0026gt; \u0026lt;code object FibonacciSequenceGenerator at 0x7f8283e49c90, file \u0026#34;main.py\u0026#34;, line 89\u0026gt; 2.2 执行 next next() 函数是 Python 的内置函数，用于驱动生成器的执行，或者说将程序的调用栈从当前函数切换到生成器中；其源码如下：\n// Python/bltinmodule.c builtin_next(PyObject *self, PyObject *const *args, Py_ssize_t nargs) { PyObject *it, *res; if (!_PyArg_CheckPositional(\u0026#34;next\u0026#34;, nargs, 1, 2)) return NULL; it = args[0]; if (!PyIter_Check(it)) { PyErr_Format(PyExc_TypeError, \u0026#34;\u0026#39;%.200s\u0026#39; object is not an iterator\u0026#34;, Py_TYPE(it)-\u0026gt;tp_name); return NULL; } res = (*Py_TYPE(it)-\u0026gt;tp_iternext)(it); if (res != NULL) { return res; } else if (nargs \u0026gt; 1) { PyObject *def = args[1]; if (PyErr_Occurred()) { if(!PyErr_ExceptionMatches(PyExc_StopIteration)) return NULL; PyErr_Clear(); } Py_INCREF(def); return def; } else if (PyErr_Occurred()) { return NULL; } else { PyErr_SetNone(PyExc_StopIteration); return NULL; } } 除去前后两大块类型检查，最核心的部分是 res = (*it-\u0026gt;ob_type-\u0026gt;tp_iternext)(it)，即获取参数中 args[0] 的类型对象，并调用其 tp_iternext 函数指针，再检查返回的结果；因此当我们对生成器对象 fsg 调用 next 函数时，实际上是调用了生成器类型对象 PyGen_Type 的 gen_iternext 函数，来驱动生成器开始或继续运行，而这个 gen_iternext 函数则调用了 gen_send_ex 函数：\n// Objects/genobject.c static PyObject * gen_iternext(PyGenObject *gen) { return gen_send_ex(gen, NULL, 0, 0); } static PyObject * gen_send_ex(PyGenObject *gen, PyObject *arg, int exc, int closing) { PyFrameObject *f = gen-\u0026gt;gi_frame; // ... /* Generators always return to their most recent caller, not * necessarily their creator. */ Py_XINCREF(tstate-\u0026gt;frame); assert(f-\u0026gt;f_back == NULL); f-\u0026gt;f_back = tstate-\u0026gt;frame; gen-\u0026gt;gi_running = 1; gen-\u0026gt;gi_exc_state.previous_item = tstate-\u0026gt;exc_info; tstate-\u0026gt;exc_info = \u0026amp;gen-\u0026gt;gi_exc_state; if (exc) { assert(_PyErr_Occurred(tstate)); _PyErr_ChainStackItem(NULL); } result = _PyEval_EvalFrame(tstate, f, exc); tstate-\u0026gt;exc_info = gen-\u0026gt;gi_exc_state.previous_item; gen-\u0026gt;gi_exc_state.previous_item = NULL; gen-\u0026gt;gi_running = 0; // ... } gen_send_ex 函数很长，但其中最关键的只有上面截取的部分，这部分代码首先将生成器对象的栈帧挂到当前调用链上 f-\u0026gt;f_back = tstate-\u0026gt;frame;，并修改生成器对象的运行状态 gen-\u0026gt;gi_running = 1，接下来再通过调用 _PyEval_EvalFrame 来执行生成器栈帧，关于 _PyEval_EvalFrame 函数的流程已经在前文讨论过，简单地来说就是通过在一个循环中通过 switch case 不断地执行生成器对象对应的字节码。\nsend 和 next 函数类似，send 函数也可以用来驱动生成器执行，从调用形式上来看它们之间唯一的区别就是 send 函数会额外的传入一个参数，而从 send 函数的源码中可以看到它同样地也会调用 gen_send_ex 函数，不过其第二个参数是一个对象指针（而不像 gen_iternext 函数中一样传入了一个 NULL）：\n// Objects/genobject.c static PyMethodDef gen_methods[] = { {\u0026#34;send\u0026#34;,(PyCFunction)_PyGen_Send, METH_O, send_doc}, // ... }; PyObject * _PyGen_Send(PyGenObject *gen, PyObject *arg) { return gen_send_ex(gen, arg, 0, 0); } 查看一下两者对应的字节码指令中的区别：\nimport os, sys def FibonacciSequenceGenerator(): a, b = 0, 1 while True: yield a + b a, b = b, a + b def DriveCo(co): r = next(fsg) r = fsg.send(1) if __name__ == \u0026#34;__main__\u0026#34;: fsg = FibonacciSequenceGenerator() DriveCo(fsg) import dis dis.dis(DriveCo) $ python3 main.py 10 0 LOAD_GLOBAL 0 (next) 2 LOAD_GLOBAL 1 (fsg) 4 CALL_FUNCTION 1 6 STORE_FAST 1 (r) 11 8 LOAD_GLOBAL 1 (fsg) 10 LOAD_METHOD 2 (send) 12 LOAD_CONST 1 (1) 14 CALL_METHOD 1 16 STORE_FAST 1 (r) 18 LOAD_CONST 0 (None) 20 RETURN_VALUE 可以看到相比于 next 函数的字节码指令，send 函数只是在调用函数（CALL_FUNCTION / CALL_METHOD）前加上了 LOAD_CONST 指令来将参数置入栈顶。\n2.3 暂停 在 Python 中可以使用内置的 yield 函数来暂停生成器对象的执行并返回一个值，我们可以研究一下 FibonacciSequenceGenerator 函数以及 yield 语句对应的字节码指令：\nimport dis dis.dis(fsg) $ python3 main.py 2 0 LOAD_CONST 1 ((0, 1)) 2 UNPACK_SEQUENCE 2 4 STORE_FAST 0 (a) 6 STORE_FAST 1 (b) 4 \u0026gt;\u0026gt; 8 LOAD_FAST 0 (a) 10 LOAD_FAST 1 (b) 12 BINARY_ADD 14 YIELD_VALUE 16 POP_TOP 5 18 LOAD_FAST 1 (b) 20 LOAD_FAST 0 (a) 22 LOAD_FAST 1 (b) 24 BINARY_ADD 26 ROT_TWO 28 STORE_FAST 0 (a) 30 STORE_FAST 1 (b) 32 JUMP_ABSOLUTE 8 34 LOAD_CONST 0 (None) 36 RETURN_VALUE 其中第 2 行（a, b = 0, 1）和第 5 行（a, b = b, a + b）都是在进行 a, b 变量的赋值操作，而在第 4 行则可以看到在执行 yield a + b 操作时，实际上是先通过 LOAD_FAST 和 BINARY_ADD 将新计算出的值保存在栈顶，再进行了 YIELD_VALUE 和 POP_TOP 指令操作，查看一下这两个指令的源码：\n// Python/ceval.c PyObject* _Py_HOT_FUNCTION _PyEval_EvalFrameDefault(PyThreadState *tstate, PyFrameObject *f, int throwflag) { // ... case TARGET(POP_TOP): { PyObject *value = POP(); Py_DECREF(value); FAST_DISPATCH(); } // ... case TARGET(YIELD_VALUE): { retval = POP(); if (co-\u0026gt;co_flags \u0026amp; CO_ASYNC_GENERATOR) { PyObject *w = _PyAsyncGenValueWrapperNew(retval); Py_DECREF(retval); if (w == NULL) { retval = NULL; goto error; } retval = w; } f-\u0026gt;f_stacktop = stack_pointer; goto exiting; } // ... return _Py_CheckFunctionResult(tstate, NULL, retval, __func__); } 可以看到 YIELD_VALUE 指令的操作非常简单，它会先取出栈顶的数据作为 yield 语句的返回值，再修改指向当前栈帧顶部的指针所指向的地址，最后通过 goto 语句结束执行；随后，_PyEval_EvalFrameDefault 函数会将生成器对象的栈帧从当前调用链中移除，并返回 retval。\n3 总结 至此可以发现 Python 中的生成器是完全符合协程的定义（可以在用户态中断和恢复）的；同时由于 Python 虚拟机本身的实现是 基于栈的（Stack-Based），因此生成器对象在字节码层面的实现也是非常简洁的。而协程可以在线程的基础之上，借助基于 epoll 等 IO 多路复用的事件循环，来驱动不同的子程序（subroutine）和上下文的执行，实现形似阻塞式但实际是异步的编程模型，适用于 IO 密集型场景。\n","permalink":"https://prov1dence.top/posts/python/python-source-code-coroutine/","summary":"\u003ch1 id=\"python-源码学习5协程\"\u003ePython 源码学习（5）：协程\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e协程\u003c/strong\u003e \u003cem\u003ecoroutine\u003c/em\u003e 是一种用户态的轻量级线程，它可以在函数的特定位置暂停或恢复，同时调用者可以从协程中获取状态或将状态传递给协程；Python中的\u003cstrong\u003e生成器\u003c/strong\u003e \u003cem\u003egenerator\u003c/em\u003e 就是一个典型的协程应用，本文简单地对 Python 中生成器的实现进行分析。\u003c/p\u003e\n\u003ch2 id=\"1-生成器\"\u003e1 生成器\u003c/h2\u003e\n\u003cp\u003e如果 Python 中的函数含有 yield 关键字，那么在调用这个函数时，它不会如同普通的函数一样运行到 \u003ccode\u003ereturn\u003c/code\u003e 语句并返回一个变量，而是会立即返回一个生成器对象；以一个斐波那契数列生成函数为例：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFibonacciSequenceGenerator\u003c/span\u003e():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    a, b \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eTrue\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eyield\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e b\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        a, b \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e b, a \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e b\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e __name__ \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;__main__\u0026#34;\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    fsg \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e FibonacciSequenceGenerator()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(fsg)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(type(fsg))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ python3 main.py\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;generator object FibonacciSequenceGenerator at 0x7fb4720b1ac0\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;class \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;generator\u0026#39;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可以看到函数 \u003ccode\u003eFibonacciSequenceGenerator\u003c/code\u003e 返回了一个类型为 \u003ccode\u003egenerator\u003c/code\u003e 的生成器对象 \u003ccode\u003ef\u003c/code\u003e；对于生成器对象，我们不能像操作普通函数一样直接进行函数调用，而是要使用 \u003ccode\u003enext()\u003c/code\u003e 或 \u003ccode\u003efsg.send()\u003c/code\u003e 来进行函数切换，使得生成器函数开始或继续执行，直到 \u003ccode\u003eyield\u003c/code\u003e 所在行或是函数末尾再将执行权交还给调用方：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e range(\u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        print(next(fsg))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ python3 main.py\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e218922995834555169026\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e354224848179261915075\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e573147844013817084101\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e生成器的这种行为与线程切换非常类似，它包含了执行，保存，恢复上下文的步骤，用生成器来模拟线程的行为可以避免从用户态到内核态的切换，从而提升效率。\u003c/p\u003e","title":"Python 源码学习（5）：协程"},{"content":"Python 源码学习（4）：编译器和虚拟机 Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。\nPython 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。\n1 Python 编译器 1.1 代码对象 Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：\n# test.py def Square(a): return a * a print(f\u0026#34;result:\\t\\t{Square(5)}\u0026#34;) # main.py f = \u0026#34;test.py\u0026#34; code_obj = compile(open(f).read(), f, \u0026#39;exec\u0026#39;) exec(code_obj) print(f\u0026#34;code_obj:\\t{code_obj}\u0026#34;) print(f\u0026#34;type:\\t\\t{type(code_obj)}\u0026#34;) $ python3 main.py result: 25 code_obj: \u0026lt;code object \u0026lt;module\u0026gt; at 0x7f052c156b30, file \u0026#34;test.py\u0026#34;, line 1\u0026gt; type: \u0026lt;class \u0026#39;code\u0026#39;\u0026gt; 可以看到生成的 code_obj 对象的类型是 class 'code'，它在源码中对应的结构体是代码对象 PyCodeObject；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：\n// Include/cpython/code.h /* Bytecode object */ struct PyCodeObject { PyObject_HEAD int co_argcount; /* #arguments, except *args */ int co_posonlyargcount; /* #positional only arguments */ int co_kwonlyargcount; /* #keyword only arguments */ int co_nlocals; /* #local variables */ int co_stacksize; /* #entries needed for evaluation stack */ int co_flags; /* CO_..., see below */ int co_firstlineno; /* first source line number */ PyObject *co_code; /* instruction opcodes */ PyObject *co_consts; /* list (constants used) */ PyObject *co_names; /* list of strings (names used) */ PyObject *co_varnames; /* tuple of strings (local variable names) */ PyObject *co_freevars; /* tuple of strings (free variable names) */ PyObject *co_cellvars; /* tuple of strings (cell variable names) */ /* The rest aren\u0026#39;t used in either hash or comparisons, except for co_name, used in both. This is done to preserve the name and line number for tracebacks and debuggers; otherwise, constant de-duplication would collapse identical functions/lambdas defined on different lines. */ Py_ssize_t *co_cell2arg; /* Maps cell vars which are arguments. */ PyObject *co_filename; /* unicode (where it was loaded from) */ PyObject *co_name; /* unicode (name, for reference) */ PyObject *co_lnotab; /* string (encoding addr\u0026lt;-\u0026gt;lineno mapping) See Objects/lnotab_notes.txt for details. */ void *co_zombieframe; /* for optimization only (see frameobject.c) */ PyObject *co_weakreflist; /* to support weakrefs to code objects */ /* Scratch space for extra data relating to the code object. Type is a void* to keep the format private in codeobject.c to force people to go through the proper APIs. */ void *co_extra; /* Per opcodes just-in-time cache * * To reduce cache size, we use indirect mapping from opcode index to * cache object: * cache = co_opcache[co_opcache_map[next_instr - first_instr] - 1] */ // co_opcache_map is indexed by (next_instr - first_instr). // * 0 means there is no cache for this opcode. // * n \u0026gt; 0 means there is cache in co_opcache[n-1]. unsigned char *co_opcache_map; _PyOpcache *co_opcache; int co_opcache_flag; // used to determine when create a cache. unsigned char co_opcache_size; // length of co_opcache. }; 其中比较重要的成员有两个，分别是编译后生成的指令序列 co_code 和执行当前代码块所需的栈空间大小 co_stacksize。\n1.2 字节码 在所有的这些成员变量中，PyObject *co_code 存储了编译后生成的指令序列，它是以字节的方式存储的：\n# test.py def Square(a): return a * a print(f\u0026#34;result:\\t\\t{Square(5)}\u0026#34;) # main.py f = \u0026#34;test.py\u0026#34; code_obj = compile(open(f).read(), f, \u0026#39;exec\u0026#39;) print(f\u0026#34;code obj:\\t{code_obj}\u0026#34;) print(f\u0026#34;stack size:\\t{code_obj.co_stacksize}\u0026#34;) result = exec(code_obj) bytecode = code_obj.co_code print(f\u0026#34;bytecode:\\t{bytecode}\u0026#34;) $ python3 main.py code obj: \u0026lt;code object \u0026lt;module\u0026gt; at 0x7f26cea5ab30, file \u0026#34;test.py\u0026#34;, line 1\u0026gt; stack size: 4 result: 25 bytecode: b\u0026#39;d\\x00d\\x01\\x84\\x00Z\\x00e\\x01d\\x02e\\x00d\\x03\\x83\\x01\\x9b\\x00\\x9d\\x02\\x83\\x01\\x01\\x00d\\x04S\\x00\u0026#39; 我们可以使用 Python 内置模块 dis 来将这些字节码反编译成类似于汇编语言的格式：\nimport dis dis.dis(bytecode) 0 LOAD_CONST 0 (0) 2 LOAD_CONST 1 (1) 4 MAKE_FUNCTION 0 6 STORE_NAME 0 (0) 8 LOAD_NAME 1 (1) 10 LOAD_CONST 2 (2) 12 LOAD_NAME 0 (0) 14 LOAD_CONST 3 (3) 16 CALL_FUNCTION 1 18 FORMAT_VALUE 0 20 BUILD_STRING 2 22 CALL_FUNCTION 1 24 POP_TOP 26 LOAD_CONST 4 (4) 28 RETURN_VALUE 在反编译后的输出结果中，第一列代表字节码中每一条指令的偏移量 offset；第二列代表各条助记符 mnemonics 的名称，这些助记符可以很方便地帮助我们理解在后续的步骤中 Python 虚拟机要执行的事件；第三列则是每条指令的操作数 opargs。\n同时，在字节码对应的十六进制表示中，每一位数字也分别代表了不同的助记符和操作数，我们可以直接通过打印出字节码的十六进制以查看其内容：\nprint(bytecode.hex()) 64 00 64 01 84 00 5a 00 65 01 64 02 65 00 64 03 83 01 9b 00 9d 02 83 01 01 00 64 04 53 00 以上面反编译后的输出为例，在 offset == 0 的地方可以找到数字 64，即 LOAD_CONST 加载常量助记符对应的操作码 opcode，其后紧跟着的是它的操作数 opargs == 0；而指令第四行对应的 offset == 6，可以看到 STORE_NAME 助记符对应的操作码 opcode == 5a ，其操作数 opargs == 0；以此类推。\nPython 的 opcode 模块提供了关于 Python 虚拟机中助记符和操作码的相关信息，也可以在源码的 Include/opcode.h 中找到相关定义：\nimport opcode print(opcode.opname[0x64]) print(opcode.opname[0x5a]) print(opcode.opmap[\u0026#39;LOAD_NAME\u0026#39;]) print(opcode.opmap[\u0026#39;RETURN_VALUE\u0026#39;]) LOAD_CONST STORE_NAME 101 83 1.3 编译原理 Python 编译器的实现和其他语言类似，包含了词法分析 Lexical，语法分析 Syntax Analysis 和语义分析 Semantic Analysis 等步骤，本文不再赘述编译原理的部分。\n2 Python 虚拟机 类似于 x86-64, arm 平台和 Java 虚拟机，Python 虚拟机也是 基于栈的（Stack-Based），它的函数调用都是通过调用栈 call stack 和栈帧 stackframe 来实现的。\n2.1 调用栈 调用栈是 CPU 寄存器中的一块内存区域，它是一种 FILO 的数据结构，可以进行插入或删除操作的一边称为栈顶，另一边则称为栈底；对于最常见的 x86-64 架构来说，栈地址空间是自顶向下（head down）增长的：\n在 x86-64 平台下，它拥有 16 个通用寄存器 general-purpose registers，寄存器被集成在 CPU 芯片上，其中 rbp 寄存器保存当前栈帧的栈底（本次函数调用开始时的位置），rsp 寄存器保存当前栈帧的栈顶（函数运行时的当前位置），rbp 和 rsp 之间的空间则被称为本次函数调用的栈帧 stack frame；在每一次发生函数调用时，调用栈上都会维护一个独立的栈帧以存储函数返回值、参数、局部变量等信息；其他通用寄存器的功能如下。\n栈相关的最常见操作有 push 和 pop，push 操作会将一个操作数插入栈顶，这包含了两个步骤，分别是先将 rsp 寄存器保存的地址减去 8，再将操作数写入到这个地址中；而 pop 则正好相反，它先从 rsp 寄存器存储的地址取出数据，写入到其他寄存器中，再对其地址加上 8。\n以调试一个简单的 Swap 函数调用为例；本文使用的所有汇编语言都是 AT\u0026amp;T Syntax 的：\n// main.cpp #include \u0026lt;iostream\u0026gt; using namespace std; void Swap(int\u0026amp; a, int \u0026amp;b) { int c = a; a = b; b = c; } int main() { int a = 5, b = 9; Swap(a, b); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 用 gdb 打开并在 main 函数处断点；在 main 函数栈帧中，会通过 movl 指令将两个常量拷贝到内存中：\n$ g++ -g -O0 -o main main.cpp $ gdb main (gdb) b main (gdb) r (gdb) layout reg \u0026gt; 0x400852 \u0026lt;main()+9\u0026gt; movl $0x5,-0x14(%rbp) # 将常量 9 保存在 rbp - 18 的位置 0x400859 \u0026lt;main()+16\u0026gt; movl $0x9,-0x18(%rbp) # 将常量 5 保存在 rbp - 14 的位置 在调用函数 Swap 前，会分别将两个参数存入 rdi 和 rsi 寄存器中：\n0x400860 \u0026lt;main()+23\u0026gt; lea -0x18(%rbp),%rdx 0x400864 \u0026lt;main()+27\u0026gt; lea -0x14(%rbp),%rax 0x400868 \u0026lt;main()+31\u0026gt; mov %rdx,%rsi 0x40086b \u0026lt;main()+34\u0026gt; mov %rax,%rdi \u0026gt; 0x40086e \u0026lt;main()+37\u0026gt; callq 0x40081d \u0026lt;Swap(int\u0026amp;, int\u0026amp;)\u0026gt; (gdb) p *$rsi $6 = 9 (gdb) p *$rdi $7 = 5 在 callq 指令处使用 stepi 进入到 Swap 函数中，此时 rbp 和 rsp 指针还分别指向 main 函数栈帧的底部和顶部，能够发现栈地址空间的确是向下增长的：\n\u0026gt; 0x40086e \u0026lt;main()+37\u0026gt; callq 0x40081d \u0026lt;Swap(int\u0026amp;, int\u0026amp;)\u0026gt; (gdb) si \u0026gt; 0x40081d \u0026lt;Swap(int\u0026amp;, int\u0026amp;)\u0026gt; push %rbp 0x40081e \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+1\u0026gt; mov %rsp,%rbp rbp 0x7fffffffe110 0x7fffffffe110 rsp 0x7fffffffe0e8 0x7fffffffe0e8 此时栈帧结构大致如下：\n执行接下来的 push 指令，将 rbp 的值存入栈顶，可以看到 rsp 的值发生了变化：\n(gdb) ni 0x40081d \u0026lt;Swap(int\u0026amp;, int\u0026amp;)\u0026gt; push %rbp \u0026gt; 0x40081e \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+1\u0026gt; mov %rsp,%rbp rbp 0x7fffffffe110 0x7fffffffe110 rsp 0x7fffffffe0e0 0x7fffffffe0e0 继续执行下一条 mov 指令，重置 rbp 的值，进入新的栈帧：\n(gdb) ni rbp 0x7fffffffe0e0 0x7fffffffe0e0 rsp 0x7fffffffe0e0 0x7fffffffe0e0 此时栈帧结构变成了如下：\n再经过一系列的 mov 指令操作，将 a 和 b 的值交换之后，执行下一条 pop 指令，将存储的上一个栈帧地址写入 rbp 中，同时修改 rsp；之后再执行 retq 指令即可继续运行 main 函数的下一条汇编指令了：\n\u0026gt; 0x400847 \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+42\u0026gt; pop %rbp 0x400848 \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+43\u0026gt; retq rbp 0x7fffffffe0e0 0x7fffffffe0e0 rsp 0x7fffffffe0e0 0x7fffffffe0e0 (gdb) ni 0x400847 \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+42\u0026gt; pop %rbp \u0026gt; 0x400848 \u0026lt;Swap(int\u0026amp;, int\u0026amp;)+43\u0026gt; retq rbp 0x7fffffffe110 0x7fffffffe110 rsp 0x7fffffffe0e8 0x7fffffffe0e8 Python 中函数调用链和调用栈之间的关系也和 x86-64 平台类似，只不过是把代码块和栈帧分别进行了封装而已。\n2.2 栈帧对象 Python 中的代码对象 PyCodeObject 本身只包含了字节码相关的信息，并不具备用于执行字节码所需要的上下文信息，因此需要引入栈帧对象 PyFrameObject，作为代码对象运行的容器，并用来模拟其他平台下的栈帧：\n// cpython/Include/frameobject.h struct _frame { PyObject_VAR_HEAD struct _frame *f_back; /* previous frame, or NULL */ PyCodeObject *f_code; /* code segment */ PyObject *f_builtins; /* builtin symbol table (PyDictObject) */ PyObject *f_globals; /* global symbol table (PyDictObject) */ PyObject *f_locals; /* local symbol table (any mapping) */ PyObject **f_valuestack; /* points after the last local */ PyObject *f_trace; /* Trace function */ int f_stackdepth; /* Depth of value stack */ char f_trace_lines; /* Emit per-line trace events? */ char f_trace_opcodes; /* Emit per-opcode trace events? */ /* Borrowed reference to a generator, or NULL */ PyObject *f_gen; int f_lasti; /* Last instruction if called */ /* Call PyFrame_GetLineNumber() instead of reading this field directly. As of 2.3 f_lineno is only valid when tracing is active (i.e. when f_trace is set). At other times we use PyCode_Addr2Line to calculate the line from the current bytecode index. */ int f_lineno; /* Current line number */ int f_iblock; /* index in f_blockstack */ PyFrameState f_state; /* What state the frame is in */ PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */ PyObject *f_localsplus[1]; /* locals+stack, dynamically sized */ }; // cpython/Include/pyframe.h typedef struct _frame PyFrameObject; 可以看到栈帧对象中大致包含了以下数据，它们构成了 Python 虚拟机执行当前栈帧所需要的所有上下文：\n上一个运行的栈帧对象的指针 struct _frame *f_back；Python 虚拟机中运行的所有栈帧对象的 *f_back 共同组成调用栈结构，仅有初始栈帧有 f_back == NULL； 代码对象指针 PyCodeObject *f_code，它包含了当前运行栈帧所执行的字节码信息； 代码对象执行期间的栈结构 PyObject **f_valuestack，在对字节码进行运算时，需要从栈顶读取数据，并将运算结果存储在栈顶，f_valuestack 就是用来用来存储数据的栈结构，它的大小由对应的代码对象 f_code 的堆栈大小决定； 代码对象执行期间使用的栈结构的深度 int f_stackdepth； 上一条执行过的字节码指令 int f_lasti，类似于 rip 寄存器； 内置命名空间、全局命名空间、局部命名空间的指针 PyObject *f_builtins, PyObject *f_globals, PyObject *f_locals，它们是用来实现 Python 中从符号到对象的映射的结构，一般用字典实现，暂不讨论； 用于跟踪代码执行情况的函数指针 PyObject *f_trace 和相关数据 char f_trace_lines, char f_trace_opcodes，暂不讨论； 用于执行生成器代码的数据 PyObject *f_gen，暂不讨论； Python 在 sys 模块中提供了 _getframe 函数来获取栈帧对象；以一个简单的 Swap 函数为例，在最深层的函数调用处打印出栈帧对象的信息：\nimport sys def Swap(a, b): frame = sys._getframe() while frame is not None: print(f\u0026#34;frame:\\t{frame}\u0026#34;) print(f\u0026#34;name:\\t{frame.f_code.co_name}\u0026#34;) print(f\u0026#34;locals:\\t{frame.f_locals.keys()}\\n\u0026#34;) print(f\u0026#34;back:\\t{frame.f_back}\\n\u0026#34;) frame = frame.f_back return b, a def main(): a, b = 5, 9 a, b = Swap(a, b) print(a, b) if __name__ == \u0026#34;__main__\u0026#34;: main() 运行后可以观察到，在 Python 程序开始执行时会先创建一个叫做 module 的栈帧对象用于执行当前脚本中的代码；在每次函数调用的过程中，都会创建出一个新的栈帧对象，这些栈帧对象会使用 f_back 指针保存上一个执行栈帧的地址，并在之后调用其他函数的时候被压入栈顶：\n$ python3 main.py frame: \u0026lt;frame at 0x7fe37d7e5900, file \u0026#39;/main.py\u0026#39;, line 36, code Swap\u0026gt; name: Swap locals: dict_keys([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;frame\u0026#39;]) back: \u0026lt;frame at 0x7fe71ca65040, file \u0026#39;/main.py\u0026#39;, line 46, code main\u0026gt; frame: \u0026lt;frame at 0x7fe376115040, file \u0026#39;/main.py\u0026#39;, line 46, code main\u0026gt; name: main locals: dict_keys([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]) back: \u0026lt;frame at 0x141f6f0, file \u0026#39;/main.py\u0026#39;, line 50, code \u0026lt;module\u0026gt;\u0026gt; frame: \u0026lt;frame at 0x1ade6f0, file \u0026#39;/main.py\u0026#39;, line 50, code \u0026lt;module\u0026gt;\u0026gt; name: \u0026lt;module\u0026gt; locals: dict_keys([\u0026#39;__name__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__package__\u0026#39;, \u0026#39;__loader__\u0026#39;, \u0026#39;__spec__\u0026#39;, \u0026#39;__annotations__\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;__file__\u0026#39;, \u0026#39;__cached__\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;Swap\u0026#39;, \u0026#39;main\u0026#39;]) back: None 9 5 2.2.1 回收和分配 前文讨论过类型对象，从刚才获取栈帧对象的例子里能够看到通过 sys._getframe() 获取的 frame 对象的类型名为 frame，不难找到它的类型对象实际上是 PyFrame_Type，我们可以从类型对象初始化时使用的函数指针找到它的相关操作：\nPyTypeObject PyFrame_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) \u0026#34;frame\u0026#34;, sizeof(PyFrameObject), sizeof(PyObject *), (destructor)frame_dealloc, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ (reprfunc)frame_repr, /* tp_repr */ 0, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ 0, /* tp_hash */ 0, /* tp_call */ 0, /* tp_str */ PyObject_GenericGetAttr, /* tp_getattro */ PyObject_GenericSetAttr, /* tp_setattro */ 0, /* tp_as_buffer */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */ 0, /* tp_doc */ (traverseproc)frame_traverse, /* tp_traverse */ (inquiry)frame_tp_clear, /* tp_clear */ 0, /* tp_richcompare */ 0, /* tp_weaklistoffset */ 0, /* tp_iter */ 0, /* tp_iternext */ frame_methods, /* tp_methods */ frame_memberlist, /* tp_members */ frame_getsetlist, /* tp_getset */ 0, /* tp_base */ 0, /* tp_dict */ }; 其中对栈帧对象进行析构的函数是 frame_dealloc，此处省略了部分代码：\n#define PyFrame_MAXFREELIST 200 static void _Py_HOT_FUNCTION frame_dealloc(PyFrameObject *f) { // ... Py_XDECREF(f-\u0026gt;f_back); Py_DECREF(f-\u0026gt;f_builtins); Py_DECREF(f-\u0026gt;f_globals); Py_CLEAR(f-\u0026gt;f_locals); Py_CLEAR(f-\u0026gt;f_trace); PyCodeObject *co = f-\u0026gt;f_code; if (co-\u0026gt;co_zombieframe == NULL) { co-\u0026gt;co_zombieframe = f; } else { struct _Py_frame_state *state = get_frame_state(); #ifdef Py_DEBUG // frame_dealloc() must not be called after _PyFrame_Fini() assert(state-\u0026gt;numfree != -1); #endif if (state-\u0026gt;numfree \u0026lt; PyFrame_MAXFREELIST) { ++state-\u0026gt;numfree; f-\u0026gt;f_back = state-\u0026gt;free_list; state-\u0026gt;free_list = f; } else { PyObject_GC_Del(f); } } Py_DECREF(co); Py_TRASHCAN_SAFE_END(f) } struct _Py_frame_state { PyFrameObject *free_list; /* number of frames currently in free_list */ int numfree; }; 这是一个使用非常高频的函数（几乎每一次栈帧退出时都会调用），因此采用了一些策略来进行优化以降低调用函数的开销；一种是在首次进行栈帧对象 f 的回收时会先判断栈帧对象关联的代码对象 co 的成员指针 co_zombieframe 是否为空 if (co-\u0026gt;co_zombieframe == NULL)；如果是，则会将该栈帧对象 f 保存在代码对象的这个指针中 co-\u0026gt;co_zombieframe = f，这样的话在下一次执行相同的代码对象 co 时，就无需再次重新进行栈帧对象 f 的内存分配（只要代码对象 co 不因为引用计数降低为 0 而被 gc）；对于栈帧对象来说，仅有 ob_type, ob_size, f_code, f_valuestack 几个成员变量会保留原有的值，因为这些成员变量与其他对象没有关联，而 f_locals, f_trace, f_exc_type 等指针依然会被通过 Py_CLEAR 置为 NULL，因为通过这些指针关联的对象可能会通过其他途径被回收，从而导致悬空指针的问题。\n另一个优化策略是当代码对象 co 的成员指针 co-\u0026gt;co_zombieframe 不为空，即再次执行相同栈帧时，会使用由 Python 线程维护的缓存栈帧链表 state-\u0026gt;free_list 将栈帧对象存储下来，此时如果有新的栈帧对象被定义的话，可以直接从缓存栈帧链表 state-\u0026gt;free_list 中获取一个已经分配内存的栈帧对象直接赋值并使用，以达到减少分配和回收内存的效果。此处可以结合分配栈帧的 frame_alloc 函数来看：\nstatic inline PyFrameObject* frame_alloc(PyCodeObject *code) { // ... if (state-\u0026gt;free_list == NULL) { f = PyObject_GC_NewVar(PyFrameObject, \u0026amp;PyFrame_Type, extras); if (f == NULL) { return NULL; } } else { #ifdef Py_DEBUG // frame_alloc() must not be called after _PyFrame_Fini() assert(state-\u0026gt;numfree != -1); #endif assert(state-\u0026gt;numfree \u0026gt; 0); --state-\u0026gt;numfree; f = state-\u0026gt;free_list; state-\u0026gt;free_list = state-\u0026gt;free_list-\u0026gt;f_back; if (Py_SIZE(f) \u0026lt; extras) { PyFrameObject *new_f = PyObject_GC_Resize(PyFrameObject, f, extras); if (new_f == NULL) { PyObject_GC_Del(f); return NULL; } f = new_f; } _Py_NewReference((PyObject *)f); } // ... } 可以看到在进行栈帧对象的分配时，会优先判断缓存栈帧链表 state-\u0026gt;free_list 是否为空，不为空的话则会从其链表头部取出一个已经分配好内存的栈帧对象，对其赋值并使用。\n这项优化（将未使用的栈帧对象保存在缓存栈帧链表中，并在创建其他栈帧对象时重复利用）与前者（在栈帧退出时将栈帧对象随代码对象保存下来，在执行相同代码对象时直接使用）的做法有些冲突，因此前者在最新的 PR 26076 中已经被移除了。\n2.3 运行过程 2.3.1 调用流程 Python 的 main 函数在 cpython/Programs/python.c 文件中，这部分实现比较简单，其调用链可以总结如下：\n从调用链中可以看到，在真正执行 Python 代码之前，会先读取配置并进行初始化，这些配置会被保存到 cpython/Include/cpython/initconfig.h 文件定义的 PyConfig 结构体中，这个结构体包含了 Python 运行时的环境变量，运行模式等信息；而调用链中 pymain_run_python 函数后的五个分支就分别代表了 Python 通过命令行、文件、标准输入等方式运行的五种模式，但无论是那种模式，最终都会通过调用 run_eval_code_obj 以及 PyEval_EvalCode 函数来执行编译后的代码对象，后者就是 Python 虚拟机执行指令的入口之一。\n2.3.2 运行栈帧 Python 虚拟机中执行指令的入口有 PyEval_EvalCode 和 PyEval_EvalCodeEx，前者相对于后者省略了部分参数，仅将必须的代码对象，全局变量和局部变量作为参数传入，其他参数均设为 NULL。\n// cpython/Python/eval.h PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyObject *, PyObject *, PyObject *); PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure); // cpython/Python/ceval.c PyObject * PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals) { return PyEval_EvalCodeEx(co, globals, locals, (PyObject **)NULL, 0, (PyObject **)NULL, 0, (PyObject **)NULL, 0, NULL, NULL); } 而 PyEval_EvalCodeEx 实际上会调用 _PyEval_EvalCodeWithName 函数，进行参数个数和类型的校验，以及线程状态的检查，并最终调用了 _PyEval_EvalCode 函数：\nPyObject * _PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals, PyObject *const *args, Py_ssize_t argcount, PyObject *const *kwnames, PyObject *const *kwargs, Py_ssize_t kwcount, int kwstep, PyObject *const *defs, Py_ssize_t defcount, PyObject *kwdefs, PyObject *closure, PyObject *name, PyObject *qualname) { PyThreadState *tstate = _PyThreadState_GET(); return _PyEval_EvalCode(tstate, _co, globals, locals, args, argcount, kwnames, kwargs, kwcount, kwstep, defs, defcount, kwdefs, closure, name, qualname); } PyObject * PyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals, PyObject *const *args, int argcount, PyObject *const *kws, int kwcount, PyObject *const *defs, int defcount, PyObject *kwdefs, PyObject *closure) { return _PyEval_EvalCodeWithName(_co, globals, locals, args, argcount, kws, kws != NULL ? kws + 1 : NULL, kwcount, 2, defs, defcount, kwdefs, closure, NULL, NULL); } _PyEval_EvalCode 函数会对代码对象参数 PyCodeObject *co 及其参数进行常规检查，并初始化栈帧对象 PyFrameObject *f，并调用 _PyEval_EvalFrame：\n// cpython/Python/ceval.c PyObject * _PyEval_EvalCode(PyThreadState *tstate, PyObject *_co, PyObject *globals, PyObject *locals, PyObject *const *args, Py_ssize_t argcount, PyObject *const *kwnames, PyObject *const *kwargs, Py_ssize_t kwcount, int kwstep, PyObject *const *defs, Py_ssize_t defcount, PyObject *kwdefs, PyObject *closure, PyObject *name, PyObject *qualname) { PyObject *retval = NULL; /* Create the frame */ PyFrameObject *f = _PyFrame_New_NoTrack(tstate, co, globals, locals); if (f == NULL) { return NULL; } PyObject **fastlocals = f-\u0026gt;f_localsplus; PyObject **freevars = f-\u0026gt;f_localsplus + co-\u0026gt;co_nlocals; // ... retval = _PyEval_EvalFrame(tstate, f, 0); fail: /* Jump here from prelude on failure */ /* decref\u0026#39;ing the frame can cause __del__ methods to get invoked, which can call back into Python. While we\u0026#39;re done with the current Python frame (f), the associated C stack is still in use, so recursion_depth must be boosted for the duration. */ if (Py_REFCNT(f) \u0026gt; 1) { Py_DECREF(f); _PyObject_GC_TRACK(f); } else { ++tstate-\u0026gt;recursion_depth; Py_DECREF(f); --tstate-\u0026gt;recursion_depth; } return retval; } _PyEval_EvalFrame 函数调用了一个函数指针，这个指针是随 Python 解释器初始化的：\n// cpython/Python/internal/pycore_ceval.h static inline PyObject* _PyEval_EvalFrame(PyThreadState *tstate, PyFrameObject *f, int throwflag) { return tstate-\u0026gt;interp-\u0026gt;eval_frame(tstate, f, throwflag); } // cpython/Python/pystate.c PyInterpreterState * PyInterpreterState_New(void) { // ... interp-\u0026gt;eval_frame = _PyEval_EvalFrameDefault; // ... } _PyEval_EvalFrameDefault 是整个调用链的终点，它的函数主体是一个循环，不断地读入字节码，并通过 switch 语句判断其类型并执行，\nPyObject* _Py_HOT_FUNCTION _PyEval_EvalFrameDefault(PyThreadState *tstate, PyFrameObject *f, int throwflag) { _Py_EnsureTstateNotNULL(tstate); // ... main_loop: for (;;) { opcode = _Py_OPCODE(*next_instr); switch (opcode) { case TARGET(LOAD_CONST): { PREDICTED(LOAD_CONST); PyObject *value = GETITEM(consts, oparg); Py_INCREF(value); PUSH(value); FAST_DISPATCH(); // ... } // ... 这就是整个调用和运行栈帧对象的过程了，整理如下：\n2.3.3 调试 最后以 [1.2](#1.2 字节码) 节的 test.py 代码为例，简单地用 gdb 来进行 _PyEval_EvalFrameDefault 函数中逐个字节码指令的调试：\n$ gdb -ex r --args python3 test.py (gdb) b _PyEval_EvalFrameDefault Breakpoint 1 at 0x41fa90: file Python/ceval.c, line 919. (gdb) r (gdb) n # ... 如果有对应版本的源码文件的话也可以直接断点在 switch (opcode) { 所在的行数，这里我们不断地往后执行直到这一行之后：\n(gdb) layout split 1487 case TARGET(LOAD_CONST): { 1488 PREDICTED(LOAD_CONST); \u0026gt; 1489 PyObject *value = GETITEM(consts, oparg); 1490 Py_INCREF(value); 1491 PUSH(value); 1492 FAST_DISPATCH(); 1493 } (gdb) p opcode $1 = 100 (gdb) p oparg $2 = 0 可以看到在执行 LOAD_CONST 助记符时，其对应的 opcode 的十六进制表示为64，十进制表示为 100，LOAD_CONST 首先获取了 oparg 的值，并填入到栈顶；\n2343 case TARGET(STORE_NAME): { \u0026gt; 2344 PyObject *name = GETITEM(names, oparg); 2345 PyObject *v = POP(); 2346 PyObject *ns = f-\u0026gt;f_locals; 2347 int err; 2348 if (ns == NULL) { 2349 _PyErr_Format(tstate, PyExc_SystemError, 2350 \u0026#34;no locals found when storing %R\u0026#34;, name); 2351 Py_DECREF(v); 2352 goto error; 2353 } 2354 if (PyDict_CheckExact(ns)) 2355 err = PyDict_SetItem(ns, name, v); 2356 else 2357 err = PyObject_SetItem(ns, name, v); 2358 Py_DECREF(v); 2359 if (err != 0) 2360 goto error; 2361 DISPATCH(); 2362 } STORE_NAME 也是类似的，它从栈顶取出一个数值，并存储在局部命名空间中；\n2828 case TARGET(BUILD_MAP): { 2829 Py_ssize_t i; \u0026gt; 2830 PyObject *map = _PyDict_NewPresized((Py_ssize_t)oparg); 2831 if (map == NULL) 2832 goto error; 2833 for (i = oparg; i \u0026gt; 0; i--) { 2834 int err; 2835 PyObject *key = PEEK(2*i); 2836 PyObject *value = PEEK(2*i - 1); 2837 err = PyDict_SetItem(map, key, value); 2838 if (err != 0) { 2839 Py_DECREF(map); 2840 goto error; 2841 } 2842 } 2843 2844 while (oparg--) { 2845 Py_DECREF(POP()); 2846 Py_DECREF(POP()); 2847 } 2848 PUSH(map); 2849 DISPATCH(); 2850 } (gdb) p opcode $9 = 105 (gdb) p oparg $10 = 0 BUILD_MAP 稍微复杂一些，它会构造一个 Python 中的字典对象（源码中 PyDictObject 结构体的实例对象，用哈希表实现），并不断地从栈帧上获取 key 和 value 插入到字典中；\n2312 case TARGET(LOAD_BUILD_CLASS): { 2313 _Py_IDENTIFIER(__build_class__); 2314 \u0026gt; 2315 PyObject *bc; 2316 if (PyDict_CheckExact(f-\u0026gt;f_builtins)) { 2317 bc = _PyDict_GetItemIdWithError(f-\u0026gt;f_builtins, \u0026amp;PyId___build_class__); 2318 if (bc == NULL) { 2319 if (!_PyErr_Occurred(tstate)) { 2320 _PyErr_SetString(tstate, PyExc_NameError, 2321 \u0026#34;__build_class__ not found\u0026#34;); 2322 } 2323 goto error; 2324 } 2325 Py_INCREF(bc); 2326 } 2327 else { 2328 PyObject *build_class_str = _PyUnicode_FromId(\u0026amp;PyId___build_class__); 2329 if (build_class_str == NULL) 2330 goto error; 2331 bc = PyObject_GetItem(f-\u0026gt;f_builtins, build_class_str); 2332 if (bc == NULL) { 2333 if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) 2334 _PyErr_SetString(tstate, PyExc_NameError, 2335 \u0026#34;__build_class__ not found\u0026#34;); 2336 goto error; 2337 } 2338 } 2339 PUSH(bc); 2340 DISPATCH(); 2341 } (gdb) p opcode $11 = 71 (gdb) p oparg $12 = 0 LOAD_BUILD_CLASS 则会从内置命名空间中通过哈希方法找到函数指针，并插入栈顶；\n其他的字节码指令还有很多，都可以通过阅读源码或者使用 gdb 调试的方法找到其实际执行的代码；相比于汇编指令，字节码指令实际上代表了由许多行代码组成的功能，而 Python 虚拟机则是通过字节码指令模拟出了对汇编指令的执行过程。\n","permalink":"https://prov1dence.top/posts/python/python-source-code-interpreter/","summary":"\u003ch1 id=\"python-源码学习4编译器和虚拟机\"\u003ePython 源码学习（4）：编译器和虚拟机\u003c/h1\u003e\n\u003cp\u003ePython 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 \u003ca href=\"https://github.com/python/cpython\"\u003eCPython\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePython 解释器\u003c/strong\u003e（\u003cem\u003ePython Interpreter\u003c/em\u003e）由 \u003cstrong\u003ePython 编译器\u003c/strong\u003e（\u003cem\u003ePython Compiler\u003c/em\u003e）和 \u003cstrong\u003ePython 虚拟机\u003c/strong\u003e（\u003cem\u003ePython Virutal Machine\u003c/em\u003e）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 \u003cstrong\u003ePython 字节码\u003c/strong\u003e（\u003cem\u003e\u003ca href=\"https://www.quora.com/What-is-the-difference-between-byte-code-and-machine-code-and-what-are-its-advantages\"\u003ebytecode\u003c/a\u003e\u003c/em\u003e）；随后 Python 虚拟机会读取并逐步执行这些字节码。\u003c/p\u003e\n\u003ch2 id=\"1-python-编译器\"\u003e1 Python 编译器\u003c/h2\u003e\n\u003ch3 id=\"11-代码对象\"\u003e1.1 代码对象\u003c/h3\u003e\n\u003cp\u003ePython 提供了内置函数 \u003ccode\u003ecompile\u003c/code\u003e，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# test.py\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSquare\u003c/span\u003e(a):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e a\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(\u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;result:\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\t\\t\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{\u003c/span\u003eSquare(\u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e)\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# main.py\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ef \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;test.py\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecode_obj \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e compile(open(f)\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eread(), f, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;exec\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexec(code_obj)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(\u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;code_obj:\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\t\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{\u003c/span\u003ecode_obj\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(\u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;type:\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\t\\t\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{\u003c/span\u003etype(code_obj)\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ python3 main.py\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eresult:         \u003cspan style=\"color:#ae81ff\"\u003e25\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecode_obj:       \u0026lt;code object \u0026lt;module\u0026gt; at 0x7f052c156b30, file \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;test.py\u0026#34;\u003c/span\u003e, line 1\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etype:           \u0026lt;class \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;code\u0026#39;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可以看到生成的 \u003ccode\u003ecode_obj\u003c/code\u003e 对象的类型是 \u003ccode\u003eclass 'code'\u003c/code\u003e，它在源码中对应的结构体是\u003cstrong\u003e代码对象\u003c/strong\u003e \u003cem\u003ePyCodeObject\u003c/em\u003e；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：\u003c/p\u003e","title":"Python 源码学习（4）：编译器和虚拟机"},{"content":"Python 源码学习（3）：list 类型 Python 中的 list 类型在源码中是一个名为 PyListObject 的结构体，定义在 listobject.h 文件中：\n// Include/cpython/listobject.h typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for \u0026#39;allocated\u0026#39; elements. The number * currently in use is ob_size. * Invariants: * 0 \u0026lt;= ob_size \u0026lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated; } PyListObject; 它的实现和 C++ 中的 std::vector 类似，都是通过维护一个动态数组，在增加数据的时候动态扩大数组的容量来实现的；PyListObject 结构中包含了一个变长对象头部 PyObject_VAR_HEAD，ob_size 表示当前动态数组的长度，**ob_item 是指向动态数组的指针，allocated 是动态数组的容量；我们可以从它的类型指针 PyTypeObject PyList_Type 中找到用来操作 list 对象的相关方法：\n// Objects/listobject.c PyTypeObject PyList_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) \u0026#34;list\u0026#34;, sizeof(PyListObject), list_methods, /* tp_methods */ // ... }; static PyMethodDef list_methods[] = { {\u0026#34;__getitem__\u0026#34;, (PyCFunction)list_subscript, METH_O|METH_COEXIST, \u0026#34;x.__getitem__(y) \u0026lt;==\u0026gt; x[y]\u0026#34;}, LIST___REVERSED___METHODDEF LIST___SIZEOF___METHODDEF LIST_CLEAR_METHODDEF LIST_COPY_METHODDEF LIST_APPEND_METHODDEF LIST_INSERT_METHODDEF LIST_EXTEND_METHODDEF LIST_POP_METHODDEF LIST_REMOVE_METHODDEF LIST_INDEX_METHODDEF LIST_COUNT_METHODDEF LIST_REVERSE_METHODDEF LIST_SORT_METHODDEF {\u0026#34;__class_getitem__\u0026#34;, (PyCFunction)Py_GenericAlias, METH_O|METH_CLASS, PyDoc_STR(\u0026#34;See PEP 585\u0026#34;)}, {NULL, NULL} /* sentinel */ }; #define LIST_APPEND_METHODDEF \\ {\u0026#34;append\u0026#34;, (PyCFunction)list_append, METH_O, list_append__doc__}, PyDoc_STRVAR(list_append__doc__, \u0026#34;append($self, object, /)\\n\u0026#34; \u0026#34;--\\n\u0026#34; \u0026#34;\\n\u0026#34; \u0026#34;Append object to the end of the list.\u0026#34;); #define LIST_COPY_METHODDEF \\ {\u0026#34;copy\u0026#34;, (PyCFunction)list_copy, METH_NOARGS, list_copy__doc__}, PyDoc_STRVAR(list_copy__doc__, \u0026#34;copy($self, /)\\n\u0026#34; \u0026#34;--\\n\u0026#34; \u0026#34;\\n\u0026#34; \u0026#34;Return a shallow copy of the list.\u0026#34;); Python 中也把所谓的函数封装成了一个叫做 PyMethodDef 的类型，其中包括了函数的名称 *ml_name、对应的 C 函数实现 ml_meth、C 函数所需要的标志 ml_flags，以及函数说明 *ml_doc：\n// Include/methodobject.h struct PyMethodDef { const char *ml_name; /* The name of the built-in function/method */ PyCFunction ml_meth; /* The C function that implements it */ int ml_flags; /* Combination of METH_xxx flags, which mostly describe the args expected by the C func */ const char *ml_doc; /* The __doc__ attribute, or NULL */ }; typedef struct PyMethodDef PyMethodDef; 1 append 如 list_append__doc__ 中所描述的，list_append 函数的目的是向 list 的末尾添加新的元素：\n// Objects/listobject.c static PyObject * list_append(PyListObject *self, PyObject *object) /*[clinic end generated code: output=7c096003a29c0eae input=43a3fe48a7066e91]*/ { if (app1(self, object) == 0) Py_RETURN_NONE; return NULL; } static int app1(PyListObject *self, PyObject *v) { Py_ssize_t n = PyList_GET_SIZE(self); assert (v != NULL); assert((size_t)n + 1 \u0026lt; PY_SSIZE_T_MAX); if (list_resize(self, n+1) \u0026lt; 0) return -1; Py_INCREF(v); PyList_SET_ITEM(self, n, v); return 0; } static int list_resize(PyListObject *self, Py_ssize_t newsize) { PyObject **items; size_t new_allocated, num_allocated_bytes; Py_ssize_t allocated = self-\u0026gt;allocated; /* Bypass realloc() when a previous overallocation is large enough to accommodate the newsize. If the newsize falls lower than half the allocated size, then proceed with the realloc() to shrink the list. */ if (allocated \u0026gt;= newsize \u0026amp;\u0026amp; newsize \u0026gt;= (allocated \u0026gt;\u0026gt; 1)) { assert(self-\u0026gt;ob_item != NULL || newsize == 0); Py_SET_SIZE(self, newsize); return 0; } /* This over-allocates proportional to the list size, making room * for additional growth. The over-allocation is mild, but is * enough to give linear-time amortized behavior over a long * sequence of appends() in the presence of a poorly-performing * system realloc(). * Add padding to make the allocated size multiple of 4. * The growth pattern is: 0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ... * Note: new_allocated won\u0026#39;t overflow because the largest possible value * is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t. */ new_allocated = ((size_t)newsize + (newsize \u0026gt;\u0026gt; 3) + 6) \u0026amp; ~(size_t)3; /* Do not overallocate if the new size is closer to overallocated size * than to the old size. */ if (newsize - Py_SIZE(self) \u0026gt; (Py_ssize_t)(new_allocated - newsize)) new_allocated = ((size_t)newsize + 3) \u0026amp; ~(size_t)3; if (newsize == 0) new_allocated = 0; num_allocated_bytes = new_allocated * sizeof(PyObject *); items = (PyObject **)PyMem_Realloc(self-\u0026gt;ob_item, num_allocated_bytes); if (items == NULL) { PyErr_NoMemory(); return -1; } self-\u0026gt;ob_item = items; Py_SET_SIZE(self, newsize); self-\u0026gt;allocated = new_allocated; return 0; } 可以看到在 list_append 中先调用了 list_resize，这个函数可能会进行两个操作：\n在添加元素后，如果新的动态数组长度 newsize 在区间 [allocated / 2, allocated] 内（小于当前容量 allocated 且大于等于当前容量的一半 allocated \u0026gt;\u0026gt; 1），则将数组容量缩小为 newsize； 否则通过公式 new_allocated = ((size_t)newsize + (newsize \u0026gt;\u0026gt; 3) + 6) \u0026amp; ~(size_t)3 计算出 append 之后动态数组应该被分配的新容量 new_allocated，并重新分配内存。 其中第二步的公式不太直观，可以列表观察具体值的变化：\n动态数组长度 ob_size 当前容量 allocated append 后新的长度 newsize append 后新的容量 new_allocated 0 0 1 (1 + 0 + 6) \u0026amp; 252 = 111 \u0026amp; 11111100 = 4 3 4 4 4 ∈ [2, 4]（不变） 4 8 5 (5 + 0 + 6) \u0026amp; 252 = 1011 \u0026amp; 11111100 = 8 7 8 8 8 ∈ [4, 8]（不变） 8 16 9 (9 + 1 + 6) \u0026amp; 252 = 10000 \u0026amp; 11111100 = 16 15 16 16 16 ∈ [8, 16]（不变） 16 16 17 (16 + 2 + 6) \u0026amp; 252 = 10011 \u0026amp; 11111100 = 24 可以观察到，只有当 append 后新的长度 newsize 大于当前容量 allocated 时，才会将容量调整为一个更大的值，这个值以 4 的倍数来补足和填充；使用 python 测试代码来验证上表的计算结果：\nimport sys l = [] s = sys.getsizeof(l) print((sys.getsizeof(l) - s) // 8) for _ in range(17): l.append(0) print(\u0026#34;newsize\u0026#34;, len(l), \u0026#34;new_allocated\u0026#34;, (sys.getsizeof(l) - s) // 8) $ python3 main.py newsize 1 new_allocated 4 newsize 2 new_allocated 4 newsize 3 new_allocated 4 newsize 4 new_allocated 4 newsize 5 new_allocated 8 newsize 6 new_allocated 8 newsize 7 new_allocated 8 newsize 8 new_allocated 8 newsize 9 new_allocated 16 newsize 10 new_allocated 16 newsize 11 new_allocated 16 newsize 12 new_allocated 16 newsize 13 new_allocated 16 newsize 14 new_allocated 16 newsize 15 new_allocated 16 newsize 16 new_allocated 16 newsize 17 new_allocated 24 使用 Python3.9 前后的版本测试较大数据时可能会有出入，因为计算 new_allocated 的过程进行过修改：\n和 std::vector 类似，由摊还分析的方法可知 list_append 的平均时间复杂度为 O(1)。\n2 copy 如 list_copy__doc__ 中所描述的，list_copy 函数的目的是返回一个浅拷贝（shallow copy）的 list：\nstatic PyObject * list_copy(PyListObject *self, PyObject *Py_UNUSED(ignored)) { return list_copy_impl(self); } static PyObject * list_copy_impl(PyListObject *self) { return list_slice(self, 0, Py_SIZE(self)); } static PyObject * list_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh) { PyListObject *np; PyObject **src, **dest; Py_ssize_t i, len; len = ihigh - ilow; np = (PyListObject *) list_new_prealloc(len); if (np == NULL) return NULL; src = a-\u0026gt;ob_item + ilow; dest = np-\u0026gt;ob_item; for (i = 0; i \u0026lt; len; i++) { PyObject *v = src[i]; Py_INCREF(v); dest[i] = v; } Py_SET_SIZE(np, len); return (PyObject *)np; } 从 PyListObject 的定义中可以得知动态数组指针 PyObject **ob_item 所指向的动态数组中存储的是对象的指针，因此在 list_slice 函数中，也只是简单地将 PyListObject *a 中每一个 PyObject 的指针依次赋予 PyListObject *np，并将其引用计数加 1；对于被拷贝的 list 中的任意一个值得修改都会反映到拷贝到的 list 上：\na = [1, True, [1, 2]] b = a print(a, b) a[0], a[1], a[2] = 0, False, [3, 4] print(a, b) 这里的 b = a 中在 C++ 中一般表示拷贝构造或拷贝赋值操作，但在 Python 中实际上则会调用 list_copy：\n$ python3 main.py [1, True, [1, 2]] [1, True, [1, 2]] [0, False, [3, 4]] [0, False, [3, 4]] 如果想要对一个 list 进行深拷贝，可以调用 copy 模块的 deepcopy 函数，这是一个用 Python 实现的模块：\ndef deepcopy(x, memo=None, _nil=[]): \u0026#34;\u0026#34;\u0026#34;Deep copy operation on arbitrary Python objects. See the module\u0026#39;s __doc__ string for more info. \u0026#34;\u0026#34;\u0026#34; if memo is None: memo = {} d = id(x) y = memo.get(d, _nil) if y is not _nil: return y cls = type(x) copier = _deepcopy_dispatch.get(cls) if copier is not None: y = copier(x, memo) else: if issubclass(cls, type): y = _deepcopy_atomic(x, memo) else: copier = getattr(x, \u0026#34;__deepcopy__\u0026#34;, None) if copier is not None: y = copier(memo) else: # ... # If is its own copy, don\u0026#39;t memoize. if y is not x: memo[d] = y _keep_alive(x, memo) # Make sure x lives at least as long as d return y deepcopy 会通过 _deepcopy_dispatch.get 来获取内置容器的拷贝器，将内置容器中的数据依次递归地进行拷贝；为了防止某些容器存储的值当中包含指向自己的指针，或是无限重复的数据，函数中会使用一个 dict 变量 memo 来记录已经被拷贝过的数据，防止 deepcopy 无限地递归下去。\n如果容器中存储的是自定义类型的对象，deepcopy 会通过 copier = getattr(x, \u0026quot;__deepcopy__\u0026quot;, None) 获取到这个类型中的函数 __deepcopy__，并将其作为一个拷贝器用来生成新的对象，这也就意味着我们需要实现 __deepcopy__ 函数来保证它可以被正确地深拷贝，以一个自定义的有向图结构为例：\nimport copy class DirectedGraphNode: def __init__(self, idx, node_list): self.idx = idx self.node_list = node_list def point_to(self, node): self.node_list.append(node) def __repr__(self): return \u0026#39;id {}, idx {}, node_list {}\u0026#39;.format(id(self), self.idx, [node.idx for node in self.node_list]) def __deepcopy__(self, memo): print(f\u0026#34;DirectedGraphNode: __deepcopy__ from {repr(self)}\u0026#34;) if self in memo: exist_obj = memo.get(self) return exist_obj cp_obj = DirectedGraphNode(self.idx, []) memo[self] = cp_obj for node in self.node_list: cp_obj.point_to(copy.deepcopy(node, memo)) print(f\u0026#34; copy done, self: {repr(self)}\u0026#34;) return cp_obj a = DirectedGraphNode(1, []) b = DirectedGraphNode(2, []) a.point_to(b) b.point_to(a) print(repr(a)) print(repr(b)) c = copy.deepcopy(a) print(repr(c)) for node in c.node_list: print(repr(node)) 在它的 __deepcopy__ 函数中，我们以其中一个节点出发，先构造出新的节点对象 cp_obj，再将它指向的所有节点以递归的方式依次进行深拷贝，如果在拷贝的过程中发现节点是已经被拷贝过的，则直接返回 exist_obj：\n$ python3 main.py id 139867268624336, idx 1, node_list [2] id 139867268624240, idx 2, node_list [1] DirectedGraphNode: __deepcopy__ from id 139867268624336, idx 1, node_list [2] DirectedGraphNode: __deepcopy__ from id 139867268624240, idx 2, node_list [1] DirectedGraphNode: __deepcopy__ from id 139867268624336, idx 1, node_list [2] copy done, self: id 139867268624240, idx 2, node_list [1] copy done, self: id 139867268624336, idx 1, node_list [2] id 139867268624048, idx 1, node_list [2] id 139867268623040, idx 2, node_list [1] ","permalink":"https://prov1dence.top/posts/python/source-code-3-list-and-dict/","summary":"\u003ch1 id=\"python-源码学习3list-类型\"\u003ePython 源码学习（3）：list 类型\u003c/h1\u003e\n\u003cp\u003ePython 中的 list 类型在源码中是一个名为 \u003ccode\u003ePyListObject\u003c/code\u003e 的结构体，定义在 \u003ccode\u003elistobject.h\u003c/code\u003e 文件中：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Include/cpython/listobject.h\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PyObject_VAR_HEAD\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PyObject \u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003eob_item;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e/* ob_item contains space for \u0026#39;allocated\u0026#39; elements.  The number\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     * currently in use is ob_size.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     * Invariants:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     *     0 \u0026lt;= ob_size \u0026lt;= allocated\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     *     len(list) == ob_size\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     *     ob_item == NULL implies ob_size == allocated == 0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     * list.sort() temporarily sets allocated to -1 to detect mutations.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     * Items must normally not be NULL, except during construction when\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     * the list is not yet visible outside the function that builds it.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e     */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Py_ssize_t allocated;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} PyListObject;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e它的实现和 C++ 中的 \u003ccode\u003estd::vector\u003c/code\u003e 类似，都是通过维护一个动态数组，在增加数据的时候动态扩大数组的容量来实现的；\u003ccode\u003ePyListObject\u003c/code\u003e 结构中包含了一个变长对象头部 \u003ccode\u003ePyObject_VAR_HEAD\u003c/code\u003e，\u003ccode\u003eob_size\u003c/code\u003e 表示当前动态数组的长度，\u003ccode\u003e**ob_item\u003c/code\u003e 是指向动态数组的指针，\u003ccode\u003eallocated\u003c/code\u003e 是动态数组的容量；我们可以从它的类型指针 \u003ccode\u003ePyTypeObject PyList_Type\u003c/code\u003e 中找到用来操作 list 对象的相关方法：\u003c/p\u003e","title":"Python 源码学习（3）：list 类型"},{"content":"ProtoBuf 语法和编码原理入门 序列化是指将结构化数据转换成易于存储或发送的数据格式的过程，Protocol Buffer 简称 ProtoBuf，是一种语言无关，平台无关的序列化工具，由谷歌在 2008 年开源。相较于常见的序列化工具 XML, JSON, YAML, CSV 等，ProtoBuf 的优势主要包括序列化后数据量小，序列化和反序列化过程速度快，使用时只需定义 proto 文件使得其维护成本低，可向后兼容等；但因为其数据以二进制数据流的形式存在，也有人类不可读的劣势。\n本文主要介绍 ProtoBuf 的使用方法，包括 .proto 文件的语法，以及如何使用 protoc 工具来生成不通语言的代码；以及其编码原理。\n1 语法 首先从 https://github.com/protocolbuffers/protobuf 找到最新版本的 ProtoBuf，下载预编译好的二进制文件 protoc 解压到环境变量目录，本文使用的是 3.15.7 版本：\n$ protoc --version libprotoc 3.15.7 以一个简单的 proto 文件为例，它的语法和 C++ 类似：\n// msg.proto syntax = \u0026#34;proto3\u0026#34;; package Message; message SearchRequest { reserved 6, 9 to 12; reserved \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;; string query = 1; int32 page_number = 2; int32 result_per_page = 3; } message ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; } } message SearchResponse { repeated ResultType.Result results = 1; } 使用 protoc 工具生成指定语言的代码：\nprotoc --proto_path=./ --go_out=./go_out/ --cpp_out=./cpp_out/ msg.proto 其中 --proto_path 或 -I 用于参数指定生成所需的 proto 文件和被导入的 proto 文件所在的目录，不指定的话默认为当前目录；go_out 和 cpp_out 分别为生成的 go 文件和 cpp 文件指定目录；最后是我们所需要转换的所有 proto 文件；更多的参数可以输入 protoc --help 查看。\n1.1 数据结构 msg.proto 文件里包含了两部分内容：首先需要指定 ProtoBuf 的版本为 proto3，不指定的话编译器则会默认使用老版本的 proto2 语法；然后是定义我们所需要的 message 类型。message 类型中有很多字段，每个字段都对应一个独一无二的编号，这些编号是用来在序列化后的二进制数据流中识别字段用的。\n字段和编号 字段（field）分为两种类型：\n唯一的（singular）：字段的默认类型，这样的字段对应的数据只能是 0 个或 1 个； 重复的（repeated）：类似于数组，这样的字段对应的数据可以有任意多个，并且会保留其顺序。 在将字段对应到编号（number）上时，需要注意以下几点：\n我们可以使用 [1, 19000) 和 (19999, 2^29 - 1] 区间内的任意编号用来标识字段，中间 [19000, 19999] 是为 ProtoBuf 的实现所预留的； 在对 proto 文件进行编码时，编号 1 到 15 需要占用 1 个字节，16 到 2047 需要占用 2 个字节，因此一般会将常用的字段对应到编号 1 到 15上以节约空间； 一旦使用了某个编号就不能修改其对应字段的类型了，否则会造成无法兼容的问题。 组合和嵌套结构 我们可以直接在一个 message 类型里直接嵌套声明并使用另一个 message 结构：\nmessage SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1; } 如果要使用在另一个 message 类型里嵌套声明的子 message 类型，则需要在定义时加上其父 message 类型的名称：\nmessage ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; } } message SearchResponse { repeated ResultType.Result results = 1; } 类似的，我们也可以以组合的方式在一个 message 类型里引入另一个 message 类型作为字段，并为其赋予 repeated 属性；如果引入的 message 类型在另一个 proto 文件中则需要 import 对应的文件：\n// msg.proto import \u0026#34;result.proto\u0026#34;; message SearchResponse { repeated Result results = 1; } // result.proto message Result { string url = 1; string title = 2; repeated string snippets = 3; } import import 的方式有两种，一种是以相对路径的方式 import，如上面的例子；另一种是在使用 protoc 工具生成代码时使用 -I 指令指定所需要包含的 proto 文件所在的目录，并以绝对路径的方式 import：\n$ tree . |-- msg.proto `-- result `-- result.proto 1 directory, 2 files $ protoc -I. -I./result/ --go_out=./ msg.proto 1.2 关键字 包 包（package）的功能很简单，类似于 C 语言中的 namespace，它可以用来避免不同的 ProtoBuf 消息之间的命名冲突：\npackage Message; 服务 服务（service）是用来定义 RPC 所使用的消息类型的，在 gPRC 有非常充分的应用，它的定义和 Go 的函数定义比较类似：\nservice SearchService { rpc Search (SearchRequest) returns (SearchResponse); } 选项 选项（option）可以改变 proto 文件中某些预定义上下文的处理方式，包括但不限于：\noptimize_for 修改代码生成的方式，有 SPEED 高度优化，CODE_SIZE 减少代码，以及 LITE_RUNTIME 精简功能三种类型； packed 针对 repeated 类型的字段，生成更紧凑的代码； deprecated 针对字段，表明已经废弃，一般只会生成注释，应该尽量搭配 reserved 关键字使用。 option optimize_for = CODE_SIZE; // ... repeated int32 samples = 4 [packed=true]; int32 old_field = 6 [deprecated=true]; 版本兼容 为了使得新版本的 proto 文件能够兼容老版本的，我们不能修改任何已有字段的类型，防止在使用以往版本的老代码在解析新版本的数据结构时发生兼容性问题。\n当我们不再使用某些字段时，我们可以将字段及其对应的编号都删除或注释掉；为了防止我们不小心再次使用相同的编号并将其对应到不同类型的字段上，我们可以使用 reserved 关键字来对已经被删除的字段和编号进行标注，让编译器在编译时检查这些字段和编号是否有被再次使用：\n// msg.proto message SearchRequest { reserved 3, 6, 9 to 12; reserved \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;; string query = 1; int32 page_number = 2; int32 result_per_page = 3; } $ protoc -I. --go_out=./ msg.proto msg.proto: Field \u0026#34;result_per_page\u0026#34; uses reserved number 3. 1.3 数据类型 基础类型 下面的列表列出了 proto 文件中可以使用的所有基础数据类型\n类型 默认值 说明 C++ 类型 Python 类型 Go 类型 double 0 double float float64 float 0 float float float32 int32 0 使用 varint 编码，因此如果有负数建议使用 sint32 int32 int int32 int64 0 使用 varint 编码，因此如果有负数建议使用 sint64 int64 int/long[3] int64 uint32 0 使用 varint 编码 uint32 int/long[3] uint32 uint64 0 使用 varint 编码 uint64 int/long[3] uint64 sint32 0 使用 varint 编码，有符号 int32 int int32 sint64 0 使用 varint 编码，有符号 int64 int/long[3] int64 fixed32 0 固定 4 字节，如果数值超过 228 则比 uint32 效率更高 uint32 int/long[3] uint32 fixed64 0 固定 8 字节，如果数值超过 256 则比 uint64 效率更高 uint64 int/long[3] uint64 sfixed32 0 固定 4 字节 int32 int int32 sfixed64 0 固定 8 字节 int64 int/long[3] int64 bool false bool bool bool string \u0026quot;\u0026quot; 必须以 UTF-8 或 7位 ASCII 编码，长度不能超过 232 string str/unicode[4] string bytes \u0026quot;\u0026quot; 长度不超过 232 的任意字节序列 string str []byte 除了这些基础类型之外，枚举类型（enums）的默认是 0（也就是定义的第一个枚举值），repeated 字段的默认值为空。\nmap ProtoBuf 的一大亮点就是内置了 map 数据类型，其 key_type 可以是任意整数类型或字符串类型：\nmap\u0026lt;key_type, value_type\u0026gt; map_field = N; map 目前不能被 repeated 修饰，但可以通过自定义一个类似于 map 的结构来实现其效果，需要自行解决从 key_type 到 value_type 的映射关系：\nmessage MapFieldEntry { key_type key = 1; value_type value = 2; } repeated MapFieldEntry map_field = N; 枚举类型 proto 文件中的枚举类型定义大致如下：\nmessage EnumRequest { enum Corpus { option allow_alias = true; UNIVERSAL = 0; WEB = 1; NET = 1; IMAGES = 2; LOCAL = 3; } Corpus corpus = 1; } 在使用枚举类型时需要注意几点：\n枚举值定义必须在 32 位整数整数范围内，并且不建议使用负数（因为枚举值在序列化时使用 varint 编码）； 在枚举类型的定义中必须有一个值为 0 的枚举变量； 如果要定义值相同的枚举类型，必须加上 option allow_alias = true。 特殊类型 除了 double, float, int32 等基础数据类型，proto 文件里还可以定义一些特殊的数据类型：\nAny 包含任意字节数的序列化消息； Oneof 类似于 union，表示多个字段共享同一块内存，并且只有其中一个能够被赋值； 2 编码过程 ProtoBuf 的编码过程分为两部分：先对字段的定义进行编码，以便在解码过程中识别其类型；再对数据的值进行编码，对其进行压缩。其中第一部分实际上是使用一定的规则对字段的类型和编号进行编码，得到字段的标签 Tag，而并没有用到字段的名字，因此在实际使用中即使修改字段的名字也是不会发生兼容性问题的；第二部分则是使用不同的算法对不同类型的数据进行压缩得到值 Value，主要用到的两种算法分别是 Varint 和 ZigZag。将这两部分编码完成后，再将标签 Tag，字节长度 Length（只有变长类型需要），值 Value 拼接在一起，就得到了编码后的二进制数据。\n2.1 标签编码 对标签的编码步骤是先将字段类型映射到一个数字 wire_type 上，再将字段编号 field_num 向左位移 3 位，并将两者进行或操作，即 (field_number \u0026lt;\u0026lt; 3) | wire_type。字段类型和 wire_type 的映射关系如下：\nwire_type 含义 存储结构 对应的字段类型 0 使用 Varint 压缩 [Tag Value] int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64 位 [Tag Value] fixed64, sfixed64, double 2 按长度区分 [Tag Length Value] string, bytes, embedded messages, packed repeated fields 3 Start group groups (弃用) 4 End group groups (弃用) 5 32 位 [Tag Value] fixed32, sfixed32, float 解码时为了能够获取存储结构的定义，必须提供正确的 proto 文件。\n举个例子，假设要对一个字段编号 field_number = 2，字段类型为 sint64 的字段进行编码，它的 wire_type = 0，能够知道 (field_number \u0026lt;\u0026lt; 3) | wire_type = 10000，即编码后得到 10；\n类似的，在解码时会先取其后三位 \u0026amp; 111 得到 wire_type = 0，再向右位移 3 位得到 field_number = 2。\n总结一下，对于字段编码后的字节，后三位表示类型，前置位表示字段编号。\n2.2 Varint 对 WireType == 0 的整数类型的主要编码方式是使用 Varint，使用 Varint 编码后的二进制数据长度是不固定的，数值越小的数字编码后的字节长度越小。其步骤分为 3 步：\n对于一个数字的二进制位表示，将其拆分为 7 个一组的字节； 在每一组的头部添加一个最高有效位（most significant bit），只有最大一组有 msb = 0，其他组的 msb 都等于 1； 按照小端序排列这些字节。 举一个简单的例子，对于数字 582963 来说：\n它的二进制表示是 10001110010100110011，将其拆分为三组，分别是 0100011, 1001010, 0110011，即 35, 74, 51； 在最大的一组前加上最高有效位 0，得到 00100011，仍然是 35；在其他组前加上最高有效位 1，得到 11001010，10110011，分别是 202, 179； 将这三个字节按小端序排列，得到 10110011 11001010 00100011，分别是 179, 202, 35，即通过 Varint 编码最后得到的结果。 用 ProtoBuf 对数字 582963 进行编码测试：\nmessage SingleNumber { int32 Num = 1; } func main() { sn := SingleNumber { Num: 582963, } bytes, err := proto.Marshal(\u0026amp;sn) if err != nil { panic(err) } fmt.Println(bytes) } 得到的结果与上述步骤相同，其中第一个字节 8 是对字段进行编码得到的 key：\n$ go run main.go msg.pb.go [8 179 202 35] 解码过程也是类似的：\nfunc main() { b := []byte{8, 179, 202, 35} var sn SingleNumber err := proto.Unmarshal(b, \u0026amp;sn) if err != nil { panic(err) } fmt.Println(sn.GetNum()) } $ go run main.go msg.pb.go 582963 2.3 ZigZag Varint 编码的本质在于去掉数字二进制表示的前置 0 从而减少数据所占用的字节数；而对于用补码表示的负数来说，使用 Varint 进行编码的话，32 位的数字会占用 5 个字节，64 位的数字会占用 10 个字节，效果就显得非常差了。对此 ProtoBuf 采用了 ZigZag 来进行优化，ZigZag 可以将有符号整数映射为无符号整数；正数的编码结果相当于将其乘以 2，负数的编码结果相当于将其绝对值乘以 2 并减 1，编码后的值对应的原始数据在正负数之间摇摆，如下表：\n原始的有符号整数 编码后的无符号整数 0 0 -1 1 1 2 -2 3 2147483647 4294967294 -2147483648 4294967295 它的过程也非常简单：\n假设被编码数的二进制表示是 num，将 num 左移 1 位得到 x 将 num 右移 31 位（num 本身的位数 - 1）得到 y，即用符号位覆盖 num 的每一位 将 x 和 y 进行异或操作，得到结果 z = x ^ y 举个例子，对于正数 5：\nx = 5 \u0026laquo; 1 = 00000000 00000000 00000000 00001010 y = 5 \u0026raquo; 31 = 00000000 00000000 00000000 00000000 z = x ^ y = 00000000 00000000 00000000 00001010，得到 10 对于负数 -5：\nx = -5 \u0026laquo; 1 = 11111111 11111111 11111111 11110110 y = -5 \u0026raquo; 31 = 11111111 11111111 11111111 11111111 z = x ^ y = 00000000 00000000 00000000 00001001，得到 9 在 ProtoBuf 中，负数会先用 ZigZag，再用 Varint 进行编码，达到进一步压缩数据的效果。\n2.4 其他编码过程 变长类型 对于 WireType == 2 的变长类型（string, bytes 等）来说，其序列化后的二进制数据流是以 [Tag Length Value] 的方式存储的，其中 Length 是变长部分的长度，例如：\nmessage SingleNumber { int32 Num = 1; string Str = 2; } func main() { sn := SingleNumber { Num: 582963, Str: \u0026#34;helloworld\u0026#34; } bytes, err := proto.Marshal(\u0026amp;sn) if err != nil { panic(err) } fmt.Println(bytes) } $ go run main.go msg.pb.go [8 179 202 35 18 10 104 101 108 108 111 119 111 114 108 100] 在输出的结果中，第五个字节 18 是 string Str = 2 的 Tag，其中 field_num = 2, wire_type = 2；第六个字节 10 代表这个变长类型的 Length，即从第七个字节到第十六个字节都是存储的 Value，每一个值均是用 ASCII 码存储的字符。\n固定长度类型 对于 WireType == 1 或 WireType == 5 的固定长度类型（fixed32, fixed64 等）来说，其序列化后的二进制数据的长度固定为 4 或 8 个字节，例如：\nmessage SingleNumber { int32 Num = 1; string Str = 2; fixed32 A = 3; fixed64 B = 4; float C = 5; } func main() { sn := SingleNumber { // Num: 582963, // Str: \u0026#34;helloworld\u0026#34;, A: 256, B: 257, } bytes, err := proto.Marshal(\u0026amp;sn) if err != nil { fmt.Println(err) return } fmt.Println(bytes) } $ go run main.go msg.pb.go [29 0 1 0 0 33 1 1 0 0 0 0 0 0] 得到的结果中第 1 个字节是 fixed32 A = 3 的 tag，其中 field_num = 3, wire_type = 5，其后的 4 个字节按照字节序直接存储；第 5 个字节是 fixed64 B = 4 的 tag，其中 field_num = 4, wire_type = 1，其后的 8 个字节同样是按照字节序直接存储的。\n","permalink":"https://prov1dence.top/posts/serialization/protocol-buffer/","summary":"\u003ch1 id=\"protobuf-语法和编码原理入门\"\u003eProtoBuf 语法和编码原理入门\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Serialization\"\u003e序列化\u003c/a\u003e是指将结构化数据转换成易于存储或发送的数据格式的过程，Protocol Buffer 简称 ProtoBuf，是一种语言无关，平台无关的序列化工具，由谷歌在 2008 年开源。相较于常见的序列化工具 \u003ca href=\"https://en.wikipedia.org/wiki/XML\"\u003eXML\u003c/a\u003e, JSON, YAML, CSV 等，ProtoBuf 的优势主要包括序列化后\u003cstrong\u003e数据量小\u003c/strong\u003e，序列化和反序列化过程\u003cstrong\u003e速度快\u003c/strong\u003e，使用时只需定义 proto 文件使得其\u003cstrong\u003e维护成本低\u003c/strong\u003e，可\u003cstrong\u003e向后兼容\u003c/strong\u003e等；但因为其数据以二进制数据流的形式存在，也有\u003cstrong\u003e人类不可读\u003c/strong\u003e的劣势。\u003c/p\u003e\n\u003cp\u003e本文主要介绍 ProtoBuf 的使用方法，包括 .proto 文件的语法，以及如何使用 protoc 工具来生成不通语言的代码；以及其编码原理。\u003c/p\u003e\n\u003ch2 id=\"1-语法\"\u003e1 语法\u003c/h2\u003e\n\u003cp\u003e首先从 \u003ca href=\"https://github.com/protocolbuffers/protobuf\"\u003ehttps://github.com/protocolbuffers/protobuf\u003c/a\u003e 找到最新版本的 ProtoBuf，下载预编译好的二进制文件 \u003ccode\u003eprotoc\u003c/code\u003e 解压到环境变量目录，本文使用的是 3.15.7 版本：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ protoc --version\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibprotoc 3.15.7\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e以一个简单的 proto 文件为例，它的语法和 C++ 类似：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-protobuf\" data-lang=\"protobuf\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// msg.proto\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003esyntax \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;proto3\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003epackage\u003c/span\u003e Message;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003emessage\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSearchRequest\u003c/span\u003e {\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e  reserved \u003cspan style=\"color:#ae81ff\"\u003e6\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e9\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eto\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e12\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e  reserved \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;foo\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;bar\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e query \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint32\u003c/span\u003e page_number \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint32\u003c/span\u003e result_per_page \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e}\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003emessage\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eResultType\u003c/span\u003e {\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003emessage\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eResult\u003c/span\u003e {\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e url \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e title \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003erepeated\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e snippets \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e  }\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e}\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003emessage\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSearchResponse\u003c/span\u003e { \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003erepeated\u003c/span\u003e ResultType.Result results \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e}\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用 protoc 工具生成指定语言的代码：\u003c/p\u003e","title":"ProtoBuf 语法和编码原理入门"},{"content":"Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。\n不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：\n\u0026gt;\u0026gt;\u0026gt; x = 10000000000 \u0026gt;\u0026gt;\u0026gt; print(x) 10000000000 在 C 语言中会发生溢出：\nprintf(\u0026#34;%d\\n\u0026#34;, 1000000 * 1000000); printf(\u0026#34;%u\\n\u0026#34;, 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：\n// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base; // Objects/longobject.h #if PYLONG_BITS_IN_DIGIT == 30 typedef uint32_t digit; // ... #elif PYLONG_BITS_IN_DIGIT == 15 typedef unsigned short digit; // ... #endif typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */ // Include/longintrepr.h struct _longobject { PyObject_VAR_HEAD digit ob_digit[1]; }; 它由两部分组成，分别是：\n一个变长对象 PyVarObject ob_base，其中包括引用计数 Py_ssize_t ob_refcnt、类型指针 PyTypeObject *ob_type、变长部分的长度 Py_ssize_t ob_size，表明 PyLongObject 也是一个变长对象；\n一个 digit 类型的数组 ob_digit ，用于存储整数值，数组长度默认为 1，在初始化时如果长度不够则会被扩大； digit 是一个被 PYLONG_BITS_IN_DIGIT 宏控制的类型，在编译 Python 解释器时可以通过修改这个宏来指定其类型；如果没有指定 PYLONG_BITS_IN_DIGIT 宏的值，则默认会根据操作系统的类型来决定，当指针占用 8 字节以上空间时（64 位以上操作系统），PYLONG_BITS_IN_DIGIT = 30，digit 即为 uint32_t，否则 PYLONG_BITS_IN_DIGIT = 15，digit 则是 unsigned short：\n#ifndef PYLONG_BITS_IN_DIGIT #if SIZEOF_VOID_P \u0026gt;= 8 #define PYLONG_BITS_IN_DIGIT 30 #else #define PYLONG_BITS_IN_DIGIT 15 #endif #endif\n`PyLongObject` 的内存结构大致如图： ![PyLongObject](https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/PyLongObject.png) ### 1.2 数据表示 在 `ob_digit` 数组中，数据的表示遵循两个原则： 1. `ob_size` 的绝对值表示 `ob_digit` 数组的长度，`ob_size = 0` 表示 `PyLongObject` 的数值等于 0；数据的正负由 `ob_size` 的正负来标识，`ob_size \u0026gt; 0` 表示 `PyLongObject \u0026gt; 0`，`ob_size \u0026lt; 0` 表示 `PyLongObject \u0026lt; 0`； 2. `ob_digit` 数组的每一个元素都是一个最大为 `2^30`（假设 `PYLONG_BITS_IN_DIGIT == 30`）的整数，如果整数超过了这个值，则会清零并使其后一位自增 1，假设 `ob_size = n`，那么数据的绝对值则等于 `ob_digit[0] + ob_digit[1] * 2^30 + ob_digit[2] * 2^60 + ... + ob_digit[n-1] * 2^(30 * (n-1))`； 例如对于整数 4294967297，可以被表示为 `1 + 4 * 2^30`，因此其 `ob_size = 2`, `ob_digit[0] = 1`, `ob_digit[1] = 4`，其内存结构大致如图： ![PyLongObject-1](https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/PyLongObject-1.png) 通过这种大数存储方式，Python 从语言层面解决了 `2^(30*2147483648) - 1` 以下（`ob_size` 的类型 `Py_ssize_t` 是通过 `typedef long int Py_ssize_t` 定义的）的大数的溢出问题。 ### 1.3 创建对象 在 Python 中， `PyLongObject` 对象一般是通过 `_PyLong_New` 函数创建出来的： ```cpp /* Allocate a new int object with size digits. Return NULL and set exception if we run out of memory. */ #define MAX_LONG_DIGITS \\ ((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/sizeof(digit)) PyLongObject * _PyLong_New(Py_ssize_t size) { PyLongObject *result; /* Number of bytes needed is: offsetof(PyLongObject, ob_digit) + sizeof(digit)*size. Previous incarnations of this code used sizeof(PyVarObject) instead of the offsetof, but this risks being incorrect in the presence of padding between the PyVarObject header and the digits. */ if (size \u0026gt; (Py_ssize_t)MAX_LONG_DIGITS) { PyErr_SetString(PyExc_OverflowError, \u0026#34;too many digits in integer\u0026#34;); return NULL; } result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) + size*sizeof(digit)); if (!result) { PyErr_NoMemory(); return NULL; } _PyObject_InitVar((PyVarObject*)result, \u0026amp;PyLong_Type, size); return result; } 这个函数非常简单，主要是做了两件事：\n内存分配前后的检查，包括参数 size 不能超过 MAX_LONG_DIGITS，也就是说 PyLongObject 所表示的整数大小不能超过 2^(30*2147483648) - 1，以及生成使用 malloc 分配内存失败后的报错信息； 为 PyLongObject 对象申请内存，其大小分为两部分，第一部分是 PyVarObject 在内存对齐后所占用的空间，即 offsetof(PyLongObject, ob_digit)；第二部分是 ob_digit 数组所占用的空间，其中参数 size 是 ob_digit 数组的长度。 1.4 数据转化 每一个 PyLongObject 对象都拥有不同的内存地址，我们可以通过 Python 中的 id 函数来查看一个变量的标识，这个标识会因内存地址的不同而改变：\nfor i in range(5): print(id(i)) $ python3 main.py 139748219328384 139748219328416 139748219328448 139748219328480 139748219328512 可以看出 0 到 4 这 5 个数的标识里每两个都相差了 32，刚好符合每一个 PyLongObject 对象所占用的空间 32 字节，而不是 C 语言里一个 long 类型变量通常所占用的 4 字节或 8 字节，这是因为所有原始的数据都会被转化为 PyLongObject 对象。\n数据转化的方法有很多，以 PyLong_FromLong 为例，它会将一个 long 类型的整数转化为 PyLongObject 对象：\n// Objects/longobject.c /* interpreter state */ #define _PY_NSMALLPOSINTS 257 #define _PY_NSMALLNEGINTS 5 #define NSMALLNEGINTS _PY_NSMALLNEGINTS #define NSMALLPOSINTS _PY_NSMALLPOSINTS #define IS_SMALL_INT(ival) (-NSMALLNEGINTS \u0026lt;= (ival) \u0026amp;\u0026amp; (ival) \u0026lt; NSMALLPOSINTS) PyObject * PyLong_FromLong(long ival) { PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so \u0026gt;\u0026gt; doesn\u0026#39;t propagate sign bit */ int ndigits = 0; int sign; if (IS_SMALL_INT(ival)) { return get_small_int((sdigit)ival); } if (ival \u0026lt; 0) { /* negate: can\u0026#39;t write this as abs_ival = -ival since that invokes undefined behaviour when ival is LONG_MIN */ abs_ival = 0U-(unsigned long)ival; sign = -1; } else { abs_ival = (unsigned long)ival; sign = ival == 0 ? 0 : 1; } /* Fast path for single-digit ints */ if (!(abs_ival \u0026gt;\u0026gt; PyLong_SHIFT)) { v = _PyLong_New(1); if (v) { Py_SET_SIZE(v, sign); v-\u0026gt;ob_digit[0] = Py_SAFE_DOWNCAST( abs_ival, unsigned long, digit); } return (PyObject*)v; } #if PyLong_SHIFT==15 /* 2 digits */ if (!(abs_ival \u0026gt;\u0026gt; 2*PyLong_SHIFT)) { v = _PyLong_New(2); if (v) { Py_SET_SIZE(v, 2 * sign); v-\u0026gt;ob_digit[0] = Py_SAFE_DOWNCAST( abs_ival \u0026amp; PyLong_MASK, unsigned long, digit); v-\u0026gt;ob_digit[1] = Py_SAFE_DOWNCAST( abs_ival \u0026gt;\u0026gt; PyLong_SHIFT, unsigned long, digit); } return (PyObject*)v; } #endif /* Larger numbers: loop to determine number of digits */ t = abs_ival; while (t) { ++ndigits; t \u0026gt;\u0026gt;= PyLong_SHIFT; } v = _PyLong_New(ndigits); if (v != NULL) { digit *p = v-\u0026gt;ob_digit; Py_SET_SIZE(v, ndigits * sign); t = abs_ival; while (t) { *p++ = Py_SAFE_DOWNCAST( t \u0026amp; PyLong_MASK, unsigned long, digit); t \u0026gt;\u0026gt;= PyLong_SHIFT; } } return (PyObject *)v; } 虽然看起来比较长，但其实思路非常简单：\n创建用于存储返回值的指针 PyLongObject *z，保存数据绝对值的变量 unsigned long abs_ival, t，标识数组长度的 int ndigits 和标识数据正负的 int sign； 如果数据范围在 [-5, 257) 内，则通过 get_small_int 函数返回结果； 获取数据的绝对值和正负符号； 如果数据绝对值没有超过 ob_digit 数组的单个元素所能表示的大小，则通过一个快速路径返回结果； 对于较大的数据，确定其 ob_digit 数组的长度，逐位置入。 可以注意到，第 2 步针对 [-5, 257) 区间内的小整数做了特殊处理，最终在调用到 __PyLong_GetSmallInt_internal 函数时，会通过 tstate-\u0026gt;interp-\u0026gt;small_ints[index] 缓存数组获取小整数对应的指针对象并将其返回，这里的 small_ints 数组是一个全局变量，一般称为小整数对象池，是针对常用的小整数做的一个优化：\n// Objects/longobject.c static inline PyObject* __PyLong_GetSmallInt_internal(int value) { PyThreadState *tstate = _PyThreadState_GET(); #ifdef Py_DEBUG _Py_EnsureTstateNotNULL(tstate); #endif assert(-_PY_NSMALLNEGINTS \u0026lt;= value \u0026amp;\u0026amp; value \u0026lt; _PY_NSMALLPOSINTS); size_t index = _PY_NSMALLNEGINTS + value; PyObject *obj = (PyObject*)tstate-\u0026gt;interp-\u0026gt;small_ints[index]; // _PyLong_GetZero() and _PyLong_GetOne() must not be called // before _PyLong_Init() nor after _PyLong_Fini() assert(obj != NULL); return obj; } 2 数学运算 PyLongObject 的类型对象是 PyLong_Type，PyLong_Type 的成员变量 PyNumberMethods *tp_as_number 由 static PyNumberMethods long_as_number* 结构体指针初始化，其中包含了许多数学运算的函数指针，当我们对 PyLong_Type 进行数学运算时，实际上会调用这些函数：\n// Objects/longobject.c PyTypeObject PyLong_Type = { // ... \u0026amp;long_as_number, /* tp_as_number */ // ... }; static PyNumberMethods long_as_number = { (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ long_mod, /*nb_remainder*/ long_divmod, /*nb_divmod*/ long_pow, /*nb_power*/ // ... }; 2.1 加法 PyLong_Type 的加法运算对应的函数是 long_add，其实现和相关的宏定义如下：\n// Objects/longobject.c #define CHECK_BINOP(v,w) \\ do { \\ if (!PyLong_Check(v) || !PyLong_Check(w)) \\ Py_RETURN_NOTIMPLEMENTED; \\ } while(0) /* convert a PyLong of size 1, 0 or -1 to an sdigit */ #define MEDIUM_VALUE(x) (assert(-1 \u0026lt;= Py_SIZE(x) \u0026amp;\u0026amp; Py_SIZE(x) \u0026lt;= 1), \\ Py_SIZE(x) \u0026lt; 0 ? -(sdigit)(x)-\u0026gt;ob_digit[0] : \\ (Py_SIZE(x) == 0 ? (sdigit)0 : \\ (sdigit)(x)-\u0026gt;ob_digit[0])) static PyObject * long_add(PyLongObject *a, PyLongObject *b) { PyLongObject *z; CHECK_BINOP(a, b); if (Py_ABS(Py_SIZE(a)) \u0026lt;= 1 \u0026amp;\u0026amp; Py_ABS(Py_SIZE(b)) \u0026lt;= 1) { return PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b)); } if (Py_SIZE(a) \u0026lt; 0) { if (Py_SIZE(b) \u0026lt; 0) { z = x_add(a, b); if (z != NULL) { /* x_add received at least one multiple-digit int, and thus z must be a multiple-digit int. That also means z is not an element of small_ints, so negating it in-place is safe. */ assert(Py_REFCNT(z) == 1); Py_SET_SIZE(z, -(Py_SIZE(z))); } } else z = x_sub(b, a); } else { if (Py_SIZE(b) \u0026lt; 0) z = x_sub(a, b); else z = x_add(a, b); } return (PyObject *)z; } 可以看到它的实现非常简单，主要分为以下几个步骤：\n创建一个用于存储返回值的指针 PyLongObject *z； 检查两个参数是否都是 PyLongObject 类型的指针 CHECK_BINOP(a, b)； 如果两个参数都满足 ob_size \u0026lt;= 1（即绝对值均小于 2^30），那么先通过 MEDIUM_VALUE 获取两个 ob_digit[0] 的值，并将两数直接相加（一定不会溢出），再通过 PyLong_FromLong 将这个数包装为一个 PyLongObject 指针并返回；通常我们进行运算的数都不会太大，因此这里可以利用简化的运算步骤和 CPU 分支预测来提高效率； 判断两者的正负关系，将问题简化为绝对值加减法，利用辅助函数 x_add 和 x_sub 进行运算并返回结果。 2.2 绝对值加法 绝对值加法函数 x_add 的定义如下：\n#if PYLONG_BITS_IN_DIGIT == 30 #define PyLong_SHIFT 30 // ... #endif #define PyLong_BASE ((digit)1 \u0026lt;\u0026lt; PyLong_SHIFT) #define PyLong_MASK ((digit)(PyLong_BASE - 1)) /* Add the absolute values of two integers. */ static PyLongObject * x_add(PyLongObject *a, PyLongObject *b) { Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b)); PyLongObject *z; Py_ssize_t i; digit carry = 0; /* Ensure a is the larger of the two: */ if (size_a \u0026lt; size_b) { { PyLongObject *temp = a; a = b; b = temp; } { Py_ssize_t size_temp = size_a; size_a = size_b; size_b = size_temp; } } z = _PyLong_New(size_a+1); if (z == NULL) return NULL; for (i = 0; i \u0026lt; size_b; ++i) { carry += a-\u0026gt;ob_digit[i] + b-\u0026gt;ob_digit[i]; z-\u0026gt;ob_digit[i] = carry \u0026amp; PyLong_MASK; carry \u0026gt;\u0026gt;= PyLong_SHIFT; } for (; i \u0026lt; size_a; ++i) { carry += a-\u0026gt;ob_digit[i]; z-\u0026gt;ob_digit[i] = carry \u0026amp; PyLong_MASK; carry \u0026gt;\u0026gt;= PyLong_SHIFT; } z-\u0026gt;ob_digit[i] = carry; return long_normalize(z); } 其步骤大致分为以下几步：\n获取两个参数的 ob_size 的绝对值，创建存储返回值的指针 PyLongObject *z， 如果 a-\u0026gt;ob_size \u0026lt; b-\u0026gt;ob_size 则交换两者，保证 a 的值较大； 将 z 的 ob_size 设置为 size_a + 1，保证不会溢出； 以 i = 0 为下标，从小到大依次对两数的每一位进行相加操作，将没有超过 2^30 的部分存储在 z-\u0026gt;ob_digit[i] 中，超过的部分进位保存在 carry 中；这里充分利用了两个小于 2^30 的数相加不会溢出的特性；如果 size_a \u0026gt; size_b 还需要将 a-\u0026gt;ob_digit 多余的部分按照相同的方法置入 z-\u0026gt;ob_digit里； 得到的结果 z 中，其 ob_digit 的最后一个元素可能等于 0，因此通过 long_normalize 函数将其转换为符合 PyLongObject 定义的格式返回。 整个过程可以抽象为类似 2^30 进制的加法，和十进制加法的过程几乎完全一样，只不过是把十进制每一位的数字换成了一个最大值为 2^30 的数字，每逢 2^30 进一位；举个例，假设有 a-\u0026gt;ob_digit = {4, 5, 6}, b-\u0026gt;ob_digit = {1073741823, 1073741823}，那么整个加法的步骤为：\nv-\u0026gt;ob_digit[0] = (4 + 1073741823) % 1073741824 = 3, carry = 1； v-\u0026gt;ob_digit[1] = (5 + 1073741823 + 1) % 1073741824 = 5, carry = 1； v-\u0026gt;ob_digit[2] = (6 + 1) % 1073741824 = 7, carry = 0； v-\u0026gt;ob_digit[3] = 0； 结果即 v-\u0026gt;ob_digit = {3, 5, 7, 0}，最后一个元素 0 需要通过 long_normalize 函数去掉。\n2.3 绝对值减法 绝对值减法的实现如下：\n/* Subtract the absolute values of two integers. */ static PyLongObject * x_sub(PyLongObject *a, PyLongObject *b) { Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b)); PyLongObject *z; Py_ssize_t i; int sign = 1; digit borrow = 0; /* Ensure a is the larger of the two: */ if (size_a \u0026lt; size_b) { sign = -1; { PyLongObject *temp = a; a = b; b = temp; } { Py_ssize_t size_temp = size_a; size_a = size_b; size_b = size_temp; } } else if (size_a == size_b) { /* Find highest digit where a and b differ: */ i = size_a; while (--i \u0026gt;= 0 \u0026amp;\u0026amp; a-\u0026gt;ob_digit[i] == b-\u0026gt;ob_digit[i]) ; if (i \u0026lt; 0) return (PyLongObject *)PyLong_FromLong(0); if (a-\u0026gt;ob_digit[i] \u0026lt; b-\u0026gt;ob_digit[i]) { sign = -1; { PyLongObject *temp = a; a = b; b = temp; } } size_a = size_b = i+1; } z = _PyLong_New(size_a); if (z == NULL) return NULL; for (i = 0; i \u0026lt; size_b; ++i) { /* The following assumes unsigned arithmetic works module 2**N for some N\u0026gt;PyLong_SHIFT. */ borrow = a-\u0026gt;ob_digit[i] - b-\u0026gt;ob_digit[i] - borrow; z-\u0026gt;ob_digit[i] = borrow \u0026amp; PyLong_MASK; borrow \u0026gt;\u0026gt;= PyLong_SHIFT; borrow \u0026amp;= 1; /* Keep only one sign bit */ } for (; i \u0026lt; size_a; ++i) { borrow = a-\u0026gt;ob_digit[i] - borrow; z-\u0026gt;ob_digit[i] = borrow \u0026amp; PyLong_MASK; borrow \u0026gt;\u0026gt;= PyLong_SHIFT; borrow \u0026amp;= 1; /* Keep only one sign bit */ } assert(borrow == 0); if (sign \u0026lt; 0) { Py_SET_SIZE(z, -Py_SIZE(z)); } return maybe_small_long(long_normalize(z)); } 其步骤和绝对值加法类似，大致分为以下几步：\n获取两个参数的 ob_size 的绝对值，创建存储返回值的指针 PyLongObject *z， 如果 a-\u0026gt;ob_size \u0026lt; b-\u0026gt;ob_size 则交换两者，保证 a 的值较大，并用 sign 记录运算结果为负；如果 a-\u0026gt;ob_size == b-\u0026gt;ob_size 则从最高位依次往低位找到第一次出现 a-\u0026gt;ob_digit[i] != b-\u0026gt;ob_digit[i] 的位置，比较 a-\u0026gt;ob_digit[i] 和 b-\u0026gt;ob_digit[i]，并决定是否交换两者以及 sign 的值； 将 z 的 ob_size 设置为 size_a； 以 i = 0 为下标，从小到大依次对两数的每一位进行相减操作，如果被减数 a-\u0026gt;ob_digit[i] 小于减数 b-\u0026gt;ob_digit[i] 则要向高位 a-\u0026gt;ob_digit[i + 1] 借 1；在十进制的减法中向高位借到的数是 10，这里向 digit 数组的高位借到的则是 2^30；但 digit 是通过 typedef uint32_t digit 定义出来，通过公式 borrow = a-\u0026gt;ob_digit[i] - b-\u0026gt;ob_digit[i] - borrow 实际上得到的是 2^32 + a-\u0026gt;ob_digit[i] - b-\u0026gt;ob_digit[i]，所以还需要与 PyLong_MASK 做 \u0026amp; 操作，取后 30 位，便能得到借位相减后的结果，再将结果存储在 z-\u0026gt;ob_digit[i] 中；借位部分 borrow 向右位移 30 位后还剩 2 位，只需要将其与 1 进行 \u0026amp; 操作即可知道此次减法运算是否有借位；如果 size_a \u0026gt; size_b 还需要将 a-\u0026gt;ob_digit 多余的部分按照相同的方法置入 z-\u0026gt;ob_digit里； 得到的结果 z 中，其 ob_digit 的最后一个元素可能等于 0，因此通过 long_normalize 函数将其转换为符合 PyLongObject 定义的格式返回。 可以看到这里的步骤也跟十进制减法几乎完全相同，都跟 NOIP 入门的大数加减法加法思路相同。\n","permalink":"https://prov1dence.top/posts/python/source-code-2/","summary":"\u003ch1 id=\"python-源码学习2int-类型\"\u003ePython 源码学习（2）：int 类型\u003c/h1\u003e\n\u003cp\u003ePython 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 \u003ccode\u003ePyBaseObject_Type\u003c/code\u003e 类型的 \u003ccode\u003ePyType_Type\u003c/code\u003e 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。\u003c/p\u003e\n\u003cp\u003e不同于 C 和 C++ 中的 \u003ccode\u003eint\u003c/code\u003e 类型，Python 中的 \u003ccode\u003eint\u003c/code\u003e 类型最大的特点是它一般是\u003cstrong\u003e不会溢出\u003c/strong\u003e的，对比用 C 和 Python 分别输出两个一百万相乘的结果：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10000000000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e print(x)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e10000000000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 C 语言中会发生溢出：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprintf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1000000\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1000000\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprintf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%u\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1000000\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1000000\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e-727379968\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e3567587328\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"1-int-类型在内存中的存储方式\"\u003e1 int 类型在内存中的存储方式\u003c/h2\u003e\n\u003ch3 id=\"11-内存结构\"\u003e1.1 内存结构\u003c/h3\u003e\n\u003cp\u003ePython 中的 \u003ccode\u003eint\u003c/code\u003e 整数类型实际上是一个名为 \u003ccode\u003ePyLongObject\u003c/code\u003e  的结构体，定义在 \u003ccode\u003elongintrepr.h\u003c/code\u003e 文件中：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Include/object.h\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define PyObject_VAR_HEAD      PyVarObject ob_base;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Objects/longobject.h\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#if PYLONG_BITS_IN_DIGIT == 30\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e digit;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// ...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#elif PYLONG_BITS_IN_DIGIT == 15\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eunsigned\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eshort\u003c/span\u003e digit;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// ...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#endif\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_longobject\u003c/span\u003e PyLongObject; \u003cspan style=\"color:#75715e\"\u003e/* Revealed in longintrepr.h */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Include/longintrepr.h\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_longobject\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PyObject_VAR_HEAD\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    digit ob_digit[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e它由两部分组成，分别是：\u003c/p\u003e","title":"Python 源码学习（2）：int 类型"},{"content":"Python 源码学习（1）：类型和对象 Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：\n$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc\t# 文档 |-- Grammar |-- Include # C 头文件 |-- Lib\t# 用 Python 写的库文件 |-- Mac\t# 用于在 macOS 上构建的文件 |-- Misc\t# 杂项 |-- Modules\t# 用 C 写的库文件 |-- Objects # 核心类型，以及对象模型的定义 |-- PC\t# 用于在 Windows 上构建的文件 |-- PCbuild # 用于在老版本的 Windows 上构建的文件 |-- Parser\t# Python 解析器源码 |-- Programs\t# Python 可执行文件和其他 |-- Python\t# CPython 编译器源码 |-- Tools\t# 构建时的工具 `-- m4 16 directories 本系列主要以阅读和分析 CPython 源码的方式学习 Python。\n1 对象模型 Python 是一门面向对象的语言，我们可以使用 Python 中的 type() 函数查看一个对象所属的类：\n\u0026gt;\u0026gt;\u0026gt; type(1) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(True) \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; 可以看到整数对象和布尔值对象的类型分别是 \u0026lt;class 'int'\u0026gt; 和 \u0026lt;class 'bool'\u0026gt;；\n而实际上，在 Python 中无论是整数，布尔值还是基本数据类型，甚至自定义的 class，都是对象：\nclass Foo: pass print(type(int)) print(type(Foo)) \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; 可以看到 int 类型和自定义类 Foo 的类型都是 \u0026lt;class 'type'\u0026gt;，它们是 type 这个类的实例对象；type 类型是专门用于定义类型的类型，也称为元类型；实际上， type 这个类型本身也是一个对象，它所属的类也是 type：\n\u0026gt;\u0026gt;\u0026gt; type(type) \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; 同时，Python 中的所有类型，无论是 int, type, 还是自定义类 Foo 都是继承自一个叫 object 的基类，而 object 则是继承链的终点：\n\u0026gt;\u0026gt;\u0026gt; int.__base__ \u0026lt;class \u0026#39;object\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type.__base__ \u0026lt;class \u0026#39;object\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(Foo.__base__) \u0026lt;class \u0026#39;object\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(object.__base__) None 而 object 基类也是一个 type 类型的对象：\n\u0026gt;\u0026gt;\u0026gt; type(object) \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; 上面的关系用图表达出来则是：\n可以看到，所有类型的基类都是 object，所有类型的类型都是 type，这就是 Python 的对象模型（object model），也是 Objects/ 目录下源码所包含的内容。\n2 核心类型与对象 虽然在 Python 的语法层面有非常多所谓的类型（包括 int, type, Foo 等），但实际上它们在源码（C 语言）层面上都是结构体对象。\n2.1 对象 PyObject Python 中所有的类型都由 PyObject 结构体扩展而来，这个结构体中有以下几个成员变量：\nPy_ssize_t ob_refcnt 用于保存对象的引用计数； PyTypeObject *ob_type 指向对象的类型对象，用来标识对象属于的类型，并存储类型的元数据； _PyObject_HEAD_EXTRA 宏代表了两个 PyObject* 双向链表的指针，用于把堆上的所有对象链接起来，只会在开启了 Py_TRACE_REFS 宏的时候进行构造，方便调试； // Include/object.h /* Define pointers to support a doubly-linked list of all live heap objects. */ #define _PyObject_HEAD_EXTRA \\ struct _object *_ob_next; \\ struct _object *_ob_prev; /* Nothing is actually declared to be a PyObject, but every pointer to * a Python object can be cast to a PyObject*. This is inheritance built * by hand. Similarly every pointer to a variable-size Python object can, * in addition, be cast to PyVarObject*. */ typedef struct _object { _PyObject_HEAD_EXTRA\t// 双向链表，用于追踪堆中所有对象，在开启了 Py_TRACE_REFS 宏的时候有用 Py_ssize_t ob_refcnt;\t// 引用计数，用于垃圾回收 PyTypeObject *ob_type;\t// 指针，指向当前对象的类型对象，用于查询对象的类型 } PyObject; PyVarObject Python 中有可以自由修改长度的 PyVarObject 变长对象，它由一个 PyObject 对象和一个存储变长部分的长度（元素个数）的变量 ob_size 组成：\ntypedef struct { PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part */ } PyVarObject; PyObject 和 PyVarObject 一般是作为头部被包含在一个变量结构体中的，根据该变量大小是否固定来选择使用哪一种：\n// Include/object.h /* PyObject_HEAD defines the initial segment of every PyObject. */ #define PyObject_HEAD PyObject ob_base; /* PyObject_VAR_HEAD defines the initial segment of all variable-size * container objects. These end with a declaration of an array with 1 * element, but enough space is malloc\u0026#39;ed so that the array actually * has room for ob_size elements. Note that ob_size is an element count, * not necessarily a byte count. */ #define PyObject_VAR_HEAD PyVarObject ob_base; Python 中最典型的变长对象就是列表 List，它和 std::vector 比较类似，列表对象里有三个成员变量，包括：\n基础的变长对象 PyVarObject ob_base，其中 ob_base.ob_size 用于表示列表当前的元素个数； 指向动态数组的指针 PyObject **ob_item； 动态数组当前的容量 Py_ssize_t allocated： // Inlucde/cpython/listobject.h typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for \u0026#39;allocated\u0026#39; elements. The number * currently in use is ob_size. * Invariants: * 0 \u0026lt;= ob_size \u0026lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated; } PyListObject; 2.2 类型 PyTypeObject PyObject 类中的 PyTypeObject *ob_type 是一个指向对象类型的指针，它是类在 Python 中的表现形式；PyTypeObject 不仅决定了 PyObject 对象属于什么类型，还包含了非常多的元数据，例如：\nPyObject_VAR_HEAD 表示 PyTypeObject 本身是一个变长对象； const char *tp_name 表示类型的名字； struct _typeobject *tp_base 是指向基类的指针，保存类型的继承信息； Py_ssize_t tp_basicsize, tp_itemsize 表示创建实力对象时分配的内存大小； setattrfunc tp_setattr 设置值，getattrfunc tp_getattr 获取值，destructor tp_dealloc 析构，hashfunc tp_hash 哈希等函数指针表示该类型所支持的标准操作； // Include/object.h /* PyTypeObject structure is defined in cpython/object.h. In Py_LIMITED_API, PyTypeObject is an opaque structure. */ typedef struct _typeobject PyTypeObject; // Include/cpython/object.h struct _typeobject { PyObject_VAR_HEAD // 即 PyVarObject ob_base; const char *tp_name; /* For printing, in format \u0026#34;\u0026lt;module\u0026gt;.\u0026lt;name\u0026gt;\u0026#34; */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ destructor tp_dealloc; Py_ssize_t tp_vectorcall_offset; getattrfunc tp_getattr; setattrfunc tp_setattr; PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2) or tp_reserved (Python 3) */ // Strong reference on a heap type, borrowed reference on a static type struct _typeobject *tp_base; /* More standard operations (here for binary compatibility) */ // ... }; Python 中的每一种类型对象都是全局唯一的，他们在源码中以全局变量的形式存在，例如 int 类型：\n// Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) \u0026#34;int\u0026#34;, /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ 0, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ long_to_decimal_string, /* tp_repr */ \u0026amp;long_as_number, /* tp_as_number */ // ... }; PyVarObject_HEAD_INIT 宏用于初始化 PyVarObject 中的 ob_refcnt, ob_type 和 ob_size：\n#define PyObject_HEAD_INIT(type) \\ { 1, type }, #define PyVarObject_HEAD_INIT(type, size) \\ { PyObject_HEAD_INIT(type) size }, 可以看到在 PyLong_Type 中，ob_type 被初始化为 \u0026amp;PyType_Type，它是专门用于定义类型对象的类型，抑或叫做类型的类型或原类型。\nPyType_Type 在前面已经了解到，type 类型对象所属的类也是 type，那么类型对象 PyTypeObject 本身也是一个类对象，它也拥有指向其类型对象的指针 PyTypeObject *ob_type；对于类型对象本身来说，它的类型对象都基于一个叫做 PyType_Type（即元类型）的 PyTypeObject 类对象：\n// Objects/typeobject.c PyTypeObject PyType_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0)\t// PyType_Type 在初始化的时候将指向自身的指针传递并用于构造了一个 PyVarObject 类型的对象 ob_base，其中 ob_base-\u0026gt;ob_type = \u0026amp;PyType_Type，参考附录 1 \u0026#34;type\u0026#34;, /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ (destructor)type_dealloc, /* tp_dealloc */ offsetof(PyTypeObject, tp_vectorcall), /* tp_vectorcall_offset */ // ... }; Python 中类型对象都定义在了 Objects/ 目录下，例如 bool 类型：\n// Objects/boolobject.c /* The type object for bool. Note that this cannot be subclassed! */ PyTypeObject PyBool_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0)\t// 同 PyType_Type，ob_base-\u0026gt;ob_type = \u0026amp;PyType_Type \u0026#34;bool\u0026#34;,\t// tp_name = \u0026#34;bool\u0026#34; sizeof(struct _longobject),\t/* tp_basicsize */ 0,\t/* tp_itemsize */ 0, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ bool_repr, /* tp_repr */ \u0026amp;bool_as_number, /* tp_as_number */ // ... 0, /* tp_base */ // ... }; 在 Python 中，无论是内建类型（int, bool 等），还是自定义类型（Foo），都是通过 PyTypeObject 这个结构体构造的，且一定满足 ob_base-\u0026gt;ob_type = \u0026amp;PyType_Type。\n前文提到 tp_base 是指向基类的指针，保存类型的继承信息，但实际上在定义 PyBool_Type 的时候可以看到 tp_base = 0，实际上这个 tp_base 是在 PyType_Ready 函数中被赋值为 PyBaseObject_Type 的：\n// Objects/typeobject.c int PyType_Ready(PyTypeObject *type) { PyTypeObject *base; // ... /* Initialize tp_base (defaults to BaseObject unless that\u0026#39;s us) */ base = type-\u0026gt;tp_base; if (base == NULL \u0026amp;\u0026amp; type != \u0026amp;PyBaseObject_Type) { base = \u0026amp;PyBaseObject_Type; if (type-\u0026gt;tp_flags \u0026amp; Py_TPFLAGS_HEAPTYPE) { type-\u0026gt;tp_base = (PyTypeObject*)Py_NewRef((PyObject*)base); } else { type-\u0026gt;tp_base = base; } } // ... } 这里 PyTypeObject *base 被赋值为的 PyBaseObject_Type 就是前文提到的基类型。\nPyBaseObject_Type PyBaseObject_Type 定义在 typeobject.c 文件中：\n// Objects/typeobject.c PyTypeObject PyBaseObject_Type = { PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0)\t// 同 PyType_Type，ob_base-\u0026gt;ob_type = \u0026amp;PyType_Type \u0026#34;object\u0026#34;, /* tp_name */ sizeof(PyObject), /* tp_basicsize */ 0, /* tp_itemsize */ object_dealloc, /* tp_dealloc */ // ... object_repr, /* tp_repr */ // ... 0, /* tp_base */ // ... }; 可以看到无论是 PyBool_Type，PyType_Type 还是 PyBaseObject_Type，都有两个共同点：\n它们是以同样的方式 PyVarObject_HEAD_INIT(\u0026amp;PyType_Type, 0) 定义其类型的，因此它们的类型都是 PyTypeObject； 它们指向基类的指针 tp_base 初始化时都是 NULL； 不同的地方是，在使用 PyType_Ready 函数为它们的基类指针 tp_base 赋值时，只有 PyBaseObject_Type.tp_base 不会被赋值，其他的 tp_base 则都会被赋值为 PyBaseObject_Type，这也印证了 PyBaseObject_Type 是继承链的终点。\n我们可以将上面的关系整理为一个图：\n附录 1 PyType_Type 构造 struct Bar; struct Foo { Bar* p_b; int ref_count; }; struct Bar { Foo f; const char* name; }; Bar b { Foo{ \u0026amp;b, 1 }, \u0026#34;ClassBar\u0026#34; }; int main() { printf(\u0026#34;%s\\n\u0026#34;, b.f.p_b-\u0026gt;name); return 0; } $ ./test ClassBar ","permalink":"https://prov1dence.top/posts/python/source-code-1/","summary":"\u003ch1 id=\"python-源码学习1类型和对象\"\u003ePython 源码学习（1）：类型和对象\u003c/h1\u003e\n\u003cp\u003ePython 是一门解释型，动态类型，多范式的编程语言，当我们从 \u003ca href=\"https://www.python.org/\"\u003epython.org\u003c/a\u003e 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 \u003ca href=\"https://github.com/python/cpython\"\u003eCPython\u003c/a\u003e，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ git clone https://github.com/python/cpython\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ tree -d -L \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e .\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e`\u003c/span\u003e-- cpython\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Doc\t\t\t\u003cspan style=\"color:#75715e\"\u003e# 文档\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Grammar\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Include \t\u003cspan style=\"color:#75715e\"\u003e# C 头文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Lib\t\t\t\u003cspan style=\"color:#75715e\"\u003e# 用 Python 写的库文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Mac\t\t\t\u003cspan style=\"color:#75715e\"\u003e# 用于在 macOS 上构建的文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Misc\t\t\u003cspan style=\"color:#75715e\"\u003e# 杂项\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Modules\t\t\u003cspan style=\"color:#75715e\"\u003e# 用 C 写的库文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Objects \t\u003cspan style=\"color:#75715e\"\u003e# 核心类型，以及对象模型的定义\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- PC\t\t\t\u003cspan style=\"color:#75715e\"\u003e# 用于在 Windows 上构建的文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- PCbuild \t\u003cspan style=\"color:#75715e\"\u003e# 用于在老版本的 Windows 上构建的文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Parser\t\t\u003cspan style=\"color:#75715e\"\u003e# Python 解析器源码\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Programs\t\u003cspan style=\"color:#75715e\"\u003e# Python 可执行文件和其他\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Python\t\t\u003cspan style=\"color:#75715e\"\u003e# CPython 编译器源码\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    |-- Tools\t\t\u003cspan style=\"color:#75715e\"\u003e# 构建时的工具\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e6db74\"\u003e`\u003c/span\u003e-- m4\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e16\u003c/span\u003e directories\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e本系列主要以阅读和分析 CPython 源码的方式学习 Python。\u003c/p\u003e","title":"Python 源码学习（1）：类型和对象"},{"content":"C++ 智能指针的简单实现 1 std::auto_ptr C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 模板类：\ntemplate\u0026lt;typename T\u0026gt; class Object { public: // constructor Object() : t_() { cout \u0026lt;\u0026lt; \u0026#34;Object::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } Object(T t) : t_(t) { cout \u0026lt;\u0026lt; \u0026#34;Object::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } // copy-ctor Object(const Object \u0026amp;other) { cout \u0026lt;\u0026lt; \u0026#34;Object::Copy-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } // destructor ~Object() { cout \u0026lt;\u0026lt; \u0026#34;Object::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } void Set(T t) { t_ = t; } void Print() { cout \u0026lt;\u0026lt; t_ \u0026lt;\u0026lt; endl; } private: T t_; }; 如果在堆上为类对象分配了内存，在离开其作用域的时候又没将其释放，则会造成内存泄漏：\nvoid AutoPointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); o-\u0026gt;Print(); } $ ./bin/smart-pointer Object::Constructor 0x7b7058 # o 1 为了解决这个问题，C++ 98 在标准中增加了最原始的智能指针 std::auto_ptr，它利用 RAII 的机制提供了自动内存管理的功能，即利用栈上对象来管理堆上内存，当智能指针对象离开其作用域时，默认在其析构函数中释放其管理的堆上变量；它能够在一定程度上减少内存泄露的发生，以下是参考 GCC 中的 std::auto_ptr 实现的 AutoPointer 类，做了一定程度的简化，增加了一些输出方便追踪资源分配过程：\ntemplate\u0026lt;typename T\u0026gt; class AutoPointer { public: // constructor explicit AutoPointer(T* t = nullptr) noexcept : ptr_(t) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // copy-ctor AutoPointer(AutoPointer\u0026lt;T\u0026gt;\u0026amp; other) noexcept : ptr_(other.Release()) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer::Copyctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // assignment operator AutoPointer\u0026lt;T\u0026gt;\u0026amp; operator=(AutoPointer\u0026lt;T\u0026gt;\u0026amp; other) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer::Assignment \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; Reset(other.Release()); return *this; } // destructor ~AutoPointer() noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; delete ptr_; } T\u0026amp; operator*() noexcept { return *ptr_; } T* operator-\u0026gt;() const noexcept { return ptr_; } T* Get() const noexcept { return ptr_; } T* Release() noexcept { T* ptr_ret = ptr_; ptr_ = nullptr; return ptr_ret; } void Reset(T* ptr_para) noexcept { if (ptr_ != ptr_para) { delete ptr_; ptr_ = ptr_para; } } private: T *ptr_; }; 在初始化时，我们需要手动在堆上分配一个对象，并将其作为参数传入；接下来就可以将智能指针对象当作普通的指针使用了，同时也并不需要关心其生命周期，并能够用使用普通指针的方法来使用智能指针：\nvoid AutoPointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; a(o); (*o).Set(2); (*o).Print(); o-\u0026gt;Set(3); o-\u0026gt;Print(); } $ ./bin/smart-pointer Object::Constructor 0x48f058 # o AutoPointer::Constructor 0xbee47668 # a 2 3 AutoPointer::Destructor 0xbee47668 # a Object::Destructor 0x48f058 # o 类中最重要的两个函数是 Release 和 Reset，前者用来解除对象当前所管理的指针对象并返回，后者会释放对象当前所管理的指针对象，并将传入的指针对象置为新的管理对象，两者搭配起来实现了拷贝构造函数和赋值操作符；而这两个函数的存在则带来了第一个问题，即在进行拷贝构造或者赋值操作的时候，被操作的 AutoPointer 对象可能在无意识的情况下失去对其自身所管理对象的所有权，从而可能造成 segmentation fault：\nvoid Foo() { AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; p1(new Object\u0026lt;int\u0026gt;(6)); AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; p2(p1); cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34;; p2-\u0026gt;Print(); cout \u0026lt;\u0026lt; \u0026#34;p1: \u0026#34;; p1-\u0026gt;Print(); } $ ./bin/smart-pointer Object::Constructor 0x1cbd058 # o AutoPointer::Constructor 0xbed23668 # a1 AutoPointer::Copyctor 0xbed23664 # a2 a2: 1 Segmentation fault 第二个问题是 AutoPointer 默认只会使用 delete 来进行删除操作，如果一个 AutoPointer 对象管理了一个数组，则会在离开其作用域时发生内存泄漏，开启 AddressSanitizer 可以检查到：\nvoid AutoPointerFoo() { int *a = new int[1000000]; AutoPointer\u0026lt;int\u0026gt; p(a); } $ ./bin/smart-pointer AutoPointer::Constructor 0xbe9955e0 # new[] AutoPointer::Destructor 0xbe9955e0 # delete ================================================================= ==2543==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new [] vs operator delete) on 0xb412e800 # ... 除此之外，如果使用同一个 Object 指针对多个 AutoPointer 对象进行初始化，那么这个 Object 对象会被多次 delete，在运行时造成 double free 的报错：\nvoid AutoPointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; a1(o); AutoPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; a2(o); } $ ./bin/smart-pointer Object::Constructor 0x9c3058 # o AutoPointer::Constructor 0xbee80668 # a1 AutoPointer::Constructor 0xbee80664 # a2 AutoPointer::Destructor 0xbee80664 # a2 Object::Destructor 0x9c3058 # o AutoPointer::Destructor 0xbee80668 # a1 Object::Destructor 0x9c3058 # o free(): double free detected in tcache 2 Aborted 2 unique_ptr 为了解决 std::auto_ptr 中出现的问题，C++ 11 参考了 boost::unique_ptr 的设计，向标准库中引入了 std::unique_ptr，下面是参考其实现的 UniquePointer 模板类，做了相当程度的简化：\ntemplate\u0026lt;typename ElementType, typename DeleterType = DefaultDeleter\u0026gt; class UniquePointer { public: // constructors UniquePointer() noexcept : ptr_(nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } explicit UniquePointer(ElementType* p) noexcept : ptr_(p) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } UniquePointer(ElementType* p, DeleterType d) noexcept : ptr_(p), deleter_(d) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // move-ctor UniquePointer(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp;\u0026amp; other) noexcept : ptr_(other.Release()), deleter_(std::move(other.deleter_)) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Move-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // move assignment operator UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; operator=(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp;\u0026amp; other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::MoveAssignment \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; ptr_ = other.Release(); deleter_ = std::move(other.deleter_); return *this; } // copy-ctor UniquePointer(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; other) noexcept = delete; // assignment operator UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; operator=(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; other) = delete; // destructor ~UniquePointer() noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; if (ptr_) { GetDeleter()(ptr_); ptr_ = nullptr; } } ElementType\u0026amp; operator*() noexcept { return *ptr_; } ElementType* operator-\u0026gt;() const noexcept { return ptr_; } ElementType* Get() const noexcept { return ptr_; } const DeleterType\u0026amp; GetDeleter() const noexcept { return deleter_; } ElementType* Release() noexcept { ElementType* ret = nullptr; std::swap(ptr_, ret); return ret; } void Reset(ElementType* p) noexcept { if (ptr_ != p) { delete ptr_; ptr_ = p; } } private: ElementType* ptr_; DeleterType deleter_; }; 相较于 AutoPointer，UniquePointer 做出的改变主要有两点：第一点是 UniquePointer 对其管理的指针拥有独占所有权，通过禁用拷贝构造和赋值操作的方式防止了所有权转移的发生：\nvoid UniquePointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u1(o); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u2{ u1 }; // error: use of deleted function ‘UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;::UniquePointer(UniquePointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp;) [with ElementType = Object\u0026lt;int\u0026gt;; DeleterType = DefaultDeleter]’ } 同时又增加了移动构造和移动赋值操作，通过 move 语义来让我们可以在特定情况下显式地转移指针：\nvoid UniquePointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u1(o); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u2(std::move(u1)); UniquePointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; u3; u3 = std::move(u2); } $ ./bin/smart-pointer Object::Constructor 0x3af058\t# o UniquePointer::Constructor 0xbec29664\t# u1 UniquePointer::Move-ctor 0xbec2965c\t# u2 UniquePointer::Constructor 0xbec29654\t# u3 UniquePointer::MoveAssignment 0xbec29654\t# u3 UniquePointer::Destructor 0xbec29654\t# u3 Object::Destructor 0x3af058\t# o UniquePointer::Destructor 0xbec2965c\t# u2 UniquePointer::Destructor 0xbec29664\t# u1 第二点是在模板参数中增加了自定义删除器，删除器是一个 functor，我们可以在其 operator() 操作符中自定义 UniquePointer 在析构时对其管理的指针进行的操作，例如使用 delete[] 来释放内存，或是关闭相关的 Socket 等：\nstruct ArrayDeleter { template\u0026lt;typename T\u0026gt; void operator()(T* p) const { static_assert(sizeof(p) \u0026gt; 0, \u0026#34;can\u0026#39;t delete pointer to incomplete type\u0026#34;); delete[] p; } }; void UniquePointerFoo() { int* int_arr = new int[1000000]; ArrayDeleter array_deleter; UniquePointer\u0026lt;int, ArrayDeleter\u0026gt; u(int_arr, array_deleter); } $ ./bin/smart-pointer UniquePointer::Constructor 0xbe9ad660 UniquePointer::Destructor 0xbe9ad660 正因为 UniquePointer 对资源具有独占所有权，不能同时有多个 UniquePointer 拥有相同的资源，因此 AutoPointer 中的第三个问题并不能通过使用 UniquePointer 来解决。\n3 shared_ptr std::shared_ptr 的应用场景在于当我们需要让多个智能指针对象同时拥有同一个指针，而又希望在这些对象都退出其作用域的时候去销毁指针。它使用了一个引用计数器来记录指针在同一时间被几个智能指针对象所共享，当这个引用计数减少为 0 时，说明已经不再有对象拥有这个指针，此时则需要进行资源的销毁。\n// A smart pointer with reference-counted copy semantics. The // object pointed to is deleted when the last shared_ptr pointing to // it is destroyed or reset. template\u0026lt;typename _Tp, _Lock_policy _Lp\u0026gt; class __shared_ptr // ... 由 std::shared_ptr 管理的指针对象（以及引用计数器）存放在堆上，如果在同一时间有两个持有相同资源但位于不同线程中的智能指针同时访问他们所持有的资源，则可能会导致线程安全问题，因此我们还需要使用一定的机制来防止线程安全问题的发生；一般来说对引用计数器的加减修改是原子的，但对于共享资源的访问则需要使用互斥锁等机制保证线程安全。\n以下是参考 std::shared_ptr 实现的 SharedPointer 类：\ntemplate\u0026lt;typename ElementType, typename DeleterType = DefaultDeleter\u0026gt; class SharedPointer { public: // constructors SharedPointer() noexcept : ptr_(nullptr), ref_count_(nullptr), deleter_(nullptr), mutex_(nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } explicit SharedPointer(ElementType* p) noexcept : ptr_(p), ref_count_(new int(1)), deleter_(new DeleterType()), mutex_(new mutex()) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } SharedPointer(ElementType* p, DeleterType *d) noexcept : ptr_(p), ref_count_(new int(1)), deleter_(d), mutex_(new mutex()) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } explicit SharedPointer(const WeakPointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; wp) noexcept : ptr_(wp.ptr_), ref_count_(wp.ref_count_), deleter_(wp.deleter_), mutex_(wp.mutex_) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; IncreaseReferenceCount(); } // copy-ctor SharedPointer(const SharedPointer\u0026lt;ElementType\u0026gt;\u0026amp; other) noexcept : ptr_(other.ptr_), ref_count_(other.ref_count_), deleter_(other.deleter_), mutex_(other.mutex_) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Copy-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; IncreaseReferenceCount(); } // assignment operator SharedPointer\u0026amp; operator=(SharedPointer\u0026lt;ElementType\u0026gt;\u0026amp; other) { if (ptr_ != other.ptr_) { Release(); ptr_ = other.ptr_; ref_count_ = other.ref_count_; mutex_ = other.mutex_; deleter_ = other.deleter_; IncreaseReferenceCount(); } return *this; } // destructor ~SharedPointer() noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; Release(); } void Swap(SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; other) { std::swap(ptr_, other.ptr_); std::swap(ref_count_, other.ref_count_); std::swap(deleter_, other.deleter_); std::swap(mutex_, other.mutex_); } void Reset() { SharedPointer().Swap(*this); } void Reset(ElementType* p, DeleterType* d = nullptr) { SharedPointer(p, d).Swap(*this); } int UseCount() { return ref_count_ ? *ref_count_ : 0; } ElementType\u0026amp; operator*() noexcept { return *ptr_; } ElementType* operator-\u0026gt;() const noexcept { return ptr_; } ElementType* Get() const noexcept { return ptr_; } const DeleterType\u0026amp; GetDeleter() const noexcept { return *deleter_; } void Release() { if (!ptr_) return; bool delete_flag = false; mutex_-\u0026gt;lock(); if (--(*ref_count_) == 0) { GetDeleter()(ptr_); delete ref_count_; delete deleter_; delete_flag = true; } mutex_-\u0026gt;unlock(); if (delete_flag) { delete mutex_; } } void IncreaseReferenceCount() { if (!ptr_) return; mutex_-\u0026gt;lock(); ++(*ref_count_); mutex_-\u0026gt;unlock(); } ElementType* ptr_; int *ref_count_; DeleterType* deleter_; mutex* mutex_; }; 现在可以正确地让一个指针被多个智能指针对象所持有了：\nvoid SharedPointerFoo() { Object\u0026lt;int\u0026gt;* o = new Object\u0026lt;int\u0026gt;(1); SharedPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; s1(o); SharedPointer\u0026lt;Object\u0026lt;int\u0026gt;\u0026gt; s2(s1); s1.Reset(nullptr); s2.Reset(nullptr); } $ ./bin/smart-pointer Object::Constructor 0x1ac7058 # o1 SharedPointer::Constructor 0xbe89c65c # p1 SharedPointer::Copy-ctor 0xbe89c64c # p2 SharedPointer::Constructor 0xbe89c630 # p1.Reset SharedPointer::Destructor 0xbe89c630 # p1.Reset SharedPointer::Constructor 0xbe89c630 # p2.Reset SharedPointer::Destructor 0xbe89c630 # p2.Reset Object::Destructor 0x1ac7058 # o1 SharedPointer::Destructor 0xbe89c64c # p2 SharedPointer::Destructor 0xbe89c65c # p1 但又出现了循环引用的问题，例如：\nvoid SharedPointerFoo() { struct Node { int i_; SharedPointer\u0026lt;Node\u0026gt; prev_; SharedPointer\u0026lt;Node\u0026gt; next_; Node(int i) : i_(i) { std::cout \u0026lt;\u0026lt; \u0026#34;Node::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } ~Node() { std::cout \u0026lt;\u0026lt; \u0026#34;Node::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } }; Node *n1 = new Node(1), *n2 = new Node(2); SharedPointer\u0026lt;Node\u0026gt; s1(n1), s2(n2); cout \u0026lt;\u0026lt; s1.UseCount() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s2.UseCount() \u0026lt;\u0026lt; endl; s1-\u0026gt;next_ = s2; s2-\u0026gt;prev_ = s1; cout \u0026lt;\u0026lt; s1.UseCount() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s2.UseCount() \u0026lt;\u0026lt; endl; } $ ./bin/smart-pointer SharedPointer::Constructor 0x3f905c # n1-\u0026gt;prev_ SharedPointer::Constructor 0x3f906c # n1-\u0026gt;next_ Node::Constructor 0x3f9058 # n1 SharedPointer::Constructor 0x3f948c # n2-\u0026gt;prev_ SharedPointer::Constructor 0x3f949c # n2-\u0026gt;next_ Node::Constructor 0x3f9488 # n2 SharedPointer::Constructor 0xbeca0658 # s1 SharedPointer::Constructor 0xbeca0648 # s2 1 1 2 2 SharedPointer::Destructor 0xbeca0648 # s2 SharedPointer::Destructor 0xbeca0658 # s1 这里虽然 s1 和 s2 两个 SharedPointer\u0026lt;Node\u0026gt; 在函数退出时被成功地销毁了，但它们所持有的 n1 和 n2 两个对象却没有，因为 s1 和 s2 的引用计数都没有减少为 0，只有当 s1-\u0026gt;next_ 不再指向 s2，且 s2-\u0026gt;prev_ 不再指向 s1 时，两者的引用计数才能够正确的减少为 0。\n4 weak_ptr std::weak_ptr 是一种弱引用智能指针，它和 std::shared_ptr 的唯一区别是它必须由 std::shared_ptr 或 std::weak_ptr 显式转换而来，而不能由使用 new 创建的对象进行构造，因此其管理的资源实际上是被另一个 std::shared_ptr 所持有的，而其本身则只是提供了对被管理资源的访问能力，同时也不对被管理资源的生命周期造成影响，即不会修改 std::shared_ptr 的引用计数。\n下面是参考 std::weak_ptr 实现的 WeakPointer 类：\ntemplate\u0026lt;typename ElementType, typename DeleterType\u0026gt; class SharedPointer; template\u0026lt;typename ElementType, typename DeleterType = DefaultDeleter\u0026gt; class WeakPointer { public: // constructors WeakPointer() noexcept : ptr_(nullptr), ref_count_(nullptr), deleter_(nullptr), mutex_(nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;WeakPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } explicit WeakPointer(SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; sp) noexcept : ptr_(sp.ptr_), ref_count_(sp.ref_count_), deleter_(sp.deleter_), mutex_(sp.mutex_) { std::cout \u0026lt;\u0026lt; \u0026#34;WeakPointer::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // copy-ctor WeakPointer(WeakPointer\u0026lt;ElementType\u0026gt;\u0026amp; other) noexcept : ptr_(other.ptr_), ref_count_(other.ref_count_), deleter_(other.deleter_), mutex_(other.mutex_) { std::cout \u0026lt;\u0026lt; \u0026#34;WeakPointer::Copy-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } // assignment operator WeakPointer\u0026amp; operator=(SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;\u0026amp; sp) { ptr_ = sp.ptr_; ref_count_ = sp.ref_count_; mutex_ = sp.mutex_; deleter_ = sp.deleter_; return *this; } // destructor ~WeakPointer() noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;WeakPointer::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } void Swap(WeakPointer\u0026amp; other) { std::swap(ptr_, other.ptr_); std::swap(ref_count_, other.ref_count_); std::swap(deleter_, other.deleter_); std::swap(mutex_, other.mutex_); } void Reset() { WeakPointer().Swap(*this); } SharedPointer\u0026lt;ElementType, DeleterType\u0026gt; Lock() const { return Expired() ? SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;() : SharedPointer\u0026lt;ElementType, DeleterType\u0026gt;(*this); } int UseCount() { return *ref_count_; } const DeleterType\u0026amp; GetDeleter() const noexcept { return *deleter_; } bool Expired() const { return *ref_count_ == 0; } ElementType* ptr_; int *ref_count_; DeleterType* deleter_; mutex* mutex_; }; std::weak_ptr 不能控制被管理资源的生命周期，因此我们在使用的时候需要先判断被管理资源是否存在，我们可以借助 std::weak_ptr::lock 获取一个新的 std::shared_ptr 对象以达到安全访问资源的目的：\nvoid WeakPointerFoo() { Object\u0026lt;string\u0026gt; *o = new Object\u0026lt;string\u0026gt;(\u0026#34;test\u0026#34;); SharedPointer\u0026lt;Object\u0026lt;string\u0026gt;\u0026gt; s(o); WeakPointer\u0026lt;Object\u0026lt;string\u0026gt;\u0026gt; w(s); s.Reset(); auto p = w.Lock().Get(); cout \u0026lt;\u0026lt; w.Expired() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; static_cast\u0026lt;void*\u0026gt;(p) \u0026lt;\u0026lt; endl; } $ ./bin/smart-pointer Object::Constructor 0xf8c058 # o SharedPointer::Constructor 0xbe97a630 # s WeakPointer::Constructor 0xbe97a620 # w SharedPointer::Constructor 0xbe97a608 # temporary variable in s.Reset() SharedPointer::Destructor 0xbe97a608 # temporary variable in s.Reset() Object::Destructor 0xf8c058 # o SharedPointer::Constructor 0xbe97a65c # temporary variable in w.Lock() SharedPointer::Destructor 0xbe97a65c # temporary variable in w.Lock() 1 # w.Expired() 0 # p WeakPointer::Destructor 0xbe97a620 # w SharedPointer::Destructor 0xbe97a630 # s 如果把上面的 s.Reset() 去掉，那么 w.Lock() 则会返回一个包含有 Object\u0026lt;string\u0026gt; 对象的 SharedPointer，上面的 *o 也不会在 s.Reset() 之后析构掉：\nvoid WeakPointerFoo() { Object\u0026lt;string\u0026gt; *o = new Object\u0026lt;string\u0026gt;(\u0026#34;test\u0026#34;); SharedPointer\u0026lt;Object\u0026lt;string\u0026gt;\u0026gt; s(o); WeakPointer\u0026lt;Object\u0026lt;string\u0026gt;\u0026gt; w(s); // s.Reset(); auto p = w.Lock().Get(); cout \u0026lt;\u0026lt; w.Expired() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; static_cast\u0026lt;void*\u0026gt;(p) \u0026lt;\u0026lt; endl; } $ ./bin/smart-pointer Object::Constructor 0xb5c058 # o SharedPointer::Constructor 0xbef4562c # s WeakPointer::Constructor 0xbef4561c # w SharedPointer::Constructor 0xbef45658 # temporary variable in s.Reset() SharedPointer::Destructor 0xbef45658 # temporary variable in s.Reset() 0 # w.Expired() 0xb5c058 # p WeakPointer::Destructor 0xbef4561c # temporary variable in w.Lock() SharedPointer::Destructor 0xbef4562c # # temporary variable in w.Lock() Object::Destructor 0xb5c058 # o 对于循环引用的问题，将需要互相指向的智能指针改为 WeakPointer 则可以成功避免指针对象不能正常析构的问题：\nvoid WeakPointerFoo() { struct Node { int i_; WeakPointer\u0026lt;Node\u0026gt; prev_; WeakPointer\u0026lt;Node\u0026gt; next_; Node(int i) : i_(i) { std::cout \u0026lt;\u0026lt; \u0026#34;Node::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } ~Node() { std::cout \u0026lt;\u0026lt; \u0026#34;Node::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; std::endl; } }; Node *n1 = new Node(1), *n2 = new Node(2); SharedPointer\u0026lt;Node\u0026gt; p1(n1), p2(n2); cout \u0026lt;\u0026lt; p1.UseCount() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p2.UseCount() \u0026lt;\u0026lt; endl; p1-\u0026gt;next_ = p2; p2-\u0026gt;prev_ = p1; cout \u0026lt;\u0026lt; p1.UseCount() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p2.UseCount() \u0026lt;\u0026lt; endl; } $ ./bin/smart-pointer WeakPointer::Constructor 0xb505c # n1-\u0026gt;prev_ WeakPointer::Constructor 0xb506c # n1-\u0026gt;next_ Node::Constructor 0xb5058 # n1 WeakPointer::Constructor 0xb548c # n2-\u0026gt;prev_ WeakPointer::Constructor 0xb549c # n2-\u0026gt;next_ Node::Constructor 0xb5488 # n2 SharedPointer::Constructor 0xbe904658 # s1 SharedPointer::Constructor 0xbe904648 # s2 1 1 1 1 SharedPointer::Destructor 0xbe904648 # s2 Node::Destructor 0xb5488 # n2 WeakPointer::Destructor 0xb549c # n2-\u0026gt;next_ WeakPointer::Destructor 0xb548c # n2-\u0026gt;prev_ SharedPointer::Destructor 0xbe904658 # s1 Node::Destructor 0xb5058 # n1 WeakPointer::Destructor 0xb506c # n1-\u0026gt;next_ WeakPointer::Destructor 0xb505c # n1-\u0026gt;prev_ ","permalink":"https://prov1dence.top/posts/cpp/smart-pointer/smart-pointer/","summary":"\u003ch1 id=\"c-智能指针的简单实现\"\u003eC++ 智能指针的简单实现\u003c/h1\u003e\n\u003ch2 id=\"1-stdauto_ptr\"\u003e1 std::auto_ptr\u003c/h2\u003e\n\u003cp\u003eC++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 模板类：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eObject\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// constructor\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    Object() \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e t_() { cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Object::Constructor \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object(T t) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e t_(t) { cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Object::Constructor \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// copy-ctor\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    Object(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Object \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eother) { cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Object::Copy-ctor \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// destructor\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#f92672\"\u003e~\u003c/span\u003eObject() { cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Object::Destructor \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSet\u003c/span\u003e(T t) { t_ \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e t; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePrint\u003c/span\u003e() { cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e t_ \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    T t_;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果在堆上为类对象分配了内存，在离开其作用域的时候又没将其释放，则会造成内存泄漏：\u003c/p\u003e","title":"C++ 智能指针的简单实现"},{"content":"启发式搜索和强化学习 The Pac-Man Projects 是 UC Berkeley CS 188 的课程项目，本文以该项目为例介绍启发式搜索和强化学习。\n1 盲目搜索 盲目搜索（Blind Search）指不利用任何额外信息（输入数据，或辅助函数），只依赖于算法本身的搜索，例如 BFS，DFS，Dijkstra 等；\nDFS The Pac-Man Projects 已经实现了吃豆人游戏的后台逻辑和图形渲染框架，我们只需要在 search.py 文件中实现具体的搜索算法，并根据搜索算法生成寻路路径，即可让吃豆人移动，先来实现一个简单的 DFS：\ndef DepthFirstSearch(problem): from util import Stack open_list = Stack() visited = [] open_list.push((problem.getStartState(), [])) while not open_list.isEmpty(): current_node, path = open_list.pop() if problem.isGoalState(current_node): return path if current_node in visited: continue visited.append(current_node) for next_node, action, cost in problem.getSuccessors(current_node): if next_node not in visited: open_list.push((next_node, path + [action])) dfs = DepthFirstSearch 在吃豆人游戏的框架下，为寻路函数传入的 problem 参数可以理解为一个 class SearchProblem 类型的抽象基类，实际的问题有 PositionSearchProblem（找到单个终点），FoodSearchProblem（找到所有食物），CapsuleSearchProblem（找到增益药丸和所有食物）等，这些子类都需要实现以下函数：\ngetStartState()：获取起始状态； isGoalState(state)：判断 state 节点是否是目标节点； getSuccessors(statu)：获取 state 节点的所有后续节点； getCostOfActions(actions)：actions 是一个由上下左右方向组成的一个动作列表，函数返回这个列表的总花费（cost）； 运行一下看看 DFS 的效果：\n$ python pacman.py -l smallEmpty -z 0.8 -p SearchAgent -a fn=dfs [SearchAgent] using function dfs [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 56 in 0.002992 seconds Search nodes expanded: 56 Pacman emerges victorious! Score: 454 Average Score: 454.0 Scores: 454.0 Win Rate: 1/1 (1.00) Record: Win 运行的参数列表中有几个参数：\n-l smallEmpty：在名为 smallEmpty 的地图上运行，地图定义在 layouts 目录下； -z 0.8：客户端表现缩放为 0.8 倍 -p SearchAgent：指定实际的问题，这里的 SearchAgent 是 fn='depthFirstSearch', prob='PositionSearchProblem' 的缩写； 实际运行效果如下：\n可以看到吃豆人 agent 绕了很远的路才到达终点，因为 DFS 在计算复杂性理论中是不完备（complete）且非最优（optimality）的。\nBFS def BreadthFirstSearch(problem): from util import Queue open_list = Queue() visited = set() open_list.push((problem.getStartState(), [])) while not open_list.isEmpty(): current_node, path = open_list.pop() if problem.isGoalState(current_node): return path if current_node in visited: continue visited.add(current_node) for next_node, action, cost in problem.getSuccessors(current_node): if next_node not in visited: open_list.push((next_node, path + [action])) bfs = BreadthFirstSearch BFS 的运行效果如下：\n$ python pacman.py -l smallEmpty -z 0.8 -p SearchAgent -a fn=bfs [SearchAgent] using function bfs [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 14 in 0.001995 seconds Search nodes expanded: 63 Pacman emerges victorious! Score: 496 Average Score: 496.0 Scores: 496.0 Win Rate: 1/1 (1.00) Record: Win 可以看到使用 BFS 的 agent 通过最短路径到达了终点，因为 BFS 是完备且最优的。\nIterative Deepening Search IDS 的思路是重复进行限制层数的 DFS 来找到最优解，它综合了 DFS 的优点（空间复杂度）和 BFS 的优点（完备且最优），但是在时间复杂度上表现比较差（可以参考输出结果中的 Search nodes expanded）：\ndef IterativeDeepeningSearch(problem): import sys from util import Stack def depthLimitSearch(problem, depth): visited = [] open_list = Stack() open_list.push((problem.getStartState(), [], visited)) while not open_list.isEmpty(): current_node, path, visited = open_list.pop() if problem.isGoalState(current_node): return path if len(path) == depth or depth == 0: continue if current_node in visited: continue actions = problem.getSuccessors(current_node) for next_node, action, cost in actions: if next_node not in visited: open_list.push((next_node, path + [action], visited+[current_node])) for depth in range(sys.maxsize**10): path = depthLimitSearch(problem, depth) if path: return path ids = IterativeDeepeningSearch 这个算法对于只有小面积可搜索空间的地图效果比较好：\n$ python pacman.py -l smallMaze -z 0.8 -p SearchAgent -a fn=ids [SearchAgent] using function ids [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 19 in 0.008976 seconds Search nodes expanded: 923 Pacman emerges victorious! Score: 491 Average Score: 491.0 Scores: 491.0 Win Rate: 1/1 (1.00) Record: Win 但是对于拥有大面积可搜索空间的地图，搜索时间会非常长：\n$ python pacman.py -l smallEmpty -z 0.8 -p SearchAgent -a fn=ids [SearchAgent] using function ids [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 14 in 0.710854 seconds Search nodes expanded: 94552 Pacman emerges victorious! Score: 496 Average Score: 496.0 Scores: 496.0 Win Rate: 1/1 (1.00) Record: Win Uniform Cost Search UCS 和 Dijkstra 类似，用一个小根堆保存当前节点到起始节点的距离，依次展开路径花费最小的节点，直到找到终点为止，而一般来说 Dijkstra 没有一个固定的终点：\ndef UniformCostSearch(problem): from util import PriorityQueue frontier = PriorityQueue() visited = [] frontier.push((problem.getStartState(), [], 0), 0) while not frontier.isEmpty(): current_node, path, current_cost = frontier.pop() if problem.isGoalState(current_node): return path if current_node in visited: continue visited.append(current_node) for next_node, action, cost in problem.getSuccessors(current_node): if next_node not in visited: frontier.push((next_node, path + [action], current_cost + cost), current_cost + cost) ucs = UniformCostSearch $ python pacman.py -l smallEmpty -z 0.8 -p SearchAgent -a fn=ucs [SearchAgent] using function ucs [SearchAgent] using problem type PositionSearchProblem Path found with total cost of 14 in 0.002992 seconds Search nodes expanded: 63 Pacman emerges victorious! Score: 496 Average Score: 496.0 Scores: 496.0 Win Rate: 1/1 (1.00) Record: Win 2 启发式搜索 传统的盲目搜索算法因为受制于完备性、最优性、时间、空间复杂度等因素，在实际的应用中很少被使用；而在路径规划，最优化算法和人工智能领域，使用启发式搜索（Heuristic Search）能够更好地在准确性和计算速度之间取得平衡。\n启发式搜索 Heuristic Search 又叫做有信息搜索 Informed Search，启发式搜索不同于盲目搜索的地方有两点：一是启发式搜索依赖于启发函数，启发函数 Heuristic Function 是用于估计当前节点到目标节点距离的一类函数；二是它需要利用输入数据并将其作为启发函数的参数，以衡量当前位置到目标位置的距离关系。\n启发式搜索通过衡量当前位置到目标位置的距离关系，使得搜索过程的移动方向优先朝向目标位置更近的方向前进，以提高搜索效率。\n启发函数 启发函数 h(n) 用于给出从特定节点到目标节点的距离的估计值（而不是真实值）；许多寻路问题都是 NP 完备（NP-completeness）的，因此在最坏情况下它们的算法时间复杂度都是指数级的；找到一个好的启发函数可以更高效地得到一个更优的解；启发函数算法的优劣直接决定了启发式搜索的效率。\n最简单的启发函数有：\nnull heuristic：估计值始终等于 0，相当于退化成了 UCS（只计算当前节点到起始节点的距离）； 曼哈顿距离：两点在南北方向上的距离加上在东西方向上的距离，即 abs(a − x) + abs(b − y)； 欧几里得距离：两点在欧氏空间中的直线距离，即 sqrt((a - x) ^ 2 + (b - y) ^ 2)； A* A* 是一种应用很广泛的启发式搜索算法，其主要思路与 Dijkstra 和 UCS 类似，都是利用一个小根堆，不断地取出堆顶节点并判断其是否是目标节点，不同的是它会为每一个已知节点计算出从起点和终点的距离之和 f(x) = g(x) + h(x)，其中 g(x) 是从起点到当前节点的实际距离，h(x) 是使用启发函数计算得到的从当前节点到目标节点的估计距离：\ndef AStarSearch(problem, heuristic=nullHeuristic): from util import PriorityQueueWithFunction def AStarHeuristic(item): state, _, cost = item h = heuristic(state, problem=problem) g = cost return g + h frontier = PriorityQueueWithFunction(AStarHeuristic) visited = [] frontier.push((problem.getStartState(),[], 0)) while not frontier.isEmpty(): currentNode, path, currentCost = frontier.pop() if problem.isGoalState(currentNode): return path if currentNode not in visited: visited.append(currentNode) for nextNode, action, cost in problem.getSuccessors(currentNode): if nextNode not in visited: frontier.push((nextNode, path + [action], currentCost + cost)) astar = AStarSearch 对于多节点的搜索问题，需要综合考虑所有目标节点对于当前节点的影响；我们可以利用贪心的思想，让吃豆人优先靠近距离较近的豆子，也就是使得距离当前节点更近的目标节点的启发函数值更小，这样距离吃豆人更近的豆子就会更有可能具有更小的 f(x) 值；在为启发函数传入的参数中， state 是一个包含当前位置 position 和所有目标点信息结构 grid 的二元组，可以使用 grid.asList() 将所有目标点转换为一个数组：\ndef FoodHeuristic(state, problem): position, food_grid = state food_gridList = food_grid if isinstance(food_grid, list) else food_grid.asList() from util import manhattanDistance minx, miny = position maxx, maxy = position for food in food_gridList: foodx, foody = food minx = min(foodx,minx) maxx = max(foodx,maxx) miny = min(foody,miny) maxy = max(foody,maxy) return abs(minx-maxx) + abs(miny-maxy) $ python pacman.py -l tinySearch -p SearchAgent -a fn=astar,prob=FoodSearchProblem,heuristic=FoodHeuristic [SearchAgent] using function astar and heuristic foodHeuristic [SearchAgent] using problem type FoodSearchProblem Path found with total cost of 27 in 0.294214 seconds Search nodes expanded: 1544 Pacman emerges victorious! Score: 573 Average Score: 573.0 Scores: 573.0 Win Rate: 1/1 (1.00) Record: Win 换个地图看看效果：\n$ python pacman.py -l mediumDottedMaze -p SearchAgent -a fn=astar,prob=FoodSearchProblem,heuristic=FoodHeuristic [SearchAgent] using function astar and heuristic foodHeuristic [SearchAgent] using problem type FoodSearchProblem Path found with total cost of 74 in 0.091756 seconds Search nodes expanded: 389 Pacman emerges victorious! Score: 646 Average Score: 646.0 Scores: 646.0 Win Rate: 1/1 (1.00) Record: Win 相比之下，如果使用 nullHeuristic（退化为 UCS）的话搜索花费的时间则会长很多：\n$ python pacman.py -l tinySearch -p SearchAgent -a fn=ucs,prob=FoodSearchProblem [SearchAgent] using function ucs [SearchAgent] using problem type FoodSearchProblem Path found with total cost of 27 in 2.880744 seconds Search nodes expanded: 5057 Pacman emerges victorious! Score: 573 Average Score: 573.0 Scores: 573.0 Win Rate: 1/1 (1.00) Record: Win 3 强化学习 强化学习 强化学习是指通过与环境进行交互和反馈来学习一种策略的过程，在这个过程中，一个强化学习的实体 agent 通过与环境 Environment 进行交互并采取一系列行为 Action 来获得一定的收益 Reward，从而更新采取相应行为的权重。\n强化学习的目标是通过学习得到某个策略 Policy，使得 agent 从 environment 中获得的长期收益最大化，因此在一般的问题中，在没有达到最终的目的前，reward 通常都是负数（随时间的增加而减少），而仅在达到最终的目的时获得较大的正反馈，这样的学习任务通常称为 episodic task（例如吃豆人游戏中的单节点搜索问题）；在另一类问题中，可能需要完成多个目标才能到达最终状态，其 reward 离散地分布在一个连续的空间中，这一类任务称为 continuing task（例如吃豆人游戏中的多节点搜索问题），对于 continuing task，我们可以定义其 reward 为：\n其中 γ 是衰减率（discount factor），衰减率可以使得我们更加偏好近期收益；引入衰减系数的理由有很多，例如避免陷入无限循环，降低远期利益的不确定性，最大化近期利益，利用近期利益产生新的利益因而其更有价值等等。\n而强化学习的结果是就是 Gt，通过 argmax 取得的值能够给出在每个状态下我们应该采取的行动，我们可以把这个策略记做 π(a|s)，它表示在状态 s 下采取行动 a 的概率。\n马尔科夫决策过程 马尔科夫决策过程（Markov Decision Process, MDP）是指在每个状态下，agent 对于行动 a 的选取只依赖于当前的状态，与任何之前的行为都没有关系；几乎所有的强化学习问题都可以使用 MDP 解决，一个标准的马尔可夫决策过程由一个四元组组成：\nS：State，状态空间的集合，S0 表示初始状态； A：Action，行为空间的集合，包含每个状态可以进行的动作； r(s\u0026rsquo; | s, a)：Reward，在 s 状态下，进行 a 操作并转移到 s‘ 状态下的奖励； P(s\u0026rsquo; | s, a)：Probability，在 s 状态下，进行 a 操作并转移到 s‘ 状态下的概率； 求解 MDP 问题的常见方法有 Value iteration，Policy iteration，Q-Learning，Deep Q-Learning Network 等等。\nValue Iteration Value Iteration 是一种基于模型的（model-based）算法，使用 Value Iteration 来解决 MDP 问题的前提是我们知道关于模型的所有信息，即 MDP 四元组的所有内容。\n假设现在有一个 3*4 叫做 GridWorld 的地图如图所示，以左下角格子为 (0, 0) 原点，其中 (1, 1) 为不可通过的墙，(2, 3) 为奖励为 +1 的终点，(1, 3) 为 -1 的终点；我们定义每一个位置的价值为 V(state)，即对于 state(x, y)，V(state) 表示其能获取的最大价值；每一个位置初始化时其 value 均为 0：\n在迭代过程中，使用贝尔曼方程（Bellman Equation）更新所有位置的 value，它描述了最佳策略必须满足的条件，前半部分 r(s, a, s\u0026rsquo;) 代表采取了 a 行为之后得到的 reward，后半部分；我们需要在每轮迭代中计算每个状态的价值即 V(s)，直到两次迭代结果的差值小于给定的阈值才能认为其收敛了，这里的 V(s) 也叫做 q-value：\n经过前三次迭代分别得到：\n收敛速度是指数级，并且随着迭代的不断进行，终将得到最优的 V(s)；或者说当迭代次数趋近于无穷大的时候，将得到 V(s) 的最优解；经过 100 次迭代后将得到：\n取 argmax 即可得到最优的策略（即上图中的小箭头）；也可以看到采取每一种行动对应的 Probaility：\n进行 Value Iteration 的流程主要对应 runValueIteration 和 computeQValueFromValues 两个函数，迭代结束后选择策略则对应 computeActionFromValues 函数：\n# valueIterationAgents.py class ValueIterationAgent(ValueEstimationAgent): \u0026#34;\u0026#34;\u0026#34; A ValueIterationAgent takes a Markov decision process (see mdp.py) on initialization and runs value iteration for a given number of iterations using the supplied discount factor. \u0026#34;\u0026#34;\u0026#34; def __init__(self, mdp, discount = 0.9, iterations = 100): \u0026#34;\u0026#34;\u0026#34; Some useful mdp methods you will use: mdp.getStates() mdp.getPossibleActions(state) mdp.getTransitionStatesAndProbs(state, action) mdp.getReward(state, action, nextState) mdp.isTerminal(state) \u0026#34;\u0026#34;\u0026#34; self.mdp = mdp self.discount = discount self.iterations = iterations self.values = util.Counter() # A Counter is a dict with default 0 self.runValueIteration() def runValueIteration(self): for _ in np.arange(0, self.iterations): next_values = util.Counter() for state in self.mdp.getStates(): if self.mdp.isTerminal(state): continue q_values = util.Counter() for action in self.mdp.getPossibleActions(state): q_values[action] = self.computeQValueFromValues(state, action) key_max_value = q_values.argMax() next_values[state] = q_values[key_max_value] self.values = next_values def getValue(self, state): return self.values[state] def computeQValueFromValues(self, state, action): \u0026#34;\u0026#34;\u0026#34; Compute the Q-value of action in state from the value function stored in self.values. \u0026#34;\u0026#34;\u0026#34; next_states_probs = self.mdp.getTransitionStatesAndProbs(state, action) q_value = 0 for (next_state, next_state_prob) in next_states_probs: q_value += next_state_prob * (self.mdp.getReward(state, action, next_state) + self.discount * self.values[next_state]) return q_value def computeActionFromValues(self, state): \u0026#34;\u0026#34;\u0026#34; The policy is the best action in the given state according to the values currently stored in self.values. You may break ties any way you see fit. Note that if there are no legal actions, which is the case at the terminal state, you should return None. \u0026#34;\u0026#34;\u0026#34; if self.mdp.isTerminal(state): return None actions = self.mdp.getPossibleActions(state) values = util.Counter() for action in actions: values[action] = self.computeQValueFromValues(state, action) policy = values.argMax() return policy def getPolicy(self, state): return self.computeActionFromValues(state) def getAction(self, state): \u0026#34;Returns the policy at the state (no exploration).\u0026#34; return self.computeActionFromValues(state) def getQValue(self, state, action): return self.computeQValueFromValues(state, action) Q-Learning Q-Learning 的思路与 Value Iteration 有一些类似，但它是一种模型无关的（model-free）算法，使用 Q-Learning 的时候我们的 agent 无需事先知道当前环境中的 State，Action 等 MDP 四元组内容，\n在使用 Value Ietration 的时候，我们需要在每一个 episode 对所有的 State 和 Action 进行更新，但在实际问题中 State 的数量可能非常多以致于我们不可能遍历完所有的状态，这时候我们可以借助 Q-Learning，在对于环境未知的前提下，不断地与环境进行交互和探索，计算出有限的环境样本中 Q-Value，并维护一个 Q-Table：\nS r(s\u0026rsquo; | s, action 1) r(s\u0026rsquo; | s, action 2) \u0026hellip; S1 (0, 0) 3 -1 S2 (0, 1) -2 4 \u0026hellip; 在刚开始时，agent 对于环境一无所知，因此 Q-Table 应该被初始化为一个零矩阵；当我们处于某个状态 s （例如表里的 S1）时，根据 Q-Table 中当前的最优值和一定的策略（Multi-armed bandit 问题，利用 ε-greedy，UCB 等解决）选择对应的动作 a （假设选择了表里的 action 1，对应 r = 3）进行探索，并根据获得的即时奖励 r 来更新奖励，这里的 r 只是即时获得的奖励（r = 3），因为还要考虑所转移到的状态 s\u0026rsquo; （表里的 S2）在未来可能会获取到的最大奖励（r\u0026rsquo; = 4）；\n真正的奖励 Q(St, At) 由公式中的两部分组成，前半部分 r 是通过动作 a 即时获得的奖励（r = 3），后半部分 γ * max(a\u0026rsquo;)Q(s\u0026rsquo;, a\u0026rsquo;) 是对未来行为的最大期望奖励（r\u0026rsquo; = 4），且后半部分往往是不确定的，因此需要乘以衰减率 γ：\n在通过计算得到当前行为所能获得的预期奖励后，将其减去表中对当前环境的估计奖励 Q(s,a)（r = 3），再乘以学习率，就能用来更新 Q-Table 中的值了。\nagent 不断地与环境进行探索并发生状态转换，直到到达目标；我们将 agent 的每一轮探索（从任意起始状态出发，经历若干个 action，直到到达目标状态）称为一个 episode；在进行指定 episode 次数的训练之后，取 argmax 得到的策略就是当前的最优解。\n现在利用 epsilon-greedy 作为探索策略，训练 10 个 episode：\n$ python gridworld.py -a q -k 10 --noise 0.0 -e 0.9 得到结果之后，对每一个状态 s 的所有动作 a 取 argmax 即可得到在当前 epsilon 值和 episode 值下的最优解：\nQ-Learning 的实现大致如下：\nclass QLearningAgent(ReinforcementAgent): def __init__(self, **args): ReinforcementAgent.__init__(self, **args) self.q_values = defaultdict(lambda: 0.0) def getQValue(self, state, action): \u0026#34;\u0026#34;\u0026#34; Returns Q(state,action) Should return 0.0 if we have never seen a state or the Q node value otherwise \u0026#34;\u0026#34;\u0026#34; return self.q_values[(state, action)] def computeValueFromQValues(self, state): \u0026#34;\u0026#34;\u0026#34; Returns max_action Q(state,action) where the max is over legal actions. Note that if there are no legal actions, which is the case at the terminal state, you should return a value of 0.0. \u0026#34;\u0026#34;\u0026#34; next_actions = self.getLegalActions(state) if not next_actions: return 0.0 else: q_value_actions = [(self.getQValue(state, action), action) for action in next_actions] # return the max in q_value_actions which is q_value return sorted(q_value_actions, key=lambda x: x[0])[-1][0] def computeActionFromQValues(self, state): \u0026#34;\u0026#34;\u0026#34; Compute the best action to take in a state. Note that if there are no legal actions, which is the case at the terminal state, you should return None. \u0026#34;\u0026#34;\u0026#34; next_actions = self.getLegalActions(state) if not next_actions: return None else: actions = [] max_q_value = self.getQValue(state, next_actions[0]) # find actions with max q value for action in next_actions: action_q_value = self.getQValue(state, action) if max_q_value \u0026lt; action_q_value: max_q_value = action_q_value actions = [action] elif max_q_value == action_q_value: actions.append(action) # break ties randomly for better behavior. The random.choice() function will help. return random.choice(actions) def getAction(self, state): \u0026#34;\u0026#34;\u0026#34; Compute the action to take in the current state. With probability self.epsilon, we should take a random action and take the best policy action otherwise. Note that if there are no legal actions, which is the case at the terminal state, you should choose None as the action. \u0026#34;\u0026#34;\u0026#34; # Pick Action legalActions = self.getLegalActions(state) action = None if legalActions: if util.flipCoin(self.epsilon): return random.choice(legalActions) else: action = self.getPolicy(state) return action def update(self, state, action, nextState, reward): \u0026#34;\u0026#34;\u0026#34; The parent class calls this to observe a state = action =\u0026gt; nextState and reward transition. You should do your Q-Value update here NOTE: You should never call this function, it will be called on your behalf \u0026#34;\u0026#34;\u0026#34; state_action_q_value = self.getQValue(state, action) self.q_values[(state, action)] = state_action_q_value + self.alpha * (reward + self.discount * self.getValue(nextState) - state_action_q_value) def getPolicy(self, state): return self.computeActionFromQValues(sta、te) def getValue(self, state): return self.computeValueFromQValues(state) DQN Q-Learning 依赖于 Q-Table，其存在的问题是当 Q-Table 中的状态非常多，或状态的维度非常多的时候，内存可能无法存储所有的状态，此时我们可以利用神经网络来拟合整个 Q-Table，即使用 Deep Q-Learning Network。DQN 主要用来解决拥有近乎无限的 State，但 Action 有限的问题，它将当前 State 作为输入，输出各个 Action 的 Q-Value。\n启发式搜索和强化学习的对比 ","permalink":"https://prov1dence.top/posts/reinforcement-learning/heuristic-search-and-reinforcement-learning/","summary":"\u003ch1 id=\"启发式搜索和强化学习\"\u003e启发式搜索和强化学习\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://inst.eecs.berkeley.edu/~cs188/fa18/projects.html\"\u003eThe Pac-Man Projects\u003c/a\u003e 是 UC Berkeley CS 188 的课程项目，本文以该项目为例介绍启发式搜索和强化学习。\u003c/p\u003e\n\u003ch2 id=\"1-盲目搜索\"\u003e1 盲目搜索\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e盲目搜索\u003c/strong\u003e（Blind Search）指不利用任何额外信息（输入数据，或辅助函数），只依赖于算法本身的搜索，例如 BFS，DFS，Dijkstra 等；\u003c/p\u003e\n\u003ch3 id=\"dfs\"\u003eDFS\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eThe Pac-Man Projects \u003c/code\u003e 已经实现了吃豆人游戏的后台逻辑和图形渲染框架，我们只需要在 \u003ccode\u003esearch.py\u003c/code\u003e 文件中实现具体的搜索算法，并根据搜索算法生成寻路路径，即可让吃豆人移动，先来实现一个简单的 DFS：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDepthFirstSearch\u003c/span\u003e(problem):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e util \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e Stack\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    open_list \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Stack()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    visited \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e []\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    open_list\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epush((problem\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003egetStartState(), []))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003enot\u003c/span\u003e open_list\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eisEmpty():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        current_node, path \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e open_list\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epop()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e problem\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eisGoalState(current_node):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e path\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e current_node \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e visited:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        visited\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eappend(current_node)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e next_node, action, cost \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e problem\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003egetSuccessors(current_node):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e next_node \u003cspan style=\"color:#f92672\"\u003enot\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e visited:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                open_list\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epush((next_node, path \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e [action]))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edfs \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e DepthFirstSearch\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在吃豆人游戏的框架下，为寻路函数传入的 \u003ccode\u003eproblem\u003c/code\u003e 参数可以理解为一个 \u003ccode\u003eclass SearchProblem\u003c/code\u003e 类型的抽象基类，实际的问题有 \u003ccode\u003ePositionSearchProblem\u003c/code\u003e（找到单个终点），\u003ccode\u003eFoodSearchProblem\u003c/code\u003e（找到所有食物），\u003ccode\u003eCapsuleSearchProblem\u003c/code\u003e（找到增益药丸和所有食物）等，这些子类都需要实现以下函数：\u003c/p\u003e","title":"启发式搜索和强化学习"},{"content":"C++ 闭包和匿名函数 本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。\n1 闭包和仿函数 闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 \u0026ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.\u0026quot;，其中有两层含义：\n词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈； 函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数； 显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：\nclass Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout \u0026lt;\u0026lt; adder(1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(3) \u0026lt;\u0026lt; endl; } $ g++ -std=c++98 -o adder adder.cpp $ ./adder 1 3 6 相比之下 golang 中真正的闭包显得简洁很多：\nfunc adder() func(int) int { sum := 0 return func(num int) int { sum += num return sum } } func main() { numAdder := adder() fmt.Println(numAdder(1)) fmt.Println(numAdder(2)) fmt.Println(numAdder(3)) } $ go run main.go 1 3 6 C++ 98 的标准库中提供了很多实用的函数，例如 std::sort，当我们需要定制其排序规则的时候，也可以定义一个简单的仿函数（或者普通的函数）作为参数传入 ，注意定义排序规则的时候要满足 Strict Weak Ordering：\nstruct Foo { int a_, b_; Foo(int a, int b) : a_(a), b_(b) {} }; struct FooComparatorGreater { bool operator()(const Foo f1, const Foo f2) { if (f1.a_ != f2.a_) return f1.a_ \u0026gt; f2.a_; return f1.b_ \u0026gt; f2.b_; } }; int main() { vector\u0026lt;Foo\u0026gt; foo{ Foo(3, 6), Foo(9, 2), Foo(9, 8) }; sort(foo.begin(), foo.end(), FooComparatorGreater()); for (const auto\u0026amp; f : foo) cout \u0026lt;\u0026lt; f.a_ \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; f.b_ \u0026lt;\u0026lt; endl; return 0; } $ g++ -std=c++11 -o sort-functor sort-functor.cpp $ ./sort-functor 9 8 9 2 3 6 2 匿名函数 匿名函数（Anonymous Function）起源于第一个函数式编程语言 Lisp，C++ 11 标准中正式引入了匿名函数，也叫做 lambda 表达式（Lambda Expression）；匿名函数是一种没有被绑定标识符的函数，可以用于很方便地定义一个临时的函数对象，或作为一个函数对象传递给更上层的函数（例如 std::for_each），其在 C++ 11 的语法上表现得非常轻量级，不需要像普通的具名函数一样单独在头文件中作出声明，且符合闭包的定义。\n匿名函数可以替代掉复杂且冗余的仿函数，使得代码更易于理解和维护：\nsort(foo.begin(), foo.end(), [](const Foo\u0026amp; f1, const Foo\u0026amp; f2) { return f1.a_ != f2.a_ ? f1.a_ \u0026gt; f2.a_ : f1.b_ \u0026gt; f2.b_; }); 匿名函数由以下几个部分组成，其中只有 1, 2, 6 三个部分是必须的，其余部分可以省略：\n捕获子句 capture clause / lambda introducer 参数列表 parameter list / lambda declarator 可变规格 mutable specification 被 mutable 修饰的匿名函数可以修改按值捕获的变量 异常规格 exception specification 尾随返回类型 trailing-return-type 匿名函数体 lambda body 2.1 捕获子句 捕获子句用于捕获外部变量，使得匿名函数体可以使用这些变量，捕获的方法分为引用捕获和值（拷贝）捕获两种，使用方法如下：\n[] 不捕获任何变量；\n[\u0026amp;] 按引用捕获所有外部变量；\n[=] 按值捕获所有外部变量\n[\u0026amp;, var] 默认按引用捕获，仅按值捕获 var；\n[=, \u0026amp;var] 默认按值捕获，仅按引用捕获 var；\n[y, y] 重复按值捕获同一个变量，没有意义，会报 warning；\n[\u0026amp;, \u0026amp;var] 默认按引用捕获，并按引用捕获 var，没有意义，会报 warning；\n[=, this] 默认按值捕获，并按值捕获 this 指针，没有意义，同样会报 warning；\nstd::function\u0026lt;void()\u0026gt; AnonyFunc = [=, this]() -\u0026gt; void {};// warning: explicit by-copy capture of ‘this’ redundant with by-copy capture default [this] 按值捕获 this 指针，this 指针虽然不能被修改，但其指向的对象可以被操作并修改，相当于按引用捕获了 this 指向的对象，即 [\u0026amp;(*this)]；\nclass Foo { public: void Func() { int y{ 0 }; std::function\u0026lt;void()\u0026gt; AnonyFunc = [this]() -\u0026gt; void { x_ = 2; // ok，x_ 是类的成员变量，可以被修改 y = 2; // error: ‘y’ is not captured，函数的局部变量并没有被捕获 this = nullptr; // error: lvalue required as left operand of assignment，这里捕获的 this 指针是一个临时变量即右值，不能被修改 }; AnonyFunc(); } private: int x_ = 0; }; [*this] 在 C++ 11 中不能按值捕获 this 指针指向的对象；\nstd::function\u0026lt;void()\u0026gt; AnonyFunc = [*this]() -\u0026gt; void {}; // error: expected identifier before ‘*’ token 在使用捕获子句的时候，需要注意一些问题：\n不建议使用 2，3 这两种方式进行捕获（对性能影响较大），应该明确地指出需要按引用捕获的变量；\n按值捕获的变量是 read-only (const) 的，只有当匿名函数的可变规格被显式声明为 mutable 的时候才可以修改按值捕获的变量；\nint x{ 0 }; auto AnonyFunc = [=]() -\u0026gt; void { x = 1; // error: assignment of read-only variable ‘x’ } auto AnonyFunc = [=]() mutable -\u0026gt; void { x = 1; // ok } 按值捕获的变量的值在匿名函数生成的时候就已经确定了，如果在匿名函数生成后修改外部变量的值，则不会影响到匿名函数内被捕获的变量值，因为它们是两个作用域不同的变量：\nint i{ 0 }; auto AnonyFunc = [i]() -\u0026gt; void { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;i \u0026lt;\u0026lt; endl; }; i = 1; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;i \u0026lt;\u0026lt; endl; AnonyFunc(); $ g++ -std=c++11 -o lambda-capture lambda-capture.cpp $ ./lambda-capture 1 0x7ffe31fced8c 0 0x7ffe31fced80 对于按引用捕获的变量（或按值捕获的指针），如果该引用变量（或指针指向的对象）在外部被析构，那么匿名函数中的引用变量（或指针）则会成为悬空引用/指针（Dangling Pointer）：\nint* x = new int[1000000]; x[0] = 0; auto AnonyFunc = [\u0026amp;x]() { x[0] = 1; // Segmentation fault }; delete[] x; AnonyFunc(); struct Foo { int x_[1000000]; }; int main() { Foo* f = new Foo(); f-\u0026gt;x_[0] = 0; auto AnonyFunc = [f]() -\u0026gt; void { f-\u0026gt;x_[0] = 1; // Segmentation fault }; delete f; AnonyFunc(); } 2.2 匿名函数和闭包 Scott Meyers 对 lambda 表达式（匿名函数）与闭包之间的关系的解释是 \u0026ldquo;The distinction between a lambda and the corresponding closure is precisely equivalent to the distinction between a class and an instance of the class. A class exists only in source code; it doesn’t exist at runtime. What exists at runtime are objects of the class type. Closures are to lambdas as objects are to classes. This should not be a surprise, because each lambda expression causes a unique class to be generated (during compilation) and also causes an object of that class type–a closure–to be created (at runtime).\u0026quot;；\n这段解释可以拆分为两段：\n匿名函数和闭包的关系就如同类和类对象的关系，匿名函数和类的定义都只存在于源码（代码段）中，而闭包和类对象则是在运行时占用内存空间的实体； 对匿名函数的定义会生成一个独一无二的类，并在运行时生成其类对象； 再结合 C++ 11 的标准说明：\n\u0026quot;[C++11: 5.1.2/3]: The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type — called the closure type\u0026hellip;\u0026quot;，C++ 11 中的匿名函数实际上也是用类（closure type）来实现的； “[C++11: 5.1.2/5]: The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters and return type are described by the lambda-expression’s parameter-declaration-clause and trailing-return-type respectively. [..]”，匿名函数生成的类中也重载了 operator()，其参数与匿名函数的参数列表相同，返回值与匿名函数的尾随返回类型相同； \u0026quot;[C++11: 5.1.2/6]: The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type’s function call operator.\u0026quot;，如果匿名函数没有任何参数，那么将会生成一个普通的函数，而不是闭包类型； 可以知道实际上匿名函数也是用仿函数实现的，它实际上是 C++ 11 加入的语法糖，不过其语法特性是符合闭包定义的。\n3 匿名函数在 C++ 14 及之后的变化 C++ 14 广义捕获 C++ 14 中引入了新的广义 lambda 捕获（Generalized Lambda Captures），即可以在捕获列表中以任意方式初始化匿名函数中的变量，使得某些被禁用了拷贝构造函数的类型可以通过 std::move 的方式被捕获到匿名函数中：\nauto ptr_0 = make_unique\u0026lt;int\u0026gt;( 0 ); auto AnonyFunc = [ptr_0 = move(ptr_0)]() { *ptr_0 = 1; cout \u0026lt;\u0026lt; *ptr_0 \u0026lt;\u0026lt; endl; }; AnonyFunc(); 这里捕获列表中左边和右边的 ptr_0 不是同一个变量，它们的作用域分别是匿名函数内和匿名函数外；\n除此之外广义 lambda 捕获还可以用来间接地捕获 *this，即在 C++ 11 中无法实现的按值捕获 this 指向的对象：\nauto AnonyFunc = [this_copy = *this]() mutable { this_copy.x_ = 1; cout \u0026lt;\u0026lt; this_copy.x_ \u0026lt;\u0026lt; endl; }; AnonyFunc(); C++ 17 捕获 *this 在 C++ 17 中，终于可以直接捕获 *this 了，提案 P0018R3 指出捕获 *this 可以用于需要进行异步操作的并发应用，因为 this 可能失效：\nauto AnonyFunc = [*this]() mutable { x_ = 1; cout \u0026lt;\u0026lt; x_ \u0026lt;\u0026lt; endl; }; AnonyFunc(); cout \u0026lt;\u0026lt; x_ \u0026lt;\u0026lt; endl; $ g++ -std=c++17 -o lambda lambda.cpp $ ./lambda 1 0 ","permalink":"https://prov1dence.top/posts/cpp/closure-and-anonymous-function/","summary":"\u003ch1 id=\"c-闭包和匿名函数\"\u003eC++ 闭包和匿名函数\u003c/h1\u003e\n\u003cp\u003e本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。\u003c/p\u003e\n\u003ch2 id=\"1-闭包和仿函数\"\u003e1 闭包和仿函数\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e闭包\u003c/strong\u003e（\u003ca href=\"https://en.wikipedia.org/wiki/Closure_(computer_programming)\"\u003eClosure\u003c/a\u003e）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 \u003cem\u003e\u0026ldquo;In programming languages, a \u003cstrong\u003eclosure\u003c/strong\u003e, also \u003cstrong\u003elexical closure\u003c/strong\u003e or \u003cstrong\u003efunction closure\u003c/strong\u003e, is a technique for implementing \u003cstrong\u003elexically scoped name binding\u003c/strong\u003e in a language with \u003cstrong\u003efirst-class functions\u003c/strong\u003e.\u0026quot;\u003c/em\u003e，其中有两层含义：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e词法作用域（\u003ca href=\"https://en.wikipedia.org/wiki/Lexically_scoped\"\u003elexically scoped\u003c/a\u003e）的名字绑定（\u003ca href=\"https://en.wikipedia.org/wiki/Name_binding\"\u003ename binding\u003c/a\u003e）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈；\u003c/li\u003e\n\u003cli\u003e函数被当作头等公民（\u003ca href=\"https://en.wikipedia.org/wiki/First-class_citizen\"\u003efirst-class citizen\u003c/a\u003e）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（\u003ca href=\"https://www.geeksforgeeks.org/functors-in-cpp/\"\u003eFunctor\u003c/a\u003e）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eAdder\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e()(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e num)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        sum \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e num;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e sum;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Adder() \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e sum(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Adder(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e num) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e sum(num) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e sum;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Adder adder(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e adder(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e adder(\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e adder(\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ g++ -std\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ec++98 -o adder adder.cpp \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ ./adder \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e相比之下 golang 中真正的闭包显得简洁很多：\u003c/p\u003e","title":"C++ 闭包和匿名函数"},{"content":"负载均衡和一致性哈希 反向代理 reverse proxy 是指以代理服务器来接收由客户端发送来的请求，并通过一定的策略将其转变发给实际处理请求的后端服务器；主要应用于负载均衡、动态缓存、安全认证、内网穿透、SSL 加密等；而负载均衡 load balancing 是指在多个 slot（槽，一般是某种计算资源）中分配负载，以优化资源利用率和避免单点故障问题的方法，是高可用性分布式系统的必备中间件；常用的开源 load balancer 有 nginx，LVS，Haproxy 等；负载均衡可以视为反向代理的一种应用，负载均衡的方法大致可以分为传统负载均衡算法和哈希算法两种，本文简单地总结了这些算法的原理。\n1 传统负载均衡算法 随机 random：将 key 随机分配到某一个 slot 上，根据概率论可知，吞吐量越大，随机算法的效果越好； 加权随机 weighted random：为每一个 slot 分配一个权重，在随机的时候考虑权重的影响；可以通过在所有 slot 的权重总和中随机出一个数字 k，找到 k 所在的 slot 位置来实现； 轮询 round robin：按顺序依次将 key 分配给每一个 slot； 加权轮询 weighted round robin：为每一个 slot 分配一个权重，在按序分配时为权重更高的 slot 分配更多的 key； 平滑加权轮询 smooth weighted round robin：一种能够均匀地分散调度序列的加权轮询方法，分为以下几个步骤： 选出当前权重最高的 slot，将 key 分配给它； 将选出的 slot 的权重数值减去其初始权重； 将所有 slot 的权重数值都加上它们的原始权重； 重复以上步骤； 最少连接数 least connections：将 key 分配给当前具有最少连接数量的 slot； 2 Mod-N 哈希 在有些场景下，传统负载均衡算法无法满足我们的需求，例如：\n当我们需要充分利用到 slot 的缓存，在任何时候都希望将同一个 key 映射到固定的 slot 上，而不是让其被任意地分配到一个负载较低的 slot 上； 当我们希望把数据分配到一些具有键值存储功能（可以是 memcache, redis, mysql 等）的 slot 上进行有状态服务，而又不使用一个全局的数据库； 对于以上两个问题，我们可以先使用哈希函数（如 md5, sha1 等，需要保证哈希后的分布平均）将 key 映射为一个 uint32 的值（key 本身可能是一个字符串或其他值），再用该值对 N（slot 的数量）进行取模运算来映射出一个值， 即 value = hash(key) mod n，这种方法可以称为 Mod-N 哈希；这里做了两次哈希，第一次是对 key 做映射，第二次是进行取模运算。\n一般来说好的哈希函数应该满足一些条件：\n从哈希值不可反向推导出 key； 发生哈希冲突的概率尽可能小； 效率高； 哈希冲突/碰撞 Hash Collision 当我们把较大的值空间映射到较小的值空间时，冲突是不可避免的；如果两个 key 通过哈希方法被映射为了同一个值，那么就称为发生了 hash collision，一般来说其解决方案有：\n(1) 单链表法 separate chaining 也称作 open hashing；对于每一个通过哈希方法映射出的值，我们将其作为一个 bucket；当有 key 被映射到 bucket 上时，如果 bucket 为空，则为其新分配一个链表节点，否则遍历这个链表，在这个链表的尾部为其分配新的链表节点；\n(2) 开放寻址法 open addressing 也称作 closed hashing；主要思路是通过搜索哈希表中的其他空的 slot（探测序列 probe sequence）来进行 key 的插入，进行查找时应该采用与插入时相同的线性探测规则；获取 probe sequence 的方法一般有：\n线性探测 linear probing：查找哈希表中离冲突位置最近的空的 slot，即 value = (hash(key) + k) mod n, k = 1, 2, 3, 4...\n二次探测 quadratic probing：对哈希结果添加一个二次多项式直到找到一个空的 slot，即 value = (hash(key) + k^2) mod n, k^2 = 1, 4, 9, 16...\n双重哈希 double hashing：借助另一个哈希函数 hash\u0026rsquo; 的结果，作为偏移量获取值，即 value = hash'(key) mod n；\n3 一致性哈希 Consistent Hashing 在数据量较大的场景下，假设我们因为某些原因需要将原本的 n 个 slot 扩容为 m 个 slot，如果仍然使用 Mod-N 哈希，将会有 n/m 份缓存不能正确命中，从而产生大量的数据库请求，可能导致缓存雪崩。\n对于传统的哈希映射，添加或者删除一个 slot，会造成哈希表的全量重新映射；而**一致性哈希**的目的是达成增量式的重新映射，即当 slot 的数量发生变化时，降低重新映射的数量，尽量最小化重新映射（minimum disruption）。\n一致性哈希算法的设计关键有 4 点：\n平衡性 balance：所有的 key 能被均匀地映射到各个 slot 上； 单调性 monotonicity：增加新的 slot 后，原有的 key 应该被映射到原有的 slot，或新的 slot 上，而不是其他旧的 slot ； 分散 spread：服务扩容或者缩容时，尽量减少数据的迁移； 负载 load：尽量降低 slot 的负载； 3.1 Ketama ketama 算法是最常用的一种一致性哈希算法，也叫做哈希环法（hash ring）， 被广泛的应用在数据库，缓存系统和服务框架上，包括但不限于 memcache, redis, dubbo, nginx 等，其步骤是：\n对于一个 [0, uint32] 的区间，将其首尾相连，形成顺时针的环； 对 slot 进行哈希，映射到 [0, uint32] 区间上，并将结果标记到环上； 对 key 进行哈希，映射到区间上，沿着环顺时针寻找并将其分配到距其最近的 slot； 举个例子，假设现在有 N0, N1, N2 三个 slot 以及 a, b, c 三个 key，其中 a 会被分配 N1 上，b 和 c 都会被分配到 N2 上；\n现在我们新增一个 N3 slot，并将其映射到 [a, N1] 之间，那么 a 和所有在 [N0, N3] 之间的 key 都会被重新分配到 N3 这个 slot 上，除此之外的其他所有 key 则不会被重新映射；\n假设我们移除 N2 slot，那么所有在 [N1, N2] 之间的 key 都会被重新映射到 N0 上，除此之外的其他所有 key 则不会被重新映射。\n可以发现，ketama 算法达成了在新增或移除 slot 后的增量式重新映射（minimum disruption），不会破坏大多数 key 的映射关系；因为要构造出一个环来存储所有 slot 的 key 被映射到的位置，所以其空间复杂度是 O(n)；为了方便地进行查找，可以将环转换成一个有序数组，在其中进行二分查找，时间复杂度是 O(logn)。\n虚拟节点 有时候我们可能会对不同的节点赋予不同的权重，也就导致了每个节点的地位不平等，从而不能直接将节点放在环上，解决方案是使用不同数量的虚拟节点（virtual node）来代表实际的节点，一般来说每个虚拟节点代表一个单位节点，虚拟节点数量之和等于实际节点的权重；即使不同节点之间的权重相同，也建议将一个实际节点映射为多个虚拟节点，因为节点越多，它们在环上的分布就越均匀，因此使用虚拟节点还可以降低节点之间的负载差异；假设 N0, N1, N2 三个节点具有相同的权重，那么用虚拟节点代替之后则大致如图：\n3.2 Jump Consistent Hashing Jump Consistent Hashing 跳跃一致性哈希是 Google 发表的一个非常简洁的一致性哈希算法，其主要思路是：\n假设有 n 个 slot 和 k 个 key，所有的 k 个 key 都被均匀地映射到了这 n 个 slot 上； 现在增加 1 个 slot，为了将原有的 k 个 key 均匀地映射到 n + 1 个 slot 上，需要将其中 k / n + 1 个 key 进行重新映射，即每次增加 1 个 slot 都需要重新映射 k / n + 1 个 key； 使用**伪随机**的方式（给定一个随机种子，生成一个固定的随机序列）来决定哪 k / n 个 key 需要被重新映射； 这里使用伪随机的含义是，对于每一个 key，我们使用这个 key 来作为随机种子，生成一个固定的随机序列 seq，于是 seq 在其下标为 [1, n] 的区间里的值都是固定的；接下来遍历 seq，在每一次迭代 i 中，如果 seq[i] \u0026lt; 1/i，则将其重新分配到第 i 个 slot 上，否则保持不变；整个过程在给定 key 时就已经确定了。\n这样一来就达成了一致性哈希的平衡性和单调性，没有使用额外的内存，所以空间复杂度是 O(1)；而因为遍历了 n 个 slot，所以时间复杂度是 O(n)，还可以从时间复杂度的角度继续优化；在 seq[i] \u0026lt; 1 / i 这个公式中（即被重新分配这个假设成立），1 / i 会随着 i 的增大而变得越来越小，而 seq[i] 是随机数，因此可以认为公式成立的概率会越来越小，所以我们可以让 i 的步进增大，来减少迭代的次数。\n假设当前 key 所在的 slot 是 b，迭代次数是 b + 1 ，下一次迭代某一个 key 会被重新映射的概率是 1 / b + 2（上面思路第 2 点），即其不会被重新分配到新 slot 的概率为 b + 1 / b + 2，再下一次的概率是 b + 2 / b + 3，直到第 j 次的概率是 j - 1 / j，将这些概率相乘得到在这 j - b 次之间 key 不会被重新分配的概率是 b + 1 / j；假设把 seq[i] 用 r = random.next() 来表示，要使得 r \u0026lt; (b + 1) / j（即被重新分配这个假设成立），就必须有 j \u0026lt; (b + 1) / r，那么 key 在步进大于等于 (b + 1) / r 次后一定会被重新分配。\n这样一来时间复杂度就减少到了 O(ln(n))；但其局限性也很明显，因为只能通过步进的方式来重新映射和分配 slot，导致其只能在尾部增删 slot，否则在中间进行增删的话会导致其后续的 slot 下标和步进关系都发生变化，\n论文中还对比了其与哈希环法的运行时间。\n3.3 Maglev Hashing Maglev 是 Google 研发的一个负载均衡组件，使用了其自研的一致性哈希算法 Maglev Hashing，其主要思路是通过维护两个 table 来将 key 映射到 slot 上；一个表是 lookup table 查找表，用于将 key 映射到 slot 上；另一个表是 permutation table 排列表，用于记录一个 slot 在 lookup table 中的位置序列：\n对于 n 个 slot 和一个长度为 m 的映射序列（即 permutation table 和 lookup table 的长度），我们希望为每一个下标为 i 的 slot 都计算出一个数量为 m 的排列，计算时需要使用两个不同的哈希函数 h1 和 h2，来计算 offset 和 skip 两个值（这里需要保证每一个 slot 的 name 都不相同）：\n举个例子，假设 n = 3，m = 7，对于下标为 0 的 slot，通过某两个哈希函数计算出来的 offset = 3，skip = 4，为其生成一个长度 m = 7 的 permutation：\npermutation[i][0] = (3 + 0 * 4) mod 7 = 3 permutation[i][1] = (3 + 1 * 4) mod 7 = 0 permutation[i][2] = (3 + 2 * 4) mod 7 = 4 permutation[i][3] = (3 + 3 * 4) mod 7 = 1 permutation[i][4] = (3 + 4 * 4) mod 7 = 5 permutation[i][5] = (3 + 5 * 4) mod 7 = 2 permutation[i][6] = (3 + 6 * 4) mod 7 = 6 再加上另外两个计算好 permutation 的下标为 1 和 2 的 slot，对应的 permutation table：\nm s0 s1 s2 0 3 0 3 1 0 2 4 2 4 4 5 3 1 6 6 4 5 1 0 5 2 3 1 6 6 5 2 现在我们让 3 个 slot 轮流地从其 permutation 中，按顺序选择第一个没有被分配的 key，来填充到之后的 lookup table 中，流程是：\ns0 的 permutation 中的第一个数字 3 没有被分配，选择 3； s1 的 permutation 中的第一个数字 0 没有被分配，选择 0； s2 的 permutation 中的第一个数字 3 已经被分配了，往后遍历到数字 4，选择 4； s0 在 permutation 中往后遍历，0 和 4 都已经被分配了，选择 1； s1 在 permutation 中往后遍历，选择 2； s2 在 permutation 中往后遍历，4 已经被分配了，选择 5； s0 在 permutation 中往后遍历直到选择 6； 于是就有了 lookup table：\nm slot 0 s1 1 s0 2 s1 3 s0 4 s2 5 s2 6 s0 这种方法类似于开放寻址法中的双重哈希，通过使用两个无关的哈希函数来生成排列（也可以使用其他生成随机排列的方法，例如 fisher-yates shuffle，必须保证方法的的随机性）降低了哈希碰撞的概率；在增加或移除 slot 时，需要为新的 slot 生成 permutation table，再重新生成 lookup table，这会导致部分重新映射，不满足最小化重新映射（minimum disruption）；维护两个表的空间复杂度是 O(n)，查询的时间复杂度是 O(1)；建立表的复杂度可以参考论文的第 3.4 节。\n4 总结 本文主要介绍了负载均衡的概念，并简单地阐明了一致性哈希算法的原理，关于一致性哈希算法的优缺点、边界条件、复杂度分析、效率对比、实际应用等还需要结合论文和开源组件进行更深入的了解。\n","permalink":"https://prov1dence.top/posts/service-governance/load-balancing/","summary":"\u003ch1 id=\"负载均衡和一致性哈希\"\u003e负载均衡和一致性哈希\u003c/h1\u003e\n\u003cp\u003e反向代理 reverse proxy 是指以代理服务器来接收由客户端发送来的请求，并通过一定的策略将其转变发给实际处理请求的后端服务器；主要应用于负载均衡、动态缓存、安全认证、内网穿透、SSL 加密等；而负载均衡 load balancing 是指在多个 slot（槽，一般是某种计算资源）中分配负载，以优化资源利用率和避免单点故障问题的方法，是高可用性分布式系统的必备中间件；常用的开源 load balancer 有 nginx，LVS，Haproxy 等；负载均衡可以视为反向代理的一种应用，负载均衡的方法大致可以分为传统负载均衡算法和哈希算法两种，本文简单地总结了这些算法的原理。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"reveser-proxy\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/reverse-proxy/reverse-proxy.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"1-传统负载均衡算法\"\u003e1 传统负载均衡算法\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e随机 random：将 key 随机分配到某一个 slot 上，根据概率论可知，吞吐量越大，随机算法的效果越好；\u003c/li\u003e\n\u003cli\u003e加权随机 weighted random：为每一个 slot 分配一个权重，在随机的时候考虑权重的影响；可以通过在所有 slot 的权重总和中随机出一个数字 k，找到 k 所在的 slot 位置来实现；\u003c/li\u003e\n\u003cli\u003e轮询 round robin：按顺序依次将 key 分配给每一个 slot；\u003c/li\u003e\n\u003cli\u003e加权轮询 weighted round robin：为每一个 slot 分配一个权重，在按序分配时为权重更高的 slot 分配更多的 key；\u003c/li\u003e\n\u003cli\u003e平滑加权轮询 smooth weighted round robin：一种能够均匀地分散调度序列的加权轮询方法，分为以下几个步骤：\n\u003col\u003e\n\u003cli\u003e选出当前权重最高的 slot，将 key 分配给它；\u003c/li\u003e\n\u003cli\u003e将选出的 slot 的权重数值减去其初始权重；\u003c/li\u003e\n\u003cli\u003e将所有 slot 的权重数值都加上它们的原始权重；\u003c/li\u003e\n\u003cli\u003e重复以上步骤；\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e最少连接数 least connections：将 key 分配给当前具有最少连接数量的 slot；\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"2-mod-n-哈希\"\u003e2 Mod-N 哈希\u003c/h2\u003e\n\u003cp\u003e在有些场景下，传统负载均衡算法无法满足我们的需求，例如：\u003c/p\u003e","title":"负载均衡和一致性哈希"},{"content":"C++ 并发入门：以 LeetCode 1114 为例 题目 直接做题：1114 按序打印\n解法 1. std::mutex 如果你对 c++ 11 略为熟悉的话，应该能够想到用 std::mutex 来解这道题，在函数构造时（主线程）对 std::mutex 进行 lock，然后在各个线程调用的函数中依次对 std::mutex 对象进行 unlock：\nclass Foo { mutex mtx1, mtx2; public: Foo() { mtx1.lock(), mtx2.lock(); } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); mtx1.unlock(); } void second(function\u0026lt;void()\u0026gt; printSecond) { mtx1.lock(); printSecond(); mtx1.unlock(); mtx2.unlock(); } void third(function\u0026lt;void()\u0026gt; printThird) { mtx2.lock(); printThird(); mtx2.unlock(); } }; Mutex 即 mutual exclusion，是用来防止多个线程同时访问共享资源对象的机制，在同一时间只有一个线程可以拥有一个 mutex 对象，其他线程调用 std::mutex::lock 函数时会阻塞直到其获取锁资源。\n这段代码能够 ac，但实际上这种使用 mutex 的方法是错误的，因为根据 c++ 标准，在一个线程尝试对一个 mutex 对象进行 unlock 操作时，mutex 对象的所有权必须在这个线程上；也就是说，应该由同一个线程来对一个 mutex 对象进行 lock 和 unlock 操作，否则会产生未定义行为。题目中提到了 first, second, third 三个函数分别是由三个不同的线程来调用的，但我们是在 Foo 对象构造时（可以是在 create 这几个线程的主线程中，也可以是在三个线程中的任意一个）对两个 mutex 对象进行 lock 操作的，因此，调用 first 和 second 函数的两个线程中至少有一个在尝试获取其他线程所拥有的 mutex 对象的所有权。\n另外，如果非要讨论这个解法有什么优化的余地的话，因为 mutex 对象本身是不保护任何数据的，我们只是通过 mutex 的机制来保护数据被同时访问，所以最好使用 lock_guard 或者 unique_lock 提供的 RAII 机制来管理 mutex 对象，而不是直接操作 mutex 对象；其中 lock_guard 只拥有构造和析构函数，用来实现 RAII 机制，而 unique_lock 是一个完整的 mutex 所有权包装器，封装了所有 mutex 的函数：\nclass Foo { mutex mtx_1, mtx_2; unique_lock\u0026lt;mutex\u0026gt; lock_1, lock_2; public: Foo() : lock_1(mtx_1, try_to_lock), lock_2(mtx_2, try_to_lock) { } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); lock_1.unlock(); } void second(function\u0026lt;void()\u0026gt; printSecond) { lock_guard\u0026lt;mutex\u0026gt; guard(mtx_1); printSecond(); lock_2.unlock(); } void third(function\u0026lt;void()\u0026gt; printThird) { lock_guard\u0026lt;mutex\u0026gt; guard(mtx_2); printThird(); } }; 2. std::condition_variable std::condition_variable 是一种用来同时阻塞多个线程的同步原语（synchronization primitive），std::condition_variable 必须和 std::unique_lock 搭配使用：\nclass Foo { condition_variable cv; mutex mtx; int k = 0; public: void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); k = 1; cv.notify_all();\t// 通知其他所有在等待唤醒队列中的线程 } void second(function\u0026lt;void()\u0026gt; printSecond) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx);\t// lock mtx cv.wait(lock, [this](){ return k == 1; });\t// unlock mtx，并阻塞等待唤醒通知，需要满足 k == 1 才能继续运行 printSecond(); k = 2; cv.notify_one();\t// 随机通知一个（unspecified）在等待唤醒队列中的线程 } void third(function\u0026lt;void()\u0026gt; printThird) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx);\t// lock mtx cv.wait(lock, [this](){ return k == 2; });\t// unlock mtx，并阻塞等待唤醒通知，需要满足 k == 2 才能继续运行 printThird(); } }; std::condition_variable::wait 函数会执行三个操作：先将当前线程加入到等待唤醒队列，然后 unlock mutex 对象，最后阻塞当前线程；它有两种重载形式，第一种只接收一个 std::mutex 对象，此时线程一旦接受到唤醒信号（通过 std::condition_variable::notify_one 或 std::condition_variable::notify_all 进行唤醒），则无条件立即被唤醒，并重新 lock mutex；第二种重载形式还会接收一个条件（一般是 variable 或者 std::function），即只有当满足这个条件时，当前线程才能被唤醒，它在 gcc 中的实现也很简单，只是在第一种重载形式之外加了一个 while 循环来保证只有在满足给定条件后才被唤醒，否则重新调用 wait 函数：\ntemplate\u0026lt;typename _Predicate\u0026gt; void wait(unique_lock\u0026lt;mutex\u0026gt;\u0026amp; __lock, _Predicate __p) { while (!__p()) wait(__lock); } 条件变量 std::condition_variable 的机制和信号量 semaphore 比较类似，它们都是建立在 mutex 的基础之上，用于实现对共享资源的同步访问，然而可惜的是 c++ 标准库中并没有信号量的实现和封装，但我们仍然可以使用 c 语言提供的 \u0026lt;sempahore.h\u0026gt; 库来解题 ：\n#include \u0026lt;semaphore.h\u0026gt; class Foo { private: sem_t sem_1, sem_2; public: Foo() { sem_init(\u0026amp;sem_1, 0, 0), sem_init(\u0026amp;sem_2, 0, 0); } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); sem_post(\u0026amp;sem_1); } void second(function\u0026lt;void()\u0026gt; printSecond) { sem_wait(\u0026amp;sem_1); printSecond(); sem_post(\u0026amp;sem_2); } void third(function\u0026lt;void()\u0026gt; printThird) { sem_wait(\u0026amp;sem_2); printThird(); } }; 3. std::future std::future 是用来获取异步操作结果的模板类；std::packaged_task, std::promise, std::async 都可以进行异步操作，并拥有一个 std::future 对象，用来存储它们所进行的异步操作返回或设置的值（或异常），这个值会在将来的某一个时间点，通过某种机制被修改后，保存在其对应的 std::future 对象中：\n对于 std::promise，可以通过调用 std::promise::set_value 来设置值并通知 std::future 对象：\nclass Foo { promise\u0026lt;void\u0026gt; pro1, pro2; public: void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); pro1.set_value(); } void second(function\u0026lt;void()\u0026gt; printSecond) { pro1.get_future().wait(); printSecond(); pro2.set_value(); } void third(function\u0026lt;void()\u0026gt; printThird) { pro2.get_future().wait(); printThird(); } }; std::future\u0026lt;T\u0026gt;::wait 和 std::future\u0026lt;T\u0026gt;::get 都会阻塞地等待拥有它的 promise 对象返回其所存储的值，后者还会获取 T 类型的对象；这道题只需要利用到异步通信的机制，所以并没有返回任何实际的值。\nstd::packaged_task 是一个拥有 std::future 对象的 functor，将一系列操作进行了封装，在运行结束之后会将返回值保存在其所拥有的 std::future\u0026lt;T\u0026gt; 对象中；同样地，在这道题中只需要利用到其函数运行结束之后通知 std::future 对象的机制：\nclass Foo { function\u0026lt;void()\u0026gt; task = []() {}; packaged_task\u0026lt;void()\u0026gt; pt_1{ task }, pt_2{ task }; public: void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); pt_1(); } void second(function\u0026lt;void()\u0026gt; printSecond) { pt_1.get_future().wait(); printSecond(); pt_2(); } void third(function\u0026lt;void()\u0026gt; printThird) { pt_2.get_future().wait(); printThird(); } }; 4. std::atomic 我们平时进行的数据修改都是非原子操作，如果多个线程同时以非原子操作的方式修改同一个对象可能会发生数据争用，从而导致未定义行为；而原子操作能够保证多个线程顺序访问，不会导致数据争用，其执行时没有任何其它线程能够修改相同的原子对象。c++ 11 提供了 std::atomic\u0026lt;T\u0026gt; 模板类来构造原子对象：\nclass Foo { std::atomic\u0026lt;bool\u0026gt; a{ false }; std::atomic\u0026lt;bool\u0026gt; b{ false }; public: void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); a = true; } void second(function\u0026lt;void()\u0026gt; printSecond) { while (!a) this_thread::sleep_for(chrono::milliseconds(1)); printSecond(); b = true; } void third(function\u0026lt;void()\u0026gt; printThird) { while (!b) this_thread::sleep_for(chrono::milliseconds(1)); printThird(); } }; 值得注意的是，原子操作的实现跟处理器和操作系统内核相关，因此 c++ 标准并没有规定 atomic 的实现是否是无锁的（lock-free），只规定了需要提供一个 is_lock_free() 来查询当前编译器对 atomic 的实现是否是无锁的。\n","permalink":"https://prov1dence.top/posts/cpp/concurrency/introduction-to-concurrency/","summary":"\u003ch1 id=\"c-并发入门以-leetcode-1114-为例\"\u003eC++ 并发入门：以 LeetCode 1114 为例\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003cp\u003e直接做题：\u003ca href=\"https://leetcode.com/problems/print-in-order/\"\u003e1114 按序打印\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"解法\"\u003e解法\u003c/h2\u003e\n\u003ch3 id=\"1-stdmutex\"\u003e1. std::mutex\u003c/h3\u003e\n\u003cp\u003e如果你对 c++ 11 略为熟悉的话，应该能够想到用 \u003ca href=\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e 来解这道题，在函数构造时（主线程）对 \u003ccode\u003estd::mutex\u003c/code\u003e 进行 \u003ccode\u003elock\u003c/code\u003e，然后在各个线程调用的函数中依次对 \u003ccode\u003estd::mutex\u003c/code\u003e 对象进行 \u003ccode\u003eunlock\u003c/code\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mutex mtx1, mtx2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Foo() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mtx1.lock(), mtx2.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efirst\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printFirst) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printFirst();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mtx1.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esecond\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printSecond) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mtx1.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printSecond();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mtx1.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mtx2.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ethird\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printThird) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mtx2.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printThird();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mtx2.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eMutex 即 \u003cstrong\u003emutual exclusion\u003c/strong\u003e，是用来防止多个线程同时访问共享资源对象的机制，在同一时间只有一个线程可以拥有一个 \u003ccode\u003emutex\u003c/code\u003e 对象，其他线程调用 \u003ccode\u003estd::mutex::lock\u003c/code\u003e 函数时会阻塞直到其获取锁资源。\u003c/p\u003e","title":"C++ 并发入门：以 LeetCode 1114 为例"},{"content":"Effective C++ 笔记 0 导言 1 构造函数 default 构造函数：可被调用而不带任何实参的构造函数，这样的构造函数要么没有参数，要么每个参数都带有默认值，例如\nclass Bar { public: // explicit Bar(); // 是 default 构造函数 // explicit Bar(int x = 0) // 不是 default 构造函数 explicit Bar(int x = 0, bool b = true); // 是 default 构造函数 private: int x; bool b; }; explicit 关键字：阻止执行隐式类型转换，其优点是禁止了编译器执行非预期的类型转换，例如\nvoid Foo(Bar obj); // Foo 函数的参数是一个类型为 Bar 的对象 Bar obj_1; // 构造一个 Bar 类型的对象 Foo (obj_1); // 没问题，传递一个 Bar 类型的对象给 Foo 函数 Foo (Bar()); // 没问题，构造一个 Bar 类型的对象，并传递给 Foo 函数 Foo (2); // 如果 Bar 的构造函数没有被声明为 explicit，那么会调用 Bar 的构造函数构造一个成员变量 x = 2 的对象，也就是说发生了隐式类型转换；如果其构造函数被声明为 explicit，那么就不会构造出 Bar 类型的对象 copy 构造函数：用同类型的对象初始化新的对象，它定义了一个对象如何 pass by reference。\ncopy assignment：拷贝另一个同类型对象的值到自身，同时 \u0026ldquo;=\u0026rdquo; 也可以用来调用 copy 构造函数，例如\nclass Bar { public: Bar(); // default 构造函数 Bar(const Bar \u0026amp;rhs); // copy 构造函数 Bar\u0026amp; operator=(const Bar \u0026amp;rhs); // copy assignment }; Bar b1; // 调用 default 构造函数 Bar b2(b1); // 调用 copy 构造函数 b1 = b2; // 调用 copy assignment Bar b3 = b2; // 调用 copy 构造函数 0.2 未定义行为 int *p = nullptr; std::cout \u0026lt;\u0026lt; *p; // 对一个空指针进行取值，导致不确定行为 char name[] = \u0026#34;Joel\u0026#34;; // name 是一个长度为 5 的 char 类型数组 char c = name[10]; // 指向一个无效的数组索引，导致不确定行为 2. 尽量使用 const, enum, inline 替换#define 使用编译器替换预处理器；使用宏定义的变量在编译器处理源码之前就被替换了，从未进入记号表。\n3. 尽可能使用 const 3.1 Iterator STL 中的 iterator 类似于一个 T* 指针，如果将 iterator 声明为 const 那么实际上是声明了一个 T* const，即 const pointer to T，指针 T 初始化后不能再指向其他的对象；而 STL 中的 const_iterator 则本身就是一个 const T*，即 pointer to const T，指向一个 const T 类型的对象，对象的值不能被修改，而其指向是可以被修改为其他对象的。\n对于 const 类型的 STL 容器，应该使用 const_iterator 来进行遍历；对于非 const 类型的 STL 容器，应该使用 iterator 来遍历。\niterator 不用使用 reference 的形式绑定到 STL::begin() 上，因为 STL::begin() 返回的是一个临时 pointer 变量，且对于内置类型和 STL 的迭代器和函数对象，pass-by-value 会比 pass-by-reference 更高效。\n使用 auto 遍历一个 STL 容器时，会直接遍历，而不是使用 iterator 指针。\n3.2 const 和 multable 4. 确保在使用前先初始化数据 4.1 成员变量初始化 对于内置类型，手动进行初始化，因为 C++ 不保证会初始化它们。\n对于类，在构造函数中将每一个成员变量初始化，成员变量的初始化动作发生在进入构造函数本体之前，使用 member initialization list 效率较高，且不会与 assignment 混淆；在成员初始化列表中总是列出所有成员变量，且排列次序应该和声明次序相同。\n4.2 static 变量 static 对象的寿命从被构造出来直到程序结束为止；决定 non-local static 对象的初始化次序非常困难，常见形式是使用 implicit template instantiations 模板隐式具现化；消除这个问题的方法是使用 local static 对象，因为 local static 对象会在函数首次被调用时被初始化。\n5. C++ 默认编写和调用的函数 5.1 类 编译器会自动为类声明 copy 构造函数和 copy assignment，它们只单纯地将来源对象的每一个 non-static 成员变量拷贝到目标对象；\n编译器会自动声明 non-virtual 的析构函数；\n当没有任何构造函数时，编译器会为类声明 default 构造函数；这些函数都是 inline public 的，并且只有当这些函数被调用的时候才会被编译器创建出来，前提是生成的代码是合法的，即对于内含 const 成员的或在基类中将 copy assignment 声明为 private 的派生类是无法自动生成对应的函数的。\n6. 对于不想使用的编译器自动生成的函数，显式地拒绝 函数的参数名称不一定需要被写出来。\n将 copy 构造函数和 copy assignment 声明为 private 并且不实现，可以防止编译器自动生成这两个函数，同时防止它们在外部被调用；但如果在 member 函数或者 friend 函数中调用了，那么连接器会报错；我们应该尽可能将连接期错误移动至编译期错误，尽早检查出错误。\n可以设计一个专门为了阻止 copying 动作为存在的 base class，因为 base class 的 copy 函数和 copy assignment 是 private 的，派生类无法调用基类的私有方法，所以编译器会拒绝为子类自动生成这两个函数并报错\nclass Uncopyable { protected: Uncopyable(); ~Uncopyable(); private: Uncopyable(const Uncopyable \u0026amp;); Uncopyable \u0026amp; operator=(const Uncopyable \u0026amp;); } class Foo: private Uncopyable { ... } C++ 11 中引入了 default 和 delete 关键字，前者可以让编译器自动生成函数，后者可以直接禁止使用函数\nclass Foo: private Uncopyable { public: A() = default; A(const A \u0026amp;) = delete; } 7. 为多态基类声明 virtual 析构函数 当派生类对象经由基类指针被删除时，如果其析构函数不是 virtual 的，那么编译器不会去虚表上查找到派生类的析构函数正确地进行调用，而是只执行基类的部分，造成局部销毁的现象。\n当不意图将一个函数作为基类实现多态时，不要将它的析构函数声明为 virtual；只有当类中至少含有一个 virtual 函数时，才为其声明 virtual 析构函数。\n所有 STL 容器都没有 virtual 析构函数。\n对于抽象类，将其析构函数声明为 pure virtual。\n析构函数的运作方式是从最深层的派生类的析构函数依次调用到基类的析构函数，因此必须为纯虚函数的 virtual 析构函数提供一个定义。\n8. 不要在析构函数中抛出异常 在 C++ 中，如果同时存在两个异常，程序会发生未定义行为（或结束执行）。\n9. 不要在构造函数和析构函数内调用 virtual 函数 对于一个派生类，其对象在构造的时候会从基类的构造函数一直调用到派生类的构造函数。\n10. 让 oprator= 返回一个 reference to *this class Foo { public: ... Foo \u0026amp;operator=(const Foo \u0026amp;rhs) { ... return *this; } } STL 中的容器均使用这个协议。\n11. 在 operator= 中处理自我赋值 在 operator= 的开头加上 identity test，防止发生因为自我赋值产生的指针指向问题：\nFoo\u0026amp; Foo::operator=(const Foo \u0026amp;rhs) { if (this == \u0026amp;rhs) return *this; delete p_bm; p_bm = new Bitmap(*rhs.p_bm); return *this; } 这样的实现并不具备异常安全性，因为 new Bitmap 可能会因为内存不足或 copy 构造函数出错导致异常。\nFoo\u0026amp; Foo::operator=(const Foo \u0026amp;rhs) { Bitmap *p_bm_temp = p_bm; p_bm = new Bitmap(*rhs.p_bm); delete p_bm_temp; return *this; } 12. 拷贝对象是确保复制每一个成员 在编写一个 copying（包括 copy 构造函数和 copy assignment）函数时，确保：1. 复制所有的 local 成员变量；2. 调用所有基类对应的 copying 函数。\n如果 copy 构造函数和 copy assignment 有相似的代码，可以定义一个新的 private 类型的初始化函数供其实用。\n13. 以对象管理资源 获得资源后立刻放进管理对象，即资源取得时机便是初始化时机（Resource Acquisition Is Initialization, RAII），总是在取得资源后马上用它来初始化某个管理对象；管理对象使用析构函数确保资源被释放。例如使用智能指针。\n14. 在资源管理类中小心 copying 行为 16. 成对使用 new 和 delete 的时候要采取相同形式 单一对象的内存布局不同于数组对象的内存布局，数组的内存还包含了数组大小的记录，以便 delete 知道需要调用多少次析构函数；new[] 和 delete[] 一定要成对出现。\n4 设计和声明 18. 让接口容易被正确使用，不易被误用 不一致性对开发人员造成的心理和精神上的摩擦与争执，没有任何一个 IDE 可以完全抹除。 19. 像设计一个新类型一样设计 class 设计一个新的 class 的时候需要考虑的因素包括但不限于：\n类的对象应该如何被创建和销毁 - 构造函数和析构函数 初始化和赋值有什么区别 - copy 构造函数和 copy assignment 的区别 对象被 pass by value 时会发生什么 - copy 构造函数的设计 哪些操作是有效的 - 成员函数必须进行错误检查 继承图系 inheritance graph 的约束 - virtual，override，final，析构函数相关 类型转换 - 定义类型转换函数 操作符的定义 public 和 private 函数的区分 未声明接口 undeclared interface 泛型的考虑 20. 使用 pass-by-reference-to-const 替代 pass-by-value 对象切割 slicing ：用一个派生类实参去初始化一个基类形参，执行其拷贝构造函数，导致函数内的参数实际上会执行基类的行为。\n以 pass-by-reference-to-const 的方式传递参数可以防止对象的拷贝构造；也可以避免对象切割问题，因为 pass-by-reference-to-const 的方式可以防止拷贝构造的发生，从而正确地表现多态特性。\n在 C++ 的底层，reference 一般是使用 pointer 实现的，因此 pass by reference 实际上传递的是指针；对于内置类型和 STL 的迭代器和函数对象，pass-by-value 会比 pass-by-reference 更高效。\n21*. 必须返回对象时，不要返回其 reference 任何时候看到一个 reference 声明式，你都应该立刻问自己，它的另一个名称是什么？ 无论是在堆还是栈上创建的对象，使用 reference 返回都会造成问题，前者会发生内存泄漏，后者会导致未定义行为。\n绝不要返回一个指向 local stack 的 pointer 或 reference，或返回 reference 指向一个 heap-allocated 对象，或返回一个指向 local static 的 pointer 或 reference。 22*. 将成员变量声明为 private 将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。例如这可以使得成员变量在被读或被写时轻松通知其他对象，可以验证 class 的约束条件以及函数的前提和事后状态，可以在多线程环境中执行同步控制等等。 从封装的角度出发，只有两种访问权限：private（提供封装）和其他（不提供封装）；protected 并不比 public 更有封装性，因为无论修改 protected 变量或是 public 变量，都会有大量代码受到破坏。\n23. 尽量使用 non-member，non-friend 替换 member 函数 将所有遍历函数放在多个头文件内，但隶属于同一个命名空间，意味着客户可以轻松扩展这一组遍历函数，他们需要做的就是添加更多 non-member non-friend 函数到此命名空间中。 尽量使用 non-member，non-friend 替换 member 函数，可以增加封装性，包裹弹性 packaging flexibility，和机能扩充性。\n24. 如果所有参数都需要类型转换，那么将这个函数设置为 non-member 25. 支持一个不抛出异常的 swap 函数 所有 STL 容器都提供 public swap 函数和 std::swap 的特化版本。\n5. 实现 Implementation 太快定义变量可能造成效率上的拖延；过度使用转型 cast 可能导致代码变慢又难维护，又招来微妙难解的错误；返回对象内部数据的句柄 handle 可能会破坏封装性并留给客户悬空句柄 dangling handle；未考虑异常带来的冲击可能导致资源泄漏和数据腐坏；过度热心地 inlining 可能引起代码膨胀；过度耦合 coupling 可能导致冗长构建时间 build time。 26. 尽量延后变量定义地出现 延后变量的定义，直到不得不使用它的前一刻为止，否则需要承受额外的构造和析构成本，以及无意义地 default 构造行为。\n对于需要在循环内反复使用的\n27. 少使用转型 C++ 风格的类型转换有四种：\nconst_cast：将对象的常量性移除 dynamic_cast：执行安全向下转型 safe downcasting，用来决定对象是否归属继承体系中的某个类型；它无法由 C 风格的类型转换执行，但可能耗费很大成本 reinterpret_cast：执行低级转型，其动作和结果可能取决于编译器 static_cast：执行隐式转换，例如将 non-const 转为 const 对象，或将 int 转为 double C++ 风格的类型转换更好，原因是：\n更容易被辨识 每种转型动作有更明确的意义，易于调试 任何一个类型转换都会让编译器编译出运行期的执行码\n28. 避免返回指向对象内部成员的 handle 对象的内部不只有成员变量，还有不被公开的成员函数，绝不应该返回一个指向“访问级别较低”的成员函数。\n避免返回指向对象内部成员的 handle，可以增加封装性，使得 const 成员函数的行为是真正的 const，也能降低出现悬空指针的可能性。\n29. 努力写出异常安全的代码 当异常被抛出时，带有异常安全性的函数会：\n不泄露任何资源，即不因为流程阻塞而导致其后的资源未被释放 不允许数据败坏，即不允许悬空指针的出现 异常安全函数提供以下三个保证之一：\n基本保证：异常抛出时，没有对象或数据结构被破坏，所有对象都处于前后一致的状态 强烈保证：如果抛出异常，程序状态不改变；如果程序失败，程序会恢复到调用函数前的状态 不抛异常保证：程序保证不抛出异常，因为它总能够完成原先承诺的功能 30. 理解 inlining 在一台内存有限的机器上，过度热衷于 inlining 会导致程序体积过大；即使拥有虚拟内存，inlining 造成的代码膨胀也会导致额外的换页 paging 行为，降低指令高速缓存装置的击中率 instruction cache hit rate，以及伴随而来的效率损失 inline 可以隐喻提出，例如将函数定义于 class 的定义内部。\ninline 函数一般被放在头文件内，因为 inlining 在大多数 C+ 程序中是编译期行为，而编译器为了将函数调用替换为被调用函数的本体，编译器需要知道函数的具体实现。template 也是如此。\n将大多数 inlining 限制在小型且被频繁调用的函数上，可以使得调试和二进制升级更容易，也可以使得潜在的代码膨胀问题最小化，并提升程序运行速度。\n31. 将文件间的编译依存关系降至最低 #include 在定义文件和包含文件之间形成了编译依存关系 compilation dependency，如果头文件中的任何一个被改变，或头文件所依赖的其他头文件有改变，那么每一个包含有该头文件的文件都会重新编译，任何使用该文件中定义的类和函数的文件也需要重新编译，这被叫做连串编译依存关系 cascading compilation dependencies。\n当编译器看到定义时，它必须知道要分配多少内存。\n6. 继承和面向对象设计 32. 确保 public 继承是 is-a 关系 适用于 base class 的每一个函数和对象也一定适用于 derived class。\n33. 避免遮挡继承得来的名称 内层作用域的名称会遮挡外部作用域的名称，当编译器处于一个作用域内的时候，会先在 local 作用域内查找是否有对应的变量名称，如果没有才会去其他作用域找。\n可以使用 using 关键字显式地声明其他作用域的变量和函数，使得它们在当前作用域可见。\n34. 区分接口继承和实现继承 不同类型成员函数的目的：\n纯虚函数：让派生类继承函数的接口 虚函数：让派生类继承函数的接口和默认实现 非虚函数：让派生类继承函数的接口和强制性实现 如果成员函数是个非虚函数，意味着它并不打算在派生类中被 override；非虚函数代表其不变性 invariant 凌驾于特异性 specialization 之上。\n一个典型的程序员有 80% 的执行时间花在 20% 的代码上；它意味着，平均而言函数调用中可以有 80% 是 virtual 而不冲击程序的大体效率，所以在担心 virtual 函数的成本之前，先将心力放在 20% 的代码上。 35. 考虑 virtual 函数以外的其他选择 通过 non-virtual interface 实现模板方法模式 非虚接口 non-virtual interface (NVI)：使客户通过 public non-virtual 成员函数间接调用 private virtual 函数，它是所谓的模板方法模式的一个独特表现形式，把这个 public non-virtual 函数称为 virtual 函数的包装器 wrapper。\n通过 function pointer 实现策略模式 36. 绝不重新定义通过继承得来的非虚函数 非虚函数是静态绑定的，被调用函数与指针本身类型对应；虚函数是动态绑定的，被调用函数与指针所指对象类型对应。\n37. 绝不重新定义通过继承得来的默认参数值 静态类型：在程序中被声明时所采用的类型 动态类型：指针实际所指向的类型；动态类型可以表现出一个对象将有什么行为，且动态类型在执行过程中可以改变 Shape *p_s; Shape *p_c = new Circle(); Shape *p_r = new Rectangle(); 此处 p_s，p_c，p_r 三者的静态类型都是 Shape，而它们的动态类型分别是 Shape，Circle，Rectangle\n在继承一个带有默认参数值的虚函数时，不应重新定义其默认参数，因为虚函数是动态绑定的，而默认参数是静态绑定的，默认参数只与静态类型有关。\n38. 通过组合 composition 构建出 has-a 或 由其实现 的关系 在应用域内，复合意味着 has-a；在实现域内，复合意味着 is-implemented-in-terms-of。\n39. 明智而审慎地使用 private 继承 private 继承意味着由其实现 implemented-in-terms-of，通过 private 继承得到的基类中的 public 和 protected 函数和对象都是 private 的。\n尽可能使用组合，必要时才使用 private 继承。\n40. 明智而审慎地使用多重继承 多重继承会导致比较多的歧义，例如\n多重继承的两个基类都有相同签名的函数：他们具有相同的匹配程度而没有最佳匹配，为了解决这个起义，必须明确指出要调用的是哪一个基类的函数 菱形继承：某个基类到某个派生类之间有一条以上的通路，那么派生类默认对多份基类数据都执行拷贝，而如果使用虚继承，那么派生类只会保留一份拷贝；标准库中的 basic_ios，basic_istream，basic_ostream 和 basic_iostream 也是菱形继承体系，它们采用的是虚继承 一般来说，public 继承都应该是 virtual 继承\n7. 模板和泛型编程 41. 了解隐式接口和编译器多态 面向对象编程总是以显式接口 explicit interface 和运行期多态 runtime polymorphism 解决问题，显式接口由函数的签名构成 template 参数具有隐式接口 implicit interface，隐式接口由有效表达式组成，也就是对于模板变量来说，它必须提供所需的成员函数和操作符；template 的多态是通过函数重载解析在编译期完成的 42. 了解 typename 的双重意义 在使用 template 时，typename 和 class 意义完全相同。\ntemplate 中，在参数 class 内嵌套的变量称为嵌套从属名称 nested dependent name，不依赖任何参数的变量叫做非从属名称 non-dependent name。\n嵌套从属名称可能导致解析困难，编译器在解析时，如果遇到 template 中有一个嵌套从属名称，会便假设这个名称不是一个类型，例如：\ntemplate \u0026lt;typename T\u0026gt; void Foo(const T \u0026amp;t) { T::const_iterator iter(t.begin()); // Warning: Missing \u0026#39;typename\u0026#39; prior to dependent type name \u0026#39;T::const_iterator\u0026#39; } 编译器会假设 T::const_iterator 不是一个类型，所以会发出 warning，只需要在其前面加上关键字 typename 即可；但 typename 不能出现在基类列表中，也不能在成员初始列 member initialization list 中作为基类修饰符，例如：\ntemplate \u0026lt;typename T\u0026gt; class Derived: public Base\u0026lt;T\u0026gt;::Nested { // 基类列表中不嫩使用 typename public: explicit Derived(int x):Base\u0026lt;T\u0026gt;::Nested(x) { // 成员初始列中不能使用 typename typename Base\u0026lt;T\u0026gt;::Nested temp; // 在普通的嵌套从属名称前可以使用 typename } }; 43. 学会处理模板化基类内的名称 44. 将与参数无关的代码抽离 templates 8. 自定义 new 和 delete 49. 了解 new 的行为 当 operator new 无法满足内存分配的需求时，它会抛出异常；\n在 operator new 抛出异常之前，它会先调用错误处理函数 new-handler，可以使用 std::set_new_handler 来设置这个函数。\nc++ 11 operator new throwing (1) void* operator new (std::size_t size); nothrow (2) void* operator new (std::size_t size, const std::nothrow_t\u0026amp; nothrow_value) noexcept; placement (3) void* operator new (std::size_t size, void* ptr) noexcept; 一个设计良好的 new-handler 应该完成：\n可分配更多内存；否则调用另一个 new-handler，或抛出异常 捕获 bad_alloc，调用 abort 或 exit 50. 了解 new 和 delete 的合理替换时间 替换默认 operator new 和 operator delete 的理由：\n检测运行时错误 优化性能：提高分配和归还的速度，降低额外的空间开销，弥补非最佳对齐（suboptimal alignment） 统计数据 51. 编写 new 和 delete 的时候需要遵守规约 9. 杂项 Miscellany 53. 关注编译器警告 在编译时使用 -Wall -Wextra -Werror。\n54. 熟悉 TR1 和标准库内容 tr1 是 2007 年提出的对标准库的补充，包括了 shared_ptr, function, bind, unordered_map, unordered_set, regex, tuple, array, mem_fn, reference_wrapper 等函数和类，以及 type traits, result_of 等模板。\n55. 熟悉 boost ","permalink":"https://prov1dence.top/posts/cpp/basics/effective-cpp/","summary":"\u003ch1 id=\"effective-c-笔记\"\u003eEffective C++ 笔记\u003c/h1\u003e\n\u003ch2 id=\"0-导言\"\u003e0 导言\u003c/h2\u003e\n\u003ch3 id=\"1-构造函数\"\u003e1 构造函数\u003c/h3\u003e\n\u003cp\u003edefault 构造函数：可被调用而不带任何实参的构造函数，这样的构造函数要么没有参数，要么每个参数都带有默认值，例如\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eBar\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// explicit Bar(); // 是 default 构造函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#75715e\"\u003e// explicit Bar(int x = 0) // 不是 default 构造函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003eexplicit\u003c/span\u003e Bar(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e b \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true); \u003cspan style=\"color:#75715e\"\u003e// 是 default 构造函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eexplicit 关键字：阻止执行隐式类型转换，其优点是禁止了编译器执行非预期的类型转换，例如\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e(Bar obj); \u003cspan style=\"color:#75715e\"\u003e// Foo 函数的参数是一个类型为 Bar 的对象\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eBar obj_1; \u003cspan style=\"color:#75715e\"\u003e// 构造一个 Bar 类型的对象\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eFoo (obj_1); \u003cspan style=\"color:#75715e\"\u003e// 没问题，传递一个 Bar 类型的对象给 Foo 函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eFoo (Bar()); \u003cspan style=\"color:#75715e\"\u003e// 没问题，构造一个 Bar 类型的对象，并传递给 Foo 函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eFoo (\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 如果 Bar 的构造函数没有被声明为 explicit，那么会调用 Bar 的构造函数构造一个成员变量 x = 2 的对象，也就是说发生了隐式类型转换；如果其构造函数被声明为 explicit，那么就不会构造出 Bar 类型的对象\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ecopy 构造函数：用同类型的对象初始化新的对象，它定义了一个对象如何 pass by reference。\u003c/p\u003e","title":"Effective C++ notes"},{"content":"C++ 单例模式的模板实现 单例模式是一种创建型的设计模式（creational design patterns），使用单例模式进行设计的类在程序中只拥有一个实例（single instance），这个类称为单例类，它会提供一个全局的访问入口（global access point），关于单例模式的讨论可以参考Singleton revisited；基于这两个特点，单例模式可以有以下几种实现：\nMeyer’s Singleton Scott Meyers 在 Effective C++ 的 Item 4: Make sure that objects are initialized before they\u0026rsquo;re used 里面提出了一种利用 C++ 的 static 关键字来实现的单例模式，这种实现非常简洁高效，它的特点是：\n仅当程序第一次执行到 GetInstance 函数时，执行 instance 对象的初始化； 在 C++ 11 之后，被 static 修饰的变量可以保证是线程安全的； template\u0026lt;typename T\u0026gt; class Singleton { public: static T\u0026amp; GetInstance() { static T instance; return instance; } Singleton(T\u0026amp;\u0026amp;) = delete; Singleton(const T\u0026amp;) = delete; void operator= (const T\u0026amp;) = delete; protected: Singleton() = default; virtual ~Singleton() = default; }; 通过禁用单例类的 copy constructor，move constructor 和 operator= 可以防止类的唯一实例被拷贝或移动；不暴露单例类的 constructor 和 destructor 可以保证单例类不会通过其他途径被实例化，同时将两者定义为 protected 可以让其被子类继承并使用。\nLazy Singleton Lazy Singleton 是一种比较传统的实现方法，通过其名字可以看出来它也具有 lazy-evaluation 的特点，但在实现的时候需要考虑线程安全的问题：\ntemplate\u0026lt;typename T, bool is_thread_safe = true\u0026gt; class LazySingleton { private: static unique_ptr\u0026lt;T\u0026gt; t_; static mutex mtx_; public: static T\u0026amp; GetInstance() { if (is_thread_safe == false) { if (t_ == nullptr) t_ = unique_ptr\u0026lt;T\u0026gt;(new T); return *t_; } if (t_ == nullptr) { unique_lock\u0026lt;mutex\u0026gt; unique_locker(mtx_); if (t_ == nullptr) t_ = unique_ptr\u0026lt;T\u0026gt;(new T); return *t_; } } LazySingleton(T\u0026amp;\u0026amp;) = delete; LazySingleton(const T\u0026amp;) = delete; void operator= (const T\u0026amp;) = delete; protected: LazySingleton() = default; virtual ~LazySingleton() = default; }; template\u0026lt;typename T, bool is_thread_safe\u0026gt; unique_ptr\u0026lt;T\u0026gt; LazySingleton\u0026lt;T, is_thread_safe\u0026gt;::t_; template\u0026lt;typename T, bool is_thread_safe\u0026gt; mutex LazySingleton\u0026lt;T, is_thread_safe\u0026gt;::mtx_; 我们通过模板参数 is_thread_safe 来控制这个类是否是线程安全的，因为在某些场景下我们会希望每个线程拥有一个实例：\n当 is_thread_safe == false，即非线程安全时，我们在 GetInstance 函数中直接判断，初始化并返回单例对象；这里使用了 unique_ptr 防止线程销毁时发生内存泄漏，也可以在析构函数中销毁指针； 当 is_thread_safe == true 时，我们通过 double-checked locking 来进行检查并加锁，防止单例类在每个线程上都被实例化。 Eager Singleton 和 Lazy Singleton 相反，Eager Singleton 利用 static member variable 的特性，在程序进入 main 函数之前进行初始化，这样就绕开了线程安全的问题：\ntemplate\u0026lt;typename T\u0026gt; class EagerSingleton { private: static T* t_; public: static T\u0026amp; GetInstance() { return *t_; } EagerSingleton(T\u0026amp;\u0026amp;) = delete; EagerSingleton(const T\u0026amp;) = delete; void operator= (const T\u0026amp;) = delete; protected: EagerSingleton() = default; virtual ~EagerSingleton() = default; }; template\u0026lt;typename T\u0026gt; T* EagerSingleton\u0026lt;T\u0026gt;::t_ = new (std::nothrow) T; 但是它也有两个问题：\n即使单例对象不被使用，单例类对象也会进行初始化； static initialization order fiasco，即 t_ 对象和 GetInstance 函数的初始化先后顺序是不固定的； Testing 将上面实现的四种 Singleton 分别继承下来作为 functor 传入线程对象进行测试：\nclass Foo : public Singleton\u0026lt;Foo\u0026gt; { public: void operator() () { cout \u0026lt;\u0026lt; \u0026amp;GetInstance() \u0026lt;\u0026lt; endl; } }; class LazyFoo : public LazySingleton\u0026lt;LazyFoo, false\u0026gt; { public: void operator() () { cout \u0026lt;\u0026lt; \u0026amp;GetInstance() \u0026lt;\u0026lt; endl; } }; class ThreadSafeLazyFoo : public LazySingleton\u0026lt;ThreadSafeLazyFoo\u0026gt; { public: void operator() () { cout \u0026lt;\u0026lt; \u0026amp;GetInstance() \u0026lt;\u0026lt; endl; } }; class EagerFoo : public EagerSingleton\u0026lt;EagerFoo\u0026gt; { public: void operator() () { cout \u0026lt;\u0026lt; \u0026amp;GetInstance() \u0026lt;\u0026lt; endl; } }; void SingletonTest() { thread t1((Foo())); thread t2((Foo())); t1.join(); t2.join(); this_thread::sleep_for(chrono::milliseconds(100)); t1 = thread((LazyFoo())); t2 = thread((LazyFoo())); t1.join(); t2.join(); this_thread::sleep_for(chrono::milliseconds(100)); t1 = thread((ThreadSafeLazyFoo())); t2 = thread((ThreadSafeLazyFoo())); t1.join(); t2.join(); this_thread::sleep_for(chrono::milliseconds(100)); t1 = thread((EagerFoo())); t2 = thread((EagerFoo())); t1.join(); t2.join(); } 输出结果为：\n0x60d110 0x60d110 0x7f92380008c0 0x7f92300008c0 0x7f92300008e0 0x7f92300008e0 0x1132010 0x1132010 可以看到只有第二组非线程安全的 LazySingleton 在两个线程中输出的实例地址是不同的，其它的 Singleton 均是线程安全的。\n","permalink":"https://prov1dence.top/posts/design-pattern/c++-template-singleton/","summary":"\u003ch1 id=\"c-单例模式的模板实现\"\u003eC++ 单例模式的模板实现\u003c/h1\u003e\n\u003cp\u003e单例模式是一种创建型的设计模式（creational design patterns），使用单例模式进行设计的类在程序中只拥有一个实例（single instance），这个类称为单例类，它会提供一个全局的访问入口（global access point），关于单例模式的讨论可以参考\u003ca href=\"http://www.italiancpp.org/2017/03/19/singleton-revisited-eng/\"\u003eSingleton revisited\u003c/a\u003e；基于这两个特点，单例模式可以有以下几种实现：\u003c/p\u003e\n\u003ch2 id=\"meyers-singleton\"\u003eMeyer’s Singleton\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eScott Meyers\u003c/em\u003e 在 \u003cem\u003eEffective C++\u003c/em\u003e 的 \u003cem\u003eItem 4: Make sure that objects are initialized before they\u0026rsquo;re used\u003c/em\u003e 里面提出了一种利用 C++ 的 \u003ccode\u003estatic\u003c/code\u003e 关键字来实现的单例模式，这种实现非常简洁高效，它的特点是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e仅当程序第一次执行到 \u003ccode\u003eGetInstance\u003c/code\u003e 函数时，执行 \u003ccode\u003einstance\u003c/code\u003e 对象的初始化；\u003c/li\u003e\n\u003cli\u003e在 C++ 11 之后，被 \u003ccode\u003estatic\u003c/code\u003e 修饰的变量可以保证是线程安全的；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSingleton\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e GetInstance()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e T instance;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e instance;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Singleton(T\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Singleton(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprotected\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Singleton() \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edefault\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evirtual\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e~\u003c/span\u003eSingleton() \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edefault\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e通过禁用单例类的 copy constructor，move constructor 和 operator= 可以防止类的唯一实例被拷贝或移动；不暴露单例类的 constructor 和 destructor 可以保证单例类不会通过其他途径被实例化，同时将两者定义为 protected 可以让其被子类继承并使用。\u003c/p\u003e","title":"C++ 单例模式的模板实现"},{"content":"并行计算入门 1 概述 1.1 并行计算 高性能计算（High Performance Computing）是计算机科学中的一个领域，其目的可以概括为优化性能，它包括了缓存技术、数据结构和算法、IO 优化、指令重组（instruction reorganization）、编译器优化等；\n并行计算（Parallel Computing）是高性能计算下的一个细分领域，其主要思想是将复杂问题分解成若干个部分，将每一个部分交给独立的处理器（计算资源）进行计算，以提高效率；针对不同的问题，并行计算需要专用的并行架构，架构既可以是专门设计的，含有多个处理器的单一硬件或超级计算机，也可以是以某种方式互连的若干台的独立计算机构成的集群；并没有一个统一的并行计算架构适用于每一个问题，如果使用了错误的架构，并行计算甚至会导致性能下降。\n1.2 硬件架构 中央处理器（Central Processing Unit）的主要功能是解释计算机指令，它由控制单元（Control Unit）、算术逻辑单元（Arithmetic Logic Unit）、乱序控制单元（Out-of-Order Control Unit）、分支预测器（Branch Predictor）、数据缓存（Data Cache）等部件组成；CPU 被设计为可以快速地处理各种通用计算任务并最小化延迟，但在并发性（时钟频率）方面受到限制；\n图形处理器（Graphics Processing Unit, GPU）是英伟达（NVIDIA）在 1999 年 8 月发布 NVIDIA GeForce 256 时提出的概念；现代 GPU 的模型设计可以概括为几个关键点：\nGPU 的设计目的是最大化吞吐量（Throughput）\n能够将程序中数据可并行的部分从 CPU 转移到 GPU\n能够使用尽可能多的线程进行并行计算\nGPU 拥有的内核数量相较于 CPU 多得多，可以有数千个同时运行的内核执行大规模并行计算，因此在早期专门应用于图形数据的处理，但随着近十几年的发展，其强大的并行处理能力也使其可以处理非图形数据，尤其在深度学习领域非常受欢迎；\n在制造工艺的限制下，芯片的密度和最大面积都是有限的（摩尔定律），因此芯片设计实际上是功能和元件数量的权衡；出于对通用性的要求，CPU 的芯片设计必须使用较多种类的原件以增加其功能，同时放弃部分具有复杂功能的元件数量，而 GPU 的芯片设计则是通过移除部分具有复杂功能的元件来换取更多的空间，并集成更多的基本功能元件；\nGPU 设备由多个流多处理器（Streaming Multiprocessor）的处理器集群（Processor Cluster）组成。每个流多处理器都关联一个控制单元 和 L1 Cache，这样的设计使得一个芯片可以同时支持上百个指令流的并行执行；通常一个流多处理器在与全局 GDDR-5 内存交换数据之前都会利用与之关联 L1 Cache 和 L2 Cache 来减少数据传输的延迟；而又因为 GPU 通常拥有足够大的计算量，使得其不需要与 CPU 一样非常频繁地从内存中获取数据，因此 GPU 的缓存层一般是小于 CPU 的。\n与 CPU 相比，GPU 可以使用较少且相对较小的内存缓存层。原因是 GPU 具有更多的专用于计算的晶体管，这意味着它无需担心从内存中获取数据需要多长时间。只要 GPU 拥有足够的计算量，就可以掩盖潜在的内存访问 “等待时间”，从而使其保持繁忙状态。\n2 概念 2.1 访存模型 共享内存模型的的计算机中通常有非常多的内核，每个内核都有本地的处理器和缓存；相对的，在互联网络上或其它结点中的处理器和存储一般称为全局的；根据不同的互联网络和访问存储器的方式，一个共享内存机器可以被分为以下几类：\nUniform Memory Access\n均匀存储访问（Uniform Memory Access, UMA）模型的特点是所有的处理器都拥有本地的高速缓存（L1 Cache, L2 Cache），所有的处理器都均匀地共享物理存储（Memory），并且每一个处理器访问任何存储字都需要相同的时间。\nNon-Uniform Memory Access\n非均匀存储访问（Non-Uniform Memory Access, NUMA）模型的共享存储器在物理上是分布式的，所有的本地存储器构成了全局地址空间；处理器在访问本地存储器时的速度比访问全局存储器（共享存储器，或其他处理器的本地存储器）快，处理器访问内存的时间取决于内存相对于处理器的位置。\n不同的处理器访问共享存储器时，位置的不同会导致访问延迟。\nCache-Only Memory Architecture\n高速缓存存储结构（Cache-Only Memory Architecture, COMA）是将 NUMA 中的分布存储器换成了高速缓存，每个处理器上没有存储层次结构，所有的高速缓存共同构成了全局地址空间。\n2.2 Flynn 分类法 Flynn 分类法（Flynn\u0026rsquo;s Taxonomy）是一种高效能计算机的分类方式，他根据指令和数据的执行方式将计算机系统分成了四类：\n单指令单数据模型（Single Instruction Single Data, SISD）\n一般来说具有单核 CPU （不讨论超线程技术）的计算机就是基于单指令单数据模型的，对于每一个 CPU 时钟，CPU 按照 Fetch（从寄存器中获取数据），Decode（解码），Execute（执行并将结果保存在另一个寄存器中）的步骤顺序执行指令；上个世纪的计算机几乎都是 SISD 模型的。\n单指令多数据模型（Single Instruction Multi Data, SIMD）\n单个控制单元拥有多个处理器，这些处理器上运行的线程共享同一个指令流，实现了时间上的并行；GPU 就是典型的 SIMD 模型。\n多指令单数据模型（Multi Instruction Single Data, MISD）\n多个处理器分别拥有自己的控制单元并共享同一个内存单元，应用场景较少。\n多指令多数据模型（Multi Instruction Multi Data, MIMD）\n多个控制单元异步地控制多个处理器，同时处理器可以在不同的数据上运行不同的程序，一般通过线程或进程层面的并行来实现，从而实现空间上的并行。\n2.3 加速比 加速比\n加速比（Speedup）用于衡量我们现在使用的并行算法比串行算法快了多少，也就是将程序并行化之后提升的效率，其公式是：\n其中 p 代表 CPU 数量，T_1 代表使用串行算法的执行时间，T_p 代表当有 p 个处理器时使用并行算法的执行时间；当 S_p == p ，即 T_1 == p * T_p 时，S_p 称为线性加速比（Linear Speedup）。\n阿姆达尔定律\n阿姆达尔定律（Amdahl\u0026rsquo;s law）用于估计程序可以达到的最大加速比，W_s 和 W_p 分别表示程序串行部分和并行部分所占的百分比，W_s + W_p 表示程序串行执行的时间（此时并行部分 W_p 相当于被单个处理器执行），W_s + W_p/p 表示程序使用 p 个处理器执行的时间；当 p -\u0026gt; ∞ 时，其上限是 (W_s + W_p) / W_s。\nfor (int i = 0; i \u0026lt; 1000000000; ++i) std::this_thread::sleep_for(std::chrono::seconds(1)); // sequential for (int i = 0; i \u0026lt; 1000000000; ++i) std::this_thread::sleep_for(std::chrono::seconds(1)); // parallel 古斯塔夫森定律\n古斯塔夫森定律（Gustafson\u0026rsquo;s Law）通过使用 来描述加速比，p 代表处理器的数量，a 代表程序串行化的部分；\n阿姆达尔定律描述的是增加处理起的数量并不一定能提高加速比，只有增加程序并行部分的比例，才能提高加速比。\n古斯塔夫森定律描述的是随着程序并行化比例的提高，加速比与处理器个数成正比的比例（斜率）也在增加。\n性能\n性能（Efficiency）是由加速比派生出的量度性能的指标，它可以表示每个处理器的加速比，即每个处理器在这个算法中的利用率，其公式是：\n时钟加速比\nS(p) = t_s / t_p\n时钟加速比（Speedup in Wall-Clock Time）的公式很简单，用使用串行算法花费的时钟时间除以使用并行算法花费的时钟时间即可，但是因为时钟时间包括了网络延迟，IO，缓存争用等无关因素，所以它与加速比和算法的复杂度并不相关，只能用于粗略地衡量加速比。\n3 并行计算框架 3.1 OpenMP OpenMP（Open Multi-Processing）是一套针对多处理器共享内存机器进行多线程并行编程的 API，支持的语言有 C，C++ 和 Fortran，支持的编译器有现在主流的 GCC 和 Clang 等；\nOpenMP 提供了用于描述并行编程的高层抽象，使用 OpenMP 最大的好处在于，当我们没有在编译的时候加上 OpenMP 相关的选项，或当编译器不支持 OpenMp 时，程序仍然可以完成编译，并使用串行的流程正常地运行；这在很大程度上降低了并行编程的难度，使得我们可以把更多的精力投入到并行算法本身，而非其实现细节；尤其对基于数据集进行并行划分的程序，OpenMP是一个很好的选择。\nDirective 所有的 OpenMP 编程操作都是基于 #pragma omp 宏指令（directive）的，每个 directive 都会被转换为与其相应的 OpenMP 库函数调用，而 OpenMP 会处理与线程线程调用相关的操作，包括线程的 fork, join, synchronizing 等，下面是一个简单的例子：\n#include \u0026lt;omp.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { #pragma omp parallel { int tid{ omp_get_thread_num() }; printf(\u0026#34;Hello world from thread %d\\n\u0026#34;, tid); int thread_num{ omp_get_num_threads() }; if (tid == thread_num - 1) { printf(\u0026#34;tid: %d, thread_num: %d\\n\u0026#34;, tid, thread_num); } } return 0; } 注意链接的时候需要加上 -fopenmp，这是一个高层级的标志，其作用主要是链接 gomp 库（GCC 的 OpenMP 实现，如果使用 clang 进行编译则会链接 llvm 对应的实现，类似于 libstdc++ 和 libc++ 的区别），OpenMP 通常是基于 pthread 实现的，所以 gomp 库还会链接更多的库来使用操作系统的线程功能：\n[joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o openmp-case openmp-case.cpp -fopenmp [joelzychen@DevCloud ~/parallel-computing]$ ./openmp-case Hello world from thread 5 Hello world from thread 2 Hello world from thread 1 Hello world from thread 3 Hello world from thread 7 tid: 7, thread_num: 8 Hello world from thread 4 Hello world from thread 0 Hello world from thread 6 omp_get_thread_num() 和 omp_get_num_threads() 两个函数的名称非常直白，分别获取了当前线程的 ID（这个 ID 是 OpenMP 管理的，并不是 PID）和总的线程数；#pragma omp parallel 是最基本的 directive，它可以启动一组线程并让他们并行地执行，如果我们没有在使用 #pragma omp parallel 这个 directive 的时候指定线程数量，那么默认会启动等同于 CPU 核心数量的线程数；并且由于程序是并行地执行的，所以我们并不能保证程序执行的顺序；\nExample 再看一个例子：\n#include \u0026lt;omp.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; constexpr int thread_num = 3; using namespace std; int main() { std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); #pragma omp parallel for schedule(static) num_threads(thread_num) for (int i = 0; i \u0026lt; thread_num; ++i) std::this_thread::sleep_for(std::chrono::seconds(1)); std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; } [joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o openmp-case openmp-case.cpp -fopenmp [joelzychen@DevCloud ~/parallel-computing]$ ./openmp-case time: 1000 ms [joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o openmp-case openmp-case.cpp [joelzychen@DevCloud ~/parallel-computing]$ ./openmp-case time: 3000 ms 因为时间粒度只精确到了毫秒级，所以只能够看到大致的运行时间是 1s 和 3s；num_threads(thread_num) 用于指定线程数量，schedule(static) 用于指定将 for 循环中的迭代以静态的方式分配给多个线程，假设有 n 次循环迭代，t 个线程，那么将给每个线程静态地分配 n/t 次迭代进行运算。\nOpenMP 还提供了 barrier（等待所有线程执行完前面的所有计算），atomic（原子操作），flash（写入内存）等各种操作；关于 OpenMP 所有的函数和 directive 可以参考 OpenMP 4.5 API C/C++ Syntax Reference Guide。\n3.2 OpenMPI OpenMPI (Open Message Passing Interface) 是基于消息队列进行进程间通信的并行编程库，MPI 是一个跨语言的通信协议，OpenMPI 只是遵循这种协议的一种实现；在基于消息队列的并行编程模型中，每个进程都有一个独立的地址空间，一个进程不能直接访问其他进程中的数据，而只能通过消息传递的方式来实现进程间的通信，我们需要显式地通过发送和接受消息来实现处理器之间的数据交换；使用消息队列进行通信的开销比共享内存大，因此它主要用来进行大粒度并行编程的开发。\nAPI MPI 有几个最基础的函数，在每一个 MPI 并行程序中几乎都会用到这几个函数：\nint MPI_Init (int* argc ,char** argv[] )\n初始化 MPI 环境，一般是第一个被调用的 MPI 函数；\nint MPI_Finalize (void)\n终止 MPI 环境，一般是最后一个被调用的 MPI 函数；\nint MPI_Comm_size (MPI_Comm comm ,int* size )\n获取通信组进程的个数，MPI_Comm comm 是指定的 communicator，共享通信空间的一组进程组成了通信组，通信组中的所有进程由 communicator 管理；\nint MPI_Comm_rank (MPI_Comm comm ,int* rank)\n获取当前进程在通信组中的进程 ID，这个 ID 是由 communicator 管理的，不是 PID；\nExample 来看一个例子，尝试用 OpenMPI 解决 0-1 背包问题，假设物品的数量是 N，背包的容量是 C，第 i 个物品的重量是 weight[i]，价值为 value[i]，先用常规的线性 DP 解决：\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;omp.h\u0026gt; using namespace std; int main() { std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); fstream input_file(\u0026#34;input-knapsack.txt\u0026#34;); int N; int64_t Capacity; input_file \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Capacity; int64_t weight[N], value[N]; for (int i = 0; i \u0026lt; N; ++i) input_file \u0026gt;\u0026gt; weight[i] \u0026gt;\u0026gt; value[i]; vector\u0026lt;vector\u0026lt;int64_t\u0026gt;\u0026gt; dp(N + 1, vector\u0026lt;int64_t\u0026gt;(Capacity + 1)); for (int i = 0; i \u0026lt;= N; ++i) { #pragma omp parallel for for (int64_t j = 0; j \u0026lt;= Capacity; ++j) { if (i == 0 || j == 0) dp[i][j] = 0; else if (j \u0026lt; weight[i - 1]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); } } cout \u0026lt;\u0026lt; \u0026#34;max value: \u0026#34; \u0026lt;\u0026lt; dp[N][Capacity] \u0026lt;\u0026lt; endl; std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count() \u0026lt;\u0026lt; endl; return EXIT_SUCCESS; } 先用背包数据随机生成器（见附录）生成数据，然后编译运行，对比一下使用 OpenMPI 前后的结果：\n[joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o knapsack-generator knapsack-generator.cpp -lcrypto [joelzychen@DevCloud ~/parallel-computing]$ ./knapsack-generator 1000 8000 [joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o knapsack knapsack.cpp [joelzychen@DevCloud ~/parallel-computing]$ ./knapsack max value: 13093 time: 175 ms [joelzychen@DevCloud ~/parallel-computing]$ g++ -std=c++11 -g -o knapsack-openmp knapsack.cpp -fopenmp [joelzychen@DevCloud ~/parallel-computing]$ ./knapsack-openmp max value: 13093 time: 75 现在使用 OpenMPI 来改造 0-1 背包问题的 DP 解法：\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;mpi.h\u0026gt; using namespace std; int main(int argc, char *argv[]) { std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); MPI_Init(\u0026amp;argc, \u0026amp;argv); MPI_Comm comm = MPI_COMM_WORLD; int rank, size; MPI_Comm_rank(comm, \u0026amp;rank); MPI_Comm_size(comm, \u0026amp;size); MPI_Status status; // MPI receive MPI_Request request; // MPI send fstream input_file(\u0026#34;input-knapsack.txt\u0026#34;); int N; int64_t Capacity; if (rank == 0) input_file \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Capacity; MPI_Bcast(\u0026amp;N, 1, MPI_INT, 0, comm); MPI_Bcast(\u0026amp;Capacity, 1, MPI_LONG, 0, comm); MPI_Barrier(comm); int64_t weight[N], value[N]; if (rank == 0) for (int i = 0; i \u0026lt; N; ++i) input_file \u0026gt;\u0026gt; weight[i] \u0026gt;\u0026gt; value[i]; MPI_Bcast(weight, N, MPI_LONG, 0, comm); MPI_Bcast(value, N, MPI_LONG, 0, comm); MPI_Barrier(comm); vector\u0026lt;vector\u0026lt;int64_t\u0026gt;\u0026gt; dp(N + 1, vector\u0026lt;int64_t\u0026gt;(Capacity + 1)); int64_t prev_max_value; // mpi send and receive variable for (int i = 0; i \u0026lt;= N; ++i) // for each item from 0 to n { for (int64_t j = rank; j \u0026lt;= Capacity; j += size) // for each capacity from 0 to Capacity, each thread computes its own rows { if (i == 0 || j == 0) dp[i][j] = 0; else if (j \u0026lt; weight[i - 1]) dp[i][j] = dp[i - 1][j]; else { // int MPI_Recv(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status) MPI_Recv(\u0026amp;prev_max_value, 1, MPI_LONG, (j - weight[i - 1]) % size, i - 1, comm, \u0026amp;status); dp[i][j] = max(dp[i - 1][j], prev_max_value + value[i - 1]); } // send dp[i][j] to the next nodes that may need this curr_max_value if (i \u0026lt; N \u0026amp;\u0026amp; weight[i] + j \u0026lt;= Capacity) { // int MPI_Isend(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) MPI_Isend(\u0026amp;dp[i][j], 1, MPI_LONG, (j + weight[i]) % size, i, comm, \u0026amp;request); // asynchronous operation } } MPI_Barrier(MPI_COMM_WORLD); } MPI_Barrier(MPI_COMM_WORLD); if (rank == Capacity % size) printf(\u0026#34;max value: %ld\\n\u0026#34;, dp[N][Capacity]); if (rank == 0) { std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); printf(\u0026#34;time: %ld ms\\n\u0026#34;, std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count()); } MPI_Finalize(); return EXIT_SUCCESS; } 相比于 OpenMP，使用 OpenMPI 解决背包问题的过程非常复杂，首先要使用 rank == 0 的线程处理输入，然后将输入的 N, C 和 weight, value 数组都广播给其他线程，之后开始处理 dp 数组，动态规划的步骤分为以下几步：\n对于从 0 到 n 的每一件物品 i 串行执行；\n对于第 j 个线程（j = rank, 0 \u0026lt;= j \u0026lt; size），使其去处理对应的 capacity (capacity == j)，之后让 j += size 处理下一件；\ni == 0 或 j == 0 时初始化边界为 0；\n如果 j \u0026lt; weight[i - 1]，此时背包容量小于 weight[i - 1]，那么 dp[i][j] = dp[i - 1][j]；\n如果 j \u0026lt;= weight[i - 1]，此时背包容量大于等于 weight[i - 1]，那么此时 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1])，但是由于容量大小为 j - weight[i - 1] 时的 dp 结果（也就是 dp[i - 1][j - weight[i - 1]]）不一定是由第 j 个线程处理的，所以本地的 dp[i - 1][j - weight[i - 1]] 不一定含有正确的值，所以需要通过 mpi 从第 (j - weight[i - 1]) % size 个线程拿到对应的值（也就是 prev_max_value）之后再做处理；\n对于下一件物品，当背包容量为 j + weight[i] 时可能会用到当前的 dp 结果，因此需要将 dp[i][j] 发送给处理容量为 j + weight[i] 的第 (j + weight[i]) % size 个线程；\n最后处理结果时只需要让处理了 dp[N][Capacity] 的第 rank = Capacity % size 个线程输出即可；注意这个做法会有 bug，如果输入中的第 i 个物品的 weight[i] == 0，那么线程在等待 recv 的时候会从自己这个线程接收一个值，从而导致结果不对；\n使用 OpenMPI 前先要从官方网站下载源码并安装（或者通过 yum 安装），然后使用 mpic++ 进行编译，使用 mpirun 运行：\n[joelzychen@DevCloud ~/parallel-computing/openmpi]$ sudo find / -name \u0026#34;mpic++\u0026#34; /usr/lib64/openmpi/bin/mpic++ /usr/lib64/mpich/bin/mpic++ [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpic++ -g -std=c++11 -o knapsack-openmpi knapsack-openmpi.cpp [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpirun -n 1 ./knapsack-openmpi max value: 13093 time: 6694 ms [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpirun -n 2 ./knapsack-openmpi max value: 13093 time: 4863 ms [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpirun -n 4 ./knapsack-openmpi max value: 13093 time: 3674 ms [joelzychen@DevCloud ~/parallel-computing]$ /usr/lib64/mpich/bin/mpirun -n 8 ./knapsack-openmpi max value: 13093 time: 2487 ms 横向比较 OpenMPI 和 串行算法，在使用 OpenMPI 做 DP 的时候因为在消息传输中浪费了很多时间，其效率甚至不如串行算法；但如果使用穷举算法解 0-1 背包（在 OJ 里会超时的那种），再用 OpenMPI 优化的话，效率会有非常大的提升，有兴趣的同学可以自己了解一下；纵向比较开启不同线程数量的 OpenMPI 算法，我们在收发消息数量不变的情况下提升了同时进行运算的线程数量，因此明显地提高了效率；关于 OpenMPI 的所有函数可以查阅 Open MPI v4.0.4 documentation。\n3.3 CUDA CUDA 的全称是 Compute Unified Device Architecture，它是一个用于并行计算的平台和 API，它允许开发人员使用支持 CUDA 的 GPU 进行并行编程；GPU 并不能独立进行运算，它需要与 CPU 通过 PCIe 总线连接到一起协同进行工作，使用 GPU 进行的并行计算可以被视为是 CPU 和 GPU 的异构计算架构，CPU 负责处理逻辑复杂的串行部分，GPU 负责处理数据密集的并行部分，其中 CPU 通常被称为 host 主机端，GPU 通常被称为 device 设备端；\nKernel CUDA 中的 kernel 核函数是在 GPU 端并行执行的函数，这个函数只包含程序的并行部分，它会被 GPU 上的诸多线程并行执行；相比于 CPU 上的线程，GPU 上的线程更加轻量级，创建的成本更小，线程切换更灵活，进入 CUDA 核函数时程序可以定义非常多的虚拟线程，但能够并行执行的硬件线程数也是有限的；一般来说基于 CUDA 程序的执行流程如下：\nhost 端进行内存分配和数据初始化，执行程序串行部分 device 端进行内存分配，并从 host 端拷贝数据到 device 端 device 端调用并执行核函数，同时使用缓存提升效率 device 端将运算好的结果拷贝到 host 端上 device 端释放内存，等待下一次核函数调用 Thread Hierarchy CUDA 执行核函数的时候开启的线程拥有三层的层级结构：\ngrid\ngrid 是一个逻辑实体，可以理解为一个工作区，它运行在整个 GPU 上，同一个 grid 里的所有 thread 共享全局内存空间；\nthread block\nthread block 是一组并行执行的线程，一个 block 在单个 streaming multi-processor 中运行，即一个 block 中的所有 thread 都在这个流式多处理器中运行，它们可以通过共享内存或同步原语进行通信，位于不同的 block 中的 thread 一般来说不能互相通信和协作，每一个 block 都应该能够独立运行；\nthread\nthread 在 CUDA core 上执行，正如前文所说，GPU 上的线程非常轻量级，可以通过较大的寄存器提供非常快速的上下文切换（CPU 的线程句柄存在于较低的内存层次结构中，例如高速缓存）；\n我们在调用核函数的时候需要通过 \u0026lt;\u0026lt;\u0026lt;block, thread\u0026gt;\u0026gt;\u0026gt; 的方式来指定 block 和 thread 的数量和维度。\nExample 来看一个简单的例子，先串行地进行大约 10 亿次加法运算：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; constexpr uint64_t magic_number = 12345; void Add(int n, uint64_t *x) { for (int i = 0; i \u0026lt; n; ++i) x[i] += x[i]; } int main(void) { int n = 1\u0026lt;\u0026lt;30; uint64_t *x = (uint64_t *)malloc(n * sizeof(uint64_t)); memset(x, magic_number, sizeof(x)); std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); Add(n, x); std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; free(x); return 0; } 为了方便对比，在 Windows PowerShell 中使用 nvcc 编译运行：\nPS G:\\\u0026gt; nvcc -o add .\\add.cpp -ccbin \u0026#34;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\VC\\Tools\\MSVC\\14.16.27023\\bin\\Hostx64\\x64\u0026#34; add.cpp PS G:\\\u0026gt; .\\add.exe time: 4472 ms 可以看到 Add 函数串行执行的时间大约是 4472 ms，现在我们将其修改为使用 CUDA 的并行程序：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; constexpr int magic_number = 12345; __global__ void Add(int n, int *x) { for (int i = 0; i \u0026lt; n; ++i) x[i] += x[i]; } int main(void) { int n = 1\u0026lt;\u0026lt;30; int64_t byte_size = n * sizeof(int); int *x; x = (int*)malloc(byte_size); for (int i = 0; i \u0026lt; n; ++i) x[i] = magic_number; int *cuda_x; cudaMalloc((void**)\u0026amp;cuda_x, byte_size); // copy from host to device cudaMemcpy(cuda_x, x, byte_size, cudaMemcpyHostToDevice); std::chrono::steady_clock::time_point time_begin = std::chrono::steady_clock::now(); Add\u0026lt;\u0026lt;\u0026lt;1, 1\u0026gt;\u0026gt;\u0026gt;(n, cuda_x); cudaDeviceSynchronize(); std::chrono::steady_clock::time_point time_end = std::chrono::steady_clock::now(); // copy from device to host cudaMemcpy(x, cuda_x, byte_size, cudaMemcpyDeviceToHost); // check result bool result{ true }; for (uint32_t i = 0; i \u0026lt; n; ++i) result = (result \u0026amp;\u0026amp; (x[i] == magic_number + magic_number)); string result_str = (result ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;result: \u0026#34; \u0026lt;\u0026lt; result_str \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(time_end - time_begin).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; free(x); cudaFree(cuda_x); return 0; } PS G:\\\u0026gt; nvcc -o cuda-add .\\cuda-add.cu -ccbin \u0026#34;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\VC\\Tools\\MSVC\\14.16.27023\\bin\\Hostx64\\x64\u0026#34; cuda-add.cu Creating library cuda-add.lib and object cuda-add.exp PS G:\\\u0026gt; .\\cuda-add.exe result: true time: 21904 ms 可以看到 CUDA 程序里有一些特殊的关键字和 API：\n__global__ 是核函数的标志，只要在函数签名前加上 __global__ 它就可以被 CUDA 编译器分析为核函数；\n因为 Add 函数是在 device 端运行的，我们需要先使用 malloc 和 cudaMalloc 分别为 host 和 device 端分配内存，然后使用 cudaMemcpy 将在 host 端初始化的数据拷贝到 device 端；\n我们需要在 device 端调用 Add 核函数，这个操作对于 host 端来说是异步的，它不会等待 device 端的执行结果，我们需要调用 cudaDeviceSynchronize 函数来等待 device 端执行完毕并返回；如果我们连续调用了多个核函数，又没有在 device 端指定控制流，那么这些核函数只会在 device 端按顺序执行；\ndevice 端执行完之后，使用 cudaMemcpy 将数据从 device 端拷贝回 host 端进行验证；\n最后分别调用 free 和 cudaFree 来释放内存；\n我们的程序虽然跑在 GPU 上，但速度反而比跑在 CPU 上的时候更慢了，因为我们只为 kernel 分配了 1 个 block 和 1 个 thread (Add\u0026lt;\u0026lt;\u0026lt;1,1\u0026gt;\u0026gt;\u0026gt;(n, x);)，既没有发挥 GPU 并行计算的优势，又浪费了时间在 CPU 和 GPU 的交互上；优化的方法和 OpenMPI 中的例子类似，只需要让每个线程处理对应自己的数据，并在循环中每次自增一个步长：\n__global__ void Add(int n, int *cuda_x) { int index = blockIdx.x * blockDim.x + threadIdx.x; int stride = blockDim.x; for (int i = index; i \u0026lt; n; i += stride) cuda_x[i] += cuda_x[i]; } int main(void) { // ... Add\u0026lt;\u0026lt;\u0026lt;4096, 256\u0026gt;\u0026gt;\u0026gt;(n, cuda_x); // ... } 其中：\nblockIdx.x 代表 block 的 ID，即当前 block 的下标；\nblockDim.x 代表 block 的维度，即一个 block 内含有多少个 thread；同时也是步长 stride；\n类似的，threadIdx.x 代表 thread 的 ID，即当前 block 的下标；\nindex 是当前需要进行运算的数据在内存中的位置\n在这个例子中，我们开启了 4096 个 block 和 256 个 thread，即 blockIdx.x \u0026lt; 4096, blockDim.x == 256, threadIdx.x \u0026lt; 256；\n当然如果申请过多的 block 并不会提升运算的效率，因为 cuda core 会浪费许多时间来调度这些 block；我们可以多次修改 \u0026lt;\u0026lt;\u0026lt;block, thread\u0026gt;\u0026gt;\u0026gt; 来对比在使用不同数量的 block 和 thread 的情况下的性能：\n# Add\u0026lt;\u0026lt;\u0026lt;4096, 256\u0026gt;\u0026gt;\u0026gt;(n, x); PS G:\\\u0026gt; nvcc -o cuda-add .\\cuda-add.cu -ccbin \u0026#34;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\VC\\Tools\\MSVC\\14.16.27023\\bin\\Hostx64\\x64\u0026#34; cuda-add.cu Creating library cuda-add.lib and object cuda-add.exp PS G:\\\u0026gt; .\\cuda-add.exe result: true time: 159454 ms # Add\u0026lt;\u0026lt;\u0026lt;1, 256\u0026gt;\u0026gt;\u0026gt;(n, x); PS G:\\\u0026gt; .\\cuda-add.exe result: true time: 1038 ms # Add\u0026lt;\u0026lt;\u0026lt;1, 1024\u0026gt;\u0026gt;\u0026gt;(n, x); PS G:\\\u0026gt; .\\cuda-add.exe result: true time: 299 ms 关于 CUDA 的更多使用说明可以参考 CUDA Toolkit Documentation。\n4 总结 本文主要讲解了并行计算所依附的硬件架构及其相关的一些概念，通过 OpenMP, OpenMPI 和 CUDA 分别简单地介绍了基于共享内存，消息传递和 GPU（其实也是一种共享内存并行编程）三种方法的并行编程，关于并行计算的更多开发经验还需要在实践中积累。\n本文所有代码均收录在 https://github.com/chr1sc2y/parallel-computing-demo。\n5 附录 0-1 背包问题随机数据生成器 // knapsack-generator.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;openssl/rand.h\u0026gt; using namespace std; int main (int argc, char *argv[]) { if (argc \u0026lt; 3) { fprintf(stderr, \u0026#34;usage: %s N C\\n\u0026#34;, argv[0]); exit(1); } int N = stoi (argv[1]); uint64_t C = stoi (argv[2]); int m = 4 * C / N; unsigned char buff[2 * N]; RAND_seed(\u0026amp;m, sizeof(m)); RAND_bytes(buff, sizeof(buff)); ofstream file_stream; file_stream.open(\u0026#34;input-knapsack.txt\u0026#34;); file_stream \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; C \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; N; i++) { file_stream \u0026lt;\u0026lt; buff[2 * i] % m \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; buff[2 * i + 1] % m \u0026lt;\u0026lt; endl;; } file_stream.close(); return 0; } 参考文献 OpenMP 4.5 API C/C++ Syntax Reference Guide. (2020). Retrieved 10 August 2020, from https://www.openmp.org/wp-content/uploads/OpenMP-4.5-1115-CPP-web.pdf\nOpen MPI v4.0.4 documentation. (2020). Retrieved 10 August 2020, from https://www.open-mpi.org/doc/current/\nJiaoyun, Yang \u0026amp; Yun, Xu \u0026amp; Yi, Shang. (2010). An Efficient Parallel Algorithm for Longest Common Subsequence Problem on GPUs. Lecture Notes in Engineering and Computer Science. 1.\nCUDA Toolkit Documentation. (2020). Retrieved 10 August 2020, from https://docs.nvidia.com/cuda/\nHarwood, A., \u0026amp; Lanch, A. (2020). COMP90025 Parallel and Multicore. Retrieved 10 August 2020, from School of Computing and Information Systems The University of Melbourne\nZeller, C. (2011). CUDA C/C++ Basics Supercomputing. Retrieved 7 August 2020, from https://www.nvidia.com/docs/IO/116711/sc11-cuda-c-basics.pdf\nHan, J., \u0026amp; Sharma, B. Learn CUDA programming.\nRuetsch, G., \u0026amp; Oster, B. (2020). Getting Started with CUDA. Retrieved 10 August 2020, from https://www.nvidia.com/content/cudazone/download/Getting_Started_w_CUDA_Training_NVISION08.pdf\nHarris, M. (2017). An Even Easier Introduction to CUDA. Retrieved 10 August 2020, from https://developer.nvidia.com/blog/even-easier-introduction-cuda/\nModern Parallel Computing (Part 3) - Some Typical GPU Architectures · Infectious Waste. (2020). Retrieved 10 August 2020, from https://infectiouswaste.github.io/2019/02/20/typical-gpu-arch/\nCheng, J. (2014). Professional Cuda C programming. Indianapolis, IN: John Wiley and Sons, Inc.\nHarris, M., Ebersole, M., \u0026amp; Sakharnykh, N. (2020). Unified Memory in CUDA 6 | NVIDIA Developer Blog. Retrieved 10 August 2020, from https://developer.nvidia.com/blog/unified-memory-in-cuda-6/\n","permalink":"https://prov1dence.top/posts/parallel-computing/parallel-computing/","summary":"\u003ch1 id=\"并行计算入门\"\u003e并行计算入门\u003c/h1\u003e\n\u003ch2 id=\"1-概述\"\u003e1 概述\u003c/h2\u003e\n\u003ch3 id=\"11-并行计算\"\u003e1.1 并行计算\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e高性能计算\u003c/strong\u003e（High Performance Computing）是计算机科学中的一个领域，其目的可以概括为\u003cstrong\u003e优化性能\u003c/strong\u003e，它包括了缓存技术、数据结构和算法、IO 优化、指令重组（instruction reorganization）、编译器优化等；\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e并行计算\u003c/strong\u003e（Parallel Computing）是\u003cstrong\u003e高性能计算\u003c/strong\u003e下的一个细分领域，其主要思想是将复杂问题分解成若干个部分，将每一个部分交给独立的处理器（计算资源）进行计算，以提高效率；针对不同的问题，并行计算需要专用的并行架构，架构既可以是专门设计的，含有多个处理器的单一硬件或超级计算机，也可以是以某种方式互连的若干台的独立计算机构成的集群；并没有一个统一的并行计算架构适用于每一个问题，如果使用了错误的架构，并行计算甚至会导致性能下降。\u003c/p\u003e\n\u003ch3 id=\"12-硬件架构\"\u003e1.2 硬件架构\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e中央处理器\u003c/strong\u003e（Central Processing Unit）的主要功能是解释计算机指令，它由\u003cstrong\u003e控制单元\u003c/strong\u003e（Control Unit）、\u003cstrong\u003e算术逻辑单元\u003c/strong\u003e（Arithmetic Logic Unit）、\u003cstrong\u003e乱序控制单元\u003c/strong\u003e（Out-of-Order Control Unit）、\u003cstrong\u003e分支预测器\u003c/strong\u003e（Branch Predictor）、\u003cstrong\u003e数据缓存\u003c/strong\u003e（Data Cache）等部件组成；\u003cstrong\u003eCPU\u003c/strong\u003e 被设计为可以快速地处理各种通用计算任务并最小化延迟，但在并发性（时钟频率）方面受到限制；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"cpu\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/parallel-computing/cpu.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e图形处理器\u003c/strong\u003e（Graphics Processing Unit, GPU）是英伟达（NVIDIA）在 1999 年 8 月发布 \u003ca href=\"https://zh.wikipedia.org/wiki/NVIDIA_GeForce_256\"\u003eNVIDIA GeForce 256\u003c/a\u003e 时提出的概念；现代 GPU 的模型设计可以概括为几个关键点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eGPU 的设计目的是最大化吞吐量（Throughput）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e能够将程序中数据可并行的部分从 CPU 转移到 GPU\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e能够使用尽可能多的线程进行并行计算\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eGPU\u003c/strong\u003e 拥有的\u003cstrong\u003e内核\u003c/strong\u003e数量相较于 CPU 多得多，可以有数千个同时运行的内核执行大规模并行计算，因此在早期专门应用于图形数据的处理，但随着近十几年的发展，其强大的并行处理能力也使其可以处理非图形数据，尤其在\u003cstrong\u003e深度学习\u003c/strong\u003e领域非常受欢迎；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"gpu\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/parallel-computing/gpu.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在制造工艺的限制下，芯片的密度和最大面积都是有限的（\u003ca href=\"%5Bhttps://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B%5D(https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B)\"\u003e摩尔定律\u003c/a\u003e），因此芯片设计实际上是功能和元件数量的权衡；出于对通用性的要求，\u003cstrong\u003eCPU\u003c/strong\u003e 的芯片设计必须使用较多种类的原件以增加其功能，同时放弃部分具有复杂功能的元件数量，而 \u003cstrong\u003eGPU\u003c/strong\u003e 的芯片设计则是通过移除部分具有复杂功能的元件来换取更多的空间，并集成更多的基本功能元件；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"process\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/parallel-computing/process.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGPU\u003c/strong\u003e 设备由多个\u003cstrong\u003e流多处理器\u003c/strong\u003e（Streaming Multiprocessor）的\u003cstrong\u003e处理器集群\u003c/strong\u003e（Processor Cluster）组成。每个\u003cstrong\u003e流多处理器\u003c/strong\u003e都关联一个\u003cstrong\u003e控制单元\u003c/strong\u003e 和 L1 Cache，这样的设计使得一个芯片可以同时支持上百个指令流的并行执行；通常一个\u003cstrong\u003e流多处理器\u003c/strong\u003e在与全局 GDDR-5 内存交换数据之前都会利用与之关联 L1 Cache 和 L2 Cache 来减少数据传输的延迟；而又因为 \u003cstrong\u003eGPU\u003c/strong\u003e 通常拥有足够大的计算量，使得其不需要与 \u003cstrong\u003eCPU\u003c/strong\u003e 一样非常频繁地从内存中获取数据，因此 \u003cstrong\u003eGPU\u003c/strong\u003e 的缓存层一般是小于 \u003cstrong\u003eCPU\u003c/strong\u003e 的。\u003c/p\u003e","title":"并行计算入门"},{"content":"boost::typeIndex 的相关探究 Effective Modern C++ 的 Item 4: Know how to view deduced types. 中提到了 Boost::typeindex 的使用，但并没有讲到其实现原理。\n1. typeid 操作符 typeid 是 C++ 中的一个操作符，可以用于获取类型的信息，常常用在必须知道多态对象的动态类型，或是识别静态类型的地方。\n我们可以写一个简单的 demo 用于获取对象类型相关的信息，需要包含 tepyinfo 头文件：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; using namespace std; class Foo {}; int main() { cout \u0026lt;\u0026lt; \u0026#34;1: \u0026#34; \u0026lt;\u0026lt; typeid(1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; typeid(int).name() \u0026lt;\u0026lt; endl; // 和 sizeof 操作符类似，typeid 也可以直接对数据类型（比如 int）进行操作 cout \u0026lt;\u0026lt; \u0026#34;typeid: \u0026#34; \u0026lt;\u0026lt; typeid(typeid(int)).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;typeid: \u0026#34; \u0026lt;\u0026lt; typeid(const type_info \u0026amp;).name() \u0026lt;\u0026lt; endl; const Foo *foo = new Foo(); cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; typeid(foo).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;*foo: \u0026#34; \u0026lt;\u0026lt; typeid(*foo).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Foo: \u0026#34; \u0026lt;\u0026lt; typeid(Foo).name() \u0026lt;\u0026lt; endl; } [joelzychen@DevCloud ~/typeid]$ g++ -std=c++11 -otypeid_test typeid_test.cpp [joelzychen@DevCloud ~/typeid]$ ./typeid_test 1: i int: i typeid: N10__cxxabiv123__fundamental_type_infoE typeid: St9type_info foo: PK3Foo *foo: 3Foo Foo: 3Foo std::type_info::name() 函数返回的字符串中，在 GCC 和 Clang 的实现里一般 i 代表 int，P 代表 pointer，K 代表 const，数字用于标识其后跟随了几个字符；我们可以将这段代码使用微软的 MSVC 编译运行，得到更加直观的输出：\n1: int int: int typeid: class type_info typeid: class type_info foo: class Foo const * *foo: class Foo Foo: class Foo 可以看到大多数结果都与我们的预期相符，但在调用 typeid(const type_info \u0026amp;).name() 返回的结果却不是我们所期望的 const type_info \u0026amp;，其中的 const 和 reference 特性并没有得到保留；再举一个简单的例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; static void PrintType(const T \u0026amp;t) { std::cout \u0026lt;\u0026lt; \u0026#34;T: \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;t: \u0026#34; \u0026lt;\u0026lt; typeid(t).name() \u0026lt;\u0026lt; std::endl; } int main() { const int *p_i; PrintType(p_i); } [joelzychen@DevCloud ~/typeid]$ g++ -std=c++11 -otypeid_test typeid_test.cpp [joelzychen@DevCloud ~/typeid]$ ./typeid_test T: PKi t: PKi PrintType 这个模板接收到的 T 的确是 PKi（const int*）类型，但和之前的例子类似，t 的 const reference 特性并没有得到保留\n2. 使用 boost::typeindex::type_id_with_cvr 代替 typeid boost 库中有一个类似于 typeid 操作符的函数 boost::typeindex::type_id_with_cvr 可以用于获取对象类型，我们可以利用这个模板函数来获取更精确的类型：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; #include \u0026lt;boost/type_index.hpp\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; static void PrintType(const T \u0026amp;t) { cout \u0026lt;\u0026lt; \u0026#34;T: \u0026#34; \u0026lt;\u0026lt; boost::typeindex::type_id_with_cvr\u0026lt;T\u0026gt;().pretty_name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;t: \u0026#34; \u0026lt;\u0026lt; boost::typeindex::type_id_with_cvr\u0026lt;decltype(t)\u0026gt;().pretty_name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;typeid: \u0026#34; \u0026lt;\u0026lt; boost::typeindex::type_id_with_cvr\u0026lt;decltype(typeid(int))\u0026gt;().pretty_name() \u0026lt;\u0026lt; endl; } int main() { const int *p_i{ nullptr }; PrintType(p_i); } [joelzychen@DevCloud ~/typeid]$ g++ -std=c++11 -otypeid_test typeid_test.cpp -I/usr/include/boost-1.73.0/gcc-head/include [joelzychen@DevCloud ~/typeid]$ ./typeid_test T: int const* t: int const* const\u0026amp; typeid: std::type_info const\u0026amp; 可以看到 typeid 真正的返回值类型是 std::type_info const\u0026amp;，boost::typeindex::type_id_with_cvr 通过某种机制保留了其 const 和 reference 的特性并通过 pretty_name() 函数将结果转换成了字符串进行输出；和 typeid 操作符不同的是， type_id_with_cvr 函数只能接收模板参数类型或通过 decltype 推导出的类型，而不能接收一个变量。\n3 type_id_with_cvr() 的实现 type_id_with_cvr 这个模板函数定义在 boost/type_index.hpp 中，它实际上是调用了 stl_type_index 类的静态模板函数 type_id_with_cvr：\n// boost/type_index.hpp namespace boost { namespace typeindex { template \u0026lt;class T\u0026gt; inline type_index type_id_with_cvr() BOOST_NOEXCEPT { return type_index::type_id_with_cvr\u0026lt;T\u0026gt;(); } } // boost/type_index/stl_type_index.hpp namespace boost { class stl_type_index : public type_index_facade\u0026lt;stl_type_index, std::type_info\u0026gt; // 省略了 BOOST_NO_STD_TYPEINFO 宏的判断 { public: typedef std::type_info type_info_t; // 省略了 BOOST_NO_STD_TYPEINFO 宏的判断 private: const type_info_t* data_; public: inline stl_type_index(const type_info_t\u0026amp; data) BOOST_NOEXCEPT : data_(\u0026amp;data) // 利用 typeid 操作符返回的 const type_info_t\u0026amp; 对象进行构造 {} template \u0026lt;class T\u0026gt; inline static stl_type_index type_id_with_cvr() BOOST_NOEXCEPT; } } boost::typeindex::type_id_with_cvr 函数将其第二个模板参数 detail::cvr_saver\u0026lt;T\u0026gt; 作为实参调用了 typeid 操作符，并利用返回的 const type_info_t\u0026amp; 对象构造了 stl_type_index 对象；\ndetail::cvr_saver 是一个空的模板类，只带有模板参数 \u0026lt;class T\u0026gt; 的信息，可以利用 typeid 来获取这个特例化模板类的 type_info。\n// boost/type_index/stl_type_index.hpp namespace boost { template \u0026lt;class T\u0026gt; inline stl_type_index stl_type_index::type_id_with_cvr() BOOST_NOEXCEPT { typedef BOOST_DEDUCED_TYPENAME boost::conditional\u0026lt; boost::is_reference\u0026lt;T\u0026gt;::value || boost::is_const\u0026lt;T\u0026gt;::value || boost::is_volatile\u0026lt;T\u0026gt;::value, detail::cvr_saver\u0026lt;T\u0026gt;, T \u0026gt;::type type; // 等价于 using type = boost::conditional\u0026lt;...\u0026gt; return typeid(type); } } // boost/type_traits/conditional.hpp namespace detail { template \u0026lt;class T\u0026gt; class cvr_saver{}; } namespace boost { template \u0026lt;bool b, class T, class U\u0026gt; struct conditional { typedef T type; }; } 4 class stl_type_facade class type_index_facade 是 class stl_type_index 的基类，其源码在 type_index_facade.hpp 文件中，使用了门面模式的设计：\n// boost/type_index/stl_type_index.hpp // 将派生类 Derived 作为模板参数 template \u0026lt;class Derived, class TypeInfo\u0026gt; class type_index_facade { public: typedef TypeInfo type_info_t; // 调用子类的 raw_name()，没有使用虚函数的方式，而是利用模板实现了静态多态 inline const char* name() const BOOST_NOEXCEPT { return derived().raw_name(); } // 返回 human-readable 的字符串，调用子类的 name() inline std::string pretty_name() const { return derived().name(); } // 比较派生类的 raw_name()，需要派生类实现 raw_name() 函数 inline bool equal(const Derived\u0026amp; rhs) const BOOST_NOEXCEPT { const char* const left = derived().raw_name(); const char* const right = rhs.raw_name(); return left == right || !std::strcmp(left, right); } // 比较派生类的 raw_name()，需要派生类实现 raw_name() 函数 inline bool before(const Derived\u0026amp; rhs) const BOOST_NOEXCEPT { const char* const left = derived().raw_name(); const char* const right = rhs.raw_name(); return left != right \u0026amp;\u0026amp; std::strcmp(left, right) \u0026lt; 0; } // 获取一个类型的哈希值，默认对派生类的 raw_name() 进行哈希 inline std::size_t hash_code() const BOOST_NOEXCEPT { const char* const name_raw = derived().raw_name(); return boost::hash_range(name_raw, name_raw + std::strlen(name_raw)); } } 除此之外，class type_index_facade 基类还重载了各类对比操作符，输出流操作符和类的哈希值算法：\n// boost/type_index/stl_type_index.hpp // 省略了其它类型的对比操作符 template \u0026lt;class Derived, class TypeInfo\u0026gt; inline bool operator == (const TypeInfo\u0026amp; lhs, const type_index_facade\u0026lt;Derived, TypeInfo\u0026gt;\u0026amp; rhs) BOOST_NOEXCEPT { return Derived(lhs) == rhs;\t// 需要派生类实现以 const TypeInfo\u0026amp; 作为参数的构造函数 } // 重载输出流操作符 template \u0026lt;class CharT, class TriatT, class Derived, class TypeInfo\u0026gt; inline std::basic_ostream\u0026lt;CharT, TriatT\u0026gt;\u0026amp; operator\u0026lt;\u0026lt;( std::basic_ostream\u0026lt;CharT, TriatT\u0026gt;\u0026amp; ostr, const type_index_facade\u0026lt;Derived, TypeInfo\u0026gt;\u0026amp; ind) { ostr \u0026lt;\u0026lt; static_cast\u0026lt;Derived const\u0026amp;\u0026gt;(ind).pretty_name(); return ostr; } // 类的哈希值算法 template \u0026lt;class Derived, class TypeInfo\u0026gt; inline std::size_t hash_value(const type_index_facade\u0026lt;Derived, TypeInfo\u0026gt;\u0026amp; lhs) BOOST_NOEXCEPT { return static_cast\u0026lt;Derived const\u0026amp;\u0026gt;(lhs).hash_code(); } 如果想要进行 class type_index_facade 基类的全部操作，还需要派生类至少实现至少以下两个函数：\nraw_name()，基类的很多函数都依赖于派生类的这个函数 Derived(const TypeInfo\u0026amp;)，即以 const TypeInfo\u0026amp; 作为参数的构造函数，用于与 TypeInfo 对象进行对比 5 class type_type_index stl_type_index 是 stl_type_facade 的派生类，它的私有成员变量的类型 type_info_t 是通过 typedef 定义出来的，BOOST_NO_STD_TYPEINFO 是意义是编译器的 namespace std 下没有 type_info 这个类型，这时会将全局命名空间的 type_info 定义为 type_info_t 。\npublic: #ifdef BOOST_NO_STD_TYPEINFO typedef type_info type_info_t; #else typedef std::type_info type_info_t; #endif private: const type_info_t* data_; 为了方便理解暂时省略 BOOST_NO_STD_TYPEINFO 宏的定义；派生类 stl_type_index 的声明大致如下：\nclass stl_type_index : public type_index_facade\u0026lt;stl_type_index, std::type_info\u0026gt; { public: typedef std::type_info type_info_t; private: const type_info_t* data_; // 唯一的私有成员 const type_info_t* public: inline stl_type_index() BOOST_NOEXCEPT : data_(\u0026amp;typeid(void)) {} inline stl_type_index(const type_info_t\u0026amp; data) BOOST_NOEXCEPT : data_(\u0026amp;data) // 以 const TypeInfo\u0026amp; 作为参数的构造函数，对比操作符和 type_id_with_cvr() 函数都依赖于这个构造函数 {} inline const type_info_t\u0026amp; type_info() const BOOST_NOEXCEPT; // 获取私有成员数据 inline const char* raw_name() const BOOST_NOEXCEPT; // raw_name() 函数 inline const char* name() const BOOST_NOEXCEPT; inline std::string pretty_name() const; inline std::size_t hash_code() const BOOST_NOEXCEPT; inline bool equal(const stl_type_index\u0026amp; rhs) const BOOST_NOEXCEPT; inline bool before(const stl_type_index\u0026amp; rhs) const BOOST_NOEXCEPT; template \u0026lt;class T\u0026gt; inline static stl_type_index type_id() BOOST_NOEXCEPT; template \u0026lt;class T\u0026gt; inline static stl_type_index type_id_with_cvr() BOOST_NOEXCEPT; template \u0026lt;class T\u0026gt; inline static stl_type_index type_id_runtime(const T\u0026amp; value) BOOST_NOEXCEPT; }; 派生类 stl_type_index 的 equal, before, hash_code 的实现都和基类类似，操作的对象都是 raw_name()：\ninline std::size_t stl_type_index::hash_code() const BOOST_NOEXCEPT { #ifdef BOOST_TYPE_INDEX_STD_TYPE_INDEX_HAS_HASH_CODE return data_-\u0026gt;hash_code(); #else return boost::hash_range(raw_name(), raw_name() + std::strlen(raw_name())); #endif } inline bool stl_type_index::equal(const stl_type_index\u0026amp; rhs) const BOOST_NOEXCEPT { #ifdef BOOST_TYPE_INDEX_CLASSINFO_COMPARE_BY_NAMES return raw_name() == rhs.raw_name() || !std::strcmp(raw_name(), rhs.raw_name()); #else return !!(*data_ == *rhs.data_); #endif } inline bool stl_type_index::before(const stl_type_index\u0026amp; rhs) const BOOST_NOEXCEPT { #ifdef BOOST_TYPE_INDEX_CLASSINFO_COMPARE_BY_NAMES return raw_name() != rhs.raw_name() \u0026amp;\u0026amp; std::strcmp(raw_name(), rhs.raw_name()) \u0026lt; 0; #else return !!data_-\u0026gt;before(*rhs.data_); #endif } name() 和 raw_name() 都调用了私有成员的 name() 函数，即 std::type_info::name()：\ninline const char* stl_type_index::raw_name() const BOOST_NOEXCEPT { #ifdef _MSC_VER // 不同编译器对 typeid 的实现不同，因此 boost 库在进行封装时同时实现了 raw_name() 和 name() 两个函数 return data_-\u0026gt;raw_name(); #else return data_-\u0026gt;name(); #endif } inline const char* stl_type_index::name() const BOOST_NOEXCEPT { return data_-\u0026gt;name(); } 在第 2 部分中调用的 pretty_name() 函数原型如下：\ninline std::string stl_type_index::pretty_name() const { static const char cvr_saver_name[] = \u0026#34;boost::typeindex::detail::cvr_saver\u0026lt;\u0026#34;; static BOOST_CONSTEXPR_OR_CONST std::string::size_type cvr_saver_name_len = sizeof(cvr_saver_name) - 1; // 对于 GCC 和 Clang，demangled_name 函数会去执行解码操作；而对于 MSVC，因为通过 std::type_info::name() 获取的就是已经解码后的字符串，因此函数里不再进行解码 const boost::core::scoped_demangled_name demangled_name(data_-\u0026gt;name()); // begin 是通过 demangled_name.get() 获取到的 svr_saver 类型对象的全文，用 GDB 断点到此处打印出来可以看到其字符串内容 // (gdb) p begin // $1 = 0x605010 \u0026#34;boost::typeindex::detail::cvr_saver\u0026lt;int const\u0026gt; ()\u0026#34; const char* begin = demangled_name.get(); if (!begin) { boost::throw_exception(std::runtime_error(\u0026#34;Type name demangling failed\u0026#34;)); } const std::string::size_type len = std::strlen(begin); const char* end = begin + len; // 字符串对比，裁剪两边多余的字符 if (len \u0026gt; cvr_saver_name_len) { const char* b = std::strstr(begin, cvr_saver_name); if (b) { b += cvr_saver_name_len; // Trim leading spaces while (*b == \u0026#39; \u0026#39;) { // the string is zero terminated, we won\u0026#39;t exceed the buffer size ++ b; } // Skip the closing angle bracket const char* e = end - 1; while (e \u0026gt; b \u0026amp;\u0026amp; *e != \u0026#39;\u0026gt;\u0026#39;) { -- e; } // Trim trailing spaces while (e \u0026gt; b \u0026amp;\u0026amp; *(e - 1) == \u0026#39; \u0026#39;) { -- e; } if (b \u0026lt; e) { // Parsing seems to have succeeded, the type name is not empty begin = b; end = e; } } } return std::string(begin, end); } 至此就了解了除了 demangled_name 函数以外的所有实现细节了，不难理解其实 stl_type_index 这个类就是对 std::type_info 类的封装，type_id_with_cvr 和 pretty_name 两个函数分别细化了 typeid 操作符和 std::type_info::name() 函数。\n","permalink":"https://prov1dence.top/posts/cpp/boost/boost-typeindex/","summary":"\u003ch2 id=\"boosttypeindex-的相关探究\"\u003eboost::typeIndex 的相关探究\u003c/h2\u003e\n\u003cp\u003eEffective Modern C++ 的 Item 4: Know how to view deduced types. 中提到了 \u003ccode\u003eBoost::typeindex\u003c/code\u003e 的使用，但并没有讲到其实现原理。\u003c/p\u003e\n\u003ch2 id=\"1-typeidhttpsencppreferencecomwcpplanguagetypeid-操作符\"\u003e1. \u003ca href=\"https://en.cppreference.com/w/cpp/language/typeid\"\u003etypeid\u003c/a\u003e 操作符\u003c/h2\u003e\n\u003cp\u003etypeid 是 C++ 中的一个操作符，可以用于获取类型的信息，常常用在必须知道多态对象的动态类型，或是识别静态类型的地方。\u003c/p\u003e\n\u003cp\u003e我们可以写一个简单的 demo 用于获取对象类型相关的信息，需要包含 \u003ccode\u003etepyinfo\u003c/code\u003e 头文件：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;typeinfo\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eusing\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enamespace\u003c/span\u003e std;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e {};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;1: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etypeid\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e).name() \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;int: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etypeid\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e).name() \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl; \u003cspan style=\"color:#75715e\"\u003e// 和 sizeof 操作符类似，typeid 也可以直接对数据类型（比如 int）进行操作\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;typeid: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etypeid\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003etypeid\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e)).name() \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;typeid: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etypeid\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e type_info \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e).name() \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Foo \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003efoo \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Foo();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;foo: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etypeid\u003c/span\u003e(foo).name() \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;*foo: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etypeid\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003efoo).name() \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Foo: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etypeid\u003c/span\u003e(Foo).name() \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ejoelzychen@DevCloud ~/typeid\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e$ g++ -std\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ec++11 -otypeid_test typeid_test.cpp \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003ejoelzychen@DevCloud ~/typeid\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e$ ./typeid_test \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e1: i\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eint: i\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etypeid: N10__cxxabiv123__fundamental_type_infoE\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etypeid: St9type_info\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efoo: PK3Foo\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e*foo: 3Foo\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eFoo: 3Foo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003estd::type_info::name()\u003c/code\u003e 函数返回的字符串中，在 GCC 和 Clang 的实现里一般 i 代表 int，P 代表 pointer，K 代表 const，数字用于标识其后跟随了几个字符；我们可以将这段代码使用微软的 MSVC 编译运行，得到更加直观的输出：\u003c/p\u003e","title":"boost::typeIndex 的相关探究"},{"content":"CMake 入门 0. 序 CMake 是一个跨平台的开源构建工具，使用 CMake 能够方便地管理依赖多个库的目录层次结构并生成 makefile 和使用 GNU make 来编译和连接程序。\n1. 构建单个文件 1.1 使用 GCC 编译 假设现在我们希望编写一个函数来实现安全的 int 类型加法防止数据溢出，这个源文件没有任何依赖的源码或静态库：\n// safe_add.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #define INT_MAX 2147483647 #define ERROR_DATA_OVERFLOW 2 int SafeIntAdd(std::unique_ptr\u0026lt;int\u0026gt; \u0026amp;sum, int a, int b) { if (a \u0026gt; INT_MAX - b) { *sum = INT_MAX; return ERROR_DATA_OVERFLOW; } *sum = a + b; return EXIT_SUCCESS; } int main() { int a, b; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; std::unique_ptr\u0026lt;int\u0026gt; sum(new int(1)); int res = SafeIntAdd(sum, a, b); std::cout \u0026lt;\u0026lt; *sum \u0026lt;\u0026lt; std::endl; return res; } 我们可以直接使用一句简单的 gcc 命令来编译这个文件并执行：\n[joelzychen@DevCloud ~/cmake-tutorial]$ g++ main.cc -g -Wall -std=c++11 -o SafeIntAdd [joelzychen@DevCloud ~/cmake-tutorial]$ ./SafeIntAdd 2100000000 2100000000 2147483647 1.2 使用 cmake 构建 如果要使用 cmake 来生成 makefile 的话我们需要首先新建一个 CMakeLists.txt 文件，cmake 的所有配置都在这个文件中完成，CMakeLists.txt 中的内容大致如下：\ncmake_minimum_required(VERSION 3.10) project(SafeIntAdd) set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_CXX_FLAGS -g -Wall) message(STATUS \u0026#34;CMAKE_CXX_FLAGS: \u0026#34; \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;) string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;) message(STATUS \u0026#34;CMAKE_CXX_FLAGS: \u0026#34; \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;) add_executable(SafeIntAdd main.cc) 其中有一些基础的 cmake 指令，它们的含义如下：\ncmake_minimum_required：cmake 的最低版本要求 project：指定项目的名称 set：设置普通变量，缓存变量或环境变量，上面例子中的 add_executable：使用列出的源文件构建可执行文件 有几个需要注意的点：\ncmake 的指令是不区分大小写的，写作 CMAKE_MINIMUM_REQUIRED 或 cmake_minimum_required，甚至是 cmAkE_mInImUm_rEquIrEd（不建议）都是可以的\n在使用 set 指令指定 CMAKE_CXX_FLAGS 的时候通过空格来分隔多个编译选项，生成的 CMAKE_CXX_FLAGS 字符串是 \u0026ldquo;-g;-Wall\u0026rdquo;，需要用字符串替换将分号替换为空格\nmessage 可以在构建的过程中向 stdout 输出一些信息，上面例子中的输出信息为：\n-- CMAKE_CXX_FLAGS: -g;-Wall -- CMAKE_CXX_FLAGS: -g -Wall 类似于 bash 脚本，在 CMakeLists.txt 中输出变量时要使用 \u0026ldquo;${CMAKE_CXX_FLAGS}\u0026rdquo; 的形式，而不能直接使用 CMAKE_CXX_FLAGS\n编辑好 CMakeLists.txt 之后，我们可以新建一个 build 目录，并在 build 目录下使用 cmake 来进行构建，构建成功的话再使用 make 来进行编译和链接，最终得到 SafeAdd 这个可执行文件：\n[joelzychen@DevCloud ~/cmake-tutorial]$ mkdir build/ [joelzychen@DevCloud ~/cmake-tutorial]$ cd build/ [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake .. -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- CMAKE_CXX_FLAGS: -g;-Wall -- CMAKE_CXX_FLAGS: -g -Wall -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target SafeIntAdd [ 50%] Building CXX object CMakeFiles/SafeIntAdd.dir/main.cc.o [100%] Linking CXX executable SafeIntAdd [100%] Built target SafeIntAdd [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./SafeIntAdd 2100000000 2100000000 2147483647 2. 构建多个文件 2.1 使用 GCC 编译 假设现在我们希望将加法函数放到单独的文件中去，并在 main 函数所在的源文件中包含这个文件：\n// main.cc #include \u0026#34;math.h\u0026#34; #include \u0026#34;error_code.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { int a{ 0 }, b{ 0 }, c{ 0 }; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; int sum{ 0 }; int ret_val = SafeAdd(sum, a, b, c); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return ret_val; } // util/math.h #ifndef UTIL_MATH_H #define UTIL_MATH_H #include \u0026#34;error_code.h\u0026#34; #include \u0026lt;limits\u0026gt; template\u0026lt;typename ValueType\u0026gt; ValueType ValueTypeMax(ValueType) { return std::numeric_limits\u0026lt;ValueType\u0026gt;::max(); } template\u0026lt;typename ValueType\u0026gt; int SafeAdd(ValueType \u0026amp;sum) { return exit_success; } template\u0026lt;typename ValueType, typename ...ValueTypes\u0026gt; int SafeAdd(ValueType \u0026amp;sum, const ValueType \u0026amp;value, const ValueTypes \u0026amp;...other_values) { int ret_val = SafeAdd\u0026lt;ValueType\u0026gt;(sum, other_values...); if (ret_val != exit_success) { return ret_val; } if (sum \u0026gt; ValueTypeMax(value) - value) { sum = ValueTypeMax(value); return error_data_overflow; } sum += value; return exit_success; } #endif // definition/error_code.h #ifndef DEFINITION_ERROR_CODE_H #define DEFINITION_ERROR_CODE_H constexpr int exit_success = 0; constexpr int exit_failure = 1; constexpr int error_data_overflow = 2; #endif 我们可以在使用 GCC 编译的时候使用 -I 参数指定头文件所在的目录：\n[joelzychen@DevCloud ~/safe_add]$ g++ -g -Wall -std=c++11 -Ilib -Idefinition -o SafeAdd main.cc [joelzychen@DevCloud ~/safe_add]$ ./SafeAdd 20000 50000 80000 150000 2.2 使用 cmake 构建 cmake_minimum_required(VERSION 3.10) project(SafeIntAdd) set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_CXX_FLAGS -g -Wall) string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;) include_directories(lib/ definition/) aux_source_directory(./ SOURCE_DIR) add_executable(SafeIntAdd ${SOURCE_DIR}) 相比于构建单个文件，我们额外使用了两个指令：\ninclude_directories：添加多个头文件搜索路径，路径之间用空格分隔；如果将 lib 和 definition 目录都添加到到搜索路径的话，在 include 的时候就不需要使用相对路径了 aux_source_directory：在目录中查找所有源文件，并将这些源文件存储在变量 SOURCE_DIR 中；需要注意这个指令不会递归包含子目录 接下来进入 build 目录进行构建：\n[joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake .. -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target SafeIntAdd [ 50%] Building CXX object CMakeFiles/SafeIntAdd.dir/main.cc.o [100%] Linking CXX executable SafeIntAdd [100%] Built target SafeIntAdd [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./SafeIntAdd 2000000000 1900000000 2147483647 3. 构建依赖于静态库的项目 关于静态库和动态库相关内容可以参考浅谈静态库和动态库。\n3.1 使用 GCC 编译静态库文件 假设现在我们希望将 exp2 函数封装到一个计算器单例类中，并计算 2 的 n 次方，并为此编写了以下这些文件：\n// main.cc #include \u0026#34;util/calculator.h\u0026#34; #include \u0026#34;definition/error_code.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { double a{ 0 }; std::cin \u0026gt;\u0026gt; a; double exp2{ 0 }; int ret_val = Calculator::GetInstance().Exp2(exp2, a); if (ret_val != exit_success) { return ret_val; } std::cout \u0026lt;\u0026lt; exp2 \u0026lt;\u0026lt; std::endl; return exit_success; } // util/singleton.h #ifndef UTIL_SINGLETON_H #define UTIL_SINGLETON_H template \u0026lt;typename T\u0026gt; class Singleton { public: static T\u0026amp; GetInstance() { static T instance; return instance; } Singleton(Singleton const \u0026amp;) = delete; Singleton\u0026amp; operator=(Singleton const \u0026amp;) = delete; protected: Singleton() = default; ~Singleton() = default; }; #endif // definition/error_code.h #ifndef DEFINITION_ERROR_CODE_H #define DEFINITION_ERROR_CODE_H constexpr int exit_success = 0; constexpr int exit_failure = 1; constexpr int error_data_overflow = 2; #endif // util/calculator.h #ifndef UTIL_CALCULATOR_H #define UTIL_CALCULATOR_H #include \u0026#34;singleton.h\u0026#34; #include \u0026#34;../definition/error_code.h\u0026#34; #include \u0026lt;limits\u0026gt; #include \u0026lt;cmath\u0026gt; class Calculator : public Singleton\u0026lt;Calculator\u0026gt; { public: template\u0026lt;typename ValueType\u0026gt; ValueType ValueTypeMax(ValueType) { return std::numeric_limits\u0026lt;ValueType\u0026gt;::max(); } int Exp2(double \u0026amp;exp2, const double \u0026amp;val); }; #endif 为了方便生成静态库文件，我们先将 calculator.cc 这个文件放到 archive 目录下：\n// archive/calculator.cc #include \u0026#34;../util/calculator.h\u0026#34; int Calculator::Exp2(double \u0026amp;exp2, const double \u0026amp;val) { if (std::sqrt(ValueTypeMax(val)) \u0026lt; val) { exp2 = ValueTypeMax(val); return error_data_overflow; } exp2 = std::exp2(val); return exit_success; } 对于 calculator.cc 这个源文件，我们可以使用 -c 参数将其编译为 obj 文件，再使用 ar 归档就能将其编译为一个 .a 库文件了：：\n[joelzychen@DevCloud ~/cmake-tutorial/archive]$ g++ calculator.cc -g -Wall -std=c++11 -c [joelzychen@DevCloud ~/cmake-tutorial/archive]$ ar -crv libcalculator.a calculator.o a - calculator.o 3.2 使用 GCC 编译项目和链接静态库 现在的目录结构如下：\n[joelzychen@DevCloud ~/cmake-tutorial]$ tree . |-- archive | |-- calculator.cc | |-- calculator.o | `-- libcalculator.a |-- CMakeLists.txt |-- definition | `-- error_code.h |-- main.cc `-- util |-- calculator.h `-- singleton.h 3 directories, 8 files 使用 GCC 编译和链接到对应的静态库文件即可得到可执行文件：\n[joelzychen@DevCloud ~/cmake-tutorial]$ g++ main.cc -g -Wall -std=c++11 -o Exp2 -Larchive -lcalculator [joelzychen@DevCloud ~/cmake-tutorial]$ ll Exp2 32K -rwxrwxr-x 1 joelzychen joelzychen 31K Jun 21 14:38 Exp2 [joelzychen@DevCloud ~/cmake-tutorial]$ ./Exp2 8 256 需要注意的点有：\n-Llib 用于指定库文件目录 -lsingleton 用于指定库文件 -L 和 -l 参数一定要在 -o 参数之后 3.3 使用 cmake 构建项目和链接静态库 我们刚才已经用 GCC 编译好了静态库文件，所以可以直接在 CMakeLists.txt 里添加链接静态库的指令：\ncmake_minimum_required(VERSION 3.10) project(Exp2) set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_CXX_FLAGS -g -Wall) string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/) message(STATUS \u0026#34;source dir: \u0026#34; ${PROJECT_SOURCE_DIR}) message(STATUS \u0026#34;binary dir: \u0026#34; ${PROJECT_BINARY_DIR}) message(STATUS \u0026#34;output dir: \u0026#34; ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}) include_directories(./) aux_source_directory(./ SOURCE_DIR) link_directories(archive/) add_executable(Exp2 ${SOURCE_DIR}) target_link_libraries(Exp2 libcalculator.a) # target_link_libraries(Exp2 calculator) 和之前相比，额外使用的指令有：\nlink_directories：指定静态库或动态库的搜索路径 target_link_libraries：将指定的静态库连接到可执行文件上，singleton 和 libsingleton.a 两种形式等价 然后进入 build 目录进行构建：\n[joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake ../ -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- source dir: /home/joelzychen/cmake-tutorial -- binary dir: /home/joelzychen/cmake-tutorial/build -- output dir: /home/joelzychen/cmake-tutorial/build/bin/ -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target Exp2 [ 50%] Building CXX object CMakeFiles/Exp2.dir/main.cc.o [100%] Linking CXX executable bin/Exp2 [100%] Built target Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll bin/Exp2 32K -rwxrwxr-x 1 joelzychen joelzychen 31K Jun 21 14:58 bin/Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./bin/Exp2 6 64 可以看到通过 cmake 构建得到二进制文件大小和直接通过 GCC 编译和链接得到的二进制文件大小是相同的。这次用 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/) 命令将生成的二进制文件放到了 bin 目录下，注意这里的 bin 目录是使用 cmake 进行构建的目录（PROJECT_BINARY_DIR），不是 CMakeLists.txt 所在的目录（PROJECT_SOURCE_DIR）。\n3.4 使用 cmake 构建静态库文件和项目 除了直接引用外部的静态库，cmake 还可以先将源文件编译成静态库之后在进行构建：\ncmake_minimum_required(VERSION 3.10) set(project_name Exp2) project(${project_name}) set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_CXX_FLAGS -g -Wall) string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/) message(STATUS \u0026#34;source dir: \u0026#34; ${PROJECT_SOURCE_DIR}) message(STATUS \u0026#34;binary dir: \u0026#34; ${PROJECT_BINARY_DIR}) message(STATUS \u0026#34;output dir: \u0026#34; \u0026#34;${PROJECT_BINARY_DIR}/${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\u0026#34;) include_directories(./) aux_source_directory(./ SOURCE_DIR) set(static_lib_source_file archive/calculator.cc) add_library(calculator_static STATIC ${static_lib_source_file}) add_executable(${project_name} ${SOURCE_DIR}) target_link_libraries(${project_name} calculator_static) 这里用到了一个新的指令 add_library 来使用指定的源文件生成库文件，再使用 target_link_libraries 将生成的库文件添加到项目中；接下来进行构建：\n[joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake ../ -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- source dir: /home/joelzychen/cmake-tutorial -- binary dir: /home/joelzychen/cmake-tutorial/build -- output dir: /home/joelzychen/cmake-tutorial/build/bin/ -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target calculator_static [ 25%] Building CXX object CMakeFiles/calculator_static.dir/archive/calculator.cc.o [ 50%] Linking CXX static library libcalculator_static.a [ 50%] Built target calculator_static Scanning dependencies of target Exp2 [ 75%] Building CXX object CMakeFiles/Exp2.dir/main.cc.o [100%] Linking CXX executable bin/Exp2 [100%] Built target Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll | grep calculator 12K -rw-rw-r-- 1 joelzychen joelzychen 11K Jun 21 15:30 libcalculator_static.a [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./bin/Exp2 5 32 可以看到在 build 目录下生成了一个名为 libcalculator_static.a 的静态库文件，这个名字是由使用 add_library 指令时的第一个参数指定的。\n4. 构建依赖于动态库的项目 4.1 使用 GCC 编译动态库文件 仍然使用之前已有的文件，在 archive 目录下生成动态库文件：\n[joelzychen@DevCloud ~/cmake-tutorial/archive]$ rm calculator.o libcalculator.a [joelzychen@DevCloud ~/cmake-tutorial/archive]$ g++ calculator.cc -g -Wall -std=c++11 -c -fPIC [joelzychen@DevCloud ~/cmake-tutorial/archive]$ g++ calculator.o -g -Wall -std=c++11 -shared -o libcalculator.so 分为两个步骤：\n使用 -c 和 -fPIC 参数生成位置无关的（position independent code）机器码 .o 文件 使用 -shared 参数生成 .so 动态库文件 也可以合并为一个步骤：\n[joelzychen@DevCloud ~/cmake-tutorial/archive]$ g++ calculator.cc -g -Wall -std=c++11 -shared -fPIC -o libcalculator.so 这样可以直接生成动态库文件，省去生成机器码文件的中间步骤。\n4.2 使用 GCC 编译项目和链接动态库 和链接到静态库类似，在编译后链接动态库即可生成二进制文件：\n[joelzychen@DevCloud ~/cmake-tutorial]$ g++ main.cc -g -Wall -std=c++11 -o Exp2 -Larchive -lcalculator [joelzychen@DevCloud ~/cmake-tutorial]$ ./Exp2 ./Exp2: error while loading shared libraries: libcalculator.so: cannot open shared object file: No such file or directory 我们发现在运行二级制文件时会出现找不到动态库的报错，这是因为动态链接库环境变量的目录下没有找到编译时所用到的动态库，我们可以将对应的目录添加到环境变量下，或是将动态库拷贝到环境变量的目录下：\n[joelzychen@DevCloud ~/cmake-tutorial]$ echo $LD_LIBRARY_PATH [joelzychen@DevCloud ~/cmake-tutorial]$ export LD_LIBRARY_PATH=\u0026#34;/usr/lib/\u0026#34; [joelzychen@DevCloud ~/cmake-tutorial]$ sudo cp archive/libcalculator.so /usr/lib/ 接下来就可以运行可执行文件了，可以看到使用链接动态库方式生成的可执行文件的大小要小于使用链接静态库方式生成的可执行文件，使用 ldd 命令也能看到可执行文件是正确地调用了对应的动态库文件：\n[joelzychen@DevCloud ~/cmake-tutorial]$ ./Exp2 9 512 [joelzychen@DevCloud ~/cmake-tutorial]$ ll Exp2 28K -rwxrwxr-x 1 joelzychen joelzychen 28K Jun 21 14:25 Exp2 [joelzychen@DevCloud ~/cmake-tutorial]$ ldd Exp2 | grep calculator libcalculator.so =\u0026gt; /usr/lib/libcalculator.so (0x00007fd2391f0000) 4.3 使用 cmake 构建项目和链接动态库 和构建静态库类似，只需要将 CMakeLists.txt 中链接静态库的指令修改为链接动态库即可进行构建：\ncmake_minimum_required(VERSION 3.10) project(Exp2) set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_CXX_FLAGS -g -Wall) string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/) message(STATUS \u0026#34;source dir: \u0026#34; ${PROJECT_SOURCE_DIR}) message(STATUS \u0026#34;binary dir: \u0026#34; ${PROJECT_BINARY_DIR}) message(STATUS \u0026#34;output dir: \u0026#34; \u0026#34;${PROJECT_BINARY_DIR}/${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\u0026#34;) include_directories(./) aux_source_directory(./ SOURCE_DIR) link_directories(archive/) add_executable(Exp2 ${SOURCE_DIR}) target_link_libraries(Exp2 libcalculator.so) [joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake ../ -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- source dir: /home/joelzychen/cmake-tutorial -- binary dir: /home/joelzychen/cmake-tutorial/build -- output dir: /home/joelzychen/cmake-tutorial/build/bin/ -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target Exp2 [ 50%] Building CXX object CMakeFiles/Exp2.dir/main.cc.o [100%] Linking CXX executable bin/Exp2 [100%] Built target Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll bin/Exp2 28K -rwxrwxr-x 1 joelzychen joelzychen 28K Jun 21 15:04 bin/Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ldd bin/Exp2 | grep calculator libcalculator.so =\u0026gt; /home/joelzychen/cmake-tutorial/archive/libcalculator.so (0x00007f4c87e35000) [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./bin/Exp2 6 64 可以看到通过 cmake 构建得到二进制文件大小和直接通过 GCC 编译和链接动态库得到的二进制文件大小也是相同的。\n4.4 使用 cmake 构建动态库文件和项目 使用 cmake 构建动态库的步骤和构建静态库的步骤几乎一模一样，只需要将 add_library 的 STATIC 参数改为 SHARED 即可：\ncmake_minimum_required(VERSION 3.10) set(project_name Exp2) project(${project_name}) set(CMAKE_CXX_COMPILER \u0026#34;c++\u0026#34;) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_CXX_FLAGS -g -Wall) string(REPLACE \u0026#34;;\u0026#34; \u0026#34; \u0026#34; CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS}\u0026#34;) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin/) message(STATUS \u0026#34;source dir: \u0026#34; ${PROJECT_SOURCE_DIR}) message(STATUS \u0026#34;binary dir: \u0026#34; ${PROJECT_BINARY_DIR}) message(STATUS \u0026#34;output dir: \u0026#34; \u0026#34;${PROJECT_BINARY_DIR}/${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\u0026#34;) include_directories(./) aux_source_directory(./ SOURCE_DIR) set(shared_lib_source_file archive/calculator.cc) add_library(calculator_shared SHARED ${shared_lib_source_file}) add_executable(${project_name} ${SOURCE_DIR}) target_link_libraries(${project_name} calculator_shared) [joelzychen@DevCloud ~/cmake-tutorial/build]$ rm -rf * [joelzychen@DevCloud ~/cmake-tutorial/build]$ cmake .. -- The C compiler identification is GNU 4.8.5 -- The CXX compiler identification is GNU 4.8.5 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc - works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ - works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- source dir: /home/joelzychen/cmake-tutorial -- binary dir: /home/joelzychen/cmake-tutorial/build -- output dir: /home/joelzychen/cmake-tutorial/build/bin/ -- Configuring done -- Generating done -- Build files have been written to: /home/joelzychen/cmake-tutorial/build [joelzychen@DevCloud ~/cmake-tutorial/build]$ make Scanning dependencies of target calculator_shared [ 25%] Building CXX object CMakeFiles/calculator_shared.dir/archive/calculator.cc.o [ 50%] Linking CXX shared library libcalculator_shared.so [ 50%] Built target calculator_shared Scanning dependencies of target Exp2 [ 75%] Building CXX object CMakeFiles/Exp2.dir/main.cc.o [100%] Linking CXX executable bin/Exp2 [100%] Built target Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll | grep calculator 16K -rwxrwxr-x 1 joelzychen joelzychen 13K Jun 21 15:34 libcalculator_shared.so [joelzychen@DevCloud ~/cmake-tutorial/build]$ ll bin/Exp2 28K -rwxrwxr-x 1 joelzychen joelzychen 28K Jun 21 15:34 bin/Exp2 [joelzychen@DevCloud ~/cmake-tutorial/build]$ ldd bin/Exp2 | grep calculator libcalculator_shared.so =\u0026gt; /home/joelzychen/cmake-tutorial/build/libcalculator_shared.so (0x00007f1fa5aa5000) [joelzychen@DevCloud ~/cmake-tutorial/build]$ ./bin/Exp2 7 128 可以看到得到的二进制文件的相关信息和使用前几种方法得到的都是相同的。\n5. 常用命令 5.1 项目相关 cmake_minimum_required(VERSION 3.10)：指定 cmake 的最低版本要求 project(project_name)：指定项目的名称 set(CMAKE_CXX_FLAGS -g -Wall -pthread)：设置普通变量，缓存变量或环境变量 5.2 编译相关 include_directories：指定头文件的目录，类似于 GCC 编译时的 -I 参数；等价于将头文件目录添加到环境变量 CPLUS_INCLUDE_PATH 中 aux_source_directory：在目录中（不含子目录）查找所有源文件，并将这些源文件存储在变量 SOURCE_DIR 中 add_executable：使用列出的源文件构建可执行文件 add_definitions：宏定义 5.3 链接相关 link_directories：指定库文件的目录，类似于 GCC 链接时的 -L 参数；等价于将库文件目录添加到环境变量 LD_LIBRARY_PATH 中 target_link_libraries：将指定的静态库连接到可执行文件上，singleton 和 libsingleton.a 两种形式等价 6. 总结 本文通过几个示例程序对比了在 Linux 下使用 GCC 和 cmake 来编译和构建程序的基本步骤，了解了一些 cmake 的基础指令。实际开发中的项目往往会非常大，以致于不能够直接使用 GCC 来编译整个项目，在这种场景下使用 cmake 进行构建往往能够节省时间和提高效率，让我们能够专注在项目的开发上。在实际应用中编写 CMakeLists.txt 的时候还会遇到非常多的问题、不熟悉的指令和其他的使用技巧，这些都需要结合教程和实践来进一步学习。\n","permalink":"https://prov1dence.top/posts/cpp/compilation/cmake/","summary":"\u003ch1 id=\"cmake-入门\"\u003eCMake 入门\u003c/h1\u003e\n\u003ch2 id=\"0-序\"\u003e0. 序\u003c/h2\u003e\n\u003cp\u003eCMake 是一个跨平台的开源构建工具，使用 CMake 能够方便地管理依赖多个库的目录层次结构并生成 makefile 和使用 GNU make 来编译和连接程序。\u003c/p\u003e\n\u003ch2 id=\"1-构建单个文件\"\u003e1. 构建单个文件\u003c/h2\u003e\n\u003ch3 id=\"11-使用-gcc-编译\"\u003e1.1 使用 GCC 编译\u003c/h3\u003e\n\u003cp\u003e假设现在我们希望编写一个函数来实现安全的 int 类型加法防止数据溢出，这个源文件没有任何依赖的源码或静态库：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// safe_add.cpp\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;memory\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define INT_MAX 2147483647\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define ERROR_DATA_OVERFLOW 2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSafeIntAdd\u003c/span\u003e(std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eunique_ptr\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003esum, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e b)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (a \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e INT_MAX \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e b)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esum \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e INT_MAX;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e ERROR_DATA_OVERFLOW;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esum \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e EXIT_SUCCESS;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a, b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eunique_ptr\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e sum(\u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e res \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e SafeIntAdd(sum, a, b);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esum \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们可以直接使用一句简单的 gcc 命令来编译这个文件并执行：\u003c/p\u003e","title":"CMake 入门"},{"content":"GDB 调试入门 0. 序 调试程序是开发过程中必不可少的一环，在 Windows 或 MacOS 上开发时，可以使用 VS 和 CLion 等 IDE 上自带的调试功能来打断点或查看变量和堆栈，但 Linux 并没有图形化的操作界面，而如果只通过打 log 的方式来查找问题的话效率将会非常低下，此时我们可以利用 GDB 来提升我们的开发效率。\nGDB 是 GNU Debugger 的简写，是 GNU 软件系统中的标准调试器。GDB 具备各种调试功能，包括但不限于打断点、单步执行、打印变量、查看寄存器、查看函数调用堆栈等，能够有效地针对函数的运行进行追踪和警告；使用 GDB 调试时，可以监督和修改程序的变量，并且这些修改是独立于主程序之外的。GDB 主要用于调试编译型语言，对 C，C++，Go，Fortran 等语言有内置的支持，但它不支持解释型语言。\n1. 环境搭建 1.1 编写程序 为了进行调试，我们需要准备一个简单的 C++ 程序：\n$ cat test.cpp #include \u0026lt;iostream\u0026gt; void Func(const char *s) { int *p = nullptr; int \u0026amp;r = static_cast\u0026lt;int\u0026amp;\u0026gt;(*p); int num = std::atoi(s); r = num; printf(\u0026#34;%d\\n\u0026#34;, r); } int main (int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;test [int]\\n\u0026#34;); return -1; } Func(argv[1]); return 0; } 1.2 编译 对于 C/C++ 程序，在使用 gcc/clang 编译的时候需要加上参数 -g，才能生成完整的调试信息并在 GDB 中调试：\n$ clang++ -g -std=c++11 -m64 -o test test.cpp 2. 调试示例 GDB 有非常多的功能，当我们忘记如何使用这些功能时，可以在 GDB 交互界面里输入 help 或 help all 来查看指令：\n(gdb) help List of classes of commands: ... 2.1 启动 我们可以使用 gdb [executable file] 来启动调试：\n$ gdb test.cpp ... Reading symbols from test...done. (gdb) 也可以直接使用 gdb 来进入交互界面，再使用 file 来指定要调试的程序：\n$ gdb ... (gdb) file test Reading symbols from test...done. 2.2 运行 对于带参数的程序，我们可以使用 set args [arg] ... 设置参数，再使用 run 来运行：\n(gdb) set args 1 (gdb) run Starting program: test 1 ... 当然也可以直接在 run 后加上参数来运行：\n(gdb) run 1 Starting program: test 1 Program received signal SIGSEGV, Segmentation fault. 0x0000000000400749 in Func (s=0x7fffffffe167 \u0026#34;/data/home/joelzychen/test/test\u0026#34;) at test.cpp:8 8 r = num; 我们发现程序出现了 Segmentation fault，此时可以通过打断点来调试程序。\n2.3 断点 通过错误信息我们可以看到是函数 Func 中，test.cpp 的第 8 行出现了错误，于是我们可以打上两个断点，一个在进入 Func 函数时，一个在 test.cpp 文件的第 8 行，并使用 info breakpoints 或 info b 来查看我们设置了哪些断点：\n(gdb) b test.cpp:8 Breakpoint 1 at 0x400742: file test.cpp, line 8. (gdb) b Func Breakpoint 2 at 0x40071c: file test.cpp, line 4. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000400742 in Func(char const*) at test.cpp:8 2 breakpoint keep y 0x000000000040071c in Func(char const*) at test.cpp:4 2.4 调试 设置好断点之后就可以使用 run 开始运行了：\n(gdb) run Starting program: test 1 Breakpoint 2, Func (s=0x7fffffffe167 \u0026#34;/data/home/joelzychen/test/test\u0026#34;) at test.cpp:4 4 int *p = nullptr; 因为我们在 Func 函数的开头设置了一个断点，所以程序在进入 Func 函数时暂停了；我们可以使用 list 或 l [function name] 来查看函数的上下文：\n(gdb) l Func 1 #include \u0026lt;iostream\u0026gt; 2 3 void Func(const char *s) { 4 int *p = nullptr; 5 int \u0026amp;r = static_cast\u0026lt;int\u0026amp;\u0026gt;(*p); 6 7 int num = std::atoi(s); 8 r = num; 9 printf(\u0026#34;%d\\n\u0026#34;, r); 10 } 此时我们可以使用 print 或 p 来查看变量：\n(gdb) p s $1 = 0x7fffffffe187 \u0026#34;1\u0026#34; (gdb) p *s $2 = 49 \u0026#39;1\u0026#39; 到目前为止还没有出现问题，我们可以使用 continue 或 c 走到下一个断点处：\n(gdb) c Continuing. Breakpoint 2, Func (s=0x7fffffffe187 \u0026#34;1\u0026#34;) at test.cpp:8 8 r = num; 查看一下当前作用域的一些变量：\n(gdb) p s $8 = 0x7fffffffe187 \u0026#34;1\u0026#34; (gdb) p p $9 = (int *) 0x0 (gdb) p *p Cannot access memory at address 0x0 (gdb) p r $10 = (int \u0026amp;) @0x0: \u0026lt;error reading variable\u0026gt; (gdb) p \u0026amp;r $11 = (int *) 0x0 (gdb) p num $12 = 1 会发现 r 这个 int\u0026amp; 绑定到了一个被解引用的空指针上，所以 \u0026amp;r == nullptr，因此不能读取 r 的值，我们可以用 next 或 n 来进行单步执行，看看接下来会发生什么：\n(gdb) n Program received signal SIGSEGV, Segmentation fault. 0x0000000000400749 in Func (s=0x7fffffffe187 \u0026#34;1\u0026#34;) at test.cpp:8 8 r = num; 果然发生了 Segmentation fault。\n3. GDB 命令 根据刚才的示例程序，可以整理出一些常用的 GDB 命令。\n3.1 启动 将 GDB 链接到一个可执行文件并启动\ngdb [executable file] gdb (gdb) file [executable file] 将 GDB 链接到一个正在运行的进程并启动\ngdb (gdb) attach [PID] 3.2 断点 增加断点\nb [function name] b [file:line] 查看断点\ninfo b 删除断点\ndelete [breakpoint number] d [breakpoint number] clear # 删除当前行的断点 clear [function name] # 删除某个函数处的断点 clear [file:line] # 删除某一行的断点 禁用和启用断点\ndisable # 禁用所有断点 disable [breakpoint number] # 禁用某个断点 enable # 启用所有断点 enable [breakpoint number] # 启用某个断点 3.3 运行 从头开始运行 run 单步执行 next 或 n 进入函数内部 step 或 s stepi 执行一条机器指令 3.4 查看 查看代码\nlist # 从头开始依次打印，默认每次打印 10 行 l # 同上 l [function name] # 从函数定义开始打印 l [file:line] # 从某一行开始打印 set listsize 20 # 修改每次打印的行数 查看变量\nprint [expression] # 打印表达式 p [expression] # 同上 ptype [expression] # 打印表达式的类型 info args # 打印函数参数 info locals # 打印局部变量 info registers # 打印寄存器信息 3.5 修改 修改变量\nset variable i = 10 # 将变量 i 设置为 10 set var i = 10 # 同上 p i = 10 # 将变量 i 设置为 10，并打印 3.6 调用信息 查看函数调用栈信息 backtrace 或 bt where 查看当前栈帧 frame 或 f 4. corefile core dump / crash dump / memory dump / system dump 都是指一个程序在特定时间崩溃（crash）时的内存记录，它包含了很多关键信息，比如寄存器（包括程序计数器和堆栈指针），内存管理信息，操作系统标志信息等。corefile 就是转储（dump）时的快照，corefile可以被重新执行用以调试错误信息。\n4.1 生成 为了让系统能够生成 corefile，需要先检查配置：\n$ ulimit -c unlimited 如果结果是 0 则说明系统禁止了 corefile 的生成，需要执行 ulimit -c unlimited 来让 corefile 能够正常生成。以刚才的示例程序为例，先执行 test 文件，生成一个 corefile：\n$ ./test 1 段错误 (core dumped) $ ll /data/corefile -rw------- 1 joelzychen dev 450560 4月 22 17:07 core_test_1587546447.28284 能够看到系统在特定的目录下（可以修改）生成了一个 corefile 叫做 core_test_1587546447.28284，我们使用 gdb 来对这个 corefile 进行调试。\n4.2 调试 要执行 corefile 还需要准备对应的可执行文件，运行 gdb [executable file] [corefile] 就能开始调试了：\n$ gdb test /data/corefile/core_test_1587546447.28284 ... Core was generated by `./test 1\u0026#39;. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400749 in Func (s=0x7ffed098c19e \u0026#34;1\u0026#34;) at test.cpp:8 8 r = num; 因为示例程序比较简单，因此函数调用栈也比较少，我们可以先使用 bt 打印函数调用栈信息：\n(gdb) bt #0 0x0000000000400749 in Func (s=0x7ffed098c19e \u0026#34;1\u0026#34;) at test.cpp:8 #1 0x00000000004007c0 in main (argc=2, argv=0x7ffed098afb8) at test.cpp:17 我们通过 frame 0 或 f 0 进入程序崩溃的栈帧来查看相关信息：\n(gdb) f 0 #0 0x0000000000400749 in Func (s=0x7ffed098c19e \u0026#34;1\u0026#34;) at test.cpp:8 8 r = num; (gdb) info args s = 0x7ffed098c19e \u0026#34;1\u0026#34; (gdb) info locals p = 0x0 r = @0x0: \u0026lt;error reading variable\u0026gt; num = 1 (gdb) ptype r type = int \u0026amp; (gdb) ptype p type = int * 查看一下当前栈帧的汇编代码：\n(gdb) disas Dump of assembler code for function Func(char const*): 0x0000000000400710 \u0026lt;+0\u0026gt;: push %rbp 0x0000000000400711 \u0026lt;+1\u0026gt;: mov %rsp,%rbp 0x0000000000400714 \u0026lt;+4\u0026gt;: sub $0x20,%rsp 0x0000000000400718 \u0026lt;+8\u0026gt;: mov %rdi,-0x8(%rbp) 0x000000000040071c \u0026lt;+12\u0026gt;: movq $0x0,-0x10(%rbp) 0x0000000000400724 \u0026lt;+20\u0026gt;: mov -0x10(%rbp),%rdi 0x0000000000400728 \u0026lt;+24\u0026gt;: mov %rdi,-0x18(%rbp) 0x000000000040072c \u0026lt;+28\u0026gt;: mov -0x8(%rbp),%rdi 0x0000000000400730 \u0026lt;+32\u0026gt;: callq 0x4005a0 \u0026lt;atoi@plt\u0026gt; 0x0000000000400735 \u0026lt;+37\u0026gt;: movabs $0x400860,%rdi 0x000000000040073f \u0026lt;+47\u0026gt;: mov %eax,-0x1c(%rbp) 0x0000000000400742 \u0026lt;+50\u0026gt;: mov -0x1c(%rbp),%eax 0x0000000000400745 \u0026lt;+53\u0026gt;: mov -0x18(%rbp),%rcx =\u0026gt; 0x0000000000400749 \u0026lt;+57\u0026gt;: mov %eax,(%rcx) 0x000000000040074b \u0026lt;+59\u0026gt;: mov -0x18(%rbp),%rcx 0x000000000040074f \u0026lt;+63\u0026gt;: mov (%rcx),%esi 0x0000000000400751 \u0026lt;+65\u0026gt;: mov $0x0,%al 0x0000000000400753 \u0026lt;+67\u0026gt;: callq 0x400550 \u0026lt;printf@plt\u0026gt; 0x0000000000400758 \u0026lt;+72\u0026gt;: mov %eax,-0x20(%rbp) 0x000000000040075b \u0026lt;+75\u0026gt;: add $0x20,%rsp 0x000000000040075f \u0026lt;+79\u0026gt;: pop %rbp 0x0000000000400760 \u0026lt;+80\u0026gt;: retq End of assembler dump. 查看寄存器状态：\n(gdb) i r rax 0x1 1 rbx 0x0 0 rcx 0x0 0 rdx 0xa 10 rsi 0x0 0 rdi 0x400860 4196448 rbp 0x7ffed098aea0 0x7ffed098aea0 rsp 0x7ffed098ae80 0x7ffed098ae80 r8 0x7f9c88bbf060 140310285643872 r9 0x7ffed098c19f 140732398092703 r10 0x1 1 r11 0x0 0 r12 0x40061c 4195868 r13 0x7ffed098afb0 140732398088112 r14 0x0 0 r15 0x0 0 rip 0x400749 0x400749 \u0026lt;Func(char const*)+57\u0026gt; eflags 0x10206 [ PF IF RF ] cs 0x33 51 ss 0x2b 43 ds 0x0 0 es 0x0 0 fs 0x0 0 gs 0x0 0 5. 总结 本文主要通过一个示例程序演示了在 Linux 环境下 GDB 的基本使用方法，整理了 GDB 的常用指令，以及调试 C/C++ 程序和 corefile 的步骤。在实际应用中 GDB 能个极大程度地提高开发和调试效率，更多的使用技巧还需要结合实践来练习。\n","permalink":"https://prov1dence.top/posts/cpp/compilation/gdb/","summary":"\u003ch1 id=\"gdb-调试入门\"\u003eGDB 调试入门\u003c/h1\u003e\n\u003ch2 id=\"0-序\"\u003e0. 序\u003c/h2\u003e\n\u003cp\u003e调试程序是开发过程中必不可少的一环，在 Windows 或 MacOS 上开发时，可以使用 VS 和 CLion 等 IDE 上自带的调试功能来打断点或查看变量和堆栈，但 Linux 并没有图形化的操作界面，而如果只通过打 log 的方式来查找问题的话效率将会非常低下，此时我们可以利用 GDB 来提升我们的开发效率。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/GNU_Debugger\"\u003eGDB\u003c/a\u003e 是 GNU Debugger 的简写，是 \u003ca href=\"https://zh.wikipedia.org/wiki/GNU\"\u003eGNU\u003c/a\u003e 软件系统中的标准\u003ca href=\"https://en.wikipedia.org/wiki/Debugger\"\u003e调试器\u003c/a\u003e。GDB 具备各种调试功能，包括但不限于打断点、单步执行、打印变量、查看寄存器、查看函数调用堆栈等，能够有效地针对函数的运行进行追踪和警告；使用 GDB 调试时，可以监督和修改程序的变量，并且这些修改是独立于主程序之外的。GDB 主要用于调试编译型语言，对 C，C++，Go，Fortran 等语言有内置的支持，但它不支持解释型语言。\u003c/p\u003e\n\u003ch2 id=\"1-环境搭建\"\u003e1. 环境搭建\u003c/h2\u003e\n\u003ch3 id=\"11-编写程序\"\u003e1.1 编写程序\u003c/h3\u003e\n\u003cp\u003e为了进行调试，我们需要准备一个简单的 C++ 程序：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e$\u003c/span\u003e cat test.cpp\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e Func(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003es) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003er \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic_cast\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026gt;\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e num \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eatoi(s);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    r \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e num;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, r);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e argc, \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eargv[]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (argc \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;test [int]\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Func(argv[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"12-编译\"\u003e1.2 编译\u003c/h3\u003e\n\u003cp\u003e对于 C/C++ 程序，在使用 gcc/clang 编译的时候需要加上参数 -g，才能生成完整的调试信息并在 GDB 中调试：\u003c/p\u003e","title":"GDB 调试入门"},{"content":"coverity 的 WRAPPER_ESCAPE 告警 const char* Foo() { std::string str_msg(\u0026#34;test\u0026#34;); return str_msg.c_str(); } int main() { const char *p_msg = Foo(); printf(\u0026#34;%s\\n\u0026#34;, p_msg); return 0; } // output:（为空，或乱码） D? 上面代码中的 Foo 函数会被 coverity 报告 WRAPPER_ESCAPE，详细说明是：\nWrapper object use after free (WRAPPER_ESCAPE) 1. escape: The internal representation of local strMsg escapes, but is destroyed when it exits scope 大意是局部变量 str_msg 在离开函数 Foo 的时候会被释放（因为 str_msg 是分配在栈上的变量），而通过函数 std::string::c_str() 获取的指向 str_msg 头部的指针会因此变为一个悬空指针，将这个悬空指针返回给函数调用者使用将会发生不可预知的行为。\n而 c_str() 本身返回的是一个 const char *p，虽然我们无法直接修改指针 p 所指向的数据，但我们可以通过修改 str_msg 来达到修改 p 所指向内存的效果，例如如下的代码：\nint main() { std::string str_msg(\u0026#34;test\u0026#34;); const char *p_msg = str_msg.c_str(); printf(\u0026#34;%s\\n\u0026#34;, p_msg); str_msg[2] = \u0026#39;x\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, p_msg); return 0; } // output: test text 想要正确地使用返回的 const char*，我们可以在堆上分配一块内从，将要使用的字符串拷贝到其中并返回：\nconst char* Foo() { std::string str_msg(\u0026#34;test\u0026#34;); uint32_t u32_msg_size = str_msg.size() + 1; char *p_return = new char[u32_msg_size]; strcpy_s(p_return, u32_msg_size, str_msg.c_str()); return p_return; } int main() { const char *p_msg = Foo(); printf(\u0026#34;%s\\n\u0026#34;, p_msg); return 0; } // output: test 当然，调用者也应该则适当的时机对 p_msg 进行 delete 操作，否则将会造成内存泄漏。\n应该记住的是，除非你需要立即以 const char* 的方式使用字符串，否则应该尽量避免使用 c_str()，尤其是在发生函数调用和返回时。\n","permalink":"https://prov1dence.top/posts/cpp/basics/wrapper_escape-in-coverity/","summary":"\u003ch1 id=\"coverity-的-wrapper_escape-告警\"\u003ecoverity 的 WRAPPER_ESCAPE 告警\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003estring str_msg(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;test\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e str_msg.c_str();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep_msg \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Foo();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%s\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, p_msg);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// output:（为空，或乱码）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eD\u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e上面代码中的 Foo 函数会被 coverity 报告 WRAPPER_ESCAPE，详细说明是：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eWrapper object use after free (WRAPPER_ESCAPE)\n1. escape: The internal representation of local strMsg escapes, but is destroyed when it exits scope\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e大意是局部变量 str_msg 在离开函数 Foo 的时候会被释放（因为 str_msg 是分配在栈上的变量），而通过函数 std::string::c_str() 获取的指向 str_msg 头部的指针会因此变为一个悬空指针，将这个悬空指针返回给函数调用者使用将会发生不可预知的行为。\u003c/p\u003e\n\u003cp\u003e而 c_str() 本身返回的是一个 const char *p，虽然我们无法直接修改指针 p 所指向的数据，但我们可以通过修改 str_msg 来达到修改 p 所指向内存的效果，例如如下的代码：\u003c/p\u003e","title":"coverity 的 WRAPPER_ESCAPE 告警"},{"content":"C++ 协程（1）：函数和协程 这篇文章的目的是探究 C++ 中协程的机制和用法，以及怎样利用协程的特性来构建上层的库和应用。\n1. 栈帧和函数 栈帧是一个函数执行的环境，包括函数参数、函数返回地址、局部变量等信息。操作系统每次调用一个函数，都会为其分配一个新的栈帧，相关的概念有：\nESP：栈指针寄存器（Extended Stack Pointer），其内存中存放一个始终指向系统栈最顶部栈帧栈顶的指针 EBP：基址指针寄存器（Extended Base Pointer），其内存中存放一个始终指向系统最顶部栈帧栈底的指针 函数栈帧：ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部 对于普通的函数来说，一般我们可以对其进行两种操作：call（调用）和 return（返回）。为了方便对比，此处不讨论 throw exception 的情况。在运行一个 C++ 程序时，编译器会先执行 C++ runtime，然后会调用 main 函数，再由 main 函数调用其他的函数。\ncall 操作一般包含以下几个步骤：\n参数入栈：参数从右向左依次入栈 返回地址入栈：将当前代码区的下一条待执行的指令入栈，以便在函数 return 之后执行 代码区跳转：处理器跳转到被调函数的入口 栈帧调整，包括： 保存当前栈帧状态值，EBP 入栈 从当前栈帧切换到新的栈帧，更新 EBP，将 EBP 的值设置为 ESP 的值 给新的栈帧分配内存空间，更新 ESP，将 ESP 的值减去所需空间的大小 当一个函数通过 return 语句返回时，执行的步骤与调用时相反：\n2. 协程 协程由程序所控制，即在用户态执行，而不是像线程一样由操作系统内核管理，使用协程时，不需要如线程一般频繁地进行上下文切换，性能能够得到很大的提升，因此协程的开销远远小于线程的开销。一般来说协程有三种特性：\nsuspend 悬停：暂停当前协程的执行，将执行权交还给调用者，但是保留当前栈帧。和函数的 return 类似，协程的 suspend 只能由协程自身发起 resume 恢复：继续执行已经 suspend 的协程，重新激活协程的栈帧 destroy 销毁：销毁协程的栈帧和其对应的内存 可以看到，协程可以在不清除栈帧的情况下被挂起而不被销毁，因此我们不能够使用调用栈这样的数据结构来严格保证活动栈帧的生命周期，我们可以把协程存储在堆中。我们可以把协程的栈帧分为两部分，一部分是执行栈帧，这部分仅在当前协程执行期间存在，在执行结束，即协程 suspend 的时候被释放；另一部分是数据栈帧，这部分即使在协程 suspend 的时候依然存在。\n2.1 Suspend 协程通过某些特定的语句来执行 suspend 操作，在 C++ Coroutine TS 中有 co_await 和 co_yield。在执行 suspend 操作的时候，我们应该确保两点：\n将当前执行栈帧中的数据保存到数据栈帧中 将协程 suspend 的位置写入数据栈帧中，以便后续的 resume 操作知道从哪里继续，或让 destroy 操作知道销毁哪一部分 接下来，协程可以将执行权转交给调用方，而执行栈帧将被释放。\n2.2. Resume 我们可以使用 resume 操作来恢复一个已经 suspend 的协程，和函数的 call 类似，resume 操作将会分配一个新的执行栈帧来存储已经保存在数据栈帧中的数据，以及调用方的返回地址等，之后协程将加载之前 suspend 的位置并继续执行。\n2.3 Destroy Destroy 操作只能在已经 suspend 的协程上执行，和 resume 类似，他也会先分配执行栈帧，将调用方的返回地址存入其中，但它并不会继续执行 suspend 的位置之后的函数体，而是执行当前作用域内所有局部变量的析构函数，并释放这些内存。\n2.4 Call 和 Return 协程的调用和普通函数的 call 操作类似，调用方会给其分配一个活动栈帧，将参数和返回地址入栈，并将执行权交给协程，而协程会先在堆上分配一个执行栈帧，并将参数复制到执行栈帧上，以便后续能够正确地删除这些参数。\n协程的 return 操作和普通函数的略有不同，当协程执行 return 操作时，他会将返回值存储在另一个地址，然后删除所有局部变量，并将执行权转交给调用方，\n3. 函数和协程的执行过程 假设 func() 是一个函数，他在函数体内调用了协程 co_func(int x)，那么编译器会在调用栈上创建新的活动栈帧，将参数和返回地址入栈，并将 ESP 移动到新的活动栈帧的栈顶位置，如下所示。\nStack Register Heap (Coroutine Manager) +----+ +------------+ \u0026lt;---------- ESP func() +----+ +------------+ ... 接下来协程管理器会在堆上申请一块新的区域作为协程的执行栈帧，此时编译器会将 EBP 指向执行栈帧的顶部，如下所示。\nStack Register Heap (Coroutine Manager) +------------+ \u0026lt;------- +------------+ co_func() | -------\u0026gt; co_func() x = 68 | | x = 68 ret = func() + 0x789 | +----+ | +------------+ +------------+ ---- ESP | func() +----+ | +------------+ EBP --------| ... +----+ 如果在 co_func 执行的某一时刻触发了 suspend，那么执行栈帧中的数据将被保存到数据栈帧中，且改协程会返回一些返回值给调用方，这些返回值中通常含有 suspend 的位置，以及协程暂挂的句柄，这个句柄可以在接下来使用 resume 的时候恢复协程，如下所示。\nStack Register Heap (Coroutine Manager) +----+ -------\u0026gt; +------------+ +------------+ \u0026lt;---------- ESP | co_func() func() +----+ | x = 68 +------------+ EBP | resume point = co_func() + 16 handle --------------- +----+ | ... | | | | --------------------- 现在因为某些原因触发了协程的 resume，恢复协程的调用方会调用 void resume (handle) 来恢复这个协程，此时编译器会再次创建新的活动栈帧用来记录参数和返回地址，同时激活执行栈帧，执行栈帧从数据栈帧读取数据，恢复协程，如下所示。\nStack Register Heap (Coroutine Manager) +------------+ \u0026lt;------- +------------+ co_func() | -------\u0026gt; co_func() x = 68 | | x = 68 ret = func() + 0x789 | +----+ | +------------+ +------------+ ---- ESP | func() +----+ | +------------+ EBP --------| handle +----+ ... ","permalink":"https://prov1dence.top/posts/cpp/coroutine/c++-coroutine---function-and-coroutine/","summary":"\u003ch1 id=\"c-协程1函数和协程\"\u003eC++ 协程（1）：函数和协程\u003c/h1\u003e\n\u003cp\u003e这篇文章的目的是探究 C++ 中协程的机制和用法，以及怎样利用协程的特性来构建上层的库和应用。\u003c/p\u003e\n\u003ch2 id=\"1-栈帧和函数\"\u003e1. 栈帧和函数\u003c/h2\u003e\n\u003cp\u003e栈帧是一个函数执行的环境，包括函数参数、函数返回地址、局部变量等信息。操作系统每次调用一个函数，都会为其分配一个新的栈帧，相关的概念有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eESP：栈指针寄存器（Extended Stack Pointer），其内存中存放一个始终指向系统栈最顶部栈帧栈顶的指针\u003c/li\u003e\n\u003cli\u003eEBP：基址指针寄存器（Extended Base Pointer），其内存中存放一个始终指向系统最顶部栈帧栈底的指针\u003c/li\u003e\n\u003cli\u003e函数栈帧：ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于普通的函数来说，一般我们可以对其进行两种操作：call（调用）和 return（返回）。为了方便对比，此处不讨论 throw exception 的情况。在运行一个 C++ 程序时，编译器会先执行 C++ runtime，然后会调用 main 函数，再由 main 函数调用其他的函数。\u003c/p\u003e\n\u003cp\u003ecall 操作一般包含以下几个步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e参数入栈：参数从右向左依次入栈\u003c/li\u003e\n\u003cli\u003e返回地址入栈：将当前代码区的下一条待执行的指令入栈，以便在函数 return 之后执行\u003c/li\u003e\n\u003cli\u003e代码区跳转：处理器跳转到被调函数的入口\u003c/li\u003e\n\u003cli\u003e栈帧调整，包括：\n\u003col\u003e\n\u003cli\u003e保存当前栈帧状态值，EBP 入栈\u003c/li\u003e\n\u003cli\u003e从当前栈帧切换到新的栈帧，更新 EBP，将 EBP 的值设置为 ESP 的值\u003c/li\u003e\n\u003cli\u003e给新的栈帧分配内存空间，更新 ESP，将 ESP 的值减去所需空间的大小\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e当一个函数通过 return 语句返回时，执行的步骤与调用时相反：\u003c/p\u003e\n\u003ch2 id=\"2-协程\"\u003e2. 协程\u003c/h2\u003e\n\u003cp\u003e协程由程序所控制，即在用户态执行，而不是像线程一样由操作系统内核管理，使用协程时，不需要如线程一般频繁地进行上下文切换，性能能够得到很大的提升，因此协程的开销远远小于线程的开销。一般来说协程有三种特性：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003esuspend 悬停：暂停当前协程的执行，将执行权交还给调用者，但是保留当前栈帧。和函数的 return 类似，协程的 suspend 只能由协程自身发起\u003c/li\u003e\n\u003cli\u003eresume 恢复：继续执行已经 suspend 的协程，重新激活协程的栈帧\u003c/li\u003e\n\u003cli\u003edestroy 销毁：销毁协程的栈帧和其对应的内存\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可以看到，协程可以在不清除栈帧的情况下被挂起而不被销毁，因此我们不能够使用调用栈这样的数据结构来严格保证活动栈帧的生命周期，我们可以把协程存储在堆中。我们可以把协程的栈帧分为两部分，一部分是\u003cstrong\u003e执行栈帧\u003c/strong\u003e，这部分仅在当前协程执行期间存在，在执行结束，即协程 suspend 的时候被释放；另一部分是\u003cstrong\u003e数据栈帧\u003c/strong\u003e，这部分即使在协程 suspend 的时候依然存在。\u003c/p\u003e","title":"C++ 协程（1）：函数和协程"},{"content":"LeetCode 树（3） 题目 4. 递归求解 617 合并二叉树 合并两个二叉树。\n判断各个节点是否存在，全部合并到一棵树上即可。\nclass Solution { public: TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) { if (!t1 \u0026amp;\u0026amp; !t2) return nullptr; else if (!t1) return t2; else if (!t2) return t1; t1-\u0026gt;val += t2-\u0026gt;val; t1-\u0026gt;left = mergeTrees(t1-\u0026gt;left, t2-\u0026gt;left); t1-\u0026gt;right = mergeTrees(t1-\u0026gt;right, t2-\u0026gt;right); return t1; } }; 226 翻转二叉树 翻转一个二叉树。\n先将左右子树分别翻转，再交换两者的位置。\nclass Solution { public: TreeNode *invertTree(TreeNode *root) { if (!root) return nullptr; TreeNode *left = invertTree(root-\u0026gt;left), *right = invertTree(root-\u0026gt;right); root-\u0026gt;right = left; root-\u0026gt;left = right; return root; } }; 104 二叉树的最大深度 找出一个二叉树的最大深度。\n每层深度为 1，加上左右子树中更大的深度即为最大深度。\nclass Solution { public: int maxDepth(TreeNode *root) { if (!root) return 0; return 1 + max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)); } }; 965 单值二叉树 判断一个二叉树是否是一个单值二叉树。\n判断每个节点与其左右节点的值是否相同即可。\nclass Solution { public: bool isUnivalTree(TreeNode *root) { if (!root) return true; return (root-\u0026gt;left ? root-\u0026gt;val == root-\u0026gt;left-\u0026gt;val : true) \u0026amp;\u0026amp; (root-\u0026gt;right ? root-\u0026gt;val == root-\u0026gt;right-\u0026gt;val : true) \u0026amp;\u0026amp; isUnivalTree(root-\u0026gt;left) \u0026amp;\u0026amp; isUnivalTree(root-\u0026gt;right); } }; 559 N叉树的最大深度 找到一个 N 叉树的最大深度。\n每层深度为 1，加上其所有子树中最大的深度即为最大深度。\nclass Solution { public: int maxDepth(Node* root) { if (!root) return 0; int depth = 0; for (auto \u0026amp;c:root-\u0026gt;children) depth = max(depth, maxDepth(c)); return 1 + depth; } }; 563 二叉树的坡度 计算一个二叉树的坡度。\n对于每个节点，计算其左子树和右子树的和，将其差的绝对值加到总的坡度上，再返回左子树，右子树，与自己的值的和，递归调用即可。\nclass Solution { int res; public: int findTilt(TreeNode *root) { res = 0; CalcTilt(root); return res; } int CalcTilt(TreeNode *node) { if (!node) return 0; int left = CalcTilt(node-\u0026gt;left); int right = CalcTilt(node-\u0026gt;right); res += abs(left - right); return node-\u0026gt;val + left + right; } }; 508 出现次数最多的子树元素和 找出一个二叉树中出现次数最多的子树元素和。\n计算出一个节点的左子树和右子树的子树元素和，加上自身的值就是一个完整的子树元素和，递归调用计算所有的节点并计数即可。\nclass Solution { unordered_map\u0026lt;int, int\u0026gt; count; public: vector\u0026lt;int\u0026gt; findFrequentTreeSum(TreeNode *root) { vector\u0026lt;int\u0026gt; res; count = unordered_map\u0026lt;int, int\u0026gt;(); Traverse(root); int n = 0; for (auto \u0026amp;c:count) { if (c.second \u0026gt; n) { n = c.second; res.clear(); res.push_back(c.first); } else if (c.second == n) res.push_back(c.first); } return res; } int Traverse(TreeNode *root) { if (!root) return 0; int val = Traverse(root-\u0026gt;left) + Traverse(root-\u0026gt;right) + root-\u0026gt;val; ++count[val]; return val; } }; 5. 栈求解 623 在二叉树中增加一行 给一个二叉树，在第 d 层追加一行值为 v 的节点。\n用一个栈保存一层的所有节点，逐层遍历即可。注意 d = 1 时要单独处理。\nclass Solution { public: TreeNode *addOneRow(TreeNode *root, int v, int d) { if (!root) return nullptr; if (d == 1) { TreeNode *new_root = new TreeNode(v); new_root-\u0026gt;left = root; return new_root; } queue\u0026lt;TreeNode *\u0026gt; q; q.push(root); int depth = 1, n = 1; while (!q.empty() \u0026amp;\u0026amp; depth \u0026lt; d) { for (int i = 0; i \u0026lt; n; ++i) { TreeNode *node = q.front(); q.pop(); if (depth == d - 1) { TreeNode *left = node-\u0026gt;left, *right = node-\u0026gt;right; node-\u0026gt;left = new TreeNode(v); node-\u0026gt;right = new TreeNode(v); node-\u0026gt;left-\u0026gt;left = left; node-\u0026gt;right-\u0026gt;right = right; } if (node-\u0026gt;left) q.push(node-\u0026gt;left); if (node-\u0026gt;right) q.push(node-\u0026gt;right); } ++depth; n = q.size(); } return root; } }; 6. 找节点 1123. 最深叶节点的最近公共祖先 找到一个二叉树最深的叶节点的最近公共祖先。\n可以先用层序遍历找到二叉树的深度，再通过一次递归找到所有叶节点的公共祖先。\nclass Solution { TreeNode *res; int lvl; public: TreeNode *lcaDeepestLeaves(TreeNode *root) { if (!root) return nullptr; res = nullptr; lvl = 0; queue\u0026lt;TreeNode *\u0026gt; nodes; nodes.push(root); int n = 1; while (!nodes.empty()) { for (int i = 0; i \u0026lt; n; ++i) { TreeNode *node = nodes.front(); nodes.pop(); if (node-\u0026gt;left) nodes.push(node-\u0026gt;left); if (node-\u0026gt;right) nodes.push(node-\u0026gt;right); } ++lvl; n = nodes.size(); } FindLCA(root, 1); return res; } bool FindLCA(TreeNode *root, int l) { if (root \u0026amp;\u0026amp; l == lvl) { res = root; return true; } else if (!root) return false; bool left = FindLCA(root-\u0026gt;left, l + 1), right = FindLCA(root-\u0026gt;right, l + 1); if (left \u0026amp;\u0026amp; right) res = root; return left || right; } }; 但实际上我们并不需要知道这棵树的深度，只需要知道最深的节点即是叶节点，并且如果一个节点的左子树和右子树的最深节点的深度相同，那么这个节点就是他们的最近公共祖先，返回这个节点即可。\nclass Solution { public: TreeNode *lcaDeepestLeaves(TreeNode *root) { return FindLCA(root).first; } pair\u0026lt;TreeNode *, int\u0026gt; FindLCA(TreeNode *root) { if (!root) return pair\u0026lt;TreeNode *, int\u0026gt;(nullptr, 0); auto left = FindLCA(root-\u0026gt;left), right = FindLCA(root-\u0026gt;right); if (left.second \u0026gt; right.second) return pair\u0026lt;TreeNode *, int\u0026gt;(left.first, left.second + 1); if (left.second \u0026lt; right.second) return pair\u0026lt;TreeNode *, int\u0026gt;(right.first, right.second + 1); return pair\u0026lt;TreeNode *, int\u0026gt;(root, left.second + 1); } } ","permalink":"https://prov1dence.top/posts/leetcode/tree-3/","summary":"\u003ch1 id=\"leetcode-树3httpsleetcode-cncomtagtree\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/tree/\"\u003eLeetCode 树（3）\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"4-递归求解\"\u003e4. 递归求解\u003c/h3\u003e\n\u003ch4 id=\"617-合并二叉树httpsleetcode-cncomproblemsmerge-two-binary-trees\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/merge-two-binary-trees/\"\u003e617 合并二叉树\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e合并两个二叉树。\u003c/p\u003e\n\u003cp\u003e判断各个节点是否存在，全部合并到一棵树上即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003emergeTrees(TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003et1, TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003et2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003et1 \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003et2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003et1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e t2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003et2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e t1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        t1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eval \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e t2\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eval;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        t1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eleft \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e mergeTrees(t1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eleft, t2\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eleft);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        t1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eright \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e mergeTrees(t1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eright, t2\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eright);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e t1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"226-翻转二叉树httpsleetcode-cncomproblemsinvert-binary-tree\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/invert-binary-tree/\"\u003e226 翻转二叉树\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e翻转一个二叉树。\u003c/p\u003e\n\u003cp\u003e先将左右子树分别翻转，再交换两者的位置。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003einvertTree(TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eroot) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003eroot)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eleft \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e invertTree(root\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eleft), \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eright \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e invertTree(root\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eright);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        root\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eright \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e left;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        root\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eleft \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e right;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e root;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"104-二叉树的最大深度httpsleetcode-cncomproblemsmaximum-depth-of-binary-tree\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\"\u003e104 二叉树的最大深度\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e找出一个二叉树的最大深度。\u003c/p\u003e","title":"LeetCode 树（3）"},{"content":"LeetCode 排序 题目 56 合并区间 按照间隔的起始进行排序，判断下一个间隔的起始是否大于前一个间隔的末尾，如果大于的话就把之前的间隔加入结果数组，否则继续扩展当前的间隔。\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;intervals) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; int n = intervals.size(); if (n == 0) return res; sort(intervals.begin(), intervals.end(), [](vector\u0026lt;int\u0026gt; const \u0026amp;v1, vector\u0026lt;int\u0026gt; const \u0026amp;v2) { return v1[0] \u0026lt; v2[0]; }); int start = intervals[0][0], end = intervals[0][1]; for (int i = 1; i \u0026lt; n; ++i) { if (intervals[i][0] \u0026gt; end) { res.push_back(vector\u0026lt;int\u0026gt;{start, end}); start = intervals[i][0]; } end = max(end, intervals[i][1]); } res.push_back(vector\u0026lt;int\u0026gt;{start, end}); return res; } }; 179 最大数 先把数字转换为字符串，然后自定义类似于字典序的排序规则 s1 + s2 \u0026gt; s2 + s1 进行排序。\nclass Solution { public: string largestNumber(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0, n = nums.size(); string res; vector\u0026lt;string\u0026gt; strs(n); for (i = 0; i \u0026lt; n; ++i) strs[i] = to_string(nums[i]); sort(strs.begin(), strs.end(), [](const string \u0026amp;s1, const string \u0026amp;s2) { return s1 + s2 \u0026gt; s2 + s1; }); for (i = 0; i \u0026lt; n; ++i) res += strs[i]; i = 0; while (i \u0026lt; res.size() - 1 \u0026amp;\u0026amp; res[i] == \u0026#39;0\u0026#39;) ++i; return res.substr(i); } }; 324 摆动排序 II 先对数组进行排序，然后从小到大地将数字间隔着放在新的数组中，这样偶数位上的数字一定比奇数位上的数字大。如果数组长度为偶数，那么初始位置是 n - 2（倒数第二位），否则是 n - 1（最后一位），不从第一位开始是因为有些。这样做时间复杂度是 O(nlogn)，空间复杂度是 O(n)。\nclass Solution { public: void wiggleSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(), i = n % 2 == 0 ? n - 2 : n - 1; vector\u0026lt;int\u0026gt; res(n); sort(nums.begin(), nums.end()); for (int j = 0; j \u0026lt; n; ++j) { res[i] = nums[j]; i -= 2; if (i \u0026lt; 0) i = n % 2 == 0 ? n - 1 : n - 2; } nums = res; } }; 524 通过删除字母匹配到字典里最长单词 用双指针判断字典里的每一个字符串是否满足要求，并比较满足要求的字符串与结果字符串，找到长度最长，字典序最小的返回即可。\nclass Solution { public: string findLongestWord(string s, vector\u0026lt;string\u0026gt; \u0026amp;d) { string res; for (auto \u0026amp;ds:d) { int l = 0; for (int i = 0; i \u0026lt; s.size(); ++i) { if (s[i] == ds[l]) ++l; if (l == ds.size()) { if (ds.size() \u0026gt; res.size() || (ds.size() == res.size() \u0026amp;\u0026amp; ds \u0026lt; res)) res = ds; break; } } } return res; } }; 969 煎饼排序 每次把在 [0, j] 内的最大的数移动到 A[j] 的位置上并 \u0026ndash;j，每次需要进行两次翻转，一次是把 [0, j] 内最大的数翻转到 A[0]上，一次是把 A[0] 翻转到 A[j] 上，这样就能保证每次都把最大的数移动到了 [0, j] 的末尾，重复这个过程直到 j 减少为 1，此时只剩 1 个数字，结束循环即可。因为在循环内做了翻转操作，时间复杂度是 O(n^2)，空间复杂度是 O(1)。\nclass Solution { public: vector\u0026lt;int\u0026gt; pancakeSort(vector\u0026lt;int\u0026gt; \u0026amp;A) { vector\u0026lt;int\u0026gt; res; int n = A.size(), j = n; while (j \u0026gt; 1) { int idx = 0; for (int i = 0; i \u0026lt; j; ++i) if (A[i] \u0026gt; A[idx]) idx = i; if (idx != j - 1) { if (idx != 0) { reverse(A.begin(), A.begin() + idx + 1); res.push_back(idx + 1); } reverse(A.begin(), A.begin() + j); res.push_back(j); } --j; } return res; } }; 1122 数组的相对排序 给 arr2 中的数字按照下标赋予权制，按照权制数组进行排序即可。\nclass Solution { public: vector\u0026lt;int\u0026gt; relativeSortArray(vector\u0026lt;int\u0026gt;\u0026amp; arr1, vector\u0026lt;int\u0026gt;\u0026amp; arr2) { vector\u0026lt;int\u0026gt; auth(1001); for (int i = 0; i \u0026lt;= 1000; ++i) auth[i] = 1001 + i; for (int i = 0; i \u0026lt; arr2.size(); ++i) auth[arr2[i]] = i; sort(arr1.begin(), arr1.end(), [\u0026amp;](const int \u0026amp;c1, const int \u0026amp;c2) { return auth[c1] \u0026lt; auth[c2]; }); return arr1; } }; ","permalink":"https://prov1dence.top/posts/leetcode/sort/","summary":"\u003ch1 id=\"leetcode-排序httpsleetcode-cncomtagsort\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/sort/\"\u003eLeetCode 排序\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch4 id=\"56-合并区间httpsleetcode-cncomproblemsmerge-intervals\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/merge-intervals/\"\u003e56 合并区间\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e按照间隔的起始进行排序，判断下一个间隔的起始是否大于前一个间隔的末尾，如果大于的话就把之前的间隔加入结果数组，否则继续扩展当前的间隔。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e merge(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eintervals) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e intervals.size();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (n \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        sort(intervals.begin(), intervals.end(), [](vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ev1, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ev2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e v1[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e v2[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e start \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e intervals[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e][\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e], end \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e intervals[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e][\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (intervals[i][\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e end) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                res.push_back(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e{start, end});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                start \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e intervals[i][\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            end \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e max(end, intervals[i][\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        res.push_back(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e{start, end});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"179-最大数httpsleetcode-cncomproblemslargest-number\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/largest-number/\"\u003e179 最大数\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e先把数字转换为字符串，然后自定义类似于字典序的排序规则 s1 + s2 \u0026gt; s2 + s1 进行排序。\u003c/p\u003e","title":"LeetCode 排序"},{"content":"LeetCode 堆 题目 215 数组中的第 K 个最大元素 最简单的堆的应用。\nclass Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; heap; for (auto \u0026amp;m:nums) { if (heap.size() \u0026lt; k || m \u0026gt; heap.top()) heap.push(m); if (heap.size() \u0026gt; k) heap.pop(); } return heap.top(); } }; 347 前 K 个高频元素 先遍历一次统计出数组中各个元素出现的次数，再用一个大根堆将前 k 个高频元素保存下来，最后再将这些元素依次 pop 出来存入结果数组。时间复杂度是 O(n)，空间复杂度是 O(n)。\nclass Solution { public: vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; freq; unordered_map\u0026lt;int, int\u0026gt; count; vector\u0026lt;int\u0026gt; res(k, 0); for (auto \u0026amp;m:nums) ++count[m]; for (auto \u0026amp;c:count) { freq.push(pair\u0026lt;int, int\u0026gt;(c.second, c.first)); if (freq.size() \u0026gt; k) freq.pop(); } for (int i = 0; i \u0026lt; k; ++i) { pair\u0026lt;int, int\u0026gt; p = freq.top(); freq.pop(); res[i] = p.second; } return res; } }; 451 根据字符出现频率排序 用一个大根堆保存每个字符出现的频率，然后依次将原字符串覆盖即可。\nclass Solution { struct Element { int asc; int num; Element() : num(0) {} }; struct Compare { bool operator()(Element \u0026amp;e1, Element \u0026amp;e2) { return e1.num \u0026lt; e2.num; } }; public: string frequencySort(string s) { vector\u0026lt;Element\u0026gt; count(200); for (int i = 0; i \u0026lt; 200; ++i) count[i].asc = i; for (auto c:s) ++count[c].num; priority_queue\u0026lt;Element, vector\u0026lt;Element\u0026gt;, Compare\u0026gt; heap; for (auto \u0026amp;c:count) if (c.num != 0) heap.push(c); int i = 0; while (!heap.empty()) { auto t = heap.top(); heap.pop(); for (int j = 0; j \u0026lt; t.num; ++j) s[i++] = t.asc; } return s; } }; 692 前 K 个高频单词 用一个 pair\u0026lt;string, int\u0026gt; 或结构体保存每个字符串及其计数的信息，并维护一个小根堆，保证堆里存储前 K 个高频单词，放回堆里的所有元素。\nclass Solution { struct Comp { bool operator()(pair\u0026lt;string, int\u0026gt; const \u0026amp;p1, pair\u0026lt;string, int\u0026gt; const \u0026amp;p2) { if (p1.second == p2.second) return p1.first \u0026lt; p2.first; return p1.second \u0026gt; p2.second; } }; public: vector\u0026lt;string\u0026gt; topKFrequent(vector\u0026lt;string\u0026gt; \u0026amp;words, int k) { vector\u0026lt;string\u0026gt; res(k); unordered_map\u0026lt;string, int\u0026gt; count; priority_queue\u0026lt;pair\u0026lt;string, int\u0026gt;, vector\u0026lt;pair\u0026lt;string, int\u0026gt;\u0026gt;, Comp\u0026gt; heap; for (auto \u0026amp;word:words) ++count[word]; for (auto \u0026amp;c:count) { heap.push(c); if (heap.size() \u0026gt; k) heap.pop(); } for (int i = 0; i \u0026lt; k; ++i) { res[i] = heap.top().first; heap.pop(); } reverse(res.begin(), res.end()); return res; } }; 778 水位上升的泳池中游泳 类似于 AI 中用到的 Greedy Best-First Search 方法。不能用贪心是因为未访问过的路径中可能出现最优解，比如 [[0, 4, 7], [5, 8, 9], [2, 3, 1]] 这个矩阵，如果采用贪心会经过路径 0 -\u0026gt; 4 -\u0026gt; 7 -\u0026gt; 9 -\u0026gt; 1，而实际上最优路径是 0 -\u0026gt; 5 - \u0026gt; 2 -\u0026gt; 3 -\u0026gt; 1，所以需要把之前未经过的节点值保存下来，以便在贪心的过程中遇到当前节点大于之前未经过的节点时重新回到之前的位置继续搜索，保存的方法是用一个小根堆保存所有可能经过的下一步节点，这样就可以每次从堆顶取出下一步的最优值，而搜索的策略则用 DFS，每次尝试四个方向未访问过的节点。时间复杂度是 O(n)。\nclass Solution { struct Element { int val; int x, y; Element(int val, int x, int y) : val(val), x(x), y(y) {} }; struct Compare { bool operator()(Element const \u0026amp;e1, Element const \u0026amp;e2) { return e1.val \u0026gt; e2.val; } }; int dir[4][2] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; public: int swimInWater(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { int m = grid.size(), n = m ? grid[0].size() : 0, res = 0; if (m == 0) return 0; priority_queue\u0026lt;Element, vector\u0026lt;Element\u0026gt;, Compare\u0026gt; heap; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(m, vector\u0026lt;bool\u0026gt;(n, false)); heap.push(Element(grid[0][0], 0, 0)); visited[0][0] = true; while (!heap.empty()) { Element e = heap.top(); heap.pop(); res = max(res, e.val); if (e.x == m - 1 \u0026amp;\u0026amp; e.y == n - 1) break; for (auto \u0026amp;d:dir) { int x = e.x + d[0], y = e.y + d[1]; if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; m \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; n \u0026amp;\u0026amp; !visited[x][y]) { heap.push(Element(grid[x][y], x, y)); visited[x][y] = true; } } } return res; } }; 703 数据流中的第 K 大元素 维护一个大小为 K 的小根堆，如果新的数比堆顶元素大则将这个数 push 进去并维护堆，当堆中的元素数量超过 K 时 pop 出堆顶元素并维护堆。\nclass KthLargest { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; min_heap; int k; public: KthLargest(int k, vector\u0026lt;int\u0026gt; \u0026amp;nums) { this-\u0026gt;k = k; min_heap = priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt;(); for (auto \u0026amp;m:nums) { if (min_heap.size() \u0026lt; k || min_heap.top() \u0026lt; m) min_heap.push(m); if (min_heap.size() \u0026gt; k) min_heap.pop(); } } int add(int val) { if (min_heap.size() \u0026lt; k || min_heap.top() \u0026lt; val) min_heap.push(val); if (min_heap.size() \u0026gt; k) min_heap.pop(); return min_heap.top(); } }; 295 数据流的中位数 最优的做法是用一个大根堆和一个小根堆，前者存数据流的后半部分，前者存数据流的前半部分，这样两个堆的堆顶分别是当前数据流的中间的较大和较小的数，每次去中位数只需要取堆顶元素即可，因此取数的时间复杂度是 O(1)，插入数的时间复杂度是 O(logk)，k 是数据流数据总数的一半。还可以用二分查找加上插入排序的做法，这样做插入的时间复杂度是 O(n)，需要将数据流中大于插入数据的所有数往右移动，查找的时间复杂度是 O(logn)。\nclass MedianFinder { priority_queue\u0026lt;double\u0026gt; max_heap; priority_queue\u0026lt;double, vector\u0026lt;double\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; min_heap; public: /** initialize your data structure here. */ MedianFinder() { max_heap = priority_queue\u0026lt;double\u0026gt;(); min_heap = priority_queue\u0026lt;double, vector\u0026lt;double\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt;(); } void addNum(int num) { if (max_heap.empty() || max_heap.top() \u0026gt; num) max_heap.push(num); else min_heap.push(num); while (max_heap.size() \u0026gt; min_heap.size() + 1) { min_heap.push(max_heap.top()); max_heap.pop(); } while (min_heap.size() \u0026gt; max_heap.size() + 1) { max_heap.push(min_heap.top()); min_heap.pop(); } } double findMedian() { int ls = max_heap.size(), rs = min_heap.size(); if ((ls + rs) % 2 == 0) return (max_heap.top() + min_heap.top()) * 1.0 / 2; return ls \u0026gt; rs ? max_heap.top() : min_heap.top(); } }; ","permalink":"https://prov1dence.top/posts/leetcode/heap/","summary":"\u003ch1 id=\"leetcode-堆httpsleetcode-cncomtagheap\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/heap/\"\u003eLeetCode 堆\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch4 id=\"215-数组中的第-k-个最大元素httpsleetcode-cncomproblemskth-largest-element-in-an-array\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\"\u003e215 数组中的第 K 个最大元素\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e最简单的堆的应用。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e findKthLargest(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003enums, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e k) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        priority_queue\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e, greater\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026gt;\u0026gt;\u003c/span\u003e heap;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003em:nums) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (heap.size() \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e k \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e heap.top())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                heap.push(m);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (heap.size() \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e k)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                heap.pop();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e heap.top();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"347-前-k-个高频元素httpsleetcode-cncomproblemstop-k-frequent-elementssubmissions\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/top-k-frequent-elements/submissions/\"\u003e347 前 K 个高频元素\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e先遍历一次统计出数组中各个元素出现的次数，再用一个大根堆将前 k 个高频元素保存下来，最后再将这些元素依次 pop 出来存入结果数组。时间复杂度是 O(n)，空间复杂度是 O(n)。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e topKFrequent(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003enums, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e k) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        priority_queue\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003epair\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003epair\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e, greater\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026gt;\u0026gt;\u003c/span\u003e freq;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        unordered_map\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e count;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e res(k, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003em:nums)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ecount[m];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ec:count) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            freq.push(pair\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(c.second, c.first));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (freq.size() \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e k)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                freq.pop();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e k; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            pair\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e p \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e freq.top();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            freq.pop();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            res[i] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e p.second;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"451-根据字符出现频率排序httpsleetcode-cncomproblemssort-characters-by-frequency\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/sort-characters-by-frequency/\"\u003e451 根据字符出现频率排序\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e用一个大根堆保存每个字符出现的频率，然后依次将原字符串覆盖即可。\u003c/p\u003e","title":"LeetCode 堆"},{"content":"LeetCode DFS 题目 26 删除排序数组中的重复项 用两个指针 len 和 i 分别表示没有重复的项的下标与遍历数组的下标，将没有重复的项拷贝到 nums[len] 下然后 ++len 即可。\nclass Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int count = 0, len = 1, n = nums.size(); if (n == 0) return 0; for (int i = 1; i \u0026lt; n; ++i) { if (nums[i] == nums[i - 1]) continue; nums[len] = nums[i]; ++len; } return len; } }; 80 删除排序数组中的重复项 II 用两个指针 len 和 i 分别表示没有最多重复 2 次的项的下标与遍历数组的下标，将重复数小于等于 1 的项拷贝到 nums[len] 下然后 ++len 即可。\nclass Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int count = 0, len = 1, n = nums.size(); if (n == 0) return 0; for (int i = 1; i \u0026lt; nums.size(); ++i) { if (nums[i] == nums[i - 1]) { if (count \u0026gt; 0) continue; ++count; } else count = 0; nums[len] = nums[i]; ++len; } return len; } }; 922 按奇偶排序数组 II 用两个下标 i 和 j 分别表示偶数位和奇数位的下标，如果偶数位下标对应的数不是偶数那么将其与奇数位下标对应的数不是奇数的数进行交换。\nclass Solution { public: vector\u0026lt;int\u0026gt; sortArrayByParityII(vector\u0026lt;int\u0026gt;\u0026amp; A) { for (int i = 0, j = 1; i \u0026lt; A.size(); i += 2) if (A[i] % 2 != 0) { while (j \u0026lt; A.size() \u0026amp;\u0026amp; A[j] % 2 != 0) j += 2; swap(A[i], A[j]); } return A; } }; 11 盛最多水的容器 用两个指针分别表示数组的头和尾，每次将高度较低的元素的下标往中间移动，同时更新结果。\nclass Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; h) { int i = 0, j = h.size() - 1, res = 0; while (i \u0026lt; j) { res = max(res, min(h[i], h[j]) * (j - i)); if (h[i] \u0026lt; h[j]) ++i; else --j; } return res; } }; 287 寻找重复数 将出现的数字的绝对值 - 1 作为下标，把对应位置的数字乘以 -1 进行标记，因为只有一个数字重复了，所以如果在标记时如果发现对应位置的数字已经是负数则说明出现过相同的下标，返回该数字即可。\nclass Solution { public: int findDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size(); ++i) { int index = abs(nums[i]) - 1; if (nums[index] \u0026lt; 0) return abs(nums[i]); nums[index] *= -1; } return 0; } }; 75 颜色分类 类似于只有两个数的数组排序，只需要用两个变量 idx_0 = 0, idx_2 = n - 1 分别表示两端的下标，将 0 和 2 分别替换到数组的两端，将 1 留在中间即可。\nclass Solution { public: void sortColors(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(), idx_0 = 0, idx_2 = n - 1; for (int i = 0; i \u0026lt;= idx_2; ++i) { if (nums[i] == 2) { swap(nums[i], nums[idx_2]); --idx_2, --i; } else if (nums[i] == 0) { swap(nums[i], nums[idx_0]); ++idx_0; } } } }; 15 三数之和 首先明确两数之和的做法：排序后用两个指针分别从头和尾往中间遍历，根据大小关系移动指针。三数之和无非就是先固定一个数，使得另外两个数之和等于这个数的负数，因此仍然要先对数组进行排序，为了固定一个数需要用一个 for 循环遍历数组，对于其后的所有元素用两数之和的方法进行求和。为了防止出现重复需要在计算两数之和后不断地移动指针直到当前元素与其前/后一个元素不相同。时间复杂度是 O(n ^ 2)，空间复杂度是 O(1)。\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; int n = nums.size(), i = 0; while (i \u0026lt; n) { int j = i + 1, k = n - 1, target = -nums[i]; while (j \u0026lt; k) { if (nums[j] + nums[k] == target) { res.push_back({nums[i], nums[j], nums[k]}); do ++j; while (j \u0026lt; k \u0026amp;\u0026amp; nums[j] == nums[j - 1]); do --k; while (j \u0026lt; k \u0026amp;\u0026amp; nums[k] == nums[k + 1]); } else if (nums[j] + nums[k] \u0026lt; target) ++j; else --k; } do ++i; while (i \u0026lt; n \u0026amp;\u0026amp; nums[i] == nums[i - 1]); } return res; } }; 424 替换后的最长重复字符 对于一个子串，我们只需要知道这个子串中出现次数最多的字符的出现次数，就可以根据 j - i + 1 - max_count \u0026lt;= k 知道这个子串是否能被替换为重复子串，因此用滑动窗口的方法固定一个子串，如果这个子串满足条件，那么我们将滑动窗口的右端 j 继续往后移动，否则需要将左端往后移动直到这个子串满足条件，j - i + 1 就是可能的最长重复子串的长度。时间复杂度是 O(n)，空间复杂度是 O(1)。\nclass Solution { public: int characterReplacement(string s, int k) { int i = 0, j = 0, res = 0, n = s.size(), max_count = 0; vector\u0026lt;int\u0026gt; count(26, 0); while (j \u0026lt; n) { ++count[s[j] - \u0026#39;A\u0026#39;]; max_count = max(max_count, count[s[j] - \u0026#39;A\u0026#39;]); while (j - i + 1 - max_count \u0026gt; k) { --count[s[i] - \u0026#39;A\u0026#39;]; ++i; for (auto \u0026amp;c:count) max_count = max(max_count, c); } res = max(res, j - i + 1); ++j; } return res; } }; 1004 最大连续 1 的个数 III 用左右两个指针保证滑动窗口中有小于等于 K 个 0，如果当前位是 1 那么右边的指针继续向后移动，如果当前位是 0 并且已经有 K 个 0，那么左边的指针往右移动直到出现 0，跳过这一位 0，将右边指针的 0 视作 1，更新结果。\nclass Solution { public: int longestOnes(vector\u0026lt;int\u0026gt; \u0026amp;A, int K) { int i = 0, res = 0; for (int j = 0; j \u0026lt; A.size(); ++j) { if (A[j] == 0) { if (K \u0026gt; 0) --K; else { while (A[i] == 1) ++i; ++i; } } res = max(res, j - i + 1); } return res; } }; 42 接雨水 可以先将每个位置左边和右边最高的柱子高度都保存下来，再计算两者中较低的减去当前位置的柱子数量得到当前位置能够接住的雨水数量。\nclass Solution { public: int trap(vector\u0026lt;int\u0026gt; \u0026amp;height) { int n = height.size(), res = 0; vector\u0026lt;int\u0026gt; left(n, 0), right(n, 0); for (int i = 1; i \u0026lt; n; ++i) left[i] = max(left[i - 1], height[i - 1]); for (int i = n - 2; i \u0026gt;= 0; --i) right[i] = max(right[i + 1], height[i + 1]); for (int i = 0; i \u0026lt; n; ++i) res += max(0, min(left[i], right[i]) - height[i]); return res; } }; 也可以用两个变量 l_max 和 r_max 分别记录左边和右边到目前为止最高的柱子高度，每次检查较低的一边，能够接住的雨水数量等于 min(l_max, r_max) 减去当前的柱子高度，同时更新柱子的最高高度。\nclass Solution { public: int trap(vector\u0026lt;int\u0026gt; \u0026amp;height) { int n = height.size(), res = 0, l_max = 0, r_max = 0, i = 0, j = n - 1; while (i \u0026lt;= j) { if (l_max \u0026lt;= r_max) { res += max(0, min(l_max, r_max) - height[i]); l_max = max(l_max, height[i]); ++i; } else { res += max(0, min(l_max, r_max) - height[j]); r_max = max(r_max, height[j]); --j; } } return res; } }; 632 最小区间 比较容易想到的方法是从每个数组的第一个元素开始遍历，使用一个数组 idx 存储每一个数组当前遍历到的元素的下标，每次取这些元素中的最大最小值进行更新，这样做时间复杂度是 O(m * n)，其中 m 是数组的个数，n 是所有元素的个数，但是这样做会 TLE。相较于每次都遍历一遍整个二维数组，我们可以用一个小根堆把所有当前遍历到的元素中的最小值连带其数组下标及其下标保存下来，这样就能每次以 O(1) 的时间复杂度取到所有数组中当前元素的最小值，再用一个变量 max_val 存储所有数组中当前元素的最大值，每次从小根堆 pop 出堆顶元素后，先更新 res 结果数组，然后用这个元素对应下标的后一个下标的值更新 max_val，直到堆顶元素已经是数组的最后一个元素。时间复杂度是 O(m * logn)。\nclass Solution { struct element { int val; int vec_idx; int idx; element(int val, int vec_idx, int idx) : val(val), vec_idx(vec_idx), idx(idx) {} }; struct Compare { bool operator()(const element \u0026amp;e1, const element \u0026amp;e2) { return e1.val \u0026gt; e2.val; } }; public: vector\u0026lt;int\u0026gt; smallestRange(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;nums) { int n = nums.size(), max_val = INT_MIN; vector\u0026lt;int\u0026gt; res(2, 0); res[1] = INT_MAX; priority_queue\u0026lt;element, vector\u0026lt;element\u0026gt;, Compare\u0026gt; heap; for (int i = 0; i \u0026lt; n; ++i) { heap.push(element(nums[i][0], i, 0)); max_val = max(max_val, nums[i][0]); } while (true) { element e = heap.top(); heap.pop(); if (res[1] - res[0] \u0026gt; max_val - e.val) res[0] = e.val, res[1] = max_val; if (e.idx == nums[e.vec_idx].size() - 1) break; ++e.idx; e.val = nums[e.vec_idx][e.idx]; heap.push(e); max_val = max(max_val, e.val); } return res; } }; 76 最小覆盖子串 先从左往右找到一个符合条件的字符串，然后用滑动窗口的做法每次在左边去掉一个字符，往右边找到一个未被使用过的对应的字符，如果长度小于之前得到的字符串则更新结果。\nclass Solution { struct Element { int pos; char c; Element(int pos, char c) : pos(pos), c(c) {} }; public: string minWindow(string s, string t) { string res; unordered_map\u0026lt;char, int\u0026gt; count; vector\u0026lt;Element\u0026gt; ele; unordered_set\u0026lt;int\u0026gt; used; for (auto c:t) ++count[c]; for (int i = 0; i \u0026lt; s.size(); ++i) if (count.find(s[i]) != count.end()) ele.push_back(Element(i, s[i])); int i = 0, j = 0, n = ele.size(), pos = 0, l = n, start = 0, end = 0; while (j \u0026lt; n \u0026amp;\u0026amp; !count.empty()) { if (count.find(ele[j].c) != count.end()) { --count[ele[j].c]; used.insert(j); end = max(end,j); if (count[ele[j].c] == 0) count.erase(ele[j].c); } ++j; } if (!count.empty()) return res; res = s.substr(ele[i].pos, ele[j - 1].pos - ele[i].pos + 1); while (start \u0026lt; n) { char target = ele[start].c; used.erase(start); ++start; int k = start; while (k \u0026lt; n) { if (ele[k].c == target \u0026amp;\u0026amp; used.find(k) == used.end()) { used.insert(k); end = min(n - 1, max(end, k)); if (res.size() \u0026gt; ele[end].pos - ele[start].pos + 1) res = s.substr(ele[start].pos, ele[end].pos - ele[start].pos + 1); break; } ++k; } if (k == n) break; } return res; } }; 992 K 个不同整数的子数组 用两个指针 left 和 right 保证滑动窗口内子数组中不同的整数有 K 个，当最左边数的计数大于 1 时代表由 [left, right] 组成的数组和 [left + 1, right] 组成的数组都是符合题意的含有 K 个不同整数的子数组，并且如果 [left + 1, right + 1] 也是符合题意的数组的话那么 [left, right + 1] 也是符合题意的数组，因此 ++acc 并 ++left，当哈希表的 size 等于 K 时将现在 acc 加到结果上去即可。时间复杂度是 O(n)，空间复杂度是 O(n)。\nclass Solution { public: int subarraysWithKDistinct(vector\u0026lt;int\u0026gt; \u0026amp;A, int K) { unordered_map\u0026lt;int, int\u0026gt; count; int acc = 1, res = 0, left = 0; for (int right = 0; right \u0026lt; A.size(); ++right) { ++count[A[right]]; while (count.size() \u0026gt; K) { --count[A[left]]; if (count[A[left]] == 0) count.erase(A[left]); ++left; acc = 1; } while (count[A[left]] \u0026gt; 1) { --count[A[left]]; ++left; ++acc; } if (count.size() == K) res += acc; } return res; } }; 239 滑动窗口最大值 用一个类似单调栈的双端队列存储滑动窗口中的元素，当需要 push_back 进来的数大于其前面的数时，不断的将小于它的数 pop_back，这样一来双端队列的 front 位置一定是当前滑动窗口里最大的数，当滑动窗口移动时最左边的数如果等于双端队列中 front 位置的数时则 pop_front，这样一来 front 位置的数仍然是当前滑动窗口里最大的数。这样做时间复杂度是 O(n)，空间复杂度是 O(n)。\nclass Solution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { int n = nums.size(); deque\u0026lt;int\u0026gt; d; vector\u0026lt;int\u0026gt; res; if (n == 0) return res; for (int i = 0; i \u0026lt; k; ++i) { while (!d.empty() \u0026amp;\u0026amp; d.back() \u0026lt; nums[i]) d.pop_back(); d.push_back(nums[i]); } res.push_back(d.front()); for (int i = k; i \u0026lt; n; ++i) { if (!d.empty() \u0026amp;\u0026amp; nums[i - k] == d.front()) d.pop_front(); while (!d.empty() \u0026amp;\u0026amp; d.back() \u0026lt; nums[i]) d.pop_back(); d.push_back(nums[i]); res.push_back(d.front()); } return res; } }; ","permalink":"https://prov1dence.top/posts/leetcode/twopointers/","summary":"\u003ch1 id=\"leetcode-dfshttpsleetcode-cncomtagtwo-pointers\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/two-pointers/\"\u003eLeetCode DFS\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch4 id=\"26-删除排序数组中的重复项httpsleetcode-cncomproblemsremove-duplicates-from-sorted-array\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\"\u003e26 删除排序数组中的重复项\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e用两个指针 len 和 i 分别表示没有重复的项的下标与遍历数组的下标，将没有重复的项拷贝到 nums[len] 下然后 ++len 即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e removeDuplicates(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026amp;\u003c/span\u003e nums) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e count \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, len \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e nums.size();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (n \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (nums[i] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e nums[i \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            nums[len] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e nums[i];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003elen;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e len;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"80-删除排序数组中的重复项-iihttpsleetcode-cncomproblemsremove-duplicates-from-sorted-array-ii\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/\"\u003e80 删除排序数组中的重复项 II\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e用两个指针 len 和 i 分别表示没有最多重复 2 次的项的下标与遍历数组的下标，将重复数小于等于 1 的项拷贝到 nums[len] 下然后 ++len 即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e removeDuplicates(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026amp;\u003c/span\u003e nums) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e count \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, len \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e nums.size();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (n \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e nums.size(); \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (nums[i] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e nums[i \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (count \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ecount;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                count \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            nums[len] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e nums[i];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003elen;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e len;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"922-按奇偶排序数组-iihttpsleetcode-cncomproblemssort-array-by-parity-ii\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/sort-array-by-parity-ii/\"\u003e922 按奇偶排序数组 II\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e用两个下标 i 和 j 分别表示偶数位和奇数位的下标，如果偶数位下标对应的数不是偶数那么将其与奇数位下标对应的数不是奇数的数进行交换。\u003c/p\u003e","title":"LeetCode 双指针"},{"content":"LeetCode DFS 题目 78 子集 典型的回溯，找出所有可能情况。\nclass Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt; \u0026amp;nums) { res = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(1, vector\u0026lt;int\u0026gt;()); vector\u0026lt;int\u0026gt; curr; DFS(nums, 0, curr); return res; } void DFS(vector\u0026lt;int\u0026gt; \u0026amp;nums, int idx, vector\u0026lt;int\u0026gt; \u0026amp;curr) { for (int i = idx; i \u0026lt; nums.size(); ++i) { curr.push_back(nums[i]); res.push_back(curr); DFS(nums, i + 1, curr); curr.pop_back(); } } }; 733 图像渲染 从给定的 image[sr][sc] 开始 DFS 或 BFS，将相邻的值相同的点的值全部修改为 newColor，注意要判断给定的 image[sr][sc] 是否等于 newColor，否则如果不使用额外空间的 visited 数组记录已经访问过的点的话会造成死循环栈溢出。\nclass Solution { int m, n; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; floodFill(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;image, int sr, int sc, int newColor) { m = image.size(), n = m ? image[0].size() : 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); if (image[sr][sc] != newColor) DFS(image, sr, sc, newColor); return image; } void DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;image, int r, int c, int val) { int ori = image[r][c]; image[r][c] = val; for (int d = 0; d \u0026lt; 4; ++d) { int i = r + dir[d][0]; int j = c + dir[d][1]; if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; image[i][j] == ori) DFS(image, i, j, val); } } }; 463 岛屿的周长 对小岛进行 DFS，根据一个点周围有几个相邻的点来计算当前点的周长。\nclass Solution { int x, y, res; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int islandPerimeter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { x = grid.size(), y = x ? grid[0].size() : 0, res = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(x, vector\u0026lt;bool\u0026gt;(y, false)); if (x == 0) return 0; for (int i = 0; i \u0026lt; x; ++i) for (int j = 0; j \u0026lt; y; ++j) if (grid[i][j] == 1) { DFS(grid, i, j); return res; } return res; } void DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { visited[i][j] = true; int edge = 4; for (int l = 0; l \u0026lt; 4; ++l) { int a = i + dir[l][0]; int b = j + dir[l][1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; x \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; y \u0026amp;\u0026amp; grid[a][b] == 1) { --edge; if (!visited[a][b]) DFS(grid, a, b); } } res += edge; } }; 200 岛屿数量 每次进行 DFS 的全部节点即为一个岛屿，DFS 完整个数组即可。\nclass Solution { vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int x, y, res; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid) { x = grid.size(), y = x ? grid[0].size() : 0, res = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(x, vector\u0026lt;bool\u0026gt;(y, 0)); if (x == 0) return 0; for (int i = 0; i \u0026lt; x; ++i) for (int j = 0; j \u0026lt; y; ++j) if (grid[i][j] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; !visited[i][j]) { ++res; DFS(grid, i, j); } return res; } void DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { visited[i][j] = true; for (int d = 0; d \u0026lt; 4; ++d) { int a = i + dir[d][0]; int b = j + dir[d][1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; x \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; y \u0026amp;\u0026amp; grid[a][b] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; !visited[a][b]) DFS(grid, a, b); } } }; 695 岛屿的最大面积 对每个岛屿进行 DFS，每次都更新最大面积即可。\nclass Solution { vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int x, y, res; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int maxAreaOfIsland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { x = grid.size(), y = x ? grid[0].size() : 0, res = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(x, vector\u0026lt;bool\u0026gt;(y, 0)); if (x == 0) return 0; for (int i = 0; i \u0026lt; x; ++i) for (int j = 0; j \u0026lt; y; ++j) if (grid[i][j] == 1 \u0026amp;\u0026amp; !visited[i][j]) { int area = 1; DFS(grid, i, j, area); } return res; } void DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j, int \u0026amp;area) { visited[i][j] = true; res = max(res, area); for (int d = 0; d \u0026lt; 4; ++d) { int a = i + dir[d][0]; int b = j + dir[d][1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; x \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; y \u0026amp;\u0026amp; grid[a][b] == 1 \u0026amp;\u0026amp; !visited[a][b]) { ++area; DFS(grid, a, b, area); } } } }; 841 钥匙和房间 对每个房间进行 DFS。\nclass Solution { vector\u0026lt;bool\u0026gt; visited; int m, n; public: bool canVisitAllRooms(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;rooms) { m = n = rooms.size(); visited = vector\u0026lt;bool\u0026gt;(n, false); return DFS(rooms, 0); } bool DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;rooms, int room_num) { --m; visited[room_num] = true; if (m == 0) return true; for (auto \u0026amp;r:rooms[room_num]) if (!visited[r] \u0026amp;\u0026amp; DFS(rooms, r)) return true; return false; } }; 113 路径总和 II 对整个树进行 DFS，在叶子节点进行判断。\nclass Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode *root, int sum) { res = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(); vector\u0026lt;int\u0026gt; path; DFS(root, sum, path); return res; } void DFS(TreeNode *root, int sum, vector\u0026lt;int\u0026gt; \u0026amp;path) { if (!root) return; path.push_back(root-\u0026gt;val); if (!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right) { if (sum - root-\u0026gt;val == 0) res.push_back(path); } else { DFS(root-\u0026gt;left, sum - root-\u0026gt;val, path); DFS(root-\u0026gt;right, sum - root-\u0026gt;val, path); } path.pop_back(); } }; 130 被围绕的区域 对最外围的所有 \u0026lsquo;O\u0026rsquo; 进行 DFS 并进行标记，最后在遍历一遍整个矩阵，将所有未被标记的 \u0026lsquo;O\u0026rsquo; 改为 \u0026lsquo;X\u0026rsquo;。\nclass Solution { int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; int m, n; public: void solve(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board) { m = board.size(), n = m ? board[0].size() : 0; for (int i = 0; i \u0026lt; m; ++i) { if (board[i][0] == \u0026#39;O\u0026#39;) DFS(board, i, 0); if (board[i][n - 1] == \u0026#39;O\u0026#39;) DFS(board, i, n - 1); } for (int j = 1; j \u0026lt; n - 1; ++j) { if (board[0][j] == \u0026#39;O\u0026#39;) DFS(board, 0, j); if (board[m - 1][j] == \u0026#39;O\u0026#39;) DFS(board, m - 1, j); } for (auto \u0026amp;bo:board) for (auto \u0026amp;b:bo) b = (b == \u0026#39;O\u0026#39; ? \u0026#39;X\u0026#39; : (b == \u0026#39;M\u0026#39; ? \u0026#39;O\u0026#39; : b)); } void DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int x, int y) { board[x][y] = \u0026#39;M\u0026#39;; for (auto \u0026amp;d:dir) { int i = x + d[0], j = y + d[1]; if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; board[i][j] == \u0026#39;O\u0026#39;) DFS(board, i, j); } } }; 529 扫雷游戏 先计算出每个位置周围的 8 个位置的炸弹的数量，如果数量大于等于 1，那么标记出来并且结束搜索，如果数量为 0，那么继续向周围 8 个位置搜索。\nclass Solution { int m, n; public: vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; updateBoard(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, vector\u0026lt;int\u0026gt; \u0026amp;click) { if (board[click[0]][click[1]] == \u0026#39;M\u0026#39;) { board[click[0]][click[1]] = \u0026#39;X\u0026#39;; return board; } m = board.size(), n = m ? board[0].size() : 0; DFS(board, click[0], click[1]); return board; } void DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int x, int y) { int b = 0; for (int i = x - 1; i \u0026lt;= x + 1; ++i) for (int j = y - 1; j \u0026lt;= y + 1; ++j) if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; board[i][j] == \u0026#39;M\u0026#39;) ++b; if (b != 0) { board[x][y] = static_cast\u0026lt;char\u0026gt;(b + \u0026#39;0\u0026#39;); return; } board[x][y] = \u0026#39;B\u0026#39;; for (int i = x - 1; i \u0026lt;= x + 1; ++i) for (int j = y - 1; j \u0026lt;= y + 1; ++j) if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; board[i][j] == \u0026#39;E\u0026#39;) DFS(board, i, j); } }; 473 火柴拼正方形 因为要求用所有的火柴来拼成正方形，所以先判断所有的火柴组成的是否是 4 的倍数以及是否有数字大于 sum / 4 ，然后将数组从大到小排序，这样可以用贪心的策略减少搜索的次数，否则需要进行回溯，最后对整个数组进行 DFS。\nclass Solution { int match, n, sum; vector\u0026lt;bool\u0026gt; visited; public: bool makesquare(vector\u0026lt;int\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end(), [](int \u0026amp;a, int \u0026amp;b) { return a \u0026gt; b; }); sum = accumulate(nums.begin(), nums.end(), 0), n = nums.size(), match = 4; visited = vector\u0026lt;bool\u0026gt;(n, false); if (n == 0 || sum % 4 != 0) return false; for (auto \u0026amp;m:nums) if (m \u0026gt; sum / 4) return false; for (int i = 0; i \u0026lt; n; ++i) { if (!visited[i] \u0026amp;\u0026amp; DFS(nums, i, nums[i])) { visited[i] = true; --match; } } return match == 0; } bool DFS(vector\u0026lt;int\u0026gt; \u0026amp;nums, int m, int acc) { if (acc \u0026gt; sum / 4) return false; else if (acc == sum / 4) return true; for (int i = m + 1; i \u0026lt; n; ++i) if (!visited[i] \u0026amp;\u0026amp; DFS(nums, i, acc + nums[i])) { visited[i] = true; return true; } return false; } }; 980 不同路径 III 用一个变量 zeros 把矩阵中 0 的数量记录下来，每次遍历到 0 即 zeros - 1，直到 zeros == 0 且当前点的四个方向上有终点，那么结果 +1 并返回，继续下一步的 DFS。\nclass Solution { int m, n, zeros, res; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int uniquePathsIII(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { m = grid.size(), n = m ? grid[0].size() : 0, zeros = m * n - 2, res = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); int sr, sc, er, ec; for (int i = 0; i \u0026lt; m; ++i) for (int j = 0; j \u0026lt; n; ++j) if (grid[i][j] == 1) sr = i, sc = j; else if (grid[i][j] == -1) --zeros; DFS(grid, sr, sc, 0); return res; } void DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int r, int c, int count) { visited[r][c] = true; for (auto \u0026amp;d:dir) { int i = r + d[0], j = c + d[1]; if (i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n) { if (grid[i][j] == 2 \u0026amp;\u0026amp; count == zeros) { ++res; break; } if (grid[i][j] == 0 \u0026amp;\u0026amp; !visited[i][j]) DFS(grid, i, j, count + 1); } } visited[r][c] = false; } }; 37 解数独 对每个 \u0026lsquo;.\u0026rsquo; 格子进行从 \u0026lsquo;1\u0026rsquo; 到 \u0026lsquo;9\u0026rsquo; 的回溯，判断当前行，列，以及 3 * 3 的格子中是否有相同的值，直到到达矩阵的最后。\nclass Solution { int m, n; public: void solveSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board) { m = board.size(), n = board[0].size(); DFS(board, 0, 0); } bool DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int i, int j) { if (j \u0026gt;= n) return DFS(board, i + 1, 0); else if (i \u0026gt;= m) return true; else if (board[i][j] != \u0026#39;.\u0026#39;) return DFS(board, i, j + 1); for (char c = \u0026#39;1\u0026#39;; c \u0026lt;= \u0026#39;9\u0026#39;; ++c) { if (CheckNum(board, i, j, c)) { board[i][j] = c; if (DFS(board, i, j + 1)) return true; board[i][j] = \u0026#39;.\u0026#39;; } } return false; } bool CheckNum(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, const int \u0026amp;i, const int \u0026amp;j, const char \u0026amp;c) { for (int k = 0; k \u0026lt; 9; ++k) if (board[k][j] == c || board[i][k] == c) return false; for (int a = 0; a \u0026lt; 3; ++a) for (int b = 0; b \u0026lt; 3; ++b) if (board[a + i / 3 * 3][b + j / 3 * 3] == c) return false; return true; } }; 79 单词搜索 在矩阵里进行一次 DFS 即可。\nclass Solution { int m, n; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; public: bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, string word) { m = board.size(), n = m ? board[0].size() : 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); for (int i = 0; i \u0026lt; m; ++i) for (int j = 0; j \u0026lt; n; ++j) if (board[i][j] == word[0] \u0026amp;\u0026amp; DFS(board, i, j, word.substr(1))) return true; return false; } bool DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int i, int j, string word) { if (word == \u0026#34;\u0026#34;) return true; visited[i][j] = true; for (auto \u0026amp;d:dir) { int a = i + d[0], b = j + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n \u0026amp;\u0026amp; board[a][b] == word[0] \u0026amp;\u0026amp; !visited[a][b] \u0026amp;\u0026amp; DFS(board, a, b, word.substr(1))) return true; } visited[i][j] = false; return false; } }; 212 单词搜索 II 最简单的方法是对每一个单词在矩阵里进行一次 DFS，这样的话时间复杂度是 O(m * n * k * l)，其中 m 是矩阵的长，n 是矩阵的宽，l是单词的数量，k 是所有单词的最长长度。我们可以为所有单词建立一个字典树，然后再在矩阵里进行一次 DFS，在矩阵的每个点处判断当前的字母是否在字典树的根节点的 next 数组中，如果是的话搜索其周围的字母以及继续遍历字典树，这样做的时间复杂度是 O(m * n * k)。\nclass Solution { struct TrieNode { vector\u0026lt;TrieNode *\u0026gt; next; bool end; TrieNode() { next = vector\u0026lt;TrieNode *\u0026gt;(26, nullptr); end = false; } }; TrieNode *root; int m, n; unordered_set\u0026lt;string\u0026gt; res; vector\u0026lt;string\u0026gt; ret; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: vector\u0026lt;string\u0026gt; findWords(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, vector\u0026lt;string\u0026gt; \u0026amp;words) { res = unordered_set\u0026lt;string\u0026gt;(); m = board.size(), n = board[0].size(); visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); BuildTrie(words); for (int i = 0; i \u0026lt; m; ++i) for (int j = 0; j \u0026lt; n; ++j) if (root-\u0026gt;next[board[i][j] - \u0026#39;a\u0026#39;]) DFS(board, i, j, root-\u0026gt;next[board[i][j] - \u0026#39;a\u0026#39;], string(1, board[i][j])); ret = vector\u0026lt;string\u0026gt;(res.begin(), res.end()); return ret; } void BuildTrie(vector\u0026lt;string\u0026gt; \u0026amp;words) { root = new TrieNode(); TrieNode *node; for (auto \u0026amp;s:words) { node = root; for (auto c:s) { if (!node-\u0026gt;next[c - \u0026#39;a\u0026#39;]) node-\u0026gt;next[c - \u0026#39;a\u0026#39;] = new TrieNode(); node = node-\u0026gt;next[c - \u0026#39;a\u0026#39;]; } node-\u0026gt;end = true; } } void DFS(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, int i, int j, TrieNode *node, string word) { if (!node) return; if (node-\u0026gt;end) res.insert(word); visited[i][j] = true; for (auto \u0026amp;d:dir) { int a = i + d[0], b = j + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n \u0026amp;\u0026amp; node-\u0026gt;next[board[a][b] - \u0026#39;a\u0026#39;] \u0026amp;\u0026amp; !visited[a][b]) DFS(board, a, b, node-\u0026gt;next[board[a][b] - \u0026#39;a\u0026#39;], word + board[a][b]); } visited[i][j] = false; } }; 749 隔离病毒 矩阵会持续地变化，每一轮 DFS 结束后需要进行两个操作，一是将已经隔离的病毒进行标记，二是将未隔离的病毒进行感染（延伸），可以先将所有的未隔离的病毒先保存下来再依次进行延伸，写起来比较复杂。\nclass Solution { int m, n; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited; public: int containVirus(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { m = grid.size(), n = m ? grid[0].size() : 0; int res = 0; bool exist = true; while (exist) { exist = false; int perimeter = 0, co_x = 0, co_y = 0; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(m, vector\u0026lt;bool\u0026gt;(n, false)); for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (grid[i][j] == 1 \u0026amp;\u0026amp; !visited[i][j]) { exist = true; int peri = CalcPeri(grid, i, j); if (peri \u0026gt; perimeter) { perimeter = peri; co_x = i, co_y = j; } } } } res += perimeter; if (exist) { Contain(grid, co_x, co_y); Infect(grid); } } return res; } int CalcPeri(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { int peri = 4, res = 0; visited[i][j] = true; for (auto \u0026amp;d:dir) { int a = i + d[0], b = j + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n) { if (grid[a][b] != 0) --peri; if (grid[a][b] == 1 \u0026amp;\u0026amp; !visited[a][b]) res += CalcPeri(grid, a, b); } else --peri; } return res + peri; } void Contain(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { grid[i][j] = 2; for (auto \u0026amp;d:dir) { int a = i + d[0], b = j + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n \u0026amp;\u0026amp; grid[a][b] == 1) Contain(grid, a, b); } } void Infect(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; infect; for (int i = 0; i \u0026lt; m; ++i) for (int j = 0; j \u0026lt; n; ++j) if (grid[i][j] == 1) infect.push_back(pair\u0026lt;int, int\u0026gt;(i, j)); for (auto \u0026amp;f:infect) { for (auto \u0026amp;d:dir) { int a = f.first + d[0], b = f.second + d[1]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n \u0026amp;\u0026amp; grid[a][b] == 0) grid[a][b] = 1; } } } }; 51 N皇后 很经典的回溯问题，用 DFS 搜索每一种可能直到搜索完最后一行，用当前位置的横纵坐标的和和差分别判断两个对角线上是否有皇后即可。\nclass Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; string temp = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; ++i) temp += \u0026#34;.\u0026#34;; vector\u0026lt;string\u0026gt; board(n, temp); unordered_map\u0026lt;int, bool\u0026gt; left_diagonal, right_diagonal; vector\u0026lt;bool\u0026gt; row(n, false), col(n, false); for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { left_diagonal[i + j] = false; right_diagonal[i - j] = false; } } Backtrack(0, n, board, res, col, left_diagonal, right_diagonal); return res; } void Backtrack(int i, int \u0026amp;n, vector\u0026lt;string\u0026gt; \u0026amp;board, vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; \u0026amp;res, vector\u0026lt;bool\u0026gt; \u0026amp;col, unordered_map\u0026lt;int, bool\u0026gt; \u0026amp;left_diagonal, unordered_map\u0026lt;int, bool\u0026gt; \u0026amp;right_diagonal) { if (i == n) { res.push_back(board); return; } for (int j = 0; j \u0026lt; n; ++j) { if (!col[j] \u0026amp;\u0026amp; !left_diagonal[i + j] \u0026amp;\u0026amp; !right_diagonal[i - j]) { col[j] = true; left_diagonal[i + j] = true; right_diagonal[i - j] = true; board[i][j] = \u0026#39;Q\u0026#39;; Backtrack(i + 1, n, board, res, col, left_diagonal, right_diagonal); board[i][j] = \u0026#39;.\u0026#39;; col[j] = false; left_diagonal[i + j] = false; right_diagonal[i - j] = false; } } } }; ","permalink":"https://prov1dence.top/posts/leetcode/dfs/","summary":"\u003ch1 id=\"leetcode-dfshttpsleetcode-cncomtagdepth-first-search\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/depth-first-search/\"\u003eLeetCode DFS\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch4 id=\"78-子集httpsleetcode-cncomproblemssubsets\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/subsets/\"\u003e78 子集\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e典型的回溯，找出所有可能情况。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e subsets(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003enums) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        res \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e curr;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        DFS(nums, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, curr);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDFS\u003c/span\u003e(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003enums, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e idx, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ecurr) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e idx; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e nums.size(); \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            curr.push_back(nums[i]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            res.push_back(curr);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            DFS(nums, i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, curr);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            curr.pop_back();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"733-图像渲染httpsleetcode-cncomproblemsflood-fill\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/flood-fill/\"\u003e733 图像渲染\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e从给定的 image[sr][sc] 开始 DFS 或 BFS，将相邻的值相同的点的值全部修改为 newColor，注意要判断给定的 image[sr][sc] 是否等于 newColor，否则如果不使用额外空间的 visited 数组记录已经访问过的点的话会造成死循环栈溢出。\u003c/p\u003e","title":"LeetCode 深度优先搜索"},{"content":"LeetCode 并发 题目 1114 按序打印 C++ mutex class Foo { mutex lock1, lock2; public: Foo() { lock1.lock(); lock2.lock(); } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); lock1.unlock(); } void second(function\u0026lt;void()\u0026gt; printSecond) { lock1.lock(); printSecond(); lock1.unlock(); lock2.unlock(); } void third(function\u0026lt;void()\u0026gt; printThird) { lock2.lock(); printThird(); lock2.unlock(); } }; C++ condition_variable class Foo { int i; mutex mut; condition_variable con_var1, con_var2; public: Foo() : i(1) { } void first(function\u0026lt;void()\u0026gt; printFirst) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); printFirst(); ++i; con_var1.notify_one(); } void second(function\u0026lt;void()\u0026gt; printSecond) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var1.wait(lock, [this]() { return i == 2; }); printSecond(); ++i; con_var2.notify_one(); } void third(function\u0026lt;void()\u0026gt; printThird) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var2.wait(lock, [this]() { return i == 3; }); printThird(); } }; C++ atomic class Foo { atomic_int i; public: Foo() : i(1) { } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); ++i; } void second(function\u0026lt;void()\u0026gt; printSecond) { while (i != 2) {} printSecond(); ++i; } void third(function\u0026lt;void()\u0026gt; printThird) { while (i != 3) {} printThird(); i = 1; } }; C++ promise class Foo { promise\u0026lt;void\u0026gt; pro1, pro2; public: Foo() { } void first(function\u0026lt;void()\u0026gt; printFirst) { printFirst(); pro1.set_value(); } void second(function\u0026lt;void()\u0026gt; printSecond) { pro1.get_future().wait(); printSecond(); pro2.set_value(); } void third(function\u0026lt;void()\u0026gt; printThird) { pro2.get_future().wait(); printThird(); } }; 1115 交替打印FooBar C++ mutex class FooBar { private: int n; mutex mut1, mut2; public: FooBar(int n) { this-\u0026gt;n = n; mut2.lock(); } void foo(function\u0026lt;void()\u0026gt; printFoo) { for (int i = 0; i \u0026lt; n; i++) { mut1.lock(); printFoo(); mut2.unlock(); } } void bar(function\u0026lt;void()\u0026gt; printBar) { for (int i = 0; i \u0026lt; n; i++) { mut2.lock(); printBar(); mut1.unlock(); } } }; C++ condition_variable class FooBar { private: int m, n; mutex mut; condition_variable con_var1, con_var2; public: FooBar(int n) : n(n), m(0) { } void foo(function\u0026lt;void()\u0026gt; printFoo) { for (int i = 0; i \u0026lt; n; i++) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var1.wait(lock, [\u0026amp;]() { return m == 0; }); printFoo(); ++m; con_var2.notify_one(); } } void bar(function\u0026lt;void()\u0026gt; printBar) { for (int i = 0; i \u0026lt; n; i++) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var2.wait(lock, [\u0026amp;]() { return m == 1; }); printBar(); m = 0; con_var1.notify_one(); } } }; C++ atomic class FooBar { private: int n; atomic_int m; public: FooBar(int n) : n(n), m(0) { } void foo(function\u0026lt;void()\u0026gt; printFoo) { for (int i = 0; i \u0026lt; n; i++) { while (m != 0) {} printFoo(); m = 1; } } void bar(function\u0026lt;void()\u0026gt; printBar) { for (int i = 0; i \u0026lt; n; i++) { while (m != 1) {} printBar(); m = 0; } } }; C++ promise class FooBar { private: int n; vector\u0026lt;promise\u0026lt;void\u0026gt;\u0026gt; pros1, pros2; public: FooBar(int n) : n(n) { for (int i = 0; i \u0026lt; n; ++i) { pros1.push_back(promise\u0026lt;void\u0026gt;()); pros2.push_back(promise\u0026lt;void\u0026gt;()); } } void foo(function\u0026lt;void()\u0026gt; printFoo) { for (int i = 0; i \u0026lt; n; i++) { if (i != 0) pros1[i - 1].get_future().wait(); printFoo(); pros2[i].set_value(); } } void bar(function\u0026lt;void()\u0026gt; printBar) { for (int i = 0; i \u0026lt; n; i++) { pros2[i].get_future().wait(); printBar(); pros1[i].set_value(); } } }; 1116 打印零与奇偶数 C++ mutex class ZeroEvenOdd { private: int m, n; mutex mut_zero, mut_odd, mut_even; public: ZeroEvenOdd(int n) { this-\u0026gt;m = 1; this-\u0026gt;n = n; mut_odd.lock(); mut_even.lock(); } void zero(function\u0026lt;void(int)\u0026gt; printNumber) { for (int i = 0; i \u0026lt; n; ++i) { mut_zero.lock(); printNumber(0); if (this-\u0026gt;m % 2 == 1) mut_odd.unlock(); else mut_even.unlock(); } } void even(function\u0026lt;void(int)\u0026gt; printNumber) { for (int i = 0; i \u0026lt; n / 2; ++i) { mut_even.lock(); printNumber(this-\u0026gt;m); ++this-\u0026gt;m; mut_zero.unlock(); } } void odd(function\u0026lt;void(int)\u0026gt; printNumber) { for (int i = 0; i \u0026lt; (n + 1) / 2; ++i) { mut_odd.lock(); printNumber(this-\u0026gt;m); ++this-\u0026gt;m; mut_zero.unlock(); } } }; 1117 H2O 生成 C++ condition variable class H2O { int m = 1; mutex mut; condition_variable con_var; public: void hydrogen(function\u0026lt;void()\u0026gt; releaseHydrogen) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var.wait(lock, [\u0026amp;]() { return m % 3 != 0; }); ++m; releaseHydrogen(); con_var.notify_all(); } void oxygen(function\u0026lt;void()\u0026gt; releaseOxygen) { unique_lock\u0026lt;mutex\u0026gt; lock(mut); con_var.wait(lock, [\u0026amp;]() { return m % 3 == 0; }); ++m; releaseOxygen(); con_var.notify_all(); } }; ","permalink":"https://prov1dence.top/posts/leetcode/concurrency/","summary":"\u003ch1 id=\"leetcode-并发httpsleetcode-cncomproblemsetconcurrency\"\u003e\u003ca href=\"https://leetcode-cn.com/problemset/concurrency/\"\u003eLeetCode 并发\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch4 id=\"1114-按序打印httpsleetcode-cncomproblemsprint-in-order\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/print-in-order/\"\u003e1114 按序打印\u003c/a\u003e\u003c/h4\u003e\n\u003ch5 id=\"c-mutex\"\u003eC++ mutex\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mutex lock1, lock2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Foo() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        lock1.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        lock2.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efirst\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printFirst) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printFirst();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        lock1.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esecond\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printSecond) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        lock1.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printSecond();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        lock1.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        lock2.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ethird\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printThird) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        lock2.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printThird();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        lock2.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch5 id=\"c-condition_variable\"\u003eC++ condition_variable\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mutex mut;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    condition_variable con_var1, con_var2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Foo() \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e i(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efirst\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printFirst) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        unique_lock\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003emutex\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e lock(mut);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printFirst();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        con_var1.notify_one();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esecond\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printSecond) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        unique_lock\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003emutex\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e lock(mut);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        con_var1.wait(lock, [\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e]() { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e; });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printSecond();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        con_var2.notify_one();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ethird\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printThird) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        unique_lock\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003emutex\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e lock(mut);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        con_var2.wait(lock, [\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e]() { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e; });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printThird();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch5 id=\"c-atomic\"\u003eC++ atomic\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    atomic_int i;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Foo() \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e i(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efirst\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printFirst) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printFirst();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esecond\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printSecond) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (i \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printSecond();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ethird\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printThird) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (i \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printThird();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch5 id=\"c-promise\"\u003eC++ promise\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    promise\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e pro1, pro2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Foo() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efirst\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printFirst) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printFirst();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        pro1.set_value();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esecond\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printSecond) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        pro1.get_future().wait();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printSecond();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        pro2.set_value();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ethird\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printThird) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        pro2.get_future().wait();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printThird();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"1115-交替打印foobarhttpsleetcode-cncomproblemsprint-foobar-alternately\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/print-foobar-alternately/\"\u003e1115 交替打印FooBar\u003c/a\u003e\u003c/h4\u003e\n\u003ch5 id=\"c-mutex-1\"\u003eC++ mutex\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFooBar\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mutex mut1, mut2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    FooBar(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003en \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mut2.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printFoo) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mut1.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printFoo();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mut2.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printBar) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mut2.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printBar();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mut1.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch5 id=\"c-condition_variable-1\"\u003eC++ condition_variable\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFooBar\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m, n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mutex mut;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    condition_variable con_var1, con_var2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    FooBar(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e n(n), m(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printFoo) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            unique_lock\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003emutex\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e lock(mut);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            con_var1.wait(lock, [\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e]() { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printFoo();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003em;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            con_var2.notify_one();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printBar) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            unique_lock\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003emutex\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e lock(mut);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            con_var2.wait(lock, [\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e]() { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printBar();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            m \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            con_var1.notify_one();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch5 id=\"c-atomic-1\"\u003eC++ atomic\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFooBar\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    atomic_int m;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    FooBar(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e n(n), m(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printFoo) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (m \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printFoo();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            m \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printBar) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (m \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printBar();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            m \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch5 id=\"c-promise-1\"\u003eC++ promise\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFooBar\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003epromise\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e pros1, pros2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    FooBar(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e n(n) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            pros1.push_back(promise\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            pros2.push_back(promise\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efoo\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printFoo) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (i \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                pros1[i \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e].get_future().wait();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printFoo();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            pros2[i].set_value();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebar\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printBar) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            pros2[i].get_future().wait();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printBar();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            pros1[i].set_value();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"1116-打印零与奇偶数httpsleetcode-cncomproblemsprint-zero-even-odd\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/print-zero-even-odd/\"\u003e1116 打印零与奇偶数\u003c/a\u003e\u003c/h4\u003e\n\u003ch5 id=\"c-mutex-2\"\u003eC++ mutex\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eZeroEvenOdd\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m, n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mutex mut_zero, mut_odd, mut_even;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ZeroEvenOdd(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003em \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003en \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mut_odd.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mut_even.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ezero\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e)\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printNumber) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mut_zero.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printNumber(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003em \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                mut_odd.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                mut_even.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eeven\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e)\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printNumber) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mut_even.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printNumber(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003em);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003em;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mut_zero.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eodd\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e)\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e printNumber) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e (n \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mut_odd.lock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printNumber(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003em);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003em;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mut_zero.unlock();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"1117-h2o-生成httpsleetcode-cncomproblemsbuilding-h2osubmissions\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/building-h2o/submissions/\"\u003e1117 H2O 生成\u003c/a\u003e\u003c/h4\u003e\n\u003ch5 id=\"c-condition-variable\"\u003eC++ condition variable\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eH2O\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mutex mut;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    condition_variable con_var;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e hydrogen(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e releaseHydrogen) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        unique_lock\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003emutex\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e lock(mut);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        con_var.wait(lock, [\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e]() { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003em;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        releaseHydrogen();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        con_var.notify_all();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eoxygen\u003c/span\u003e(function\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e releaseOxygen) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        unique_lock\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003emutex\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e lock(mut);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        con_var.wait(lock, [\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e]() { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; });\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003em;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        releaseOxygen();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        con_var.notify_all();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"LeetCode 并发"},{"content":"LeetCode 树（2） 题目 3. 二叉搜索树 95 不同的二叉搜索树 II 生成由 1 \u0026hellip; n 为节点所组成的二叉搜索树。\n为了构造以 i 为根节点的二叉搜索树，我们需要先构造以 1 \u0026hellip; i - 1 为左子树的所有二叉搜索树与以 i + 1 \u0026hellip; n 为右子树的所有二叉搜索树，再将这些子树排列组合得到以 i 为根节点的所有二叉搜索树。\nclass Solution { public: vector\u0026lt;TreeNode *\u0026gt; generateTrees(int n) { if (n == 0) return {}; return Generate(1, n); } vector\u0026lt;TreeNode *\u0026gt; Generate(int m, int n) { vector\u0026lt;TreeNode *\u0026gt; nodes; if (m == n) nodes.push_back(new TreeNode(n)); if (m \u0026gt; n) nodes.push_back(nullptr); if (m \u0026gt;= n) return nodes; for (int i = m; i \u0026lt;= n; ++i) { vector\u0026lt;TreeNode *\u0026gt; left = Generate(m, i - 1); vector\u0026lt;TreeNode *\u0026gt; right = Generate(i + 1, n); for (auto \u0026amp;l:left) for (auto \u0026amp;r:right) { TreeNode *node = new TreeNode(i); node-\u0026gt;left = l, node-\u0026gt;right = r; nodes.push_back(node); } } return nodes; } }; 98 验证二叉搜索树 因为二叉搜索树的中序遍历结果是一个有序数组，所以一种方法是将中序遍历的结果保存下来进行判断，也可以根据二叉搜索树的定义判断子节点和根节点的大小关系。\nclass Solution { public: bool isValidBST(TreeNode *root) { return IsValidSubtree(root, nullptr, nullptr); } bool IsValidSubtree(TreeNode *node, const int *min_val, const int *max_val) { if (!node) return true; if ((min_val \u0026amp;\u0026amp; *min_val \u0026gt;= node-\u0026gt;val) || (max_val \u0026amp;\u0026amp; *max_val \u0026lt;= node-\u0026gt;val)) return false; return IsValidSubtree(node-\u0026gt;left, min_val, \u0026amp;(node-\u0026gt;val)) \u0026amp;\u0026amp; IsValidSubtree(node-\u0026gt;right, \u0026amp;(node-\u0026gt;val), max_val); } }; 108 将有序数组转换为二叉搜索树 给一个有序数组，将其转换为一棵平衡二叉搜索树。\n二叉搜索树的中序遍历结果即为有序数组，所以只需要每次找到中间的元素作为根节点，左边的子数组作为左子树，右边的子数组作为右子树，递归构造即可。\nclass Solution { public: TreeNode *sortedArrayToBST(vector\u0026lt;int\u0026gt; \u0026amp;nums) { return Build(nums, 0, nums.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;nums, int x, int y) { if (x \u0026gt;= y) return nullptr; int pos = x + (y - x) / 2; TreeNode *node = new TreeNode(nums[pos]); node-\u0026gt;left = Build(nums, x, pos); node-\u0026gt;right = Build(nums, pos + 1, y); return node; } }; 235 二叉搜索树的最近公共祖先 找到一个二叉搜索树中两个指定节点的最近公共祖先。\n由二叉搜索树可知，如果两个节点的值都大于根节点，那么他们都应该在根节点的右子树上；如果两个节点的值都小于根节点，那么他们都应该在根节点的左子树上；否则他们可能在根节点及其子树上的任意位置，那么根节点即是他们的最近公共祖先。\nclass Solution { public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) { if (!root) return nullptr; else if (root-\u0026gt;val \u0026gt; p-\u0026gt;val \u0026amp;\u0026amp; root-\u0026gt;val \u0026gt; q-\u0026gt;val) return lowestCommonAncestor(root-\u0026gt;left, p, q); else if (root-\u0026gt;val \u0026lt; p-\u0026gt;val \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt; q-\u0026gt;val) return lowestCommonAncestor(root-\u0026gt;right, p, q); return root; } }; 671 二叉树中第二小的节点 给一个二叉树，其子节点数量只为 0 或 2，并且根节点的值一定小于等于子节点的值，找到所有节点中的第二小的值。\n因为二叉树上根节点一定小于等于子节点，所以整个树的根节点的值一定是最小值，只需要遍历整个树，找到除根节点之外的最小值即可。\nclass Solution { public: int findSecondMinimumValue(TreeNode *root) { if (!root) return -1; int first = root-\u0026gt;val, *res = nullptr; queue\u0026lt;TreeNode *\u0026gt; q; q.push(root); while (!q.empty()) { TreeNode *node = q.front(); q.pop(); if (first \u0026lt; node-\u0026gt;val) if (!res) res = new int(node-\u0026gt;val); else *res = min(*res, node-\u0026gt;val); if (node-\u0026gt;left \u0026amp;\u0026amp; node-\u0026gt;right) q.push(node-\u0026gt;left), q.push(node-\u0026gt;right); } return res ? *res : -1; } }; 230 二叉搜索树中第 K 小的元素 找到一个二叉搜索树中第 k 小的元素。\n因为二叉搜索树的中序遍历结果是有序的，我们可以使用中序遍历并在找到第 k 小的元素时提前终止并返回结果。\nclass Solution { int res; public: int kthSmallest(TreeNode *root, int k) { res = 0; Inorder(root, k); return res; } void Inorder(TreeNode *root, int \u0026amp;k) { if (!root) return; Inorder(root-\u0026gt;left, k); if (k \u0026lt;= 0) return; --k; if (k == 0) { res = root-\u0026gt;val; return; } Inorder(root-\u0026gt;right, k); } }; 450 删除二叉搜索树中的节点 给一个二叉搜索树和一个值，删除二叉搜索树中的对应节点。\n根据二叉搜素树的定义，很容易通过大小关系找到对应节点，找到之后只需要将原先的节点替换为左子树上的最大节点，也就是左子节点的最右子节点即可，注意要将左子节点的最右子节点的左子树接到其父节点的右子节点上。\nclass Solution { public: TreeNode *deleteNode(TreeNode *root, int key) { if (!root) return nullptr; if (root-\u0026gt;val == key) { if (!root-\u0026gt;left) return root-\u0026gt;right; auto node = root-\u0026gt;left, head = node; if (!node-\u0026gt;right) { node-\u0026gt;right = root-\u0026gt;right; return node; } while (node-\u0026gt;right) head = node, node = node-\u0026gt;right; head-\u0026gt;right = node-\u0026gt;left; node-\u0026gt;left = root-\u0026gt;left, node-\u0026gt;right = root-\u0026gt;right; return node; } else if (root-\u0026gt;val \u0026lt; key) root-\u0026gt;right = deleteNode(root-\u0026gt;right, key); else if (root-\u0026gt;val \u0026gt; key) root-\u0026gt;left = deleteNode(root-\u0026gt;left, key); return root; } }; 669 修剪二叉搜索树 给一个二叉搜索树，以及最小边界 L 和最大边界 R，修剪二叉搜索树使得所有节点值都在 [L, R] 的范围内。\n如果一个节点的值在范围外，根据二叉搜索树的定义，返回对应方向的节点修剪后的结果即可；如果一个节点的值在范围内，对其左右子树分别进行修建即可。\nclass Solution { public: TreeNode *trimBST(TreeNode *root, const int \u0026amp;L, const int \u0026amp;R) { if (!root) return nullptr; if (root-\u0026gt;val \u0026lt; L) return trimBST(root-\u0026gt;right, L, R); if (root-\u0026gt;val \u0026gt; R) return trimBST(root-\u0026gt;left, L, R); root-\u0026gt;left = trimBST(root-\u0026gt;left, L, R); root-\u0026gt;right = trimBST(root-\u0026gt;right, L, R); return root; } }; 530 二叉搜索树的最小绝对差 求一个二叉搜索树树中任意两节点的差的绝对值的最小值。\n因为二叉搜索树的中序遍历结果是有序的，任意两节点的差的绝对值的最小值一定产生在相邻的两个值之间，因此做一次中序遍历，同时更新两节点的差的绝对值的最小值即可。\nclass Solution { TreeNode *node; int res; public: int getMinimumDifference(TreeNode *root) { node = nullptr; res = INT_MAX; Inorder(root); return res; }\nvoid Inorder(TreeNode *root) { if (!root) return; Inorder(root-\u0026gt;left); if (!node) node = root; else res = min(res, abs(node-\u0026gt;val - root-\u0026gt;val)); node = root; Inorder(root-\u0026gt;right); } };\n783 二叉搜索树结点最小距离 求一个二叉搜索树树中任意两节点的差的绝对值的最小值。\n同上。\nclass Solution { TreeNode *node; int res; public: int minDiffInBST(TreeNode *root) { node = nullptr; res = INT_MAX; Inorder(root); return res; }\nvoid Inorder(TreeNode *root) { if (!root) return; Inorder(root-\u0026gt;left); if (!node) node = root; else res = min(res, abs(node-\u0026gt;val - root-\u0026gt;val)); node = root; Inorder(root-\u0026gt;right); } };\n501 二叉搜索树中的众数 找出一个二叉搜索树中的所有众数。\n因为二叉搜索树的中序遍历结果是有序的，可以直接进行一次中序遍历，同时更新结果数组。\nclass Solution { vector\u0026lt;int\u0026gt; res; TreeNode *node; int n, m; public: vector\u0026lt;int\u0026gt; findMode(TreeNode *root) { res = vector\u0026lt;int\u0026gt;(); node = nullptr; n = m = 0; Inorder(root); return res; } void Inorder(TreeNode *root) { if (!root) return; Inorder(root-\u0026gt;left); if (!node || node-\u0026gt;val != root-\u0026gt;val) m = 1; else ++m; node = root; if (m \u0026gt; n) { n = m; res.clear(); } if (m == n) res.push_back(node-\u0026gt;val); Inorder(root-\u0026gt;right); } }; 538 把二叉搜索树转换为累加树 把一个二叉搜索树转换成为累加树。\n按照二叉搜索树的定义，每个节点值一定比右子树上的节点值小，所以按照右中左的顺序遍历整个树，同时在根节点处加上右边的累积值。\nclass Solution { int val; public: TreeNode *convertBST(TreeNode *root) { val = 0; Accumulate(root); return root; } void Accumulate(TreeNode *root) { if (!root) return; Accumulate(root-\u0026gt;right); root-\u0026gt;val += val; val = root-\u0026gt;val; Accumulate(root-\u0026gt;left); } }; 700 二叉搜索树中的搜索 在二叉搜索树中搜索一个特定值。\n按照二叉搜索树的特性搜索即可。\nclass Solution { public: TreeNode *searchBST(TreeNode *root, const int \u0026amp;val) { if (!root) return nullptr; if (root-\u0026gt;val \u0026lt; val) return searchBST(root-\u0026gt;right, val); else if (root-\u0026gt;val \u0026gt; val) return searchBST(root-\u0026gt;left, val); else return root; } }; 701 二叉搜索树中的插入操作 在一个二叉搜索树中插入一个值。\n按照给定值与节点的值的大小关系依次往下搜索直到找到空节点，新建一个节点并返回即可。\nclass Solution { public: TreeNode *insertIntoBST(TreeNode *root, const int \u0026amp;val) { if (!root) return new TreeNode(val); else if (val \u0026lt; root-\u0026gt;val) root-\u0026gt;left = insertIntoBST(root-\u0026gt;left, val); else if (val \u0026gt; root-\u0026gt;val) root-\u0026gt;right = insertIntoBST(root-\u0026gt;right, val); return root; } }; 938 二叉搜索树的范围和 给一个二叉搜索树，计算 L 和 R 之间的所有结点的值的和。\n判断根节点的值 L \u0026lt;= val \u0026lt;= R 即可。\nclass Solution { public: int rangeSumBST(TreeNode* root, const int \u0026amp;L, const int \u0026amp;R) { if (!root) return 0; int left = 0, right = 0; if (root-\u0026gt;val \u0026gt;= L) left = rangeSumBST(root-\u0026gt;left, L, R); if (root-\u0026gt;val \u0026lt;= R) right = rangeSumBST(root-\u0026gt;right, L, R); return left + right + (root-\u0026gt;val \u0026gt;= L \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= R ? root-\u0026gt;val : 0); } }; 99 恢复二叉搜索树 恢复一个有两个节点被错误地交换的二叉搜索树。\n因为只有两个节点被错误地交换，只需要做一次中序遍历就能从相邻节点的大小关系找到这两个节点，将第一次出现错误位置关系的前一个节点与第二次出现错误位置关系的后一个节点交换即可。\nclass Solution { TreeNode *first, *second, *prev; public: void recoverTree(TreeNode *root) { first = second = prev = nullptr; Inorder(root); swap(first-\u0026gt;val, second-\u0026gt;val); } void Inorder(TreeNode *root) { if (!root) return; Inorder(root-\u0026gt;left); if (prev \u0026amp;\u0026amp; prev-\u0026gt;val \u0026gt;= root-\u0026gt;val \u0026amp;\u0026amp; !first) first = prev; if (prev \u0026amp;\u0026amp; prev-\u0026gt;val \u0026gt;= root-\u0026gt;val \u0026amp;\u0026amp; first) second = root; prev = root; Inorder(root-\u0026gt;right); } }; ","permalink":"https://prov1dence.top/posts/leetcode/tree-2/","summary":"\u003ch1 id=\"leetcode-树2httpsleetcode-cncomtagtree\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/tree/\"\u003eLeetCode 树（2）\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"3-二叉搜索树\"\u003e3. 二叉搜索树\u003c/h3\u003e\n\u003ch4 id=\"95-不同的二叉搜索树-iihttpsleetcode-cncomproblemsunique-binary-search-trees-ii\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\"\u003e95 不同的二叉搜索树 II\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e生成由 1 \u0026hellip; n 为节点所组成的二叉搜索树。\u003c/p\u003e\n\u003cp\u003e为了构造以 i 为根节点的二叉搜索树，我们需要先构造以 1 \u0026hellip; i - 1 为左子树的所有二叉搜索树与以 i + 1 \u0026hellip; n 为右子树的所有二叉搜索树，再将这些子树排列组合得到以 i 为根节点的所有二叉搜索树。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eTreeNode \u003cspan style=\"color:#f92672\"\u003e*\u0026gt;\u003c/span\u003e generateTrees(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (n \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e {};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eGenerate\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, n);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eTreeNode \u003cspan style=\"color:#f92672\"\u003e*\u0026gt;\u003c/span\u003e Generate(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eTreeNode \u003cspan style=\"color:#f92672\"\u003e*\u0026gt;\u003c/span\u003e nodes;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (m \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            nodes.push_back(\u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e TreeNode(n));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (m \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            nodes.push_back(\u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (m \u003cspan style=\"color:#f92672\"\u003e\u0026gt;=\u003c/span\u003e n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e nodes;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e m; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eTreeNode \u003cspan style=\"color:#f92672\"\u003e*\u0026gt;\u003c/span\u003e left \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Generate(m, i \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eTreeNode \u003cspan style=\"color:#f92672\"\u003e*\u0026gt;\u003c/span\u003e right \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Generate(i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, n);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003el:left)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003er:right) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003enode \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e TreeNode(i);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    node\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eleft \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l, node\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eright \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e r;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    nodes.push_back(node);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e nodes;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"98-验证二叉搜索树httpsleetcode-cncomproblemsvalidate-binary-search-tree\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\"\u003e98 验证二叉搜索树\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e因为二叉搜索树的中序遍历结果是一个有序数组，所以一种方法是将中序遍历的结果保存下来进行判断，也可以根据二叉搜索树的定义判断子节点和根节点的大小关系。\u003c/p\u003e","title":"LeetCode 树（2）"},{"content":"LeetCode 树（1） 题目 1. 树的遍历 144 二叉树的前序遍历 前序遍历一个二叉树。\n前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，先将节点加入结果数组，然后用一个栈保存右，左子节点，依次访问，重复此过程。\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) { res = vector\u0026lt;int\u0026gt;(); Preorder(root); return res; } void Preorder(TreeNode *root) { if (!root) return; res.push_back(root-\u0026gt;val); Preorder(root-\u0026gt;left); Preorder(root-\u0026gt;right); } }; class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;TreeNode *\u0026gt; pre; pre.push(root); while (!pre.empty()) { TreeNode *node = pre.top(); pre.pop(); res.push_back(node-\u0026gt;val); if (node-\u0026gt;right) pre.push(node-\u0026gt;right); if (node-\u0026gt;left) pre.push(node-\u0026gt;left); } return res; } }; 589 N叉树的前序遍历 前序遍历一个 N 叉树。\n跟二叉树的前序遍历类似，有递归和迭代两种做法。\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; preorder(Node *root) { res = vector\u0026lt;int\u0026gt;(); Preorder(root); return res; } void Preorder(Node *root) { if (!root) return; res.push_back(root-\u0026gt;val); for (auto \u0026amp;c:root-\u0026gt;children) Preorder(c); } }; class Solution { public: vector\u0026lt;int\u0026gt; preorder(Node *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;Node *\u0026gt; pre; pre.push(root); while (!pre.empty()) { Node *node = pre.top(); pre.pop(); res.push_back(node-\u0026gt;val); for (auto iter = node-\u0026gt;children.rbegin(); iter \u0026lt; node-\u0026gt;children.rend(); ++iter) pre.push(*iter); } return res; } }; 94 二叉树的中序遍历 中序遍历一个二叉树。\n中序遍历是按照左子节点，根节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，用一个栈保存父节点以便最后访问，先找到最左节点，将其加入结果数组，然后访问其右子节点，重复此过程。\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { res = vector\u0026lt;int\u0026gt;(); Inorder(root); return res; } void Inorder(TreeNode *root) { if (!root) return; Inorder(root-\u0026gt;left); res.push_back(root-\u0026gt;val); Inorder(root-\u0026gt;right); } }; class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;TreeNode *\u0026gt; in; TreeNode *node = root; while (node || !in.empty()) { while (node) { in.push(node); node = node-\u0026gt;left; } if (!in.empty()) { node = in.top(); in.pop(); res.push_back(node-\u0026gt;val); node = node-\u0026gt;right; } } return res; } }; 145 二叉树的后序遍历 后序遍历一个二叉树。\n后序遍历是按照左子节点，右子节点，根节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，用一个栈保存父节点以便最后访问，先找到最左节点，如果其已经是叶子节点则将其加入结果数组，否则访问其右子节点，用 last 保存上一次访问过的右子节点防止再次访问，重复此过程。\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { res = vector\u0026lt;int\u0026gt;(); Postorder(root); return res; } void Postorder(TreeNode *root) { if (!root) return; Postorder(root-\u0026gt;left); Postorder(root-\u0026gt;right); res.push_back(root-\u0026gt;val); } }; class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;TreeNode *\u0026gt; post; TreeNode *node = root, *last = nullptr; while (node || !post.empty()) { while (node) { post.push(node); node = node-\u0026gt;left; } if (!post.empty()) { node = post.top(); if (node-\u0026gt;right \u0026amp;\u0026amp; node-\u0026gt;right != last) node = node-\u0026gt;right; else { res.push_back(node-\u0026gt;val); post.pop(); last = node; node = nullptr; } } } return res; } }; 590 N叉树的后序遍历 跟二叉树的后序遍历类似，有递归和迭代两种做法。\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; postorder(Node *root) { res = vector\u0026lt;int\u0026gt;(); Postorder(root); return res; } void Postorder(Node *root) { if (!root) return; for (auto \u0026amp;c:root-\u0026gt;children) Postorder(c); res.push_back(root-\u0026gt;val); } }; class Solution { public: vector\u0026lt;int\u0026gt; postorder(Node *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;Node *\u0026gt; post; post.push(root); while (!post.empty()) { Node *node = post.top(); post.pop(); res.push_back(node-\u0026gt;val); for (auto \u0026amp;c:node-\u0026gt;children) post.push(c); } reverse(res.begin(), res.end()); return res; } }; 102 二叉树的层次遍历 给一个二叉树，返回其按层次遍历的节点值。\n用一个队列来保存该二叉树当前一层的所有节点，一边将这些节点 pop 并 push 进结果数组中，一边将这些节点的子节点 push 进队列。\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (!root) return res; queue\u0026lt;TreeNode *\u0026gt; q; q.push(root); int n = 1; while (!q.empty()) { vector\u0026lt;int\u0026gt; lvl; for (int i = 0; i \u0026lt; n; ++i) { TreeNode *node = q.front(); q.pop(); lvl.push_back(node-\u0026gt;val); if (node-\u0026gt;left) q.push(node-\u0026gt;left); if (node-\u0026gt;right) q.push(node-\u0026gt;right); } res.push_back(lvl); n = q.size(); } return res; } }; 107 二叉树的层次遍历 II 给一个二叉树，返回其节点值自底向上的层次遍历。\n跟上一题相同，只需要将结果数组倒置，或用一个栈保存结果，再 pop 进结果数组即可。\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrderBottom(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (!root) return res; queue\u0026lt;TreeNode *\u0026gt; q; int n = 1; q.push(root); while (!q.empty()) { vector\u0026lt;int\u0026gt; lvl; for (int i = 0; i \u0026lt; n; ++i) { TreeNode *node = q.front(); q.pop(); lvl.push_back(node-\u0026gt;val); if (node-\u0026gt;left) q.push(node-\u0026gt;left); if (node-\u0026gt;right) q.push(node-\u0026gt;right); } res.push_back(lvl); n = q.size(); } reverse(res.begin(), res.end()); return res; } }; 429 N 叉树的层序遍历 层序遍历一个 N 叉树。\n用一个队列来保存该 N 叉树当前一层的所有节点，一边将这些节点 pop 并 push 进结果数组中，一边将这些节点的子节点 push 进队列。\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(Node *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (!root) return res; queue\u0026lt;Node *\u0026gt; q; q.push(root); int n = 1; while (!q.empty()) { vector\u0026lt;int\u0026gt; lvl; for (int i = 0; i \u0026lt; n; ++i) { Node *node = q.front(); q.pop(); lvl.push_back(node-\u0026gt;val); for (auto \u0026amp;c:node-\u0026gt;children) q.push(c); } res.push_back(lvl); n = q.size(); } return res; } }; 987 二叉树的垂序遍历 垂序遍历一个二叉树。\n用红黑树把二叉树中每个节点的位置保存下来，如果根节点的位置是 (x, y)，那么其左子节点和右子节点的位置分别是 (x - 1, y + 1) 和 (x + 1, y + 1)，再按顺序保存到结果数组即可。\nclass Solution { map\u0026lt;int, map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; matrix; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; verticalTraversal(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; matrix = map\u0026lt;int, map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(); Traverse(root, 0, 0); for (auto \u0026amp;m:matrix) { vector\u0026lt;int\u0026gt; temp; for (auto \u0026amp;n:m.second) { sort(n.second.begin(), n.second.end()); temp.insert(temp.end(), n.second.begin(), n.second.end()); } res.push_back(temp); } return res; } void Traverse(TreeNode *root, int x, int y) { if (!root) return; if (matrix.find(x) == matrix.end()) matrix[x] = map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt;(); if (matrix[x].find(y) == matrix[x].end()) matrix[x][y] = vector\u0026lt;int\u0026gt;(); matrix[x][y].push_back(root-\u0026gt;val); Traverse(root-\u0026gt;left, x - 1, y + 1); Traverse(root-\u0026gt;right, x + 1, y + 1); } }; 103 二叉树的锯齿形层次遍历 锯齿形层次遍历一个二叉树。\n用两个栈轮流从左往右和从右往左保存节点，再依次加入结果数组即可。\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s1, s2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (!root) return res; s1.push(root); while (!s1.empty() || !s2.empty()) { vector\u0026lt;int\u0026gt; lvl; if (s2.empty()) { while (!s1.empty()) { TreeNode *node = s1.top(); s1.pop(); lvl.push_back(node-\u0026gt;val); if (node-\u0026gt;left) s2.push(node-\u0026gt;left); if (node-\u0026gt;right) s2.push(node-\u0026gt;right); } } else { while (!s2.empty()) { TreeNode *node = s2.top(); s2.pop(); lvl.push_back(node-\u0026gt;val); if (node-\u0026gt;right) s1.push(node-\u0026gt;right); if (node-\u0026gt;left) s1.push(node-\u0026gt;left); } } res.push_back(lvl); } return res; } }; 124 二叉树中的最大路径和 用递归的方式，在每个节点值加上其左右子树的最大路径来更新结果，并以其左右子树中较大的一个加上其节点值返回即可。\nclass Solution { int res; public: int maxPathSum(TreeNode *root) { res = INT_MIN; Traverse(root); return res; } int Traverse(TreeNode *node) { if (!node) return 0; int left = max(0, Traverse(node-\u0026gt;left)); int right = max(0, Traverse(node-\u0026gt;right)); res = max(res, left + right + node-\u0026gt;val); return max(left, right) + node-\u0026gt;val; } }; 968 监控二叉树 贪心法，分情况讨论，三种状态分别是：0 表示节点未被监控，1 表示节点自带监控，2 表示节点被子节点监控；一个节点的两个字子节点组合起来分别由 6 种情况，分别是：若两个子节点都为 2（22），那么当前节点未被监控，需要被父节点监控，返回 0；若两个子节点至少有一个为 0（00，01，02，未被监控），那么当前节点需要装上监控以监控子节点，返回 1；剩下的 2 种情况是至少有一个子节点自带监控（11，12），那么当前节点被子节点监控，且其子节点都已被监控或自带监控，返回 2；最后需要单独判断树的根节点是否是 0 的状态，因为已经没有父节点可以进行监控。\nclass Solution { int res; public: int minCameraCover(TreeNode *root) { res = 0; if (Traverse(root) == 0) ++res; return res; } int Traverse(TreeNode *node) { if (!node) return 2; int left = Traverse(node-\u0026gt;left); int right = Traverse(node-\u0026gt;right); if (left == 2 \u0026amp;\u0026amp; right == 2) return 0; else if (left == 0 || right == 0) { ++res; return 1; } return 2; } }; 2. 构造二叉树 105 从前序与中序遍历序列构造二叉树 根据前序遍历与中序遍历的结果构造二叉树。\n前序遍历结果中的第一个元素一定是二叉树的根节点的值，因此在中序遍历结果中找到这个值，那么中序遍历结果中这个值左边的所有元素一定都在这个根节点的左子树上，右边的所有元素一定都在这个根节点的右子树上，假设左边的长度为 m，那么在前序遍历结果的第一个元素后的 m 个元素也都对应左子树上的这些元素，分别把这两部分递归调用构造新的子树即可。\nclass Solution { public: TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { return Build(preorder, 0, preorder.size(), inorder, 0, inorder.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;preorder, int x, int y, vector\u0026lt;int\u0026gt; \u0026amp;inorder, int m, int n) { if (x \u0026gt;= y || m \u0026gt;= n) return nullptr; TreeNode *node = new TreeNode(preorder[x]); int pos = m; while (pos \u0026lt; n \u0026amp;\u0026amp; inorder[pos] != preorder[x]) ++pos; node-\u0026gt;left = Build(preorder, x + 1, x + 1 + pos - m, inorder, m, pos); node-\u0026gt;right = Build(preorder, x + 1 + pos - m, y, inorder, pos + 1, n); return node; } }; 106 从中序与后序遍历序列构造二叉树 根据后序遍历与中序遍历的结果构造二叉树。\n后序遍历结果中的最后一个元素一定是二叉树的根节点的值，因此在中序遍历结果中找到这个值，那么中序遍历结果中这个值左边的所有元素一定都在这个根节点的左子树上，右边的所有元素一定都在这个根节点的右子树上，假设左边的长度为 m，那么在后序遍历结果中从第一个元素往后 m 个元素也都对应左子树上的这些元素，分别把这两部分递归调用构造新的子树即可。\nclass Solution { public: TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;inorder, vector\u0026lt;int\u0026gt; \u0026amp;postorder) { return Build(inorder, 0, inorder.size(), postorder, 0, postorder.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;inorder, int x, int y, vector\u0026lt;int\u0026gt; \u0026amp;postorder, int m, int n) { if (x \u0026gt;= y || m \u0026gt;= n) return nullptr; TreeNode *node = new TreeNode(postorder[n - 1]); int pos = x; while (pos \u0026lt; y \u0026amp;\u0026amp; inorder[pos] != postorder[n - 1]) ++pos; node-\u0026gt;left = Build(inorder, x, pos, postorder, m, m + pos - x); node-\u0026gt;right = Build(inorder, pos + 1, y, postorder, m + pos - x, n - 1); return node; } }; 889 根据前序和后序遍历构造二叉树 根据前序遍历与后序遍历的结果构造二叉树。\n前序遍历结果中的第一个元素对应后序遍历结果中的最后一个元素，都是二叉树的根节点的值，以此构建根节点；前序遍历结果中的第二个元素一定是根节点的左子节点，而后序遍历结果中的这个值一定是左子树上的最后一个值，那么只需要找到这个值在后序遍历结果中的位置，就可以确定左子树和右子树的长度，分别递归调用构造新的子树即可。\nclass Solution { public: TreeNode *constructFromPrePost(vector\u0026lt;int\u0026gt; \u0026amp;pre, vector\u0026lt;int\u0026gt; \u0026amp;post) { return Build(pre, 0, pre.size(), post, 0, post.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;pre, int x, int y, vector\u0026lt;int\u0026gt; \u0026amp;post, int m, int n) { if (x \u0026gt;= y || m \u0026gt;= n) return nullptr; TreeNode *node = new TreeNode(pre[x]); if (x == y - 1) return node; int pos = m; while (pos \u0026lt; n \u0026amp;\u0026amp; post[pos] != pre[x + 1]) ++pos; node-\u0026gt;left = Build(pre, x + 1, x + pos - m + 2, post, m, pos + 1); node-\u0026gt;right = Build(pre, x + pos - m + 2, y, post, pos + 1, n - 1); return node; } }; 1008 先序遍历构造二叉树 给一个先序遍历的结果，构造其对应的二叉搜索树。\n根据先序遍历和二叉搜索树的定义，数组的第一个元素即是根节点，其后所有小于它的元素都在它的左子树上，所有大于它的元素都在它的右子树上，递归求解即可。\nclass Solution { public: TreeNode *bstFromPreorder(vector\u0026lt;int\u0026gt; \u0026amp;preorder) { return Build(preorder, 0, preorder.size()); } TreeNode *Build(vector\u0026lt;int\u0026gt; \u0026amp;preorder, int x, int y) { if (x \u0026gt;= y) return nullptr; TreeNode *root = new TreeNode(preorder[x]); int i = x + 1; while (i \u0026lt; y \u0026amp;\u0026amp; preorder[i] \u0026lt; preorder[x]) ++i; root-\u0026gt;left = Build(preorder, x + 1, i); root-\u0026gt;right = Build(preorder, i, y); return root; } }; 1028 从先序遍历还原二叉树 给一个先序遍历的结果和用不同长度的 \u0026lsquo;-\u0026rsquo; 相连的字符串，构造其对应的二叉树。\n\u0026lsquo;-\u0026rsquo; 的长度代表当前的层次，如果当前节点之后的 \u0026lsquo;-\u0026rsquo; 的长度等于当前的层次加一，那么其后的数构成当前节点的左节点；如果左节点之后的 \u0026lsquo;-\u0026rsquo; 的长度等于当前的层次加一，那么其后的数构成当前节点的右节点；否则如果当前节点之后或左节点之后的 \u0026lsquo;-\u0026rsquo; 的长度小于等于等钱层次则代表当前节点已经是叶子节点，其没有左右子节点，直接返回。用一个变量 pos 保存当前遍历到的字符串位置，递归调用该过程即可。\nclass Solution { public: TreeNode *recoverFromPreorder(string S) { int pos = 0; return Build(S, 0, pos, 0); } TreeNode *Build(const string \u0026amp;S, int x, int \u0026amp;pos, int lvl) { int num = 0, i = x; while (S[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; S[i] \u0026lt;= \u0026#39;9\u0026#39;) ++i; TreeNode *node = new TreeNode(stoi(S.substr(x, i - x + 1))); pos = i; while (S[i] == \u0026#39;-\u0026#39;) ++i; if (i - pos == lvl + 1) node-\u0026gt;left = Build(S, i, pos, lvl + 1); else return node; i = pos; while (S[i] == \u0026#39;-\u0026#39;) ++i; if (i - pos == lvl + 1) node-\u0026gt;right = Build(S, i, y, pos, lvl + 1); return node; } }; ","permalink":"https://prov1dence.top/posts/leetcode/tree-1/","summary":"\u003ch1 id=\"leetcode-树1httpsleetcode-cncomtagtree\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/tree/\"\u003eLeetCode 树（1）\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"1-树的遍历\"\u003e1. 树的遍历\u003c/h3\u003e\n\u003ch4 id=\"144-二叉树的前序遍历httpsleetcode-cncomproblemsbinary-tree-preorder-traversal\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\"\u003e144 二叉树的前序遍历\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e前序遍历一个二叉树。\u003c/p\u003e\n\u003cp\u003e前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，先将节点加入结果数组，然后用一个栈保存右，左子节点，依次访问，重复此过程。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e preorderTraversal(TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eroot) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        res \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Preorder(root);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePreorder\u003c/span\u003e(TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eroot) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003eroot)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        res.push_back(root\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eval);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Preorder(root\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eleft);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Preorder(root\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eright);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e preorderTraversal(TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eroot) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003eroot)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        stack\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eTreeNode \u003cspan style=\"color:#f92672\"\u003e*\u0026gt;\u003c/span\u003e pre;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        pre.push(root);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003epre.empty()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            TreeNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003enode \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pre.top();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            pre.pop();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            res.push_back(node\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eval);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (node\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eright)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                pre.push(node\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eright);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (node\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eleft)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                pre.push(node\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eleft);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"589-n叉树的前序遍历httpsleetcode-cncomproblemsn-ary-tree-preorder-traversal\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/\"\u003e589 N叉树的前序遍历\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e前序遍历一个 N 叉树。\u003c/p\u003e","title":"LeetCode 树（1）"},{"content":"LeetCode 链表（2） 题目 4. 双指针 19 删除链表的倒数第N个节点 删除链表的倒数第 n 个节点。\n在链表中不易直接取到倒数第 n 个位置，所以用两个指针 prev 和 tail，tail 先往前走 n 步，然后两个指针一起往前走直到 tail 没有后继指针，此时 prev 的后继指针就是倒数第 n 个位置，删除其即可。注意如果要删除的指针是头指针的话要单独处理。\nclass Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *prev = head, *tail = head; for (int i = 0; i \u0026lt; n; ++i) tail = tail-\u0026gt;next; if (!tail) { head = head-\u0026gt;next; delete prev; return head; } while (tail-\u0026gt;next) tail = tail-\u0026gt;next, prev = prev-\u0026gt;next; ListNode *next = prev-\u0026gt;next; prev-\u0026gt;next = next-\u0026gt;next; delete next; return head; } }; 61 旋转链表 给一个链表，将其每个节点向右移动 k 个位置。\n在链表中不易直接取到前 k 个位置，所以用两个指针，第一个先往前走 k 步，然后两个指针一起往前走直到第一个指针没有后继指针，就可以将头节点链接到第一个指针后，将第二个指针后置为空。注意 k 可能非常大，要先计算一次链表的长度 len 然后用 k % len 进行计算。\nclass Solution { public: ListNode *rotateRight(ListNode *head, int k) { if (!head) return nullptr; ListNode *first = head, *second = head, *traverse = head; int len = 0; while (traverse) { traverse = traverse-\u0026gt;next; ++len; } k %= len; for (int i = 0; i \u0026lt; k; i++) first = first-\u0026gt;next; while (first \u0026amp;\u0026amp; first-\u0026gt;next) first = first-\u0026gt;next, second = second-\u0026gt;next; first-\u0026gt;next = head; auto ret = second-\u0026gt;next; second-\u0026gt;next = nullptr; return ret; } }; 876 链表的中间结点 找链表的中间节点。\n用两个指针 slow 和 fast，fast 每次移动两步，slow 每次移动一步，当 fast 走到末尾的时候 slow 恰好到指针的中间。\nclass Solution { public: ListNode* middleNode(ListNode* head) { auto slow = head, fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return slow; } }; 160 相交链表 找到两个链表相交的起始节点。\n假设链表 A 未相交的长度为 l1，链表 B 未相交的长度为 l2，相交部分的长度为 lc，为了让两个指针走相同的长度，只需要让两个指针在走到尾部的时候重新回到另一个链表的头部再继续走，最后当两个指针走过的长度都是 l1 + l2 + l3 时即相交。\nclass Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { auto a = headA, b = headB; if (!a || !b) return nullptr; while (a != b) { a = a ? a-\u0026gt;next : headB; b = b ? b-\u0026gt;next : headA; } return a; } }; 141 环形链表 判断一个链表中是否有环。\n用两个指针 slow 和 fast，fast 每次移动两步，slow 每次移动一步，如果链表中有环那么这两个指针一定会最终相遇，否则 fast 将先到达末尾，当 fast == nullptr 或 fast-\u0026gt;next == nullptr 即代表链表没有换并且 fast 已经到达末尾。\nclass Solution { public: bool hasCycle(ListNode *head) { auto slow = head, fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) return true; } return false; } }; 142 环形链表 II 给一个链表，找到链表中入环的第一个节点。\n跟上一题相同，用两个指针 slow 和 fast，fast 每次移动两步，slow 每次移动一步，如果链表中有环那么这两个指针一定会最终相遇，此时 fast 指针移动的距离是 l1 + l2 + c，其中 l1 是链表中环外部分的长度，l2 是环内两个指针走过的共同部分的长度，c 是环的长度，而 slow 指针移动的距离则是 l1 + l2，因为 fast 指针的移动速度是 slow 的两倍，所以有 l1 + l2 + c = 2 * (l1 + l2)，因此 c = l1 + l2，又因为 slow 指针已经在环中走过了长度为 l2 的部分，只剩下长度为 l1 的部分，只需要用一个新的指针从链表的头部开始每次移动一步，同时让 slow 指针每次移动一步，最终他们都会移动 l1 的距离并在入环处相遇。\nclass Solution { public: ListNode *detectCycle(ListNode *head) { if (!head || !head-\u0026gt;next) return nullptr; auto slow = head-\u0026gt;next, fast = head-\u0026gt;next-\u0026gt;next; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next \u0026amp;\u0026amp; fast != slow) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } if (!fast || !fast-\u0026gt;next) return nullptr; auto lin = head; while (lin != slow) lin = lin-\u0026gt;next, slow = slow-\u0026gt;next; return lin; } }; 5. 综合 234 回文链表 判断一个链表是否为回文链表。\n先找到链表的中间节点，然后将右边的链表翻转，将左边的链表从中间截断，再一次对比两边的每一个节点是否相等。\nclass Solution { public: bool isPalindrome(ListNode *head) { if (!head || !head-\u0026gt;next) return true; auto prev = head, slow = head, fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { prev = slow; slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } auto node = Reverse(fast ? slow-\u0026gt;next : slow); prev-\u0026gt;next = nullptr; while (head \u0026amp;\u0026amp; node \u0026amp;\u0026amp; head-\u0026gt;val == node-\u0026gt;val) head = head-\u0026gt;next, node = node-\u0026gt;next; return !head \u0026amp;\u0026amp; !node; } ListNode *Reverse(ListNode *head) { if (!head) return head; ListNode *prev = nullptr, *curr = head, *next = head-\u0026gt;next; while(curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 109 有序链表转换二叉搜索树 给一个有序链表，将其转换为一个平衡二叉搜索树。\n先找到链表的中间节点，将其作为树的根节点，将中间节点的左边部分链表作为其左子树，右边部分链表作为其右子树。\nclass Solution { public: TreeNode *sortedListToBST(ListNode *head) { if (!head) return nullptr; ListNode *prev = nullptr, *slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) prev = slow, slow = slow-\u0026gt;next, fast = fast-\u0026gt;next-\u0026gt;next; if (prev) prev-\u0026gt;next = nullptr; auto root = new TreeNode(slow-\u0026gt;val); root-\u0026gt;left = sortedListToBST(prev ? head : nullptr); root-\u0026gt;right = sortedListToBST(slow-\u0026gt;next); return root; } }; 426 将二叉搜索树转化为排序的双向链表 将一个二叉搜索树转换为一个双向循环链表。\n对于一个根节点，其被转换为双向链表之后的前驱节点应该是其左子树中值最大的节点，也就是其左子节点的最右子节点，因此只需要先找到这个节点，然后将根节点与其首尾相连即可，在此之前应该先对根节点的左子树左对应的操作，右子树亦然。除此之外还要把最小的和最大的两个节点保存下来，将这两个节点首尾相连，形成循环链表。\nclass Solution { Node *first, *last; public: Node *treeToDoublyList(Node *root) { first = last = nullptr; TreeToList(root); if (first) first-\u0026gt;left = last; if (last) last-\u0026gt;right = first; return first; } void TreeToList(Node *root) { if (!root) return; if (!first || first-\u0026gt;val \u0026gt; root-\u0026gt;val) first = root; if (!last || last-\u0026gt;val \u0026lt; root-\u0026gt;val) last = root; auto left = root-\u0026gt;left, right = root-\u0026gt;right; TreeToList(left); TreeToList(right); while (left \u0026amp;\u0026amp; left-\u0026gt;right) left = left-\u0026gt;right; if (left) left-\u0026gt;right = root; root-\u0026gt;left = left; while (right \u0026amp;\u0026amp; right-\u0026gt;left) right = right-\u0026gt;left; if (right) right-\u0026gt;left = root; root-\u0026gt;right = right; } }; 143 重排链表 将一个链表从 L0→L1→…→Ln-1→Ln 重新排列为 L0→Ln→L1→Ln-1→L2→Ln-2→\u0026hellip;。\n先将链表从中间分为两部分，将后半部分反转，再将对应位置的节点依次链接上。\nclass Solution { public: void reorderList(ListNode* head) { if (!head) return; auto prev = head, slow = head, fast = head, first = head, second = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) prev = slow, slow = slow-\u0026gt;next, fast = fast-\u0026gt;next-\u0026gt;next; if (fast) { second = slow-\u0026gt;next; slow-\u0026gt;next = nullptr; } else { second = slow; prev-\u0026gt;next = nullptr; } second = Reverse(second); while (second) { auto n1 = first-\u0026gt;next, n2 = second-\u0026gt;next; first-\u0026gt;next = second; second-\u0026gt;next = n1; first = n1; second = n2; } } ListNode *Reverse(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 138 复制带随机指针的链表 给一个链表，每个节点包含一个 random 指针指向链表的某一个节点，返回这个链表的深拷贝。\n因为在第一次遍历时 random 指针指向的节点可能并未被拷贝，可以先将所有节点先拷贝一次，用一个哈希表将节点的对应关系保存下来，再遍历一次将 random 指针指向的节点依次链接上，这样做空间复杂度是 O(n)。也可以先将每一个节点都拷贝一次，并将拷贝的节点链接到该节点后，再遍历两次分别修改 random 指针指向的节点以及将原链表及其拷贝分开，这样做空间复杂度是 O(1)。\nclass Solution { public: Node *copyRandomList(Node *head) { if (!head) return head; Node *node = head; while (node) { Node *cop = new Node(node-\u0026gt;val, node-\u0026gt;next, node-\u0026gt;random); node-\u0026gt;next = cop; node = node-\u0026gt;next-\u0026gt;next; } node = head; while (node \u0026amp;\u0026amp; node-\u0026gt;next) { if (node-\u0026gt;random) node-\u0026gt;next-\u0026gt;random = node-\u0026gt;random-\u0026gt;next; node = node-\u0026gt;next-\u0026gt;next; } node = head; Node *res = head-\u0026gt;next; while (node) { Node *next = node-\u0026gt;next; node-\u0026gt;next = next-\u0026gt;next; next-\u0026gt;next = next-\u0026gt;next ? next-\u0026gt;next-\u0026gt;next : nullptr; node = node-\u0026gt;next; } return res; } }; 23 合并K个排序链表 合并 k 个有序链表。\n最简单的做法是每次遍历所有头节点，取出值最小的一个，将其加到要返回的链表中。时间复杂度是 O(m * n)，其中 m 是链表的个数，n 是节点的总个数，空间复杂度是 O(1)。\nclass Solution { public: ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { ListNode *root = new ListNode(0), *node = root; while (node) { ListNode *min_ptr = nullptr; for (auto \u0026amp;l :lists) if (l \u0026amp;\u0026amp; (!min_ptr || l-\u0026gt;val \u0026lt; min_ptr-\u0026gt;val)) min_ptr = l; node-\u0026gt;next = min_ptr; for (auto \u0026amp;l :lists) if (l \u0026amp;\u0026amp; l == min_ptr) l = l-\u0026gt;next; node = node-\u0026gt;next; } return root-\u0026gt;next; } }; 在此基础上可以用一个小根堆来保存所有头节点，每次取出堆顶的节点，将该节点加入要返回的链表中，判断该节点是否有后继节点，如果有的话则将其加入堆中并维护，注意需要重载优先队列的比较函数。时间复杂度是 O(n * logm)，空间复杂度是 O(m)。\nclass Solution { struct compare { bool operator()(ListNode *l1, ListNode *l2) { return l1-\u0026gt;val \u0026gt; l2-\u0026gt;val; } }; public: ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { ListNode *root = new ListNode(0), *node = root; priority_queue\u0026lt;ListNode *, vector\u0026lt;ListNode *\u0026gt;, compare\u0026gt; heap; for (auto \u0026amp;l:lists) if (l) heap.push(l); while (!heap.empty()) { ListNode *curr = heap.top(); node-\u0026gt;next = curr; node = node-\u0026gt;next; heap.pop(); if (curr-\u0026gt;next) heap.push(curr-\u0026gt;next); } return root-\u0026gt;next; } }; 还可以用分治法两两合并链表，省去维护堆所花费的空间和时间，因为链表的数量是 m，所以用分治法需要花费 logm 的时间来合并所有的链表。时间复杂度是 O(n * logm)，空间复杂度是 O(1)。\nclass Solution { ListNode *MergeLists(ListNode *l1, ListNode *l2) { ListNode *root = new ListNode(0), *node = root; while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { node-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { node-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } node = node-\u0026gt;next; } node-\u0026gt;next = l1 ? l1 : l2; return root-\u0026gt;next; } public: ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { int n = lists.size(); for (int interval = 1; interval \u0026lt; n; interval *= 2) { for (int i = 0; i \u0026lt; n; i += interval * 2) if (i + interval \u0026lt; n) lists[i] = MergeLists(lists[i], lists[i + interval]); } return n == 0 ? nullptr : lists[0]; } }; ","permalink":"https://prov1dence.top/posts/leetcode/linkedlist-2/","summary":"\u003ch1 id=\"leetcode-链表2httpsleetcode-cncomtaglinked-list\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/linked-list/\"\u003eLeetCode 链表（2）\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"4-双指针\"\u003e4. 双指针\u003c/h3\u003e\n\u003ch4 id=\"19-删除链表的倒数第n个节点httpsleetcode-cncomproblemsremove-nth-node-from-end-of-listsubmissions\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/\"\u003e19 删除链表的倒数第N个节点\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e删除链表的倒数第 n 个节点。\u003c/p\u003e\n\u003cp\u003e在链表中不易直接取到倒数第 n 个位置，所以用两个指针 prev 和 tail，tail 先往前走 n 步，然后两个指针一起往前走直到 tail 没有后继指针，此时 prev 的后继指针就是倒数第 n 个位置，删除其即可。注意如果要删除的指针是头指针的话要单独处理。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ListNode\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e removeNthFromEnd(ListNode\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e head, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        ListNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eprev \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e head, \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003etail \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e head;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            tail \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e tail\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003etail) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            head \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e head\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e prev;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e head;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (tail\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            tail \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e tail\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext, prev \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e prev\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        ListNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003enext \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e prev\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        prev\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e next\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e next;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e head;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"61-旋转链表httpsleetcode-cncomproblemsrotate-listsubmissions\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/rotate-list/submissions/\"\u003e61 旋转链表\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e给一个链表，将其每个节点向右移动 k 个位置。\u003c/p\u003e","title":"LeetCode 链表（2）"},{"content":"LeetCode 链表（1） 题目 1. 常规题 2 两数相加 给两个链表分别代表两个正数的逆序表示，计算两个链表之和。\n依次按位进行相加。\nclass Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { int acc = 0, val = 0; auto head = l1, tail = l1; while (l1 \u0026amp;\u0026amp; l2) { val = l1-\u0026gt;val + l2-\u0026gt;val + acc; acc = val / 10; l1-\u0026gt;val = val % 10; if (!l1-\u0026gt;next) l1-\u0026gt;next = l2-\u0026gt;next, l2-\u0026gt;next = nullptr; tail = l1; l1 = l1-\u0026gt;next, l2 = l2-\u0026gt;next; } while (l1) { val = l1-\u0026gt;val + acc; acc = val / 10; l1-\u0026gt;val = val % 10; tail = l1; l1 = l1-\u0026gt;next; } if (acc) tail-\u0026gt;next = new ListNode(1); return head; } }; 21 合并两个有序链表 合并两个有序链表。\n逐个比较大小并添加到当前节点后面，并移动对应的链表节点。\nclass Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head = new ListNode(0), *node = head; while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) head-\u0026gt;next = l1, l1 = l1-\u0026gt;next; else head-\u0026gt;next = l2, l2 = l2-\u0026gt;next; head = head-\u0026gt;next; } while (l1) head-\u0026gt;next = l1, l1 = l1-\u0026gt;next, head = head-\u0026gt;next; while (l2) head-\u0026gt;next = l2, l2 = l2-\u0026gt;next, head = head-\u0026gt;next; return node-\u0026gt;next; } }; 83 删除排序链表中的重复元素 删除链表中所有重复的节点。\n将每个节点与其后面的节点的值做对比，如果相同则删除后面的节点。\nclass Solution { public: ListNode* deleteDuplicates(ListNode* head) { auto ret = head; while (head) { while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;next-\u0026gt;val == head-\u0026gt;val) { auto next = head-\u0026gt;next; head-\u0026gt;next = next-\u0026gt;next; delete next; } head = head-\u0026gt;next; } return ret; } }; 82 删除排序链表中的重复元素 II 删除链表中所有重复的节点，只保留原始链表中没有重复出现的数字。\n为了删除所有重复的节点并只保留所有没有出现过的数字，需要提前两个节点检查接下来的两个节点的值是否相同，如果相同的话需要将这两个节点及其后的所有重复节点都删除。\nclass Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode *node = new ListNode(0), *ret = node, *next = nullptr, *temp = nullptr; node-\u0026gt;next = head; while (node \u0026amp;\u0026amp; node-\u0026gt;next) { next = node-\u0026gt;next-\u0026gt;next; while (next \u0026amp;\u0026amp; node-\u0026gt;next-\u0026gt;val == next-\u0026gt;val) { temp = next; next = next-\u0026gt;next; delete temp; } if (next != node-\u0026gt;next-\u0026gt;next) { temp = node-\u0026gt;next; node-\u0026gt;next = next; delete temp; } else node = node-\u0026gt;next; } return ret-\u0026gt;next; } }; 203 移除链表元素 删除链表中等于给定值的所有节点。\n先判断头节点是否等于给定值，再判断其后面的节点是否等于给定值。\nclass Solution { public: ListNode* removeElements(ListNode* head, int val) { while (head \u0026amp;\u0026amp; head-\u0026gt;val == val) { auto prev = head; head = head-\u0026gt;next; delete prev; } auto ret = head; while (head) { while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;next-\u0026gt;val == val) { auto next = head-\u0026gt;next; head-\u0026gt;next = next-\u0026gt;next; delete next; } head = head-\u0026gt;next; } return ret; } }; 817 链表组件 给一个链表和一个数组，找到链表中一段子链表的值都在数组中的子链表的个数。\n先将数组转换成哈希表方便查询，再依次遍历整个链表，判断一段子链表结束时或遍历结束时子链表是否是符合条件。\nclass Solution { public: int numComponents(ListNode* head, vector\u0026lt;int\u0026gt;\u0026amp; G) { unordered_set\u0026lt;int\u0026gt; exist(G.begin(), G.end()); bool cont = false, curr = false; int res = 0; while (head) { curr = exist.count(head-\u0026gt;val); res += cont \u0026amp;\u0026amp; !curr; cont = curr; head = head-\u0026gt;next; } return res + cont; } }; 24 两两交换链表中的节点 给一个链表，返回两两交换其中相邻的节点后的结果。\n用三个指针把要交换的两个节点和他们的前驱节点保存下来，交换后再更新三个指针，按顺序交换即可。\nclass Solution { public: ListNode *swapPairs(ListNode *head) { if (!head || !head-\u0026gt;next) return head; ListNode *root = new ListNode(0), *prev = root; root-\u0026gt;next = head; auto first = head, second = head-\u0026gt;next; while (first \u0026amp;\u0026amp; second) { auto temp = second-\u0026gt;next; prev-\u0026gt;next = second; second-\u0026gt;next = first; first-\u0026gt;next = temp; prev = first; first = temp; second = temp ? temp-\u0026gt;next : nullptr; } return root-\u0026gt;next; } }; 430 扁平化多级双向链表 给一个带子节点的双向链表，将其扁平化并使所有结点出现在单级双链表中。\n对于某一个节点，如果它有 child 节点，那么需要将其 child 节点作为其新的 next 节点，将其 child 链表上的最后一个节点作为其原本 next 节点的 prev 节点，递归调用整个过程即可。\nclass Solution { public: Node *flatten(Node *head) { if (!head) return nullptr; Node *node = head, *next = nullptr; while (node) { if (node-\u0026gt;child) { next = node-\u0026gt;next; auto child = flatten(node-\u0026gt;child); node-\u0026gt;next = child; child-\u0026gt;prev = node; node-\u0026gt;child = nullptr; while (node-\u0026gt;next) node = node-\u0026gt;next; node-\u0026gt;next = next; if (next) next-\u0026gt;prev = node; } node = node-\u0026gt;next; } return head; } }; 2. 链表反转 206 反转链表 class Solution { public: ListNode* reverseList(ListNode* head) { if (!head) return nullptr; ListNode *prev = nullptr, *curr = head, *next = head-\u0026gt;next; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 92 反转链表 II 将链表中从 m 到 n 位置的节点反转。\n先找到位置在 m - 1 的节点，将其后的节点截断，再找到位置在 n 的节点，将其后的节点截断，将中间的一段链表反转后再链接到愿链表上。\nclass Solution { public: ListNode *reverseBetween(ListNode *head, int m, int n) { ListNode *root = new ListNode(0), *r = root, *prev, *last; root-\u0026gt;next = head; int cnt = 1; while (cnt \u0026lt; m \u0026amp;\u0026amp; r) r = r-\u0026gt;next, ++cnt; prev = r; while (cnt \u0026lt;= n \u0026amp;\u0026amp; r \u0026amp;\u0026amp; r-\u0026gt;next) r = r-\u0026gt;next, ++cnt; last = r-\u0026gt;next; r-\u0026gt;next = nullptr; prev-\u0026gt;next = Reverse(prev-\u0026gt;next); while (prev \u0026amp;\u0026amp; prev-\u0026gt;next) prev = prev-\u0026gt;next; prev-\u0026gt;next = last; return root-\u0026gt;next; } ListNode *Reverse(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 369 给单链表加一 用一个单链表表示一个整数，计算将其加一的结果。\n先将链表反转方便进位，然后进行加一和进位的操作，最后再反转一次链表。\nclass Solution { public: ListNode* plusOne(ListNode* head) { if (!head) return nullptr; head = Reverse(head); auto root = head; while (head) { if (head-\u0026gt;val == 9) { head-\u0026gt;val = 0; if (!head-\u0026gt;next) { head-\u0026gt;next = new ListNode(1); break; } head = head-\u0026gt;next; } else { ++head-\u0026gt;val; break; } } return Reverse(root); } ListNode *Reverse(ListNode* head) { if (!head) return nullptr; ListNode *prev = nullptr, *curr = head, *next = head-\u0026gt;next; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 445 两数相加 II 给两个链表分别代表两个正数，计算两个链表之和。\n先将两个链表反转，再依次按位进行相加，最后再将得到的结果反转并返回。\nclass Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { if (!l1 || !l2) return !l1 ? l2 : l1; l1 = Reverse(l1); l2 = Reverse(l2); int carry = 0, sum = 0; ListNode *head = l1, *prev = l1; while (l1 \u0026amp;\u0026amp; l2) { prev = l1; sum = l1-\u0026gt;val + l2-\u0026gt;val + carry; carry = sum / 10; l1-\u0026gt;val = sum - carry * 10; if (l2-\u0026gt;next \u0026amp;\u0026amp; !l1-\u0026gt;next) l1-\u0026gt;next = l2-\u0026gt;next, l2-\u0026gt;next = nullptr; l1 = l1-\u0026gt;next; l2 = l2-\u0026gt;next; } while (l1) { prev = l1; sum = l1-\u0026gt;val + carry; carry = sum / 10; l1-\u0026gt;val = sum - carry * 10; l1 = l1-\u0026gt;next; } if (carry \u0026amp;\u0026amp; prev) prev-\u0026gt;next = new ListNode(1); return Reverse(head); } ListNode *Reverse(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } }; 25 K 个一组翻转链表 给一个链表，每 k 个节点一组进行翻转。\n用几个指针记录下需要反转的部分的起始，终止位置，依次反转即可。\nclass Solution { ListNode *ReverseLinkedList(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } return prev; } public: ListNode *reverseKGroup(ListNode *head, int k) { ListNode *root = new ListNode(0), *prev = root; prev-\u0026gt;next = head; while (prev) { int i = 1; ListNode *start = prev-\u0026gt;next, *end = prev-\u0026gt;next, *curr = end, *next = nullptr; while (curr \u0026amp;\u0026amp; i \u0026lt; k) curr = curr-\u0026gt;next, ++i; if (i \u0026lt; k || !curr) break; next = curr-\u0026gt;next; curr-\u0026gt;next = nullptr; start = ReverseLinkedList(start); prev-\u0026gt;next = start; end-\u0026gt;next = next; prev = end; } return root-\u0026gt;next; } }; 3. 双链表 328 奇偶链表 把一个链表中的奇数位节点和偶数位节点分别排在一起。\n用两个头节点分别表示奇数位和偶数位节点的起始位置，遍历整个链表，将奇数位节点链接在奇数位起始节点后，将偶数位节点链接在偶数位起始节点后，最后将偶数位起始节点链接在奇数位最后节点后即可。\nclass Solution { public: ListNode* oddEvenList(ListNode* head) { if (!head || !head-\u0026gt;next) return head; auto odd = head, even = head-\u0026gt;next, node = even-\u0026gt;next, even_head = even; bool flag = true; while (node) { if (flag) { odd-\u0026gt;next = node; odd = odd-\u0026gt;next; flag = false; } else { even-\u0026gt;next = node; even = even-\u0026gt;next; flag = true; } node = node-\u0026gt;next; } odd-\u0026gt;next = even_head; even-\u0026gt;next = nullptr; return head; } }; 86 分隔链表 给一个链表和一个值 x，重新排列链表使得所有小于 x 的节点都在大于等于 x 的节点之前。\n用两个头节点 sth 和 geq 分别表示小于 x 和大于等于 x 的节点的起始位置，遍历整个链表，分别将各个节点链接到两个头节点之后，最后将 geq 链接到 sth 之后，再将 geq 的末端设为空指针。\nclass Solution { public: ListNode* partition(ListNode* head, int x) { auto sth = new ListNode(0), sth_head = sth, geq = new ListNode(0), geq_head = geq; while (head) { if (head-\u0026gt;val \u0026lt; x) { sth-\u0026gt;next = head; sth = sth-\u0026gt;next; } else { geq-\u0026gt;next = head; geq = geq-\u0026gt;next; } head = head-\u0026gt;next; } sth-\u0026gt;next = geq_head-\u0026gt;next; geq-\u0026gt;next = nullptr; return sth_head-\u0026gt;next; } }; 725 分隔链表 给一个链表, 将其分隔为 k 个连续的部分。\n先计算出链表的长度和 k 个连续部分中每个部分的长度，依次将每个部分的头节点放入数组中。\nclass Solution { public: vector\u0026lt;ListNode *\u0026gt; splitListToParts(ListNode *root, int k) { vector\u0026lt;ListNode *\u0026gt; res(k, nullptr); int len = 0; ListNode *head = root, *temp = nullptr; while (root) root = root-\u0026gt;next, ++len; int n = len / k, m = len % k, i = 0; while (head) { res[i] = head; for (int j = 0; j \u0026lt; n + (m \u0026gt; 0) - 1; ++j) head = head-\u0026gt;next; temp = head; head = head-\u0026gt;next; temp-\u0026gt;next = nullptr; ++i; --m; } return res; } }; ","permalink":"https://prov1dence.top/posts/leetcode/linkedlist-1/","summary":"\u003ch1 id=\"leetcode-链表1httpsleetcode-cncomtaglinked-list\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/linked-list/\"\u003eLeetCode 链表（1）\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"1-常规题\"\u003e1. 常规题\u003c/h3\u003e\n\u003ch4 id=\"2-两数相加httpsleetcode-cncomproblemsadd-two-numbers\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/add-two-numbers/\"\u003e2 两数相加\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e给两个链表分别代表两个正数的逆序表示，计算两个链表之和。\u003c/p\u003e\n\u003cp\u003e依次按位进行相加。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ListNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eaddTwoNumbers(ListNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003el1, ListNode \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003el2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e acc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e head \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l1, tail \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (l1 \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e l2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eval \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e l2\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eval \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e acc;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            acc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e val \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            l1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eval \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e val \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003el1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                l1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l2\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext, l2\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            tail \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            l1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext, l2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l2\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (l1) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eval \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e acc;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            acc \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e val \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            l1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eval \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e val \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            tail \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            l1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e l1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (acc)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            tail\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003enext \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e ListNode(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e head;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"21-合并两个有序链表httpsleetcode-cncomproblemsmerge-two-sorted-listssubmissions\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/\"\u003e21 合并两个有序链表\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e合并两个有序链表。\u003c/p\u003e","title":"LeetCode 链表（1）"},{"content":"LeetCode 动态规划 题目 6. 字符串相关 712 两个字符串的最小ASCII删除和 给定两个字符串，计算使两个字符串相同所需要删除的字符的ASCII值的和的最小值。\n对于两个字符串中的字符 s1[i] 和 s2[j]，如果s1[i] == s2[j]，那么这两个字符都不需要被删除，所以 dp[i][j] = dp[i - 1][j - 1]，否则至少有一个应该被删除，取两个中的最小值，状态转移方程是dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\nclass Solution { public: int minimumDeleteSum(string s1, string s2) { int n1 = s1.size(), n2 = s2.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n1 + 1, vector\u0026lt;int\u0026gt;(n2 + 1, 0)); for (int i = 1; i \u0026lt;= n1; ++i) dp[i][0] = dp[i - 1][0] + s1[i - 1]; for (int j = 1; j \u0026lt;= n2; ++j) dp[0][j] = dp[0][j - 1] + s2[j - 1]; for (int i = 0; i \u0026lt; n1; ++i) for (int j = 0; j \u0026lt; n2; ++j) if (s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j]; else dp[i + 1][j + 1] = min(dp[i][j] + s1[i] + s2[j], min(dp[i][j + 1] + s1[i], dp[i + 1][j] + s2[j])); return dp[n1][n2]; } }; 5 最长回文子串 找到一个字符串中的最长回文子串。\n最简单的方法是从一个字符与其前一个/两个字符分别往两边遍历。也可以按照自下而上的动态规划思想，用一个二维数组 dp[i][j]，判断两个字符 s[i] 与 s[j] 是否相等，以及他们内侧的子字符串是否是一个回文串，状态转移方程是 dp[i][j] = s[i] == s[j] \u0026amp;\u0026amp; (dp[i + 1][j - 1] || j - i \u0026lt; 3)。\nclass Solution { public: string longestPalindrome(string s) { int n = s.size(); string res; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n, vector\u0026lt;bool\u0026gt;(n, false)); for (int i = 0; i \u0026lt; n; ++i) for (int j = i; j \u0026gt;= 0; --j) if (s[i] == s[j] \u0026amp;\u0026amp; (i - j \u0026lt; 3 || dp[j + 1][i - 1])) { dp[j][i] = true; if (i - j + 1 \u0026gt; res.size()) res = s.substr(j, i - j + 1); } return res; } }; 647 回文子串 找到一个字符串中的回文子串的个数。\n与上一题类似，用一个二维数组 dp[i][j]，判断两个字符 s[i] 与 s[j] 是否相等，以及他们内侧的子字符串是否是一个回文串，如果是那么 s.substr(j, i - j + 1)，将结果 +1 即可。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。\nclass Solution { public: int countSubstrings(string s) { int res = 0, n = s.size(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n, vector\u0026lt;bool\u0026gt;(n, false)); for (int i = 0; i \u0026lt; n; ++i) for (int j = i; j \u0026gt;= 0; --j) if (s[i] == s[j] \u0026amp;\u0026amp; (i - j \u0026lt; 3 || dp[j + 1][i - 1])) dp[j][i] = true, ++res; return res; } }; 516 最长回文子序列 给定一个字符串，找最长的回文子序列。\n只有当两个字符相等时，他们才有可能和他们之间的子序列形成回文子序列，因此只需要知道他们之间的最长回文子序列的长度即可，否则他们之间的最长回文子序列只能是其中一个字符的左边或右边到另一个字符之间的最大回文子序列长度，状态转移方程是 dp[j][i] = s[i] == s[j] ? dp[j + 1][i - 1] + 2 : max(dp[j + 1][i], dp[j][i - 1])。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。\nclass Solution { public: int longestPalindromeSubseq(string s) { int n = s.size(); if (n \u0026lt;= 1) return n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 1; i \u0026lt; n; ++i) { dp[i][i] = 1; for (int j = i - 1; j \u0026gt;= 0; --j) { if (s[i] == s[j]) dp[j][i] = dp[j + 1][i - 1] + 2; else dp[j][i] = max(dp[j + 1][i], dp[j][i - 1]); } } return dp[0][n - 1]; } }; 7. 路径和 62 不同路径 给一个矩阵，求从左上角走到右下角有多少种方法。\n走到第一列和第一行的每一格都只有一种方法，其余的格子均可以从其上方和左方走一格到达，因此有状态转移方程 dp[i][j] = dp[i][j - 1] + dp[i - 1][j]。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\nclass Solution { public: int uniquePaths(int m, int n) { if (m == 0 || n == 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 1)); for (int i = 1; i \u0026lt; m; ++i) for (int j = 1; j \u0026lt; n; ++j) dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; return dp[m - 1][n - 1]; } }; 对于每一个格子来说，它的值都等于到达上方和左方格子的方法数量之和，也就相当于在遍历完一行之后，把上一行的值全部赋值给下一行，在下一行遍历时使其加上左方格子的方法数量，由此可以将赋值的过程简化为一个一维数组，空间复杂度降低为 O(min(m, n))。\nclass Solution { public: int uniquePaths(int m, int n) { if (m == 0 || n == 0) return 0; vector\u0026lt;int\u0026gt; dp(n, 1); for (int i = 1; i \u0026lt; m; ++i) for (int j = 1; j \u0026lt; n; ++j) dp[j] += dp[j - 1]; return dp[n - 1]; } }; 63 不同路径 II 给一个矩阵，部分位置有障碍物，求从左上角走到右下角有多少种方法。\n和上一题相比在部分位置增加了障碍物，首先要处理第一列和第一行，如果有一个位置有障碍物那么接下来的位置都不能到达了，然后对于其他格子，如果本身是障碍物那么也无法到达，否则仍然等于其上方和左方之和。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\nclass Solution { public: int uniquePathsWithObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = m != 0 ? grid[0].size() : 0; if (m == 0 || n == 0) return 0; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(m, vector\u0026lt;long long\u0026gt;(n, 0)); dp[0][0] = grid[0][0] ^ 1; for (int i = 1; i \u0026lt; m; ++i) dp[i][0] = (grid[i][0] ^ 1) \u0026amp; dp[i - 1][0]; for (int j = 1; j \u0026lt; n; ++j) dp[0][j] = (grid[0][j] ^ 1) \u0026amp; dp[0][j - 1]; for (int i = 1; i \u0026lt; m; ++i) for (int j = 1; j \u0026lt; n; ++j) dp[i][j] = grid[i][j] ? 0 : dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; } }; 64 最小路径和 给一个带权值的矩阵，求从左上角走到右下角的最小权值之和。\n到达第一列和第一行的每一格都只有一种方法，因此先将其初始化。因为每一格只能从其上方和左方到达，因此有状态转移方程 grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])。时间复杂度是 O(m * n)。可以直接在给的矩阵中操作，因此空间复杂度是 O(1)。\nclass Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = m != 0 ? grid[0].size() : 0; if (m == 0) return 0; for (int i = 1; i \u0026lt; m; ++i) grid[i][0] += grid[i - 1][0]; for (int j = 1; j \u0026lt; n; ++j) grid[0][j] += grid[0][j - 1]; for (int i = 1; i \u0026lt; m; ++i) for (int j = 1; j \u0026lt; n; ++j) grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]); return grid[m - 1][n - 1]; } }; 120 三角形最小路径和 给一个带权值的三角形，求自顶向下的最小路径和。每一步可以移动到左下方或右下方。\n因为每一格只能从其左上方和右上方到达，因此有状态转移方程 tri[i][j] += min(tri[i - 1][j], tri[i - 1][j - 1])。时间复杂度是 O(m * n)。可以直接在给的矩阵中操作，因此空间复杂度是 O(1)。\nclass Solution { public: int minimumTotal(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;tri) { int n = tri.size(), res = INT_MAX; if (n \u0026lt;= 1) return n == 0 ? 0 : tri[0][0]; for (int i = 1; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; tri[i].size(); ++j) { if (j == 0) tri[i][j] += tri[i - 1][j]; else if (j \u0026gt;= tri[i - 1].size()) tri[i][j] += tri[i - 1][j - 1]; else tri[i][j] += min(tri[i - 1][j], tri[i - 1][j - 1]); if (i == n - 1) res = min(res, tri[i][j]); } } return res; } }; 931 下降路径最小和 给一个带权值的方形，求自顶向下的最小路径和。每一步可以移动到左下方，下方或右下方。\n每一格可以从其左上方，上方和右上方到达，因此有状态转移方程 A[i][j] += min({A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1]})。\nclass Solution { public: int minFallingPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; A) { int m = A.size(), n = m != 0 ? A[0].size() : 0, val = INT_MAX, res = INT_MAX; if (m == 0) return 0; for (int i = 1; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { val = A[i - 1][j]; if (j \u0026lt; n - 1) val = min(val, A[i - 1][j + 1]); if (j \u0026gt; 0) val = min(val, A[i - 1][j - 1]); A[i][j] += val; } } return *min_element(A[m - 1].begin(), A[m - 1].end()); } }; 8. 其他 650 只有两个键的键盘 有一个字符 \u0026lsquo;A\u0026rsquo;，只能进行复制和粘贴操作，求得到 n 个 \u0026lsquo;A\u0026rsquo; 的最小操作次数。\nm 个 \u0026lsquo;A\u0026rsquo; 只能通过粘贴的操作得到，求出所有能整除 m 的数里通过复制粘贴操作得到 m 的最小次数即可。\nclass Solution { public: int minSteps(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, n); dp[1] = 0; for (int i = 1; i \u0026lt;= n; ++i) { int res = dp[i] + 1; for (int j = i; j \u0026lt;= n; j += i) { dp[j] = min(dp[j], res); ++res; } } return dp[n]; } }; 651 4键键盘 一个键盘上有四个键：输入 \u0026lsquo;A\u0026rsquo;，选中全部，复制，和粘贴。可以按 N 次键盘，求最多能显示多少个 \u0026lsquo;A\u0026rsquo;。\n因为 N 是最后一次操作，所以只能进行输入 \u0026lsquo;A\u0026rsquo; 和粘贴两种操作，只需要求出每一步在之前一步基础上输入 \u0026lsquo;A\u0026rsquo;，以及在往前三步的每一步基础上选中，复制，粘贴能得到的最2优解。\nclass Solution { public: int maxA(int N) { vector\u0026lt;int\u0026gt; dp(N + 1, 0); for (int i = 1; i \u0026lt;= N; ++i) { dp[i] = dp[i - 1] + 1; for (int j = i - 1; j \u0026gt;= 2; --j) dp[i] = max(dp[i], dp[j - 2] * (i - j + 1)); } return dp[N]; } }; ","permalink":"https://prov1dence.top/posts/leetcode/dynamicprogramming-3/","summary":"\u003ch1 id=\"leetcode-动态规划httpsleetcode-cncomproblemsetallsearche4b891e695b0\"\u003e\u003ca href=\"https://leetcode-cn.com/problemset/all/?search=%E4%B8%91%E6%95%B0\"\u003eLeetCode 动态规划\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"6-字符串相关\"\u003e6. 字符串相关\u003c/h3\u003e\n\u003ch4 id=\"712-两个字符串的最小ascii删除和httpsleetcode-cncomproblemsminimum-ascii-delete-sum-for-two-strings\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/\"\u003e712 两个字符串的最小ASCII删除和\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e给定两个字符串，计算使两个字符串相同所需要删除的字符的ASCII值的和的最小值。\u003c/p\u003e\n\u003cp\u003e对于两个字符串中的字符 s1[i] 和 s2[j]，如果s1[i] == s2[j]，那么这两个字符都不需要被删除，所以 dp[i][j] = dp[i - 1][j - 1]，否则至少有一个应该被删除，取两个中的最小值，状态转移方程是dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e minimumDeleteSum(string s1, string s2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s1.size(), n2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s2.size();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e dp(n1 \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(n2 \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e n1; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            dp[i][\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dp[i \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e][\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e s1[i \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; j \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e n2; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ej)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            dp[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e][j] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dp[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e][j \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e s2[j \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n1; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; j \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n2; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ej)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (s1[i] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e s2[j])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    dp[i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e][j \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dp[i][j];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    dp[i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e][j \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e min(dp[i][j] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e s1[i] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e s2[j], min(dp[i][j \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e s1[i], dp[i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e][j] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e s2[j]));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e dp[n1][n2];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"5-最长回文子串httpsleetcode-cncomproblemslongest-palindromic-substring\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\"\u003e5 最长回文子串\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e找到一个字符串中的最长回文子串。\u003c/p\u003e","title":"LeetCode 动态规划（3）"},{"content":"LeetCode 动态规划 题目 3. 数组相关 300 最长上升子序列 在无序数组中找到最长上升子序列的长度。\n用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的每个数字 j，如果 nums[i] \u0026gt; nums[j]，那么 j 和 i 可以形成一个上升子序列，让 dp[i] = max(dp[i], dp[j] + 1) 就能得到最长的上升子序列了。\nclass Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), res = 2; if (n \u0026lt;= 1) return n; vector\u0026lt;int\u0026gt; dp(n, 1); for (int i = 1; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; i; ++j) if (nums[i] \u0026gt; nums[j]) { dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); } return res; } }; 53 最大子序和 找一个数组中具有最大和的连续子数组的和。\n从头开始用一个变量 val 保存到当前数为止的连续子数组和，每一个数对于之前的连续子数组和只有加与不加两种选择，当之前的连续子数组和大于 0 时加上之前的连续子数组和，否则不加。\nclass Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int res = INT_MIN, val = 0; for (auto \u0026amp;n:nums) { val = max(val, 0) + n; res = max(res, val); } return res; } }; 718 最长重复子数组 给两个数组，求两个数组中公共的长度最长的子数组的长度。\n对于某两个字符 A[i] 和 B[j]，如果 A[i] == B[j]，则代表 A[i]，B[j] 与他们之前的子数组有可能是公共子数组，其最长长度 dp[i][j] = dp[i - 1][j - 1] + 1，否则他们不能组成公共子数组，dp[i][j] = 0。用两层循环遍历两个数组即可，时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\nclass Solution { public: int findLength(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { int m = A.size(), n = B.size(), res = 0; if (m == 0 || n == 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 1; i \u0026lt;= m; ++i) for (int j = 1; j \u0026lt;= n; ++j) { dp[i][j] = A[i - 1] == B[j - 1] ? dp[i - 1][j - 1] + 1 : 0; res = max(res, dp[i][j]); } return res; } }; 983 最低票价 给出要旅行的所有日期，有三种通行证：一日票，七日票，三十日票。求最低消费。\n对于第 i 天的最低消费，只需要选出一天前的最低消费加上一日票的消费，七天前的最低消费加上七日票，三十天前的最低消费加上三十日票这三种消费中最低的即可，因此有状态转移方程 dp[i] = min({dp[i - 1] + costs[0], dp[i - 7] + costs[1], dp[i - 30] + costs[2]})。\nclass Solution { public: int mincostTickets(vector\u0026lt;int\u0026gt; \u0026amp;days, vector\u0026lt;int\u0026gt; \u0026amp;costs) { vector\u0026lt;int\u0026gt; dp(366, INT_MAX); dp[0] = 0; int j = 0, n = days.size(); for (int i = 1; i \u0026lt;= 365 \u0026amp;\u0026amp; j \u0026lt; n; ++i) { if (i == days[j]) { dp[i] = min({dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2]}); ++j; } else dp[i] = dp[i - 1]; } return dp[days[n - 1]]; } }; 813 最大平均值和的分组 将数组分为 K 个相邻的非空子数组，求所有子数组的平均值的和的最大值。\n用二维数组 dp[n][K] 来表示前 i 个数分成 k 组得到的最优值，每次将从第 j 个数到第 n 个数分为一组，将前面 j - 1 个数分为 k - 1 组，求得 dp[i][k] 的最大值。为了快速地算出第 j 个数到第 n 个数的和以及前 j - 1 个数的和，可以用一个前缀和数组将前 m 个数的和保存下来，再用状态转移方程 dp[i][k] = max(dp[i][k], dp[j][k - 1] + (pre[i] - pre[j]) / (i - j)) 求得最优值。\nclass Solution { public: double largestSumOfAverages(vector\u0026lt;int\u0026gt; \u0026amp;A, int K) { int n = A.size(); if (n == 0) return 0; vector\u0026lt;double\u0026gt; pre(n + 1, 0); for (int i = 1; i \u0026lt;= n; ++i) pre[i] += pre[i - 1] + A[i - 1]; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;double\u0026gt;(K + 1, 0)); for (int i = 1; i \u0026lt;= n; ++i) { dp[i][1] = pre[i] / i; for (int k = 2; k \u0026lt;= K \u0026amp;\u0026amp; k \u0026lt;= i; ++k) for (int j = 1; j \u0026lt; i; ++j) dp[i][k] = max(dp[i][k], dp[j][k - 1] + (pre[i] - pre[j]) / (i - j)); } return dp[n][K]; } }; 646 最长数对链 按照每个数对的第一个元素从小到大排序，从第二个数对开始，依次判断其与其前面的所有数对是否符合题意，是的话则 dp[j] = max(dp[j], dp[i] + 1）。时间复杂度是 O(n^2)。\nclass Solution { public: int findLongestChain(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; pairs) { sort(pairs.begin(), pairs.end()); int n = pairs.size(), res = 1; vector\u0026lt;int\u0026gt; dp(n, 1); for (int j = 1; j \u0026lt; n; ++j) for (int i = 0; i \u0026lt; j; ++i) if (pairs[j][0] \u0026gt; pairs[i][1]) { dp[j] = max(dp[j], dp[i] + 1); res = max(res, dp[j]); } return res; } }; 4. 等差数列 413 等差数列划分 给一个数组，计算数组中等差子数组的个数。\n等差数列必须是相邻两个元素之差相等的长度大于 3 的子数组，因此只需要知道 nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 1] 即可。用一个变量 cul 表示到目前为止等差数列的长度，diff 表示之前的公差，如果目前的差等于 diff 则加上 cul。时间复杂度是 O(n)，空间复杂度是 O(1)。\nclass Solution { public: int numberOfArithmeticSlices(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = 0, n = nums.size(), cul = 1, curr = 0; if (n \u0026lt; 3) return 0; int diff = nums[1] - nums[0]; for (int i = 2; i \u0026lt; n; ++i) { if ((curr = nums[i] - nums[i - 1]) == diff) { res += cul; ++cul; } else { diff = curr; cul = 1; } } return res; } }; 446 等差数列划分 II - 子序列 给一个数组，计算数组中等差子序列的个数。\n对于某一个数 nums[i]，已知其与其之前某一个数的差 diff = nums[i] - nums[j]，需要知道在 nums[j] 之前公差为 diff 的等差子序列的最大个数，可以用一个哈希表数组来表示数 nums[j] 之前公差为 diff 的等差子序列的最大个数，如果 nums[i] - nums[j] == diff 则到位置 i 为止公差为 diff 的等差子序列的个数 dp[i][diff] += dp[j][diff]，注意要用 += 而不是 =，因为如果在 nums[i] 之前有多个相同的数字那么需要把每一个都算作一个独立的等差子序列。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。很搞笑的是这道题的动态规划解法在 LeetCode 上提交的时候 runtime 是 1000ms +-，而在LeetCode-CN 上提交的时候执行用时是 1400ms ~ 1800ms，而且偶尔还会超时，超时的 case 的公差超过了 int32 的表示范围，如果加上判断 diff \u0026lt; INT_MIN || diff \u0026gt; INT_MAX 直接 continue 就能正常通过了。\nclass Solution { public: int numberOfArithmeticSlices(vector\u0026lt;int\u0026gt;\u0026amp; A) { int n = A.size(), res = 0; long long diff = 0; vector\u0026lt;unordered_map\u0026lt;long long, int\u0026gt;\u0026gt; dp(n); for (int i = 1; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { diff = static_cast\u0026lt;long long\u0026gt;(A[i]) - A[j]; if (diff \u0026lt; INT_MIN || diff \u0026gt; INT_MAX) continue; dp[i][diff] += dp[j][diff] + 1; res += dp[j][diff]; } } return res; } }; 1027 最长等差数列 给一个数组，计算数组中最长等差子序列的长度。\n对于某一个数 nums[i]，已知其与其之前某一个数的差 diff = nums[i] - nums[j]，需要知道在 nums[j] 之前公差为 diff 的等差子序列有多长，可以用一个哈希表数组来表示每一个数之前公差为 diff 的等差子序列的最长长度，在此基础上 +1 即可得到最长的等差子序列的长度。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。\nclass Solution { public: int longestArithSeqLength(vector\u0026lt;int\u0026gt; \u0026amp;A) { int n = A.size(), res = 2; vector\u0026lt;unordered_map\u0026lt;int, int\u0026gt;\u0026gt; dp(n); for (int i = 1; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { int diff = A[i] - A[j]; if (dp[j].find(diff) == dp[j].end()) dp[i][diff] = 2; else { dp[i][diff] = dp[j][diff] + 1; res = max(res, dp[i][diff]); } } } return res; } }; 5. 斐波那契数列 70 爬楼梯 每次能爬 1 或 2 阶楼梯，求爬 n 阶楼梯有多少种方法。\n爬到当前楼梯的方法等于爬到前两阶楼梯的方法之和，因此有状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]，又因为当前状态只取决于前两个状态，因此可以只使用两个变量 s1 和 s2 来保存前两个状态的结果。时间复杂度是 O(n)，空间复杂度是 O(1)。\nclass Solution { public: int climbStairs(int n) { if (n \u0026lt;= 1) return 1; int s1 = 1, s2 = 1, temp; for (int i = 1; i \u0026lt; n; ++i) { temp = s2; s2 += s1; s1 = temp; } return s2; } }; 746 使用最小花费爬楼梯 每次能爬 1 或 2 阶楼梯，每一阶楼梯有一个权值，求爬 n 阶楼梯的最小花费。\n和上一题类似，不过每次只需要取前两阶楼梯中权值较小的就可以了。\nclass Solution { public: int minCostClimbingStairs(vector\u0026lt;int\u0026gt;\u0026amp; cost) { int n = cost.size(); if (n == 0) return 0; else if (n == 1) return cost[0]; else if (n == 2) return cost[0] + cost[1]; int s1 = cost[0], s2 = cost[1]; for (int i = 2; i \u0026lt; n; ++i) { int temp = s2; s2 = min(s1, s2) + cost[i]; s1 = temp; } return min(s1, s2); } }; 740 删除与获得点数 给一个数组，每次任选一个 nums[i]，获得 nums[i] 的个数乘以 nums[i] 的点数，计算能获得的最大点数。\n对于 nums[i]，能取到的最大点数只能是 nums[i - 1] 的最大点数或 nums[i - 2] 的最大点书加上 nums[i] 能获得的点数，因此有状态转移方程 dp[i] = max(dp[i - 1], dp[i - 2] + val[i])，时间复杂度是 O(n)。每个点只与其之前两个点有关，因此可以只使用两个变量 p1 和 p2 来保存前两个点的结果，空间复杂度是 O(1)。\nclass Solution { public: int deleteAndEarn(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; val(10001, 0); for (auto \u0026amp;m:nums) val[m] += m; int res = 0, prev = 0, curr = 0; for (int i = 1; i \u0026lt;= 10000; ++i) { res = max(curr, prev + val[i]); prev = curr; curr = res; } return res; } }; 198 打家劫舍 给一个带权值的数组，取不相邻的数，求能取到的最大值。\n对于某一点，如果到之前一点为止能取到的最大值大于取当前点与之前两点的最大值的和则不取，否则取当前点，当前点的值与之前两点的最大值之和就是当前点的最优值，因此有状态转移方程 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])，时间复杂度是 O(n)。当前点只与之前两个点有关，因此可以只使用两个变量 p1 和 p2 来保存前两个点的结果，空间复杂度是 O(1)。\nclass Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n \u0026lt;= 2) return n == 0 ? 0 : n == 1 ? nums[0] : max(nums[0], nums[1]); int p1 = nums[0], p2 = max(nums[0], nums[1]), temp; for (int i = 2; i \u0026lt; n; ++i) { temp = p2; p2 = max(p1 + nums[i], p2); p1 = temp; } return p2; } }; 213 打家劫舍 II 给一个带权值的数组，数组首尾相邻，取不相邻的数，求能取到的最大值。\n数组首尾相邻代表不能同时取第一个点和最后一个点，因此从第一个点到倒数第二个点进行动态规划得到的就是包含第一个点而不包含最后一个点能取到的最大值，从第二个点到最后一个点进行动态规划得到的就是包含最后一个点而不包含第一个点能取到的最大值，用于上一题同样的方法分别做两次就能得到结果。时间复杂度是 O(n)，空间复杂度是 O(1)。\nclass Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = 0, n = nums.size(); if (n \u0026lt;= 2) return n == 0 ? 0 : n == 1 ? nums[0] : max(nums[0], nums[1]); int p1 = nums[0], p2 = max(nums[0], nums[1]); for (int i = 2; i \u0026lt; n - 1; ++i) { int temp = p2; p2 = max(p2, p1 + nums[i]); p1 = temp; } res = p2; p1 = nums[1], p2 = max(nums[1], nums[2]); for (int i = 3; i \u0026lt; n; ++i) { int temp = p2; p2 = max(p2, p1 + nums[i]); p1 = temp; } return max(res, p2); } }; 337 打家劫舍 III 给一个带权值的二叉树，取不相邻的数，求能取到的最大值。\n对于一个节点，如果取节点本身则不能取两个子节点，如果取两个子节点则不能去其本身和四个子节点，因此对比其两个子节点的和与其本身和四个孙子节点的和，取最大值返回，也就是 max(dp[node-\u0026gt;left-\u0026gt;left] + dp [node-\u0026gt;left-\u0026gt;right] + dp[node-\u0026gt;right-\u0026gt;left] + dp [node-\u0026gt;right-\u0026gt;right] + dp[node], dp[node-\u0026gt;left] + dp[node-\u0026gt;right])。因为递归会造成大量的重复计算，因此用一个哈希表把已经计算过的节点的最优值保存下来，递归到该节点的时候直接取值防止造成TLE。时间复杂度是 O(n)，空间复杂度是 O(n)。\nclass Solution { unordered_map\u0026lt;TreeNode *, int\u0026gt; val; public: int rob(TreeNode *node) { if (!node) return 0; if (val.find(node) != val.end()) return val[node]; int p1 = 0, p2 = 0; if (node-\u0026gt;left) p1 += rob(node-\u0026gt;left-\u0026gt;left) + rob(node-\u0026gt;left-\u0026gt;right); if (node-\u0026gt;right) p1 += rob(node-\u0026gt;right-\u0026gt;left) + rob(node-\u0026gt;right-\u0026gt;right); p1 += node-\u0026gt;val; p2 += rob(node-\u0026gt;left) + rob(node-\u0026gt;right); val[node] = max(p1, p2); return val[node]; } } 96 不同的二叉搜索树 求有 n 个节点的二叉搜索树有多少种。\n对于某一个数 i 作为根结点时，无论 i 是多少，其左子树左子树总是由 i - 1 个节点构成的，而其右节点总是由 n - i 个节点构成的，例如 n = 3 时，如果让 3 作为根节点，那么其左子树一定是由 1 和 2 两个节点构成的，那么我们只需要知道由两个节点构成的二叉搜索树有多少种，再用这个左子树的种类数 dp[2] 乘以右子树的种类数 dp[0] 就能知道由 3 个节点构成的，以 3 作为根节点的种类数，其次需要依次让 1 和 2 作为根节点，那么他们的左子树分别有 dp[0] 和 dp[1] 种构成的方法，因此得到状态转移方程 dp[i] += dp[j - 1] * dp[i - j]，时间复杂度是 O(n ^ 2)，空间复杂度是 O(n)。\nclass Solution { public: int numTrees(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, 0); dp[0] = dp[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= i; ++j) dp[i] += dp[j - 1] * dp[i - j]; return dp[n]; } }; 873 最长的斐波那契子序列的长度 给一个严格递增的数组，找到其中最长的斐波那契子序列的长度。\n根据斐波那契数列的定义，要判断 A[i] 和 A[j] 能否在原数组中构成斐波那契数列，只需要知道 A[i - j] 是否在原数组中，并且 A[i] - A[j] \u0026lt; A[j] \u0026lt; A[i] 是否成立，于是我们可以用一个二维数组 dp[n][n] 来代表由 A[i] 和 A[j] 以及 A[i - j] 构成的斐波那契子序列的最长长度。为了查找 A[i - j] 是否在原数组中，我们可以用一个哈希表 pos 来保存 A[i - j] 在原数组中的下标，获取下标 k = pos[A[i] - A[j]] 后，用状态转移方程 dp[i][j] = dp[j][k] + 1 来更新最长长度。\n注意在判断下标是否存在于哈希表中时要用 pos.find(A[i] - A[j]) == pos.end()，而不能直接用 pos[A[i] - A[j]] 来获取，这样虽然如果 A[i] - A[j] 不存在于哈希表中仍然能够得到结果 0，但效率非常低，会导致TLE。\nclass Solution { public: int lenLongestFibSubseq(vector\u0026lt;int\u0026gt; \u0026amp;A) { int n = A.size(), res = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n, 0)); unordered_map\u0026lt;int, int\u0026gt; pos; for (int i = 0; i \u0026lt; n; ++i) { pos[A[i]] = i; for (int j = 0; j \u0026lt; i; ++j) { auto k = pos.find(A[i] - A[j]) == pos.end() ? -1 : pos[A[i] - A[j]]; dp[i][j] = A[i] - A[j] \u0026lt; A[j] \u0026amp;\u0026amp; k != -1 ? dp[j][k] + 1 : 2; res = max(res, dp[i][j]); } } return res \u0026lt; 3 ? 0 : res; } }; ","permalink":"https://prov1dence.top/posts/leetcode/dynamicprogramming-2/","summary":"\u003ch1 id=\"leetcode-动态规划httpsleetcode-cncomproblemsetallsearche4b891e695b0\"\u003e\u003ca href=\"https://leetcode-cn.com/problemset/all/?search=%E4%B8%91%E6%95%B0\"\u003eLeetCode 动态规划\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"3-数组相关\"\u003e3. 数组相关\u003c/h3\u003e\n\u003ch4 id=\"300-最长上升子序列httpsleetcode-cncomproblemslongest-increasing-subsequencesubmissions\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/submissions/\"\u003e300 最长上升子序列\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e在无序数组中找到最长上升子序列的长度。\u003c/p\u003e\n\u003cp\u003e用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的每个数字 j，如果 nums[i] \u0026gt; nums[j]，那么 j 和 i 可以形成一个上升子序列，让 dp[i] = max(dp[i], dp[j] + 1) 就能得到最长的上升子序列了。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e lengthOfLIS(vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026amp;\u003c/span\u003e nums) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e nums.size(), res \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (n \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e dp(n, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; j \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e i; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ej)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (nums[i] \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e nums[j]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    dp[i] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e max(dp[i], dp[j] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    res \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e max(res, dp[i]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"53-最大子序和httpsleetcode-cncomproblemsmaximum-subarray\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/maximum-subarray/\"\u003e53 最大子序和\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e找一个数组中具有最大和的连续子数组的和。\u003c/p\u003e","title":"LeetCode 动态规划（2）"},{"content":"LeetCode 动态规划 题目 1. 数字相关 263 丑数 判断一个数 num 是否是丑数。\n通用的方法是自底向上求出大于等于 num 的第一个数来判断 num 是否是丑数。但这道题已经给出了数 num，直接通过模运算就能得到结果了。\nclass Solution { public: bool isUgly(int num) { if (num \u0026lt; 1) return false; while (num % 2 == 0) num /= 2; while (num % 3 == 0) num /= 3; while (num % 5 == 0) num /= 5; return num == 1; } }; 264 丑数 II 求第 n 个丑数。\n用一个数组 ugly 来保存前 m 个丑数，用三个质因数 2，3，5 乘以其当前系数对应的丑数，得到新的丑数，最小的一个就是第 m + 1 个丑数。时间复杂度是 O(m * n)，其中 m 是质因数的个数，n 是要找的第 n 个丑数。\nclass Solution { public: int nthUglyNumber(int n) { vector\u0026lt;int\u0026gt; ugly(n, 1); int base_2 = 0, base_3 = 0, base_5 = 0; int m = INT_MAX; for (int i = 1; i \u0026lt; n; ++i) { ugly[i] = min({2 * ugly[base_2], 3 * ugly[base_3], 5 * ugly[base_5]}); if (2 * ugly[base_2] == ugly[i]) ++base_2; if (3 * ugly[base_3] == ugly[i]) ++base_3; if (5 * ugly[base_5] == ugly[i]) ++base_5; cout \u0026lt;\u0026lt; ugly[i] \u0026lt;\u0026lt; endl; } return ugly[n - 1]; } }; 313 超级丑数 给定质因数数组 primes，求第 n 个丑数。\n跟上一题完全相同，只是把原有的三个质因数 2，3，5 换成了一个数组。时间复杂度是 O(n * m)，其中 n 是第 n 个丑数，m 是数组的长度。\nclass Solution { public: int nthSuperUglyNumber(int N, vector\u0026lt;int\u0026gt;\u0026amp; primes) { int n = primes.size(), m = INT_MAX;; vector\u0026lt;int\u0026gt; ugly(N, 1), base(n, 0); for (int i = 1; i \u0026lt; N; ++i) { m = INT_MAX; for (int j = 0; j \u0026lt; n; ++j) m = min(m, primes[j] * ugly[base[j]]); ugly[i] = m; for (int j = 0; j \u0026lt; n; ++j) if (primes[j] * ugly[base[j]] == m) ++base[j]; } return ugly[N - 1]; } }; 279 完全平方数 给一个数 n，其可以被表示为 m 个完全平方数的，找到最小的 m。\nn 只能由比 n 小 1, 4, 9 等等的数的最优值加一得到，因此用一个数组 dp[n] 保存小于等于 n 的数被表示为 k 个完全平方数的和的最小的 k 的数量，根据状态转移方程 dp[n] = min({dp[n], dp[n - 1], dp[n - 4], dp[n - 9], \u0026hellip;}) + 1 计算得到结果。时间复杂度是 O(n * w)，w 是比 n 小的完全平方数的个数，空间复杂度是 O(n)。\nclass Solution { public: int numSquares(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, INT_MAX); dp[0] = 0, dp[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) for (int j = 1; i - j * j \u0026gt;= 0; ++j) dp[i] = min(dp[i], dp[i - j * j] + 1); return dp[n]; } }; 343 整数拆分 给一个数 n，将其拆分为至少两个数的和，求这些整数的最大乘积。\nn 可以被拆分为 2 个数的和，这两个数又可以被拆分为若干个数的和，因此只需要知道其被拆分为两个数时这两个数的最大乘积，自下往上地计算小于等于 n 的数被拆分时的最大乘积即可，状态转移方程是 dp[i] = max(dp[i], dp[j] * dp[i - j])。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n)。\nclass Solution { public: int integerBreak(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, 0); if (n \u0026lt; 3) return 1; if (n == 3) return 2; dp[2] = 2, dp[3] = 3; for (int i = 4; i \u0026lt;= n; ++i) for (int j = 1, k = i - j; j \u0026lt;= k; ++j, --k) dp[i] = max(dp[i], dp[j] * dp[k]); return dp[n]; } }; 1155 掷骰子的 N 种方法 对于每一个骰子来说，它可以在之前的基础上有 f 种投掷的方法，它之后的状态是 dp[i + 1][j + k]，i 是投掷过的骰子的个数，k 是它投掷不同的 f 种方法，j 是到它为止投掷出和为 j 的种数，自下而上动态规划即可。\nclass Solution { public: int numRollsToTarget(int d, int f, int target) { int dp[d + 1][target + f + 1]; memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 0; i \u0026lt; d; ++i) for (int j = 0; j \u0026lt; target; ++j) if (dp[i][j]) for (int k = 1; k \u0026lt;= f; ++k) if (j + k \u0026lt;= target) dp[i + 1][j + k] = (dp[i + 1][j + k] + dp[i][j]) % 1000000007; return dp[d][target]; } }; 2. 买卖股票 121 买卖股票的最佳时机 给一个股票数组，只能进行一次交易，求最大利润。\n最大化当前值与之前的最小值之差。时间复杂度是 O(n)。\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int min_val = INT_MAX, res = 0; for (auto \u0026amp;p:prices) { min_val = min(min_val, p); res = max(res, p - min_val); } return res; } }; 122 买卖股票的最佳时机 II 给一个股票数组，不限制交易次数，求最大利润。\n每一个严格递增的区间都是交易的时机，所以将严格递增区间内的差值全部加上即可。时间复杂度是 O(n)。\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { int res = 0; for (int i = 1; i \u0026lt; prices.size(); ++i) res += max(prices[i] - prices[i - 1], 0); return res; } }; 123 买卖股票的最佳时机 III 给一个股票数组，只能进行两笔交易，求最大利润。\n因为要进行两笔交易，所以需要最大化两个值：一个是到第 i 天为止的最大收益，一个是第 i 天之后的最大收益。第一种方法是两次遍历，第一次计算到第 i 天为止的最大收益，第二次反向遍历计算第 i 天之后的最大收益，方法跟第一题相同，注意第二次买入操作必须在第一次卖出操作之后，不能发生在同一天。时间复杂度是 O(n)。\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { int n = prices.size(), pre_min = INT_MAX, post_max = 0, res = 0; vector\u0026lt;int\u0026gt; pre(n, 0), post(n, 0); for (int i = 0; i \u0026lt; n - 1; ++i) { pre_min = min(pre_min, prices[i]); pre[i] = max(pre[max(0, i - 1)], prices[i] - pre_min); } for (int i = n - 1; i \u0026gt;= 0; --i) { post_max = max(post_max, prices[i]); post[i] = max(post[min(n - 1, i + 1)], post_max - prices[i]); } for (int i = 0; i \u0026lt; n; ++i) res = max(res, pre[i] + post[i]); return res; } }; 第二种方法则是基于每天只有四种可能的操作：第一次买入，第一次卖出 res1，第二次买入，和第二次卖出 res2。第一次买入需要最大化之前买入股票的最小花费，第一次卖出需要最大化到第 i 天为止的股票价格与第一次买入的差值，第二次买入需要最大化在第 i 天买入股票并减去第一次卖出的收益，最后第二次卖出需要最大化到第 i 天为止的股票价格与第二次买入的差值。最后得到第二次卖出的最优值。时间复杂度是 O(n)。\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { int buy1 = INT_MIN, sell1 = 0, buy2 = INT_MIN, sell2 = 0; for (auto \u0026amp;p:prices) { buy1 = max(buy1, -p); sell1 = max(sell1, p + buy1); buy2 = max(buy2, sell1 - p); sell2 = max(sell2, p + buy2); cout \u0026lt;\u0026lt; buy1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; sell1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; buy2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; sell2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; endl; } return sell2; } }; 309 最佳买卖股票时机含冷冻期 给一个股票数组，不限制交易次数，卖出和买入之间需要隔一天，求最大利润。\n和上一题的第二种方法类似，我们可以用两个数组 buy 和 sell 分别表示买入和卖出操作，对于买入操作，需要最大化两天前卖出的最优值于今天买入的差值，对于卖出操作，需要最大化当天价格与前一天买入的最优值的差值。时间复杂度是 O(n)。\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (n \u0026lt; 2) return 0; vector\u0026lt;int\u0026gt; buy(n, 0), sell(n, 0); buy[0] = -prices[0], sell[0] = 0; for (int i = 1; i \u0026lt; n; ++i) { buy[i] = max(buy[i - 1], sell[max(0, i - 2)] - prices[i]); sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]); } return sell[n - 1]; } }; 714 买卖股票的最佳时机含手续费 给一个股票数组，不限制交易次数，每次卖出有一定手续费，求最大利润。\n和上一题类似，区别在于没有了交易间隔，以及每次进行 sell 操作的时候需要减去手续费。时间复杂度是 O(n)。\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices, int fee) { int n = prices.size(); if (n \u0026lt; 2) return 0; vector\u0026lt;int\u0026gt; buy(n, 0), sell(n, 0); buy[0] = -prices[0]; for (int i = 1; i \u0026lt; n; ++i) { buy[i] = max(buy[i - 1], sell[i - 1] - prices[i]); sell[i] = max(sell[i - 1], buy[i - 1] + prices[i] - fee); } return sell[n - 1]; } }; 188 买卖股票的最佳时机 IV 给一个股票数组，最多能进行 k 笔交易，求最大利润。\n把上面五道题都做完之后这道题就很简单了。相比于第二题，因为这道题的 k 是未知的，所以要用一个循环将所有可能的 k 笔交易的最优值都计算出来，因此用一个三维数组 dp[n][k][2]，或是分开成两个二维数组 buy[n][k] 和 sell[n][k]，来表示前 n 天进行 k 笔交易的最优的买入和卖出值。同样的，买入和卖出操作都是在之前一次的卖出和买入的基础上进行的，使用 buy[i][j] = max({buy[i][j - 1], buy[i - 1][j], sell[i - 1][j - 1] - prices[i]}) 来表示前 i 天进行了 j 次交易的最优的买入值，第一项在 j \u0026lt;= i / 2 时会填充为 buy[i][j - 1]的值，防止后面操作时不会取到空值或默认值造成错误，第二项是当前买入操作不能取得最优值的结果，第三项则是当前买入操作能取得最优值的结果；对应的卖出操作则是 sell[i][j] = max({sell[i][j - 1], sell[i - 1][j], buy[i - 1][j] + prices[i]})。\n值得注意的是，当 k 远大于数组长度的两倍，或 k 非常大时，构造二维数组会造成MLE，此时可以直接用第二题的思路解决。时间复杂度是 O(n * k)，空间复杂度是 O(n * k)。\nclass Solution { public: int maxProfit(int k, vector\u0026lt;int\u0026gt; \u0026amp;prices) { int n = prices.size(), res = 0; if (n \u0026lt; 2 || k == 0) return 0; if (k \u0026gt;= n * 2) { for (int i = 1; i \u0026lt; n; ++i) res += max(0, prices[i] - prices[i - 1]); return res; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; buy(n, vector\u0026lt;int\u0026gt;(k, INT_MIN)), sell(n, vector\u0026lt;int\u0026gt;(k, 0)); buy[0][0] = -prices[0], sell[0][0] = 0; for (int i = 1; i \u0026lt; n; ++i) { buy[i][0] = max(buy[i - 1][0], -prices[i]); sell[i][0] = max(sell[i - 1][0], buy[i - 1][0] + prices[i]); for (int j = 1; j \u0026lt; k; ++j) { buy[i][j] = max({buy[i][j - 1], buy[i - 1][j], sell[i - 1][j - 1] - prices[i]}); sell[i][j] = max({sell[i][j - 1], sell[i - 1][j], buy[i - 1][j] + prices[i]}); } } return sell[n - 1][k - 1]; } }; ","permalink":"https://prov1dence.top/posts/leetcode/dynamicprogramming-1/","summary":"\u003ch1 id=\"leetcode-动态规划httpsleetcode-cncomproblemsetallsearche4b891e695b0\"\u003e\u003ca href=\"https://leetcode-cn.com/problemset/all/?search=%E4%B8%91%E6%95%B0\"\u003eLeetCode 动态规划\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"1-数字相关\"\u003e1. 数字相关\u003c/h3\u003e\n\u003ch4 id=\"263-丑数httpsleetcode-cncomproblemsugly-number\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/ugly-number/\"\u003e263 丑数\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e判断一个数 num 是否是丑数。\u003c/p\u003e\n\u003cp\u003e通用的方法是自底向上求出大于等于 num 的第一个数来判断 num 是否是丑数。但这道题已经给出了数 num，直接通过模运算就能得到结果了。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e isUgly(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e num) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (num \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e false;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (num \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            num \u003cspan style=\"color:#f92672\"\u003e/=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (num \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            num \u003cspan style=\"color:#f92672\"\u003e/=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (num \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            num \u003cspan style=\"color:#f92672\"\u003e/=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e num \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"264-丑数-iihttpsleetcode-cncomproblemsugly-number-iicomments\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/ugly-number-ii/comments/\"\u003e264 丑数 II\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e求第 n 个丑数。\u003c/p\u003e\n\u003cp\u003e用一个数组 ugly 来保存前 m 个丑数，用三个质因数 2，3，5 乘以其当前系数对应的丑数，得到新的丑数，最小的一个就是第 m + 1 个丑数。时间复杂度是 O(m * n)，其中 m 是质因数的个数，n 是要找的第 n 个丑数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSolution\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e nthUglyNumber(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e ugly(n, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e base_2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, base_3 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, base_5 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e INT_MAX;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            ugly[i] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e min({\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ugly[base_2], \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ugly[base_3], \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ugly[base_5]});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ugly[base_2] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e ugly[i])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ebase_2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ugly[base_3] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e ugly[i])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ebase_3;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ugly[base_5] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e ugly[i])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ebase_5;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e ugly[i] \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e ugly[n \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"313-超级丑数httpsleetcode-cncomproblemssuper-ugly-number\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/super-ugly-number/\"\u003e313 超级丑数\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e给定质因数数组 primes，求第 n 个丑数。\u003c/p\u003e","title":"LeetCode 动态规划（1）"},{"content":"LeetCode 二分查找 二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。\n易错点 计算中间值的方法\nk = i + (j - i) / 2 k = (i + j) / 2 第二种方法一般都会造成整型数据溢出，所以只用第一种方法。\n循环条件\n如果要找唯一的值，且下限i和上限j都会在更新时在中间值k的基础上+1或-1，那么循环条件是 i \u0026lt;= j，j能被取到，j = nums.size() - 1，计算中间值用 k = i + (j - i + 1) / 2\n如果要找大于等于或小于等于某条件的值，且下限i和上限j其中之一不会在k的基础上+1或-1，那么循环条件是 i \u0026lt; j，j不能被取到，j = nums.size()，计算中间值用 k = i + (j - i) / 2\n两种方法有各自的应用场景，没用对的话会出现边界值的问题，或是死循环导致TLE。\n题目 1. 查找数 704 二分查找 在有序数组中搜索目标值，如果存在则返回下标，否则返回 -1。\n最标准的二分查找。因为下限i和上限j都会在更新时+1和-1，所以让j = nums.size() - 1，循环条件是 i \u0026lt;= j。\nclass Solution { public: int search(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int i = 0, j = nums.size() - 1, k = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; if (nums[k] \u0026gt; target) j = k - 1; else if (nums[k] \u0026lt; target) i = k + 1; else return k; } return -1; } }; 374 猜数字大小 从 1 到 n 选择一个数字，通过一个预定义的接口 guess(int num)得到-1：数字打了；1：数字小了；0：猜对了。\n跟上一题几乎一模一样，只是把target换成了一个接口。\nint guess(int num); class Solution { public: int guessNumber(int n) { int i = 1, j = n, k = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; auto res = guess(k); if (res == 1) i = k + 1; else if (res == -1) j = k - 1; else return k; } return 0; } }; 367 有效的完全平方数 判断一个正整数是否是一个完全平方数。\n判断一个数是否是完全平方数。因为在二分的过程中平方得到的结果可能会超过32位int型的上限，所以用long long。\nclass Solution { public: bool isPerfectSquare(int num) { long long i = 0, j = num, k = 0, res = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; res = k * k; if (res \u0026lt; num) i = k + 1; else if (res \u0026gt; num) j = k - 1; else return true; } return j * j == num; } }; 69 x的平方根 计算一个数的平方根，只保留整数部分。\n实现int sqrt(int x)函数。用商来判断比用乘积来判断更直观。\nclass Solution { public: int mySqrt(int x) { if (x \u0026lt;= 1) return x; int i = 1, j = x, k = 0, sqrt = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; sqrt = x / k; if (sqrt \u0026lt; k) j = k - 1; else if (sqrt \u0026gt; k) i = k + 1; else return k; } return j; } }; 2. 查找上界/下界 35 搜索插入位置 在有序数组中找到目标值，如果不存在则返回它将会被按顺序插入的位置，数组中无重复元素。\n找到大于等于target的第一个数。因为上限j在更新时会直接被赋给k的值，所以让j = nums.size()，循环条件是i \u0026lt; j。\nclass Solution { public: int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int i = 0, j = nums.size(), k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; if (nums[k] \u0026lt; target) i = k + 1; else if (nums[k] \u0026gt; target) j = k; else return k; } return j; } }; 744 寻找比目标字母大的最小字母 在有序数组中找到比目标字母大的最小字母，数组里的字母是循环的。\n找到大于target的第一个数，相比于上一题只是少了在循环内判断是否等于的情况。从int类型数组变成了char类型数组，不过这一点并没有任何影响。\nclass Solution { public: char nextGreatestLetter(vector\u0026lt;char\u0026gt;\u0026amp; letters, char target) { int n = letters.size(), i = 0, j = n, k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; if (letters[k] \u0026lt;= target) i = k + 1; else if (letters[k] \u0026gt; target) j = k; } return j \u0026lt; n ? letters[j] : letters[0]; } }; 278 第一个错误的版本 产品都是基于之前的版本开发的，所有错误的版本之后的所有版本都是错的，找到出错的第一个版本。通过一个接口 bool isBadVersion(version) 来判断版本是否出错。\n很标准的找下界。\nbool isBadVersion(int version); class Solution { public: int firstBadVersion(long long n) { long long i = 0, j = n + 1, k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; if (!isBadVersion(k)) i = k + 1; else j = k; } return j; } }; 875 爱吃香蕉的珂珂 有 N 堆香蕉，每小时内吃完一堆则不吃另外一堆，计算能在 H 小时内吃完的最慢速度。\n将速度作为二分查找的变量，每次判断以当前速度是否能吃完所有香蕉，如果能则 j = k，k 有可能是最后的结果，否则 i = k + 1，此时的 k 一定比结果小。\nclass Solution { public: int minEatingSpeed(vector\u0026lt;int\u0026gt;\u0026amp; piles, int H) { int i = 1, j = INT_MAX, k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; int res = CanEatAll(k, H, piles); if (res) j = k; else i = k + 1; } return j; } bool CanEatAll(const int \u0026amp;speed, int hour, vector\u0026lt;int\u0026gt;\u0026amp; piles) { for (auto \u0026amp;p:piles) hour -= p / speed + (p % speed \u0026gt; 0); return hour \u0026gt;= 0; } }; 3. 根据位置关系查找 378 有序矩阵中第K小的元素 n x n 的矩阵中每行和每列均按升序排序，找到矩阵中第k小的元素。\n这道题可以用跟剑指offer里二维数组中的查找这道题的思路结合二分查找来做，二分的时候每次计算矩阵里小于等于中间值的数的个数就能得到结果了。时间复杂度是 O(logm * n)，m 是 matrix[n - 1][n - 1]，n 是 matrix.size()。\nclass Solution { public: int kthSmallest(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int m) { int n = matrix.size(), i = matrix[0][0], j = matrix[n - 1][n - 1] + 1, k = 0; while (i \u0026lt; j) { k = i + (j - i) / 2; auto res = CountLess(matrix, k); if (res \u0026lt; m) i = k + 1; else j = k; } return i; } int CountLess(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, const int \u0026amp;target) { int n = matrix.size(), i = 0, j = n - 1, res = 0; while (i \u0026lt; n \u0026amp;\u0026amp; j \u0026gt;= 0) { if (matrix[i][j] \u0026lt;= target) res += j + 1, ++i; else --j; } return res; } }; 153 寻找旋转排序数组中的最小值 一个有序数组在某个点上进行了旋转，找出其中最小的元素。\n根据中间值与左右边值和其左右边一位的大小关系来判断，如果中间值k比左边值小，那么k有可能是结果，让 j = k ；否则比较中间值与其右边一位，如果中间值大于右边一位的值，那么右边一位的值就是结果，否则让 i = k + 1。\nclass Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), i = 0, j = nums.size(), k = 0; if (n == 1 || nums[0] \u0026lt; nums[n - 1]) return nums[0]; else if (n == 2) return min(nums[0], nums[1]); while (i \u0026lt; j) { k = i + (j - i) / 2; if (nums[i] \u0026gt; nums[k]) j = k; else if (k + 1 \u0026lt; j \u0026amp;\u0026amp; nums[k + 1] \u0026gt; nums[i]) i = k + 1; else return nums[k + 1]; } return j \u0026gt;= n ? nums[i] : min(nums[i], nums[j]); } }; 540 有序数组中的单一元素 一个有序数组中每个元素都会出现了两次，只有一个数出现了一次，找出这个数。\n有序数组里其他每个元素都出现两次，找到唯一只出现一次的数。在唯一的数出现之后奇偶位的相等关系会发生变化，利用这一点来做判断。比较直观的写法是分别判断 k % 2 == 0 和 k % 2 == 1 的情况，这样写起来比较复杂，可以直接在 k % 2 == 1 的时候 \u0026ndash;k，再直接判断 nums[k] 和 nums[k + 1] 的关系。\nclass Solution { public: int singleNonDuplicate(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0, j = nums.size() - 1, k = 0, n = nums.size(); while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; endl; if (k % 2 == 0) { if (k + 1 \u0026lt; n \u0026amp;\u0026amp; nums[k] == nums[k + 1]) i = k + 1; else if (k - 1 \u0026gt;= 0 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) j = k - 1; else return nums[k]; } else { if (k + 1 \u0026lt; n \u0026amp;\u0026amp; nums[k] == nums[k + 1]) j = k - 1; else if (k - 1 \u0026gt;= 0 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) i = k + 1; else return nums[k]; } } return 0; } }; class Solution { public: int singleNonDuplicate(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0, j = nums.size(), k = 0, n = nums.size(); while (i \u0026lt; j) { k = i + (j - i) / 2; if (k % 2 == 1) --k; if (k + 1 \u0026lt; n \u0026amp;\u0026amp; nums[k] == nums[k + 1]) i = k + 2; else j = k; } return nums[j]; } }; 4. 综合 1095 山脉数组中查找目标值 在一个山脉数组中找到等于目标值的最小下标。\n因为已知数组一定是一个山脉数组，所以一定有唯一的山顶，用二分查找找到山顶的下标。如果山顶小于目标值那么数组中一定没有目标值存在，返回 -1，否则在山顶左边使用二分查找找目标值，没有的话则在山顶右边使用二分查找找目标值。\nclass Solution { public: int findInMountainArray(int target, MountainArray \u0026amp;mountainArr) { int n = mountainArr.length(), i = 0, j = n - 1, k = 0, peak = 0; while (i \u0026lt;= j) { k = i + (j - i + 1) / 2; if (mountainArr.get(k) \u0026gt; mountainArr.get(k - 1) \u0026amp;\u0026amp; mountainArr.get(k) \u0026gt; mountainArr.get(k + 1)) break; else if (mountainArr.get(k) \u0026lt; mountainArr.get(k - 1)) j = k - 1; else i = k + 1; } if (mountainArr.get(k) \u0026lt; target) return -1; else if (mountainArr.get(k) == target) return k; peak = k; i = 0, j = peak; while (i \u0026lt; j) { k = i + (j - i) / 2; if (mountainArr.get(k) \u0026lt; target) i = k + 1; else j = k; } if (mountainArr.get(j) == target) return j; i = peak + 1, j = n; while (i \u0026lt; j) { k = i + (j - i) / 2; if (mountainArr.get(k) \u0026lt; target) j = k - 1; else if (mountainArr.get(k) \u0026gt; target) i = k + 1; else j = k; } if (i \u0026lt; n \u0026amp;\u0026amp; mountainArr.get(i) == target) return i; return -1; } }; 5. 猜数 719 找出第 k 小的距离对 最简单的做法遍历两遍算出所有数对的差值保存在一个小根堆中，然后依次找到小于等于 k 的最小距离，但这样做时间复杂度是 O(n ^ 2) 会超时。我们可以先将数组排序，然后用 low = 0, high = nums[n - 1] - nums[0] 表示可能结果的最小值和最大值，用二分法来判断中间值 mid 是否满足小于等于 mid 的数对差值的数是否小于等于 k，判断时因为数组是有序的，可以使用双指针让中间的差值维持在小于等于 mid，从而计算出小于等于 mid 的数对差值的数，时间复杂度是 O(nlogn + nlogm)，其中 n 是数组的长度，m 是数组最大值与最小值之差，nlogn 是排序的平均时间复杂度，而 nlogm 中 n 是使用双指针判断的时间复杂度，logm 是二分法的时间复杂度。\nclass Solution { public: int smallestDistancePair(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { sort(nums.begin(), nums.end()); int n = nums.size(), low = 0, high = nums[n - 1] - nums[0], mid = 0; while (low \u0026lt; high) { mid = low + (high - low) / 2; if (IsDistMoreThanK(nums, mid, k)) high = mid; else low = mid + 1; } return high; } bool IsDistMoreThanK(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int m, const int \u0026amp;k) { int left = 0, right = 0, count = 0; while (right \u0026lt; nums.size()) { while (nums[right] - nums[left] \u0026gt; m) ++left; count += right - left; ++right; } return count \u0026gt;= k; } }; ","permalink":"https://prov1dence.top/posts/leetcode/binarysearch/","summary":"\u003ch1 id=\"leetcode-二分查找httpsleetcode-cncomtagbinary-search\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/binary-search/\"\u003eLeetCode 二分查找\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。\u003c/p\u003e\n\u003ch2 id=\"易错点\"\u003e易错点\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e计算中间值的方法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ek = i + (j - i) / 2\u003c/li\u003e\n\u003cli\u003ek = (i + j) / 2\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e第二种方法一般都会造成整型数据溢出，所以只用第一种方法。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e循环条件\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e如果要找唯一的值，且下限i和上限j都会在更新时在中间值k的基础上+1或-1，那么循环条件是 i \u0026lt;= j，j能被取到，j = nums.size() - 1，计算中间值用 k = i + (j - i + 1) / 2\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e如果要找大于等于或小于等于某条件的值，且下限i和上限j其中之一不会在k的基础上+1或-1，那么循环条件是 i \u0026lt; j，j不能被取到，j = nums.size()，计算中间值用 k = i + (j - i) / 2\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e两种方法有各自的应用场景，没用对的话会出现边界值的问题，或是死循环导致TLE。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"1-查找数\"\u003e1. 查找数\u003c/h3\u003e\n\u003ch4 id=\"704-二分查找httpsleetcode-cncomproblemsbinary-search\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/binary-search/\"\u003e704 二分查找\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e在有序数组中搜索目标值，如果存在则返回下标，否则返回 -1。\u003c/p\u003e\n\u003cp\u003e最标准的二分查找。因为下限i和上限j都会在更新时+1和-1，所以让j = nums.size() - 1，循环条件是 i \u0026lt;= j。\u003c/p\u003e","title":"LeetCode 二分查找"},{"content":"LeetCode 位运算 位运算包括：\n与 \u0026amp; 或 | 异或 ^ 取反 ~ 左移 \u0026laquo; 右移 \u0026raquo; 技巧 移位运算\nx \u0026laquo; 1：算数左移 数字的二进制表示的所有位向左移动一位，相当于乘以 2 在右边补 0 x \u0026raquo; 1：算数右移 数字的二进制表示的所有位向右移动一位，相当于除以 2 在左边补符号位，即正数补 0，负数（在补码的基础上）补 1 负数移位 负数是以补码的形式存储的，负数进行右移运算时需要将其取反转换成反码，加一转换成补码，再将其向右移动一位得到新的补码，再将其减一得到新的反码，再取反转换成原码才能得到结果。例如 -7 的二进制表示是 10000111（因为 32 位太长所以这里用 8 位 int 型表示），其反码是 11111000，补码是11111001，向右移动一位是 11111100，减一得到新的反码 11111011，原码是10000100，也就是 -4；补码向左移一位是 11110010，减一得到新的反码 11110001，原码是 10001110，也就是 -14 比较简单的理解方式是左移乘以 2，右移除以 2。例如 -7 \u0026raquo; 1 = -7 / 2 = -4，-7 \u0026laquo; 1 = -14 题目 1. 单个数字 693 交替位二进制数 检查一个二进制数相邻的两个位数是否均不相等。\n逐位 \u0026amp; 1 进行判断即可。\nclass Solution { public: bool hasAlternatingBits(int n) { bool rel = n \u0026amp; 1; while (n \u0026gt; 0 \u0026amp;\u0026amp; (n \u0026amp; 1) == rel) { rel = !rel; n \u0026gt;\u0026gt;= 1; } return n \u0026lt;= 0; } }; 476 数字的补数 给一个正整数，求二进制表示取反的结果，取反不包括前导 0。\n对每一位异或 1 即可。将大于 num 的第一个 2 ^ n 的数减一即可得到二进制表示全是 1 的，位数等于 num 的位数的数。\nclass Solution { public: int findComplement(int num) { long long util = 1; while (util \u0026lt;= num) util \u0026lt;\u0026lt;= 1; return num ^ (util - 1); } }; 461 汉明距离 计算两个整数的二进制表示在各位上不同的数目。\n逐位进行异或判断即可。\nclass Solution { public: int hammingDistance(int x, int y) { int res = 0; while (x \u0026gt; 0 || y \u0026gt; 0) { res += ((x \u0026amp; 1) ^ (y \u0026amp; 1)); x \u0026gt;\u0026gt;= 1, y \u0026gt;\u0026gt;= 1; } return res; } }; 762 二进制表示中质数个计算置位 计算 [L, R] 中置位位数为质数的个数。\n先逐位判断数 i 在当前位上是否等一 1，得到置位位数后判断是否是质数。判断质数的时候可以先排除掉模以 6 等于 0, 2, 3, 4 的情况，因为这几种情况分别可以被 6, 2, 3, 2 整除，剩下的再判断其模以 6n - 1 和 6n + 1 是否等于 0 即可。还可以先把小于等于 32 的质数存储在哈希表或数组中，这样的话查询时间会降低一些。时间复杂度是 O(n)，n 是 [L, R] 的个数。\nclass Solution { public: int countPrimeSetBits(int L, int R) { int res = 0; for (int i = L; i \u0026lt;= R; ++i) { int m = i; int cnt = 0; while (m \u0026gt; 0) { if (m \u0026amp; 1) ++cnt; m \u0026gt;\u0026gt;= 1; } if (IsPrime(cnt)) ++res; } return res; } bool IsPrime(int num) { if (num \u0026lt; 4) return num \u0026gt; 1; else if (num % 6 != 1 \u0026amp;\u0026amp; num % 6 != 5) return false; for (int i = 5; i \u0026lt;= sqrt(num); i += 6) if (num % i == 0 || num % (i + 2) == 0) return false; return true; } }; 136 只出现一次的数字 给一个数组，其他数都出现了两次，只有一个数出现了一次，找到这个数。\n因为 a ^ a = 0，所以可以用 0 异或这个数组中的所有数，最后得到的就是唯一的一个数。\nclass Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = 0; for (auto \u0026amp;m:nums) res ^= m; return res; } }; ","permalink":"https://prov1dence.top/posts/leetcode/bitmanipulation/","summary":"\u003ch1 id=\"leetcode-位运算httpsleetcode-cncomtagbit-manipulation\"\u003e\u003ca href=\"https://leetcode-cn.com/tag/bit-manipulation/\"\u003eLeetCode 位运算\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e位运算包括：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e与 \u0026amp;\u003c/li\u003e\n\u003cli\u003e或 |\u003c/li\u003e\n\u003cli\u003e异或 ^\u003c/li\u003e\n\u003cli\u003e取反 ~\u003c/li\u003e\n\u003cli\u003e左移 \u0026laquo;\u003c/li\u003e\n\u003cli\u003e右移 \u0026raquo;\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"技巧\"\u003e技巧\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e移位运算\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ex \u0026laquo; 1：算数左移\n\u003cul\u003e\n\u003cli\u003e数字的二进制表示的所有位向左移动一位，相当于乘以 2\u003c/li\u003e\n\u003cli\u003e在右边补 0\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ex \u0026raquo; 1：算数右移\n\u003cul\u003e\n\u003cli\u003e数字的二进制表示的所有位向右移动一位，相当于除以 2\u003c/li\u003e\n\u003cli\u003e在左边补符号位，即正数补 0，负数（在补码的基础上）补 1\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e负数移位\n\u003cul\u003e\n\u003cli\u003e负数是以补码的形式存储的，负数进行右移运算时需要将其取反转换成反码，加一转换成补码，再将其向右移动一位得到新的补码，再将其减一得到新的反码，再取反转换成原码才能得到结果。例如 -7 的二进制表示是 10000111（因为 32 位太长所以这里用 8 位 int 型表示），其反码是 11111000，补码是11111001，向右移动一位是 11111100，减一得到新的反码 11111011，原码是10000100，也就是 -4；补码向左移一位是 11110010，减一得到新的反码 11110001，原码是 10001110，也就是 -14\u003c/li\u003e\n\u003cli\u003e比较简单的理解方式是左移乘以 2，右移除以 2。例如 -7 \u0026raquo; 1 = -7 / 2 = -4，-7 \u0026laquo; 1 = -14\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003ch3 id=\"1-单个数字\"\u003e1. 单个数字\u003c/h3\u003e\n\u003ch4 id=\"693-交替位二进制数httpsleetcode-cncomproblemsbinary-number-with-alternating-bits\"\u003e\u003ca href=\"https://leetcode-cn.com/problems/binary-number-with-alternating-bits/\"\u003e693 交替位二进制数\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e检查一个二进制数相邻的两个位数是否均不相等。\u003c/p\u003e","title":"LeetCode 位运算"},{"content":"Kick Start 2019 Round C Wiggle Walk (6pts, 12pts) 在一个R * C的矩阵里面移动，遇到已经走过的格子直接跳过。数据保证移动时不会超出给定的矩阵。\nSolution: Simulation 用一个visited数组记录已经走过的格子，遇到走过的格子则直接跳过往后遍历。讲道理这个方法时间复杂度是过不了Hidden Test Set的，但是我也不知道为什么就过了。\n时间复杂度：O(n^2) 空间复杂度：O(n^2) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(50001, vector\u0026lt;bool\u0026gt;(50001, false)); void Forward(char \u0026amp;p, int \u0026amp;r, int \u0026amp;c) { if (p == \u0026#39;E\u0026#39;) { while (visited[r][c + 1]) ++c; visited[r][++c] = true; } else if (p == \u0026#39;W\u0026#39;) { while (visited[r][c - 1]) --c; visited[r][--c] = true; } else if (p == \u0026#39;N\u0026#39;) { while (visited[r - 1][c]) --r; visited[--r][c] = true; } else if (p == \u0026#39;S\u0026#39;) { while (visited[r + 1][c]) ++r; visited[++r][c] = true; } } void solve(const int \u0026amp;t) { int n, R, C, r, c; string str; scanf(\u0026#34;%d %d %d %d %d\u0026#34;, \u0026amp;n, \u0026amp;R, \u0026amp;C, \u0026amp;r, \u0026amp;c); cin \u0026gt;\u0026gt; str; visited = vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(50001, vector\u0026lt;bool\u0026gt;(50001, false)); visited[r][c] = true; for (int i = 0; i \u0026lt; n; ++i) Forward(str[i], r, c); printf(\u0026#34;Case #%d: %d %d\\n\u0026#34;, t, r, c); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) solve(t); return 0; } Circuit Board (14pts, 20pts) 在矩阵里找到每一行最大值与最小值不超过K的最大子矩阵。\nSolution: Dynamic Programming 定义一个矩阵len[r][c]来保存格子r, c在r行上符合条件的最长数组。因为题目要求是需要保证每一行的最大值与最小值不超过K，行与行之间是没有关系的，所以对于每一个格子，遍历该列上的所有格子，找到这些格子能够到达的最远的位置，取最小值，用当前的高度乘最远位置就能得到答案。\n时间复杂度：O(RRC) 空间复杂度：O(RC) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; void solve(const int \u0026amp;t) { int R, C, K; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;R, \u0026amp;C, \u0026amp;K); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; len(301, vector\u0026lt;int\u0026gt;(301, 1)), matrix(301, vector\u0026lt;int\u0026gt;(301)); for (int r = 0; r \u0026lt; R; ++r) for (int c = 0; c \u0026lt; C; ++c) scanf(\u0026#34;%d\u0026#34;, \u0026amp;matrix[r][c]); for (int r = 0; r \u0026lt; R; ++r) { for (int c = 0; c \u0026lt; C; ++c) { int i = c - 1, current_max = matrix[r][c], current_min = matrix[r][c]; while (i \u0026gt;= 0) { current_max = max(current_max, matrix[r][i]); current_min = min(current_min, matrix[r][i]); if (current_max - current_min \u0026gt; K) break; --i; } len[r][c] = c - i; } } int res = 1; for (int r = 0; r \u0026lt; R; ++r) { for (int c = 0; c \u0026lt; C; ++c) { int min_c = len[r][c]; for (int line = r; line \u0026gt;= 0; --line) { min_c = min(min_c, len[line][c]); res = max(res, min_c * (r - line + 1)); } } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, t, res); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) solve(t); return 0; } Catch Some (18pts, 30pts) // TODO\n","permalink":"https://prov1dence.top/posts/kick-start/2019-round-c/","summary":"\u003ch1 id=\"kick-start-2019-round-chttpscodingcompetitionswithgooglecomkickstartround0000000000050ff2\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ff2\"\u003eKick Start 2019 Round C\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"wiggle-walk-6pts-12ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050ff20000000000150aac\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ff2/0000000000150aac\"\u003eWiggle Walk (6pts, 12pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e在一个R * C的矩阵里面移动，遇到已经走过的格子直接跳过。数据保证移动时不会超出给定的矩阵。\u003c/p\u003e\n\u003ch3 id=\"solution-simulation\"\u003eSolution: Simulation\u003c/h3\u003e\n\u003cp\u003e用一个visited数组记录已经走过的格子，遇到走过的格子则直接跳过往后遍历。讲道理这个方法时间复杂度是过不了Hidden Test Set的，但是我也不知道为什么就过了。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e时间复杂度：O(n^2)\u003c/li\u003e\n\u003cli\u003e空间复杂度：O(n^2)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// C++\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;cstdio\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;math.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;limits\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stack\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;queue\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eusing\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enamespace\u003c/span\u003e std;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e visited(\u003cspan style=\"color:#ae81ff\"\u003e50001\u003c/span\u003e, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e50001\u003c/span\u003e, false));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eForward\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ep, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003er, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ec) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (p \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;E\u0026#39;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (visited[r][c \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ec;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        visited[r][\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ec] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    } \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (p \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;W\u0026#39;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (visited[r][c \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003ec;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        visited[r][\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003ec] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    } \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (p \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;N\u0026#39;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (visited[r \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e][c])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003er;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        visited[\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003er][c] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    } \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (p \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;S\u0026#39;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (visited[r \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e][c])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003er;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        visited[\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003er][c] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esolve\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003et) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n, R, C, r, c;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    string str;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    scanf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d %d %d %d %d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003en, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eR, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eC, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003er, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ec);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e str;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    visited \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e50001\u003c/span\u003e, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e50001\u003c/span\u003e, false));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    visited[r][c] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Forward(str[i], r, c);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Case #%d: %d %d\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, t, r, c);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e T;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    scanf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eT);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e t \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; t \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e T; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003et)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        solve(t);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"circuit-board-14pts-20ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050ff20000000000150aae\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ff2/0000000000150aae\"\u003eCircuit Board (14pts, 20pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e在矩阵里找到每一行最大值与最小值不超过K的最大子矩阵。\u003c/p\u003e","title":"Kick Start 2019 Round C"},{"content":"Object Detection Object detection deals with detecting instances of objects of a certain class, such as humans, animals, etc, in digital images and videos. Object detection has applications in many areas of computer vision, including image retrieval, face detection, video surveillance, and self-driving, etc. Current detection systems repurpose classifiers to perform detection. To detect an object, these systems take a classifier for that object and evaluate it at various locations and scales in a test image.\nObject detection has made important progress in recent years. Mainstream algorithms are divided into two types: (1) two-stage detectors, such as R-CNN algorithm. The main idea is to adopt the heuristic method (selective search) first, or regional proposal network (RPN) to generate a series of sparse candidate boxes, and then classifies and returns these candidate boxes. This kind of approach needs two shots to detect objects, one for generating region proposals, one for detecting the object of each proposal. Such models reach the highest accuracy rate, but are typically slower; (2) single-stage detectors, such as YOLO (You Only Look Once) and SSD (Single Shot MultiBox Detector), that treat object detection as a simple regression problem by taking an input image and learning the class probabilities and bounding box coordinates. The main idea is to uniformly sample at different positions of the image. Different scales and aspect ratios can be used for sampling. Then, using convolutional neural networks to extract features and directly classify and return, the whole process only needs a single step, so its advantage is Fast. But an important disadvantage of uniform sampling is that the training is difficult, mainly because the positive and negative samples are extremely unbalanced, resulting in slightly lower model accuracy.\n![](https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Deep-Learning/YOLOv3 Inference Time.png)\nYOLO Sliding Window Image detection is harder than image recognition because, in image detection, there can be multiple objects, or even maybe even multiple objects of different categories within a single image. At this time, sliding windows can help. We define a window of some size and put the window over a region on the image. Then feeding the input region to the convolutional neural network model to get an output. Likewise, we repeat this process on each and every region of the image with a certain stride. Once done, we take a window of other sizes (longer, wider, etc) and slide the window over the image, and repeat this process again and again. We may probably end up with a window of the size of a snake in the image and seeing the model to output a breed for that window, meaning we detect a snake in that particular region.\nBounding Box One of the disadvantages of sliding windows is the computational cost. As we crop out many square regions in the image, we run each region on a model independently. We may think of using a bigger window as it will reduce computation but, as a cost, the accuracy will decrease dramatically. Bounding boxes are the boxes that enclose the object in an image. The idea of bounding boxes is to divide the image into grids and then for each grid we define our Y label with some arguments. P is the probability that there is an object in the grid cell. If P equals to 0, then the other arguments are all ignored. Bx, By, Bh, Bw are respectively the x coordinate, the y coordinate, the height, the width of the bounding box. C1, C2\u0026hellip; Cn refers to the class probability that the object is of a specific class. The number of classes may vary, depending on whether it’s a Binary Classification or Multi-Class Classification. If a grid contains an object, i.e. P equals to 1, then we know there is an object in a certain region of the image. Now there are some issues we should consider, including how big is the size of the grid, which grid among all the girds whose P equals to 1 is responsible for outputting a bounding box for the object that span over multiple grids, etc. Usually, in practice 19 by 19 grid is used and the grid responsible for outputting the Bounding-Box for a particular object is the grid that contains the mid-point of the object. And, one more advantage of using 19 by 19 grid is that the chance of mid-point of the object appearing in two grid cells is smaller.\nIntersection Over Union IOU means to divide the intersection of the bounding box and the true rectangle edge of the object by the union of them. The concept of intersection over union comes in to determine how accurate are these predictions. Suppose there are multiple bounding boxes an object in some grids, what intersection over union tells us is how close our prediction is to the ground truth. Then if the result is high enough (namely, greater than equal to a certain threshold) then the prediction is considered to be correct else we need to work on other bounding boxes.\nNon-Max Suppression After doing intersection over union, for a prediction of a single object which spans over multiple grids, each grid would output its own prediction with a probability score, but it can make the predictions messy because there are multiple bounding boxes for a single object. What we do is, out of all the bounding boxes, we choose the box with the highest probability, and discard all the other boxes with a lower probability than the highest one. This is called non-max suppression.\nAnchor Box The last problem is how to detect multiple objects in the same grid cell. It is easy to deal with. The idea is to define multiple bounding box prediction values, that is to have many probabilities, x and y coordinates, heights, widths, and class confidences in a single array to refer to the class probability of an object, and this is called anchor boxes.\n","permalink":"https://prov1dence.top/posts/deep-learning/object-detection-yolo/","summary":"\u003ch1 id=\"object-detection\"\u003eObject Detection\u003c/h1\u003e\n\u003cp\u003eObject detection deals with detecting instances of objects of a certain class, such as humans, animals, etc, in digital images and videos. Object detection has applications in many areas of computer vision, including image retrieval, face detection, video surveillance, and self-driving, etc. Current detection systems repurpose classifiers to perform detection. To detect an object, these systems take a classifier for that object and evaluate it at various locations and scales in a test image.\u003c/p\u003e","title":"Object Detection"},{"content":"Code Jam 2019 Round 1C Robot Programming Strategy (10pts, 18pts) 已知所有人石头剪刀布的出招顺序，每一轮同时和所有人比赛，找到必胜的策略。\nSolution: Eliminiating 每一轮遍历当前轮次所有人的出招，如果同时有三种情况（R, P, S）则没有必胜策略，直接输出IMPOSSIBLE；否则返回胜利或打平的策略。\n对于已经打败过的对手没有必要再考虑其之后的出招，所以用一个defeated数组保存已经打败过的对手以便直接跳过。因为当前轮次有可能超过对手的出招顺序长度，所以要用i % size获取对手当前的出招。\n时间复杂度：O(A ^ 2) 空间复杂度：O(A) #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; char Decide(const char \u0026amp;R, const char \u0026amp;P, const char \u0026amp;S) { if (R \u0026amp;\u0026amp; P \u0026amp;\u0026amp; S) return \u0026#39;X\u0026#39;; if (R \u0026amp;\u0026amp; P) return \u0026#39;P\u0026#39;; if (R \u0026amp;\u0026amp; S) return \u0026#39;R\u0026#39;; if (P \u0026amp;\u0026amp; S) return \u0026#39;S\u0026#39;; if (R) return \u0026#39;P\u0026#39;; if (P) return \u0026#39;S\u0026#39;; return \u0026#39;R\u0026#39;; } bool Defeate(const char \u0026amp;current, const char \u0026amp;opponent) { return (current == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; opponent == \u0026#39;S\u0026#39;) || (current == \u0026#39;S\u0026#39; \u0026amp;\u0026amp; opponent == \u0026#39;P\u0026#39;) || (current == \u0026#39;P\u0026#39; \u0026amp;\u0026amp; opponent == \u0026#39;R\u0026#39;); } void solve(const int \u0026amp;t) { int A; scanf(\u0026#34;%d\u0026#34;, \u0026amp;A); int i = 0; vector\u0026lt;string\u0026gt; opponent(A); vector\u0026lt;bool\u0026gt; defeated(A, false); bool R, P, S; string res; for (int a = 0; a \u0026lt; A; ++a) cin \u0026gt;\u0026gt; opponent[a]; while (true) { int current_opponent = 0; R = false, P = false, S = false; for (int a = 0; a \u0026lt; A; ++a) { if (!defeated[a]) { ++current_opponent; if (opponent[a][i % opponent[a].size()] == \u0026#39;R\u0026#39;) R = true; else if (opponent[a][i % opponent[a].size()] == \u0026#39;P\u0026#39;) P = true; else S = true; } } if (current_opponent == 0) break; char result = Decide(R, P, S); if (result == \u0026#39;X\u0026#39;) { res = \u0026#34;IMPOSSIBLE\u0026#34;; break; } res += result; for (int a = 0; a \u0026lt; A; ++a) { if (!defeated[a] \u0026amp;\u0026amp; Defeate(result, opponent[a][i % opponent[a].size()])) defeated[a] = true; } ++i; } printf(\u0026#34;Case #%d: %s\\n\u0026#34;, t, res.c_str()); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) solve(t); return 0; } Power Arrangers (11pts, 21pts) // TODO\nBacterial Tactics (15pts, 25pts) // TODO\n","permalink":"https://prov1dence.top/posts/code-jam/2019-round-1c/","summary":"\u003ch1 id=\"code-jam-2019-round-1chttpscodingcompetitionswithgooglecomcodejamround00000000000516b9\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/codejam/round/00000000000516b9\"\u003eCode Jam 2019 Round 1C\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"robot-programming-strategy-10pts-18ptshttpscodingcompetitionswithgooglecomcodejamround00000000000516b90000000000134c90\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/codejam/round/00000000000516b9/0000000000134c90\"\u003eRobot Programming Strategy (10pts, 18pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e已知所有人石头剪刀布的出招顺序，每一轮同时和所有人比赛，找到必胜的策略。\u003c/p\u003e\n\u003ch3 id=\"solution-eliminiating\"\u003eSolution: Eliminiating\u003c/h3\u003e\n\u003cp\u003e每一轮遍历当前轮次所有人的出招，如果同时有三种情况（R, P, S）则没有必胜策略，直接输出IMPOSSIBLE；否则返回胜利或打平的策略。\u003c/p\u003e\n\u003cp\u003e对于已经打败过的对手没有必要再考虑其之后的出招，所以用一个defeated数组保存已经打败过的对手以便直接跳过。因为当前轮次有可能超过对手的出招顺序长度，所以要用i % size获取对手当前的出招。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e时间复杂度：O(A ^ 2)\u003c/li\u003e\n\u003cli\u003e空间复杂度：O(A)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;cstdio\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;math.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;limits\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stack\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;queue\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eusing\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enamespace\u003c/span\u003e std;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDecide\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eR, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eP, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eS) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (R \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e P \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e S)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;X\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (R \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e P)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;P\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (R \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e S)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;R\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (P \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e S)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;S\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (R)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;P\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (P)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;S\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;R\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDefeate\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ecurrent, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eopponent) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (current \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;R\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e opponent \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;S\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e (current \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;S\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e opponent \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;P\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e||\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           (current \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;P\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e opponent \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;R\u0026#39;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esolve\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003et) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e A;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    scanf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eA);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003estring\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e opponent(A);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e defeated(A, false);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e R, P, S;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    string res;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; a \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e A; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ea)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e opponent[a];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (true) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e current_opponent \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        R \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e false, P \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e false, S \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e false;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; a \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e A; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ea) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003edefeated[a]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ecurrent_opponent;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (opponent[a][i \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e opponent[a].size()] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;R\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    R \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (opponent[a][i \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e opponent[a].size()] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;P\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    P \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    S \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (current_opponent \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Decide(R, P, S);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (result \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;X\u0026#39;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            res \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;IMPOSSIBLE\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        res \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e result;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; a \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e A; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ea) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003edefeated[a] \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e Defeate(result, opponent[a][i \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e opponent[a].size()]))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                defeated[a] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Case #%d: %s\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, t, res.c_str());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e T;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    scanf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eT);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e t \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; t \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e T; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003et)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        solve(t);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"power-arrangers-11pts-21ptshttpscodingcompetitionswithgooglecomcodejamround00000000000516b90000000000134e91\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/codejam/round/00000000000516b9/0000000000134e91\"\u003ePower Arrangers (11pts, 21pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e// TODO\u003c/p\u003e","title":"Code Jam 2019 Round 1C"},{"content":"Kick Start 2019 Round B Building Palindromes (5pts, 12pts) 判断给定区间内的子字符串是否是回文串。\nSolution: Prefix Sum 判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。\n时间复杂度：O(N) 空间复杂度：O(N) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { int N, Q, m, n, total = 0; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; string words; cin \u0026gt;\u0026gt; words; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; odds(N + 1, vector\u0026lt;int\u0026gt;(26)); for (int i = 1; i \u0026lt;= N; ++i) { for (int j = 0; j \u0026lt; 26; ++j) odds[i][j] = odds[i - 1][j]; ++odds[i][words[i - 1] - \u0026#39;A\u0026#39;]; } for (int q = 0; q \u0026lt; Q; ++q) { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; int odd = 0; for (int j = 0; j \u0026lt; 26; ++j) odd += ((odds[n][j] - odds[m - 1][j]) % 2 != 0); total += odd \u0026lt;= 1; } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, case_number, total); } return 0; } Energy Stones (17pts, 24pts) 在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于背包问题。\nSolution 1: Dynamic Programming (Visible Test Set) 对于Visible Test Set，吃掉每一件物品所消耗的seconds都是相同的，因此可以简化为一个单纯的背包问题。为了最大化获得的energy（最小化所有物品的总lost），应该先吃掉lost高的物品，所以按照lost排序。\n初始状态是dp[index][time] = 0，index = 0, time = 0。状态转移方程是\n如果当前物品还有剩余的energy则吃掉当前的物品 if (stones[index].energy \u0026gt; stones[index].lost * time) res = max(res, stones[index].energy - stones[index].lost * time + DP(index + 1, time + stones[index].seconds)); 不吃当前的物品 res = max(res, DP(index + 1, time)); 时间复杂度：O(N * (S * N)) 空间复杂度：O(N * (S * N)) //C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; struct Stone { int seconds; int energy; int lost; }; vector\u0026lt;Stone\u0026gt; stones; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; int N; int DP(int index, int time) { if (index \u0026gt;= N) return 0; int \u0026amp;res = dp[index][time]; if (res != -1) return res; if (stones[index].energy \u0026gt; stones[index].lost * time) res = max(res, stones[index].energy - stones[index].lost * time + DP(index + 1, time + stones[index].seconds)); res = max(res, DP(index + 1, time)); return res; } int solve(const int \u0026amp;T) { cin \u0026gt;\u0026gt; N; stones = vector\u0026lt;Stone\u0026gt;(N); for (int i = 0; i \u0026lt; N; ++i) cin \u0026gt;\u0026gt; stones[i].seconds \u0026gt;\u0026gt; stones[i].energy \u0026gt;\u0026gt; stones[i].lost; dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(N, vector\u0026lt;int\u0026gt;(stones[0].seconds * N, -1)); sort(stones.begin(), stones.end(), [](const Stone \u0026amp;s1, const Stone \u0026amp;s2) { return s1.lost \u0026gt; s2.lost; }); return DP(0, 0); } int main() { int T; cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; ++t) printf(\u0026#34;Case #%d: %d\\n\u0026#34;, t, solve(t)); return 0; } Solution 2: Dynamic Programming (Hidden Test Set) 对于Hidden Test Set，每一件物品消耗的时间并不相同，不能直接使用lost进行排序。对于每两件物品s1和s2，只要满足s1.lost * s2.seconds \u0026gt; s2.lost * s1.seconds就可以保证得到更小的总lost。同时dp数组的大小需要按照每个物品的耗时来计算。\n时间复杂度：O(N * (S * N)) 空间复杂度：O(N * (S * N)) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; struct Stone { int seconds; int energy; int lost; }; vector\u0026lt;Stone\u0026gt; stones; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; int N; void solve(const int \u0026amp;T) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); stones = vector\u0026lt;Stone\u0026gt;(N); int total_time = 0; for (int i = 0; i \u0026lt; N; ++i) { scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;stones[i].seconds, \u0026amp;stones[i].energy,\u0026amp;stones[i].lost); total_time += stones[i].seconds; } sort(stones.begin(), stones.end(), [](const Stone \u0026amp;s1, const Stone \u0026amp;s2) { return s1.lost * s2.seconds \u0026gt; s2.lost * s1.seconds; }); int res = 0; dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(N + 1, vector\u0026lt;int\u0026gt;(total_time + 1, -1)); for (int i = 1; i \u0026lt;= N; ++i) { dp[i - 1][0] = 0; for (int j = 0; j \u0026lt; stones[i - 1].seconds; ++j) dp[i][j] = dp[i - 1][j]; for (int j = stones[i - 1].seconds; j \u0026lt; dp[i - 1].size(); ++j) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i - 1].seconds] + stones[i - 1].energy - (j - stones[i - 1].seconds) * stones[i - 1].lost); res = max(res, dp[i][j]); } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, T, res); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int t = 1; t \u0026lt;= T; ++t) solve(t); return 0; } Diverse Subarray (14pts, 28pts) 给定最大值S，选取一段连续子数组，使得子数组中相同值的个数不超过S的总数最大化。\nSolution 1: Brute Force (Visible Test Set) Visible Test Set的数组长度N \u0026lt;= 1000，只需要两层循环做穷举，每次计算符合要求的总数。\n时间复杂度：O(N^2) 空间复杂度：O(N) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { int N, S, res = 0; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; vector\u0026lt;int\u0026gt; trinkets(N); for (int i = 0; i \u0026lt; N; ++i) cin \u0026gt;\u0026gt; trinkets[i]; for (int j = 0; j \u0026lt; N; ++j) { unordered_map\u0026lt;int, int\u0026gt; types; for (int i = j; i \u0026gt;= 0; --i) { ++types[trinkets[i]]; int total = 0; for (auto t:types) { if (t.second \u0026lt;= S) total += t.second; } res = max(res, total); } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, case_number, res); } return 0; } Solution 2: Segment Tree (Hidden Test Set) // TODO\n","permalink":"https://prov1dence.top/posts/kick-start/2019-round-b/","summary":"\u003ch1 id=\"kick-start-2019-round-bhttpscodingcompetitionswithgooglecomkickstartround0000000000050eda\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda\"\u003eKick Start 2019 Round B\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"building-palindromes-5pts-12ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda0000000000119866\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/0000000000119866\"\u003eBuilding Palindromes (5pts, 12pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e判断给定区间内的子字符串是否是回文串。\u003c/p\u003e\n\u003ch3 id=\"solution-prefix-sum\"\u003eSolution: Prefix Sum\u003c/h3\u003e\n\u003cp\u003e判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e时间复杂度：O(N)\u003c/li\u003e\n\u003cli\u003e空间复杂度：O(N)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// C++\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;cstdio\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;math.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;limits\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stack\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;queue\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eusing\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enamespace\u003c/span\u003e std;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e total_test_case_number;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e total_test_case_number;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e case_number \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; case_number \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e total_test_case_number; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ecase_number) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e N, Q, m, n, total \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e N \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e Q;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        string words;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e words;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e odds(N \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e26\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e N; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; j \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e26\u003c/span\u003e; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ej)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                odds[i][j] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e odds[i \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e][j];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003eodds[i][words[i \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;A\u0026#39;\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e q \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; q \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e Q; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003eq) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e odd \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; j \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e26\u003c/span\u003e; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ej)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                odd \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e ((odds[n][j] \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e odds[m \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e][j]) \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            total \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e odd \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Case #%d: %d\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, case_number, total);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"energy-stones-17pts-24ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda00000000001198c3\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/00000000001198c3\"\u003eEnergy Stones (17pts, 24pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于\u003ca href=\"https://zh.wikipedia.org/wiki/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\"\u003e背包问题\u003c/a\u003e。\u003c/p\u003e","title":"Kick Start 2019 Round B"},{"content":"Code Jam 2019 Round 1A Pylons (8pts, 23pts) 在m*n的网格里移动，每次移动后的位置不能与之前的位置在同一行/列/对角线上。\nSolution: BackTracking 类似于八皇后问题，不过每次的限制条件只和上一个位置有关，可以用回溯解决。\n时间复杂度：O(m^2 * n^2) 空间复杂度：O(m * n) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; int m, n; bool BackTracking(int t, int i, int j, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visited, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;res) { visited[i][j] = true; res[t] = {i, j}; if (t + 1 == m * n) return true; for (int x = 0; x \u0026lt; m; ++x) { for (int y = 0; y \u0026lt; n; ++y) { int r = (x + i) % m, c = (y + j) % n; if (!visited[r][c] \u0026amp;\u0026amp; r != i \u0026amp;\u0026amp; c != j \u0026amp;\u0026amp; r + c != i + j \u0026amp;\u0026amp; r - c != i - j \u0026amp;\u0026amp; BackTracking(t + 1, r, c, visited, res)) return true; } } visited[i][j] = false; return false; } int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { bool rev = false; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; if (m \u0026gt; n) { rev = true; swap(n, m); } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(m, vector\u0026lt;bool\u0026gt;(n, false)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(m * n, vector\u0026lt;int\u0026gt;()); printf(\u0026#34;Case #%d: \u0026#34;, case_number); if (BackTracking(0, 0, 0, visited, res)) { printf(\u0026#34;POSSIBLE\\n\u0026#34;); for (int i = 0; i \u0026lt; m * n; ++i) if (!rev) printf(\u0026#34;%d %d\\n\u0026#34;, res[i][0] + 1, res[i][1] + 1); else printf(\u0026#34;%d %d\\n\u0026#34;, res[i][1] + 1, res[i][0] + 1); } else printf(\u0026#34;IMPOSSIBLE\\n\u0026#34;); } return 0; } Alien Rhyme (10pts, 27pts) 找到后缀相同的一对单词，后缀的长度可以自己定义，其他单词的后缀不能与这一对相同，使得这样的单词对最多。\nSolution: Suffix 先翻转每一个单词（如果不翻转的话取substr的时候就从中间开始取到最后，翻转的话只需要取前面m个字母）。从最长的单词长度依次递减，取每一个单词的后缀，如果两个单词有相同的后缀则把这两个单词去掉，结果+2。因为是从最长的单词长度开始依次取后缀，可以保证后缀相同的单词不被漏掉。\n时间复杂度：O(N * m) m：最长的单词长度 N：单词个数 空间复杂度：O(N) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; #include \u0026#34;Print.h\u0026#34; using namespace std; int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { int N, sum = 0, max_len = 0; cin \u0026gt;\u0026gt; N; vector\u0026lt;string\u0026gt; words(N); for (int m = 0; m \u0026lt; N; ++m) { cin \u0026gt;\u0026gt; words[m]; max_len = max(max_len, static_cast\u0026lt;int\u0026gt;(words[m].size())); reverse(words[m].begin(), words[m].end()); } unordered_map\u0026lt;string, int\u0026gt; status; vector\u0026lt;bool\u0026gt; visited(N, false); int total = 0; for (int len = max_len; len \u0026gt; 0; --len) { for (int m = 0; m \u0026lt; N; ++m) { if (visited[m] || words[m].size() \u0026lt; len) continue; string str = words[m].substr(0, len); if (status.find(str) != status.end()) { if (status[str] != -1) { sum += 2; visited[status[str]] = true, visited[m] = true; status[str] = -1; } } else status[str] = m; } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, case_number, sum); } return 0; } Golf Gophers (11pts, 21pts) // TODO\n","permalink":"https://prov1dence.top/posts/code-jam/2019-round-1a/","summary":"\u003ch1 id=\"code-jam-2019-round-1ahttpscodingcompetitionswithgooglecomcodejamround0000000000051635\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051635\"\u003eCode Jam 2019 Round 1A\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"pylons-8pts-23ptshttpscodingcompetitionswithgooglecomcodejamround00000000000516350000000000104e03\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051635/0000000000104e03\"\u003ePylons (8pts, 23pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e在m*n的网格里移动，每次移动后的位置不能与之前的位置在同一行/列/对角线上。\u003c/p\u003e\n\u003ch3 id=\"solution-backtracking\"\u003eSolution: BackTracking\u003c/h3\u003e\n\u003cp\u003e类似于八皇后问题，不过每次的限制条件只和上一个位置有关，可以用回溯解决。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e时间复杂度：O(m^2 * n^2)\u003c/li\u003e\n\u003cli\u003e空间复杂度：O(m * n)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// C++\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;cstdio\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;math.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;limits\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stack\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;queue\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eusing\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enamespace\u003c/span\u003e std;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m, n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eBackTracking\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e t, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e j, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003evisited, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eres) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    visited[i][j] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    res[t] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {i, j};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (t \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; x \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e m; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ex) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e y \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; y \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ey) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e r \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (x \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e i) \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e m, c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (y \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e j) \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003evisited[r][c] \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e r \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e r \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e r \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e j \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                BackTracking(t \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, r, c, visited, res))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    visited[i][j] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e false;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e false;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e total_test_case_number;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e total_test_case_number;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e case_number \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; case_number \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e total_test_case_number; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ecase_number) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e rev \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e false;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (m \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e n) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            rev \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e true;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            swap(n, m);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e visited(m, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e(n, false));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e res(m \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e n, vector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Case #%d: \u0026#34;\u003c/span\u003e, case_number);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (BackTracking(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, visited, res)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;POSSIBLE\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e m \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e n; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003ei)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#f92672\"\u003e!\u003c/span\u003erev)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d %d\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, res[i][\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, res[i][\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%d %d\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e, res[i][\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, res[i][\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        } \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            printf(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;IMPOSSIBLE\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"alien-rhyme-10pts-27ptshttpscodingcompetitionswithgooglecomcodejamround00000000000516350000000000104e05\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051635/0000000000104e05\"\u003eAlien Rhyme (10pts, 27pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e找到后缀相同的一对单词，后缀的长度可以自己定义，其他单词的后缀不能与这一对相同，使得这样的单词对最多。\u003c/p\u003e","title":"Code Jam 2019 Round 1A"},{"content":"Code Jam 2019 Qualification Round Foregone Solution (6pts, 10pts, 1pts) 将一个带有数字4的数拆分为两个不带数字4的数。\nSolution: Construction 输入的数一定带有数字4，对于每一位上的数字4，我们可以将其拆分为2+2（或1+3）的两个数。输入数据最大是10的100次方，所以我们可以将其作为字符串处理。\n时间复杂度：O(n) 空间复杂度：O(1) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; ++t) { string N; cin \u0026gt;\u0026gt; N; string a, b; for (auto c:N) { a += c == \u0026#39;4\u0026#39; ? \u0026#39;2\u0026#39; : c; b += c == \u0026#39;4\u0026#39; ? \u0026#39;2\u0026#39; : \u0026#39;0\u0026#39;; } while (a[0] == \u0026#39;0\u0026#39;) a.erase(a.begin()); while (b[0] == \u0026#39;0\u0026#39;) b.erase(b.begin()); cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } } You Can Go Your Own Way (5pts, 9pts, 10pts) 在n*n的矩阵里从(0,0)走到(n-1,n-1)，只能向右或向下走。矩阵里有一条已有的路径，不能与该路径有重合。最常规的做法是DFS/BFS，时间复杂度为O(n^2)。\nSolution: Mirror 因为只有一条已知路径，我们可以将其以对角线作镜像，得到的新路径一定与原路径没有重合。\n时间复杂度：O(2 * n - 2) 空间复杂度：O(1) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; ++t) { int N; string str; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; str; for (int i = 0; i \u0026lt; N * 2 - 2; ++i) str[i] = str[i] == \u0026#39;E\u0026#39; ? \u0026#39;S\u0026#39; : \u0026#39;E\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } } Cryptopangrams (10pts, 15pts) 输入上限N和一个长为L的数组product，数组里的每一个数都是一个长为L+1的质数数组res里的相邻质数的乘积。质数数组里一共只有26个质数，返回将这26个质数排序后分别映射为A-Z的结果。对于比较小的N，可以把小于等于N的所有质数保存下来，计算出product[0]是哪两个质数的乘积，再计算出product[1]是哪两个质数的乘积，得到res[1]，再依次计算质数数组res里的其他数。在N比较大的时候时间和空间占用都会很高。\nSolution: Greatest Common Denominator 相较于先找到所有质数再找到product[0]是哪两个质数的乘积，我们可以使用小学学过的辗转相除法来求出这个质数，这样可以非常有效地降低时间和空间消耗。\n这道题测试用例的N最大值是10的100次方，用C++需要自己处理大数乘法（C++最大只支持128位的int型数）。\n时间复杂度：O(L) 空间复杂度：O(L) # Python 3 def GCD(a: int, b: int) -\u0026gt; int: if b == 0: return a return GCD(b, a % b) T = int(input()) for t in range(1, T + 1): N, L = map(int, input().split()) product = list(map(int, input().split())) res = [0 for _ in range(L + 1)] pos = -1 for i in range(L - 1): if product[i] != product[i + 1]: res[i + 1] = GCD(product[i], product[i + 1]) pos = i + 1 break for i in range(pos + 1, L + 1): res[i] = product[i - 1] // res[i - 1] for i in range(pos - 1, -1, -1): res[i] = product[i] // res[i + 1] match = [] for m in res: if m not in match: match.append(m) match.sort() ret = [chr(match.index(res[i]) + ord(\u0026#39;A\u0026#39;)) for i in range(len(res))] print(\u0026#34;Case #{t}: {str}\u0026#34;.format(t=t, str=\u0026#34;\u0026#34;.join(ret))) Dat Bae (14pts, 20pts) // TODO\n","permalink":"https://prov1dence.top/posts/code-jam/2019-qualification-round/","summary":"\u003ch1 id=\"code-jam-2019-qualification-roundhttpscodingcompetitionswithgooglecomcodejamround0000000000051705\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705\"\u003eCode Jam 2019 Qualification Round\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"foregone-solution-6pts-10pts-1ptshttpscodingcompetitionswithgooglecomcodejamround00000000000517050000000000088231\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/0000000000088231\"\u003eForegone Solution (6pts, 10pts, 1pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e将一个带有数字4的数拆分为两个不带数字4的数。\u003c/p\u003e\n\u003ch3 id=\"solution-construction\"\u003eSolution: Construction\u003c/h3\u003e\n\u003cp\u003e输入的数一定带有数字4，对于每一位上的数字4，我们可以将其拆分为2+2（或1+3）的两个数。输入数据最大是10的100次方，所以我们可以将其作为字符串处理。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e时间复杂度：O(n)\u003c/li\u003e\n\u003cli\u003e空间复杂度：O(1)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// C++\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;math.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;limits\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;stack\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;queue\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_map\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;unordered_set\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eusing\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enamespace\u003c/span\u003e std;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e T;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e T;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e t \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e; t \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e T; \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003et) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        string N;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e N;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        string a, b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e c:N) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            a \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;4\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;2\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e c;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            b \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;4\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;2\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;0\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (a[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;0\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            a.erase(a.begin());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ewhile\u003c/span\u003e (b[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;0\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            b.erase(b.begin());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        cout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Case #\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e t \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e b \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"you-can-go-your-own-way-5pts-9pts-10ptshttpscodingcompetitionswithgooglecomcodejamround000000000005170500000000000881da\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da\"\u003eYou Can Go Your Own Way (5pts, 9pts, 10pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e在n*n的矩阵里从(0,0)走到(n-1,n-1)，只能向右或向下走。矩阵里有一条已有的路径，不能与该路径有重合。最常规的做法是DFS/BFS，时间复杂度为O(n^2)。\u003c/p\u003e","title":"Code Jam 2019 Qualification Round"},{"content":"Kick Start 2019 Round A Training (7pts, 13pts) 一共有N个人，从中选P个人，计算这P个人中 skill rating 的最大值与其他人的 skill rating 的差值之和。\n$$ \\sum_{i}^{j} max(rating) - rating[i] $$\nSolution: Sort + Prefix Sum 先对数组排序，然后在长度为N的有序数组中遍历长为P的所有连续子数组，计算子数组中的最大值与其他值的差值之和。\n$$ \\sum_{i}^{j - 1} rating[j] - rating[i] $$\n如果直接遍历长为P的子数组会浪费很多时间，可以将上面的公式简化为如下。\n$$ \\sum_{i}^{j - 1} rating[j] - rating[i] = rating[j] * (j - 1 - i) - \\sum_{i}^{j - 1} rating[i] $$\n为了避免重复计算 $$ \\sum_{i}^{j - 1} rating[i] $$，可以用一个长为N+1的数组将原始数组的前缀和保存下来，这样每次直接计算 prefix[j] - prefix[i] 就能得到 $$ \\sum_{i}^{j - 1} rating[i] $$ 了，时间复杂度是O(N)。\n时间复杂度：O(NlogN) 空间复杂度：O(N) #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; int main() { int c = 1; int T; std::cin \u0026gt;\u0026gt; T; for (int t = 0; t \u0026lt; T; ++t) { int N, P; int min_hour = 1000000000; std::cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; P; std::vector\u0026lt;int\u0026gt; rating(N, 0); for (int n = 0; n \u0026lt; N; ++n) std::cin \u0026gt;\u0026gt; rating[n]; std::sort(rating.begin(), rating.end()); std::vector\u0026lt;int\u0026gt; prefix(N + 1, 0); for (int i = 0; i \u0026lt; N; ++i) prefix[i + 1] = prefix[i] + rating[i]; for (int i = P - 1; i \u0026lt; N; ++i) { int sum = rating[i] * (P - 1) - (prefix[i] - prefix[i - P + 1]); min_hour = std::max(0, std::min(min_hour, sum)); } std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(c) + \u0026#34;: \u0026#34; + std::to_string(min_hour) \u0026lt;\u0026lt; std::endl; ++c; } return 0; } Parcels (15pts, 20pts) 一道中等难度的BFS，DFS，二分查找的题。需要先计算出图中的曼哈顿距离，再找到一个最优的位置使得其他点离这些点的距离最短。\nSolution #1: Manhattan Distance 曼哈顿距离可以用公式 $$ |r1 - r2| + |c1 - c2| $$ 计算得出，因此可以直接使用两层循环来计算出曼哈顿距离。\n第一步对于每个已经存在的 delivery office，计算出其距离所有点的曼哈顿距离，得到此时的最大运输时间 max_time，时间复杂度是O(RC^2)；\n第二步依次遍历所有可能的点，计算出在该点添加 delivery office 后的图中的最大运输时间 curr_max_time，与 max_time 比较取最小值，时间复杂度是O(RC^2)。\n时间复杂度：O(RC^2) 空间复杂度：O(RC) #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;algorithm\u0026gt; int main() { int num_case = 1; int T; std::cin \u0026gt;\u0026gt; T; for (int t = 0; t \u0026lt; T; ++t) { int R, C; std::cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; grid(R, std::vector\u0026lt;int\u0026gt;(C, INT_MAX)); for (int i = 0; i \u0026lt; R; ++i) { std::string temp_in; std::cin \u0026gt;\u0026gt; temp_in; for (int j = 0; j \u0026lt; C; ++j) { char \u0026amp;temp = temp_in[j]; if (temp == \u0026#39;1\u0026#39;) { for (int x = 0; x \u0026lt; R; ++x) { for (int y = 0; y \u0026lt; C; ++y) { grid[x][y] = std::min(grid[x][y], abs(i - x) + abs(j - y)); } } } } } int max_time = 0; for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { max_time = std::max(max_time, grid[i][j]); } } if (max_time == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: 0\u0026#34; \u0026lt;\u0026lt; std::endl; ++num_case; continue; } for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { if (grid[i][j] != 0) { int curr_max_time = 0; for (int x = 0; x \u0026lt; R; ++x) { for (int y = 0; y \u0026lt; C; ++y) { curr_max_time = std::max(curr_max_time, std::min(grid[x][y], abs(i - x) + abs(j - y))); } } max_time = std::min(max_time, curr_max_time); } } } std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: \u0026#34; + std::to_string(max_time) \u0026lt;\u0026lt; std::endl; ++num_case; } return 0; } Solution #2: Breadth-First-Search 对于第一步来说，可以将所有已经存在的 delivery office 保存在一个队列中，然后使用BFS直接计算出最短的曼哈顿距离，得到此时的最大运输时间 max_time，时间复杂度是O(RC)；\n第二步与第一步类似，也可以通过BFS计算出在所有可能的点增加 delivery office 后的最大运输时间，时间复杂度是O(RC^2)。\n时间复杂度：O(RC^2) 空间复杂度：O(RC) #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;algorithm\u0026gt; int dir_x[4] = {-1, 0, 1, 0}; int dir_y[4] = {0, -1, 0, 1}; int BFS0(const int \u0026amp;R, const int \u0026amp;C, int x, int y, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;que) { int max_time = 0; int size = que.size(), degree = 1; while (!que.empty()) { x = que.front().first, y = que.front().second; que.pop(); max_time = std::max(max_time, grid[x][y]); for (int i = 0; i \u0026lt; 4; ++i) { int new_x = x + dir_x[i], new_y = y + dir_y[i]; if (new_x \u0026gt;= 0 \u0026amp;\u0026amp; new_x \u0026lt; R \u0026amp;\u0026amp; new_y \u0026gt;= 0 \u0026amp;\u0026amp; new_y \u0026lt; C \u0026amp;\u0026amp; grid[new_x][new_y] == -1) { que.push(std::pair\u0026lt;int, int\u0026gt;(new_x, new_y)); grid[new_x][new_y] = degree; } } --size; if (size == 0) { size = que.size(); ++degree; } } return max_time; } int BFS1(const int \u0026amp;R, const int \u0026amp;C, int x, int y, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;que) { std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; visited(R, std::vector\u0026lt;bool\u0026gt;(C, false)); visited[x][y] = true; int max_time = INT_MIN; int size = 1, degree = 0; while (!que.empty()) { x = que.front().first, y = que.front().second; que.pop(); max_time = std::max(max_time, std::min(grid[x][y], degree)); for (int i = 0; i \u0026lt; 4; ++i) { int new_x = x + dir_x[i], new_y = y + dir_y[i]; if (new_x \u0026gt;= 0 \u0026amp;\u0026amp; new_x \u0026lt; R \u0026amp;\u0026amp; new_y \u0026gt;= 0 \u0026amp;\u0026amp; new_y \u0026lt; C \u0026amp;\u0026amp; !visited[new_x][new_y]) { que.push(std::pair\u0026lt;int, int\u0026gt;(new_x, new_y)); visited[new_x][new_y] = true; } } --size; if (size == 0) { size = que.size(); ++degree; } } return max_time; } int main() { int num_case = 1; int T; std::cin \u0026gt;\u0026gt; T; for (int t = 0; t \u0026lt; T; ++t) { int R, C; std::cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; grid(R, std::vector\u0026lt;int\u0026gt;(C, -1)); std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; que; for (int i = 0; i \u0026lt; R; ++i) { std::string temp_in; std::cin \u0026gt;\u0026gt; temp_in; for (int j = 0; j \u0026lt; C; ++j) { char \u0026amp;temp = temp_in[j]; if (temp == \u0026#39;1\u0026#39;) { que.push(std::pair\u0026lt;int, int\u0026gt;(i, j)); grid[i][j] = 0; } } } int size = que.size(); if (size == R * C) { std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: 0\u0026#34; \u0026lt;\u0026lt; std::endl; ++num_case; continue; } // BFS for existing delivery offices int max_time = BFS0(R, C, 0, 0, grid, que); // BFS for all possible positions for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { if (grid[i][j] != 0) { que = std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;(); que.push(std::pair\u0026lt;int, int\u0026gt;(i, j)); int curr_max_time = BFS1(R, C, i, j, grid, que); max_time = std::min(max_time, curr_max_time); } } } std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: \u0026#34; + std::to_string(max_time) \u0026lt;\u0026lt; std::endl; ++num_case; } return 0; } Solution #3: Binary Search 前面的方法对每个可能的点都进行了搜索，时间复杂度达到了平方级别，因此不能通过 Hidden Test Set。因为题目需要求满足要求的最小值，自然容易想到使用二分法来求下界。\n对于一个给定的mid值，如果能够添加新的 delivery office 使得最大运输时间小于等于mid，那么可能有小于 mid 的值 (1 \u0026hellip; k-1) 使得结论成立；如果给定的mid值不能使结论成立，那么大于等于 mid 的所有值 (k \u0026hellip; INT_MAX) 都不能使结论成立。\n为了确认图中的点到 delivery office 的最短距离小于 mid，可以将图旋转45度，使用 i + j 和 i - j 分别作为左下和右上两条对角线的值来计算将 mid 作为最大运输时间时能否完成运输。\n$$ distance((x1，y1)，(x2，y2))= \\max (abs(x1 + y1 - (x2 + y2))，abs(x1 - y1 - (x2 - y2))) $$\n时间复杂度：O(RClog(R+C)) 空间复杂度：O(RC) #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;algorithm\u0026gt; int dir_x[4] = {-1, 0, 1, 0}; int dir_y[4] = {0, -1, 0, 1}; int R, C; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; grid; int BFS(int x, int y, std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;que) { int max_time = 0; int size = que.size(), time = 1; while (!que.empty()) { x = que.front().first, y = que.front().second; que.pop(); max_time = std::max(max_time, grid[x][y]); for (int i = 0; i \u0026lt; 4; ++i) { int new_x = x + dir_x[i], new_y = y + dir_y[i]; if (new_x \u0026gt;= 0 \u0026amp;\u0026amp; new_x \u0026lt; R \u0026amp;\u0026amp; new_y \u0026gt;= 0 \u0026amp;\u0026amp; new_y \u0026lt; C \u0026amp;\u0026amp; grid[new_x][new_y] == -1) { que.push(std::pair\u0026lt;int, int\u0026gt;(new_x, new_y)); grid[new_x][new_y] = time; } } --size; if (size == 0) { size = que.size(); ++time; } } return max_time; } bool CanDeliver(int \u0026amp;max_time) { bool deliver = true; int left_low = INT_MAX, left_high = INT_MIN, right_low = INT_MAX, right_high = INT_MIN; for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { if (grid[i][j] \u0026gt; max_time) { deliver = false; left_low = std::min(left_low, i + j + max_time); left_high = std::max(left_high, i + j - max_time); right_low = std::min(right_low, i - j + max_time); right_high = std::max(right_high, i - j - max_time); } } } if (deliver) return true; for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { int left = i + j, right = i - j; if (left_high \u0026lt;= left \u0026amp;\u0026amp; left \u0026lt;= left_low \u0026amp;\u0026amp; right_high \u0026lt;= right \u0026amp;\u0026amp; right \u0026lt;= right_low) return true; } } return false; } int main() { int num_case = 1; int T; std::cin \u0026gt;\u0026gt; T; for (int t = 0; t \u0026lt; T; ++t) { std::cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; grid = std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(R, std::vector\u0026lt;int\u0026gt;(C, -1)); std::queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; que; for (int i = 0; i \u0026lt; R; ++i) { std::string temp_in; std::cin \u0026gt;\u0026gt; temp_in; for (int j = 0; j \u0026lt; C; ++j) { char \u0026amp;temp = temp_in[j]; if (temp == \u0026#39;1\u0026#39;) { que.push(std::pair\u0026lt;int, int\u0026gt;(i, j)); grid[i][j] = 0; } } } int size = que.size(); if (size == R * C) { std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: 0\u0026#34; \u0026lt;\u0026lt; std::endl; ++num_case; continue; } // BFS int max_time = BFS(0, 0, que); // Binary Search int lowest_time = 0, highest_time = INT_MAX; while (lowest_time \u0026lt; highest_time) { int mid_time = lowest_time + ((highest_time - lowest_time) \u0026gt;\u0026gt; 1); if (CanDeliver(mid_time)) highest_time = mid_time; else lowest_time = mid_time + 1; } std::cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; + std::to_string(num_case) + \u0026#34;: \u0026#34; + std::to_string(highest_time) \u0026lt;\u0026lt; std::endl; ++num_case; } return 0; } Contention (18pts, 27pts) // TODO\n","permalink":"https://prov1dence.top/posts/kick-start/2019-round-a/","summary":"\u003ch1 id=\"kick-start-2019-round-ahttpscodingcompetitionswithgooglecomkickstartround0000000000050e01\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e01\"\u003eKick Start 2019 Round A\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"training-7pts-13ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050e0100000000000698d6\"\u003e\u003ca href=\"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e01/00000000000698d6\"\u003eTraining (7pts, 13pts)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e一共有N个人，从中选P个人，计算这P个人中 skill rating 的最大值与其他人的 skill rating 的差值之和。\u003c/p\u003e\n\u003cp\u003e$$ \\sum_{i}^{j} max(rating) - rating[i] $$\u003c/p\u003e\n\u003ch3 id=\"solution-sort--prefix-sum\"\u003eSolution: Sort + Prefix Sum\u003c/h3\u003e\n\u003cp\u003e先对数组排序，然后在长度为N的有序数组中遍历长为P的所有连续子数组，计算子数组中的最大值与其他值的差值之和。\u003c/p\u003e\n\u003cp\u003e$$ \\sum_{i}^{j - 1} rating[j] - rating[i] $$\u003c/p\u003e\n\u003cp\u003e如果直接遍历长为P的子数组会浪费很多时间，可以将上面的公式简化为如下。\u003c/p\u003e\n\u003cp\u003e$$ \\sum_{i}^{j - 1} rating[j] - rating[i] = rating[j] * (j - 1 - i) - \\sum_{i}^{j - 1} rating[i] $$\u003c/p\u003e\n\u003cp\u003e为了避免重复计算 $$ \\sum_{i}^{j - 1} rating[i] $$，可以用一个长为N+1的数组将原始数组的前缀和保存下来，这样每次直接计算 prefix[j] - prefix[i] 就能得到 $$ \\sum_{i}^{j - 1} rating[i] $$ 了，时间复杂度是O(N)。\u003c/p\u003e","title":"Kick Start 2019 Round A"},{"content":"Methods to Prevent Overfitting in Deep Learning Overfitting Overfitting refers to that when a model fits the training data well but cannot predict the test data correctly, we may say that the model lacks the ability of generalization. It is important to figure out how it happens, and how we can prevent overfitting from the very beginning.\nDetect Overfitting The simplest way to detect overfitting is to split the dataset into two parts: the training set for training the model, and the test set for testing the accuracy of the model on a dataset that it has never seen before. Of course, we will also partition part of the training set to be the validation set for fine-tuning hyper-parameters. Note that it is necessary to shuffle all the data before splitting.\nThrough this split, we check the performance of the model to gain insight on how the training process goes, and detect overfitting.\nDuring training, we may see the process:\nThe accuracy on the training set has reached a very high ratio, but the accuracy on the validation set still remains not high enough, or even a little bit low.\nIf we plot the accuracy and loss of the training set and the validation set into one figure, we will see:\nIt is obvious that the accuracy of the validation data is much lower than that of the training data.\nAlthough overfitting is frustrating, there are plenty of methods to prevent it from happening.\nPrevent Overfitting Here are some practical methods to prevent overfitting during training deep neural networks:\n1. Regularization Regularization is the most-used method to prevent overfitting in Machine Learning. It constrains the learning of the model by adding a regularization term. Typical regularization is to explicitly add regularization terms in the objective function, e.g. L1 and L2 regularization terms.\nIn deep learning, there are two commonly-used regularization methods: Batch Normalization and Dropout.\nBatch Normalization As the training progresses, the parameters in the deep neural network are constantly updated. On the one hand, parameters are changing slightly during the training. Due to the activation functions in each layer, these slight changes are amplified as the number of layers deepens, and the input distribution of each layer changes; on the other hand, with the change of parameters, former layers need to adapt to these distribution changes, which makes it more difficult to train the model. These are called Internal Covariate Shift.\nBatch Normalization is proposed to solve these two problems. We perform normalization on each layer separately, making the features of each layer have a mean of 0 and a variance of 1, which lets the value of each layer propagate in the effective range. we can also add a linear transformation operation, so that the data can restore the ability of expression.\nThe intuition of Batch Normalization is not to prevent over-fitting or prevent the gradient from vanishing or exploding but to increase the robustness by normalizing the parameter. This constraint also improves the structural rationality of the system, which brings a series of improvements, e.g. accelerate convergence, prevent over-fitting, etc.\nDropout When we are training the model, we can set a probability P for eliminating a node in the deep neural network. For each node, there is a probability of (1-P) for keeping it and a probability of P for dropping it. Then we perform forward-propagation and backpropagation-propagation on this much-diminished deep neural network.\nAt each training step of a mini-batch dataset, the process of dropout creates a different deep neural network by randomly removing some units regarding the probability P. The process of dropout is similar to use ensemble learning on many different deep neural networks, each trained with a separate mini-batch dataset but share some context in the process of training.\nIn ensemble learning, since each classifier has been trained separately, it has learned different aspects of the dataset and their mistakes are different. Combining them helps to produce a more accurate classifier, which is less prone to overfitting. We can view dropout as a form of ensemble learning, and this is why it can prevent overfitting.\n2. Data Augmentation In Deep Learning, collecting data is an effective way to enhance the training but also a tedious and intricate process. In fact, for the majority of image recognition problems, we cannot get as much data as we expect. In order to obtain more data, data augmentation techniques is a very efficient method to improve the result.\nFor Convolutional Neural Networks, some common image augmentation techniques are listed:\nmirroring/flipping (on vertical or horizontal axis) rotating cropping scaling warping color shifting adding noise There are two ways to do data augmentation: Offline Augmentation and Online Augmentation.\nOffline Augmentation Offline Augmentation is to perform all augmentations in advance, before training, and save all the augmented data in memory. In fact, it will increase, or multiple, the size of the dataset. This method fits small datasets well.\nOnline Augmentation Another option, Online Augmentation, is to perform these augmentations on a mini-batch dataset right before they are fed to the model. This method is more suitable for large datasets because we do not have enough memory for staging all the augmented data when its scale is too enormous, so what we do is to perform mini-batch augmentation before feeding the current batch of data into the model.\n3. Early Stopping Early Stopping is a trade-off between training epochs and validation accuracy. At the end of each epoch, compare current validation accuracy of this epoch with the best validation accuracy. If the accuracy on the validation set decreases or does not reach the best one for more than 10 consecutive epochs, we stop the training, and we think the accuracy is no longer improved.\n4. Simplify The Model If we have done all the methods above to prevent overfitting but the performance is still bad, we may consider simplifying our model. The model may be too complicated for our dataset to fit and we can try to reduce the complexity of the model in some ways, e.g. reduce the number of layers, remove some neurons, etc.\n","permalink":"https://prov1dence.top/posts/deep-learning/methods-to-prevent-overfitting-in-deep-learning/","summary":"\u003ch1 id=\"methods-to-prevent-overfitting-in-deep-learning\"\u003eMethods to Prevent Overfitting in Deep Learning\u003c/h1\u003e\n\u003ch2 id=\"overfitting\"\u003eOverfitting\u003c/h2\u003e\n\u003cp\u003eOverfitting refers to that when a model fits the training data well but cannot predict the test data correctly, we may say that the model lacks the ability of generalization. It is important to figure out how it happens, and how we can prevent overfitting from the very beginning.\u003c/p\u003e\n\u003ch2 id=\"detect-overfitting\"\u003eDetect Overfitting\u003c/h2\u003e\n\u003cp\u003eThe simplest way to detect overfitting is to split the dataset into two parts: the training set for training the model, and the test set for testing the accuracy of the model on a dataset that it has never seen before. Of course, we will also partition part of the training set to be the validation set for fine-tuning hyper-parameters. Note that it is necessary to shuffle all the data before splitting.\u003c/p\u003e","title":"Methods to Prevent Overfitting in Deep Learning"},{"content":"C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器\nprivate: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使\b其计数器自减1。\b如果计数器等于0，则表示已经没有其他的对象在使用当前指针，\b此时则可以销毁指针，计数器和删除器。\ntemplate\u0026lt;typename T, typename D\u0026gt; void SharedPointer\u0026lt;T, D\u0026gt;::release() { if (pointer) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; counter remains \u0026#34; \u0026lt;\u0026lt; *counter \u0026lt;\u0026lt; std::endl; if (--(*counter) == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针\ntemplate\u0026lt;typename T, typename D\u0026gt; void SharedPointer\u0026lt;T, D\u0026gt;::reset(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) { pointer = other.pointer; counter = other.counter; deleter = other.deleter; if (pointer) ++(*counter); } 析构函数可以直接调用release函数\ntemplate\u0026lt;typename T, typename D\u0026gt; SharedPointer\u0026lt;T, D\u0026gt;::~SharedPointer() { release(); } 拷贝构造函数可以直接调用reset函数\ntemplate\u0026lt;typename T, typename D\u0026gt; SharedPointer\u0026lt;T, D\u0026gt;::SharedPointer(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; copy constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; reset(other); } 使用赋值操作符时先调用release函数，再调用reset函数\ntemplate\u0026lt;typename T, typename D\u0026gt; SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;SharedPointer\u0026lt;T, D\u0026gt;::operator=(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; assignment operator called.\u0026#34; \u0026lt;\u0026lt; std::endl; if (this != \u0026amp;other) { release(); reset(other); } return *this; } 实现 根据shared_ptr的源码，能够大致实现SharedPointer类\ntemplate\u0026lt;typename T, typename D\u0026gt; class SharedPointer { public: explicit SharedPointer(T *t = nullptr, D *d = nullptr); ~SharedPointer(); T \u0026amp;operator*(); T *operator-\u0026gt;(); void reset(const SharedPointer \u0026amp;other); void release(); SharedPointer(const SharedPointer \u0026amp;other); SharedPointer \u0026amp;operator=(const SharedPointer \u0026amp;other); private: int *counter; T *pointer; D *deleter; }; template\u0026lt;typename T, typename D\u0026gt; void SharedPointer\u0026lt;T, D\u0026gt;::reset(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) { pointer = other.pointer; counter = other.counter; deleter = other.deleter; if (pointer) ++(*counter); } template\u0026lt;typename T, typename D\u0026gt; void SharedPointer\u0026lt;T, D\u0026gt;::release() { if (pointer) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; counter remains \u0026#34; \u0026lt;\u0026lt; *counter \u0026lt;\u0026lt; std::endl; if (--(*counter) == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } template\u0026lt;typename T, typename D\u0026gt; SharedPointer\u0026lt;T, D\u0026gt;::SharedPointer(T *t, D *d): pointer(t), deleter(d) { if (pointer) counter = new int(1); else counter = nullptr; std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T, typename D\u0026gt; SharedPointer\u0026lt;T, D\u0026gt;::SharedPointer(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; copy constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; reset(other); } template\u0026lt;typename T, typename D\u0026gt; SharedPointer\u0026lt;T, D\u0026gt;::~SharedPointer() { release(); } template\u0026lt;typename T, typename D\u0026gt; T \u0026amp;SharedPointer\u0026lt;T, D\u0026gt;::operator*() { return *pointer; } template\u0026lt;typename T, typename D\u0026gt; T *SharedPointer\u0026lt;T, D\u0026gt;::operator-\u0026gt;() { return pointer; } template\u0026lt;typename T, typename D\u0026gt; SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;SharedPointer\u0026lt;T, D\u0026gt;::operator=(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; assignment operator called.\u0026#34; \u0026lt;\u0026lt; std::endl; if (this != \u0026amp;other) { release(); reset(other); } return *this; } 测试 尝试使用拷贝构造函数和赋值操作符使多个SharedPointer对象使用同一个指针，以及使用reset函数清空智能指针对象的指针\nint main() { Deleter *deleter = new Deleter(); Obj *o = new Obj(); SharedPointer\u0026lt;Obj, Deleter\u0026gt; s1(o, deleter); SharedPointer\u0026lt;Obj, Deleter\u0026gt; s2(s1); SharedPointer\u0026lt;Obj, Deleter\u0026gt; s3; s3 = s1; return 0; } /* output: Construct SharedPointer 0x7ffeeebdda00 constructor called. SharedPointer 0x7ffeeebdd9e8 copy constructor called. SharedPointer 0x7ffeeebdd9d0 constructor called. SharedPointer 0x7ffeeebdd9d0 assignment operator called. SharedPointer 0x7ffeeebdd9d0 counter remains 3 SharedPointer 0x7ffeeebdd9e8 counter remains 2 SharedPointer 0x7ffeeebdda00 counter remains 1 SharedPointer 0x7ffeeebdda00 destructor called. Destruct */ 考虑如下一个类\nclass Object : public Obj { public: SharedPointer\u0026lt;Object, Deleter\u0026gt; S; }; 创建两个Object类型的对象\nint main() { SharedPointer\u0026lt;Object, Deleter\u0026gt; s1(new Object()); SharedPointer\u0026lt;Object, Deleter\u0026gt; s2(new Object()); s1-\u0026gt;S = s2; s2-\u0026gt;S = s1; return 0; } /* output: Construct SharedPointer 0x7f88eac02ab0 constructor called. SharedPointer 0x7ffee0bfaa20 constructor called. Construct SharedPointer 0x7f88eac02ae0 constructor called. SharedPointer 0x7ffee0bfa9f8 constructor called. SharedPointer 0x7f88eac02ab0 assignment operator called. SharedPointer 0x7f88eac02ae0 assignment operator called. SharedPointer 0x7ffee0bfa9f8 counter remains 2 SharedPointer 0x7ffee0bfaa20 counter remains 2 */ 两个Object类型的指针都包含了一个SharedPointer类型的智能指针对象，但这两个指针又依赖于SharedPointer对象去进行销毁，导致最后s1和s2的计数器都不能减为0，从而不能正确地\b销毁指针，导致了内存泄漏。这种现象叫做交叉引用。\n总结 SharedPointer利用Reference counting（计数引用）解决了多个对象使用同一个指针时自动销毁指针的问题，但又会发生交叉引用时不能够正确销毁指针的问题。\b\nshared_pointer源码 template\u0026lt;class _Tp\u0026gt; class _LIBCPP_TEMPLATE_VIS shared_ptr { public: typedef _Tp element_type; #if _LIBCPP_STD_VER \u0026gt; 14 typedef weak_ptr\u0026lt;_Tp\u0026gt; weak_type; #endif private: element_type* __ptr_; __shared_weak_count* __cntrl_; struct __nat {int __for_bool_;}; public: _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT; _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT; template\u0026lt;class _Yp\u0026gt; explicit shared_ptr(_Yp* __p, typename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat()); template\u0026lt;class _Yp, class _Dp\u0026gt; shared_ptr(_Yp* __p, _Dp __d, typename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat()); template\u0026lt;class _Yp, class _Dp, class _Alloc\u0026gt; shared_ptr(_Yp* __p, _Dp __d, _Alloc __a, typename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat()); template \u0026lt;class _Dp\u0026gt; shared_ptr(nullptr_t __p, _Dp __d); template \u0026lt;class _Dp, class _Alloc\u0026gt; shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a); template\u0026lt;class _Yp\u0026gt; _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp; __r, element_type* __p) _NOEXCEPT; _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026amp; __r) _NOEXCEPT; template\u0026lt;class _Yp\u0026gt; _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp; __r, typename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat()) _NOEXCEPT; #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY shared_ptr(shared_ptr\u0026amp;\u0026amp; __r) _NOEXCEPT; template\u0026lt;class _Yp\u0026gt; _LIBCPP_INLINE_VISIBILITY shared_ptr(shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp;\u0026amp; __r, typename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat()) _NOEXCEPT; #endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES template\u0026lt;class _Yp\u0026gt; explicit shared_ptr(const weak_ptr\u0026lt;_Yp\u0026gt;\u0026amp; __r, typename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type= __nat()); #if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR) #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES template\u0026lt;class _Yp\u0026gt; shared_ptr(auto_ptr\u0026lt;_Yp\u0026gt;\u0026amp;\u0026amp; __r, typename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat()); #else template\u0026lt;class _Yp\u0026gt; shared_ptr(auto_ptr\u0026lt;_Yp\u0026gt; __r, typename enable_if\u0026lt;is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, __nat\u0026gt;::type = __nat()); #endif #endif #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES template \u0026lt;class _Yp, class _Dp\u0026gt; shared_ptr(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;\u0026amp;\u0026amp;, typename enable_if \u0026lt; !is_lvalue_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp; !is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value, __nat \u0026gt;::type = __nat()); template \u0026lt;class _Yp, class _Dp\u0026gt; shared_ptr(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;\u0026amp;\u0026amp;, typename enable_if \u0026lt; is_lvalue_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp; !is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value, __nat \u0026gt;::type = __nat()); #else // _LIBCPP_HAS_NO_RVALUE_REFERENCES template \u0026lt;class _Yp, class _Dp\u0026gt; shared_ptr(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;, typename enable_if \u0026lt; !is_lvalue_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp; !is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value, __nat \u0026gt;::type = __nat()); template \u0026lt;class _Yp, class _Dp\u0026gt; shared_ptr(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;, typename enable_if \u0026lt; is_lvalue_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp; !is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value, __nat \u0026gt;::type = __nat()); #endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES ~shared_ptr(); _LIBCPP_INLINE_VISIBILITY shared_ptr\u0026amp; operator=(const shared_ptr\u0026amp; __r) _NOEXCEPT; template\u0026lt;class _Yp\u0026gt; typename enable_if \u0026lt; is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, shared_ptr\u0026amp; \u0026gt;::type _LIBCPP_INLINE_VISIBILITY operator=(const shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp; __r) _NOEXCEPT; #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY shared_ptr\u0026amp; operator=(shared_ptr\u0026amp;\u0026amp; __r) _NOEXCEPT; template\u0026lt;class _Yp\u0026gt; typename enable_if \u0026lt; is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, shared_ptr\u0026lt;_Tp\u0026gt;\u0026amp; \u0026gt;::type _LIBCPP_INLINE_VISIBILITY operator=(shared_ptr\u0026lt;_Yp\u0026gt;\u0026amp;\u0026amp; __r); #if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR) template\u0026lt;class _Yp\u0026gt; _LIBCPP_INLINE_VISIBILITY typename enable_if \u0026lt; !is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, shared_ptr \u0026gt;::type\u0026amp; operator=(auto_ptr\u0026lt;_Yp\u0026gt;\u0026amp;\u0026amp; __r); #endif #else // _LIBCPP_HAS_NO_RVALUE_REFERENCES #if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR) template\u0026lt;class _Yp\u0026gt; _LIBCPP_INLINE_VISIBILITY typename enable_if \u0026lt; !is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, shared_ptr\u0026amp; \u0026gt;::type operator=(auto_ptr\u0026lt;_Yp\u0026gt; __r); #endif #endif template \u0026lt;class _Yp, class _Dp\u0026gt; typename enable_if \u0026lt; !is_array\u0026lt;_Yp\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;typename unique_ptr\u0026lt;_Yp, _Dp\u0026gt;::pointer, element_type*\u0026gt;::value, shared_ptr\u0026amp; \u0026gt;::type #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY operator=(unique_ptr\u0026lt;_Yp, _Dp\u0026gt;\u0026amp;\u0026amp; __r); #else // _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY operator=(unique_ptr\u0026lt;_Yp, _Dp\u0026gt; __r); #endif _LIBCPP_INLINE_VISIBILITY void swap(shared_ptr\u0026amp; __r) _NOEXCEPT; _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT; template\u0026lt;class _Yp\u0026gt; typename enable_if \u0026lt; is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, void \u0026gt;::type _LIBCPP_INLINE_VISIBILITY reset(_Yp* __p); template\u0026lt;class _Yp, class _Dp\u0026gt; typename enable_if \u0026lt; is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, void \u0026gt;::type _LIBCPP_INLINE_VISIBILITY reset(_Yp* __p, _Dp __d); template\u0026lt;class _Yp, class _Dp, class _Alloc\u0026gt; typename enable_if \u0026lt; is_convertible\u0026lt;_Yp*, element_type*\u0026gt;::value, void \u0026gt;::type _LIBCPP_INLINE_VISIBILITY reset(_Yp* __p, _Dp __d, _Alloc __a); _LIBCPP_INLINE_VISIBILITY element_type* get() const _NOEXCEPT {return __ptr_;} _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference\u0026lt;element_type\u0026gt;::type operator*() const _NOEXCEPT {return *__ptr_;} _LIBCPP_INLINE_VISIBILITY element_type* operator-\u0026gt;() const _NOEXCEPT {return __ptr_;} _LIBCPP_INLINE_VISIBILITY long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_-\u0026gt;use_count() : 0;} _LIBCPP_INLINE_VISIBILITY bool unique() const _NOEXCEPT {return use_count() == 1;} _LIBCPP_INLINE_VISIBILITY _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;} template \u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY bool owner_before(shared_ptr\u0026lt;_Up\u0026gt; const\u0026amp; __p) const _NOEXCEPT {return __cntrl_ \u0026lt; __p.__cntrl_;} template \u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY bool owner_before(weak_ptr\u0026lt;_Up\u0026gt; const\u0026amp; __p) const _NOEXCEPT {return __cntrl_ \u0026lt; __p.__cntrl_;} _LIBCPP_INLINE_VISIBILITY bool __owner_equivalent(const shared_ptr\u0026amp; __p) const {return __cntrl_ == __p.__cntrl_;} #ifndef _LIBCPP_NO_RTTI template \u0026lt;class _Dp\u0026gt; _LIBCPP_INLINE_VISIBILITY _Dp* __get_deleter() const _NOEXCEPT {return static_cast\u0026lt;_Dp*\u0026gt;(__cntrl_ ? const_cast\u0026lt;void *\u0026gt;(__cntrl_-\u0026gt;__get_deleter(typeid(_Dp))) : nullptr);} #endif // _LIBCPP_NO_RTTI #ifndef _LIBCPP_HAS_NO_VARIADICS template\u0026lt;class ..._Args\u0026gt; static shared_ptr\u0026lt;_Tp\u0026gt; make_shared(_Args\u0026amp;\u0026amp; ...__args); template\u0026lt;class _Alloc, class ..._Args\u0026gt; static shared_ptr\u0026lt;_Tp\u0026gt; allocate_shared(const _Alloc\u0026amp; __a, _Args\u0026amp;\u0026amp; ...__args); #else // _LIBCPP_HAS_NO_VARIADICS static shared_ptr\u0026lt;_Tp\u0026gt; make_shared(); template\u0026lt;class _A0\u0026gt; static shared_ptr\u0026lt;_Tp\u0026gt; make_shared(_A0\u0026amp;); template\u0026lt;class _A0, class _A1\u0026gt; static shared_ptr\u0026lt;_Tp\u0026gt; make_shared(_A0\u0026amp;, _A1\u0026amp;); template\u0026lt;class _A0, class _A1, class _A2\u0026gt; static shared_ptr\u0026lt;_Tp\u0026gt; make_shared(_A0\u0026amp;, _A1\u0026amp;, _A2\u0026amp;); template\u0026lt;class _Alloc\u0026gt; static shared_ptr\u0026lt;_Tp\u0026gt; allocate_shared(const _Alloc\u0026amp; __a); template\u0026lt;class _Alloc, class _A0\u0026gt; static shared_ptr\u0026lt;_Tp\u0026gt; allocate_shared(const _Alloc\u0026amp; __a, _A0\u0026amp; __a0); template\u0026lt;class _Alloc, class _A0, class _A1\u0026gt; static shared_ptr\u0026lt;_Tp\u0026gt; allocate_shared(const _Alloc\u0026amp; __a, _A0\u0026amp; __a0, _A1\u0026amp; __a1); template\u0026lt;class _Alloc, class _A0, class _A1, class _A2\u0026gt; static shared_ptr\u0026lt;_Tp\u0026gt; allocate_shared(const _Alloc\u0026amp; __a, _A0\u0026amp; __a0, _A1\u0026amp; __a1, _A2\u0026amp; __a2); #endif // _LIBCPP_HAS_NO_VARIADICS private: template \u0026lt;class _Yp, bool = is_function\u0026lt;_Yp\u0026gt;::value\u0026gt; struct __shared_ptr_default_allocator { typedef allocator\u0026lt;_Yp\u0026gt; type; }; template \u0026lt;class _Yp\u0026gt; struct __shared_ptr_default_allocator\u0026lt;_Yp, true\u0026gt; { typedef allocator\u0026lt;__shared_ptr_dummy_rebind_allocator_type\u0026gt; type; }; template \u0026lt;class _Yp, class _OrigPtr\u0026gt; _LIBCPP_INLINE_VISIBILITY typename enable_if\u0026lt;is_convertible\u0026lt;_OrigPtr*, const enable_shared_from_this\u0026lt;_Yp\u0026gt;* \u0026gt;::value, void\u0026gt;::type __enable_weak_this(const enable_shared_from_this\u0026lt;_Yp\u0026gt;* __e, _OrigPtr* __ptr) _NOEXCEPT { typedef typename remove_cv\u0026lt;_Yp\u0026gt;::type _RawYp; if (__e \u0026amp;\u0026amp; __e-\u0026gt;__weak_this_.expired()) { __e-\u0026gt;__weak_this_ = shared_ptr\u0026lt;_RawYp\u0026gt;(*this, const_cast\u0026lt;_RawYp*\u0026gt;(static_cast\u0026lt;const _Yp*\u0026gt;(__ptr))); } } _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {} template \u0026lt;class _Up\u0026gt; friend class _LIBCPP_TEMPLATE_VIS shared_ptr; template \u0026lt;class _Up\u0026gt; friend class _LIBCPP_TEMPLATE_VIS weak_ptr; }; ","permalink":"https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-3/","summary":"\u003ch1 id=\"c智能指针3shared_ptr\"\u003eC++智能指针（3）：shared_ptr\u003c/h1\u003e\n\u003ch2 id=\"分析\"\u003e分析\u003c/h2\u003e\n\u003cp\u003eUniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate:\n    int *counter;\n    T *pointer;\n    D *deleter;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使\b其计数器自减1。\b如果计数器等于0，则表示已经没有其他的对象在使用当前指针，\b此时则可以销毁指针，计数器和删除器。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003etemplate\u0026lt;typename T, typename D\u0026gt;\nvoid SharedPointer\u0026lt;T, D\u0026gt;::release() {\n    if (pointer) {\n        std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; counter remains \u0026#34; \u0026lt;\u0026lt; *counter \u0026lt;\u0026lt; std::endl;\n        if (--(*counter) == 0) {\n            std::cout \u0026lt;\u0026lt; \u0026#34;SharedPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl;\n            (*deleter)(pointer);\n            (*deleter)(counter);\n            (*deleter)(deleter);\n            pointer = nullptr;\n            counter = nullptr;\n            deleter = nullptr;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ereset函数将指针设为other的指针\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003etemplate\u0026lt;typename T, typename D\u0026gt;\nvoid SharedPointer\u0026lt;T, D\u0026gt;::reset(const SharedPointer\u0026lt;T, D\u0026gt; \u0026amp;other) {\n    pointer = other.pointer;\n    counter = other.counter;\n    deleter = other.deleter;\n    if (pointer)\n        ++(*counter);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e析构函数可以直接调用release函数\u003c/p\u003e","title":"C++ 智能指针（3）：shared_ptr"},{"content":"C++智能指针（2）：unique_ptr 分析 在使用 AutoPointer 的时候会发生所有权转移和内存泄漏的问题，所以我们可以对 AutoPointer 类稍加修改，修复这两个问题\b。\n所有权转移 为了规避可能发生所有权转移的情况，我们可以直接禁止它使用拷贝构造函数和赋值操作符。\nUniquePointer(UniquePointer\u0026lt;T\u0026gt; \u0026amp;other) = delete; UniquePointer\u0026lt;T\u0026gt; \u0026amp;operator=(const UniquePointer\u0026lt;T\u0026gt; \u0026amp;other) = delete; \b但很多时候我们都需要使用到传递指针的操作，如果只是使用 deleted 函数禁止拷贝构造函数和赋值操作符，那么这个智能指针存在的意义就不大了，我们可以通过 move 语义来实现移动构造函数和移动赋值操作符，从而在使用 UniquePointer 的时候可以在特定情况下进行所有权转移。\nUniquePointer(UniquePointer\u0026lt;T\u0026gt; \u0026amp;\u0026amp;other) noexcept; UniquePointer \u0026amp;operator=(UniquePointer \u0026amp;\u0026amp;other) noexcept; 内存泄漏 为了防止发生内存泄漏，我们可以在UniquePointer的私有成员中增加一个删除器，并\b根据当前指针对象的类型指定删除器，从而防止发生内存泄漏。\nclass Deleter { template\u0026lt;typename T\u0026gt; void operator()(T *p) { if (p) delete p; } }; template\u0026lt;typename T, typename D\u0026gt; class UniquePointer { ... private: T *pointer; Deleter deleter; }; 实现 根据unique_ptr的源码，能够大致实现UniquePointer类\ntemplate\u0026lt;typename T, typename D\u0026gt; class UniquePointer { public: explicit UniquePointer(T *t, const D \u0026amp;d); ~UniquePointer(); T \u0026amp;operator*(); T *operator-\u0026gt;(); T *release(); void reset(T *p); UniquePointer(UniquePointer \u0026amp;\u0026amp;other) noexcept; UniquePointer \u0026amp;operator=(UniquePointer \u0026amp;\u0026amp;other) noexcept; UniquePointer(const UniquePointer \u0026amp;other) = delete; UniquePointer \u0026amp;operator=(const UniquePointer \u0026amp;other) = delete; private: T *pointer; D deleter; }; template\u0026lt;typename T, typename D\u0026gt; UniquePointer\u0026lt;T, D\u0026gt;::UniquePointer(T *t, const D \u0026amp;d) { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; this-\u0026gt;pointer = t; this-\u0026gt;deleter = d; } template\u0026lt;typename T, typename D\u0026gt; UniquePointer\u0026lt;T, D\u0026gt;::~UniquePointer() { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; deleter(this-\u0026gt;pointer); } template\u0026lt;typename T, typename D\u0026gt; T \u0026amp;UniquePointer\u0026lt;T, D\u0026gt;::operator*() { return *this-\u0026gt;pointer; } template\u0026lt;typename T, typename D\u0026gt; T *UniquePointer\u0026lt;T, D\u0026gt;::operator-\u0026gt;() { return this-\u0026gt;pointer; } template\u0026lt;typename T, typename D\u0026gt; T *UniquePointer\u0026lt;T, D\u0026gt;::release() { T *new_pointer = this-\u0026gt;pointer; this-\u0026gt;pointer = nullptr; return new_pointer; } template\u0026lt;typename T, typename D\u0026gt; void UniquePointer\u0026lt;T, D\u0026gt;::reset(T *p) { if (this-\u0026gt;pointer != p) { deleter(this-\u0026gt;pointer); this-\u0026gt;pointer = p; } } template\u0026lt;typename T, typename D\u0026gt; UniquePointer\u0026lt;T, D\u0026gt;::UniquePointer(UniquePointer\u0026lt;T, D\u0026gt; \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; move constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; this-\u0026gt;pointer = other.release(); deleter(std::move(other.deleter)); } template\u0026lt;typename T, typename D\u0026gt; UniquePointer\u0026lt;T, D\u0026gt; \u0026amp;UniquePointer\u0026lt;T, D\u0026gt;::operator=(UniquePointer\u0026lt;T, D\u0026gt; \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;UniquePointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; assignment operator called.\u0026#34; \u0026lt;\u0026lt; std::endl; if (this-\u0026gt;pointer != other.pointer) { reset(other.release()); deleter = std::move(other.deleter); } return *this; } 测试 尝试使用移动构造函数\nclass Deleter { public: template\u0026lt;typename T\u0026gt; void operator()(T *p) { if (p) delete p; } }; int main() { Deleter deleter; Obj *o = new Obj(); UniquePointer\u0026lt;Obj, Deleter\u0026gt; u1(o, deleter); UniquePointer\u0026lt;Obj, Deleter\u0026gt; u2(move(u1)); return 0; } /* output: Construct UniquePointer 0x7ffee7dada08 constructor called. UniquePointer 0x7ffee7dad9f8 move constructor called. UniquePointer 0x7ffee7dad9f8 destructor called. Destruct UniquePointer 0x7ffee7dada08 destructor called. */ 尝试使用移动赋值操作符\nclass Deleter { public: template\u0026lt;typename T\u0026gt; void operator()(T *p) { if (p) delete p; } }; int main() { Deleter deleter; Obj *o = new Obj(); UniquePointer\u0026lt;Obj, Deleter\u0026gt; u1(o, deleter); UniquePointer\u0026lt;Obj, Deleter\u0026gt; u2(nullptr, deleter); u2 = move(u1); return 0; } /* output: Construct UniquePointer 0x7ffee915da08 constructor called. UniquePointer 0x7ffee915d9f8 constructor called. UniquePointer 0x7ffee915d9f8 assignment operator called. UniquePointer 0x7ffee915d9f8 destructor called. Destruct UniquePointer 0x7ffee915da08 destructor called. */ 定义一个数组删除器，尝试\b以数组指针初始化UniquePointer类对象\nclass ArrayDeleter { public: template\u0026lt;typename T\u0026gt; void operator()(T *p) { if (p) delete[] p; } }; int main() { ArrayDeleter array_deleter; Obj *o = new Obj[3]; UniquePointer\u0026lt;Obj, ArrayDeleter\u0026gt; u(o, array_deleter); return 0; } /* output: Construct Construct Construct UniquePointer 0x7ffeed926a08 constructor called. UniquePointer 0x7ffeed926a08 destructor called. Destruct Destruct Destruct */ 作为对比，如果使用默认删除器作为数组指针的删除器\nclass Deleter { public: template\u0026lt;typename T\u0026gt; void operator()(T *p) { if (p) delete p; } }; int main() { Deleter deleter; Obj *o = new Obj[3]; UniquePointer\u0026lt;Obj, Deleter\u0026gt; u(o, deleter); return 0; } /* output: Construct Construct Construct UniquePointer 0x7ffee8f85a10 constructor called. UniquePointer 0x7ffee8f85a10 destructor called. Destruct */ 说明删除器能够正确地修复内存泄漏的问题。\n尝试将两个UniquePointer的对象指向同一个指针\nint main() { Deleter deleter; Obj *o = new Obj(); UniquePointer\u0026lt;Obj, Deleter\u0026gt; u1(o, deleter); UniquePointer\u0026lt;Obj, Deleter\u0026gt; u2(o, deleter); return 0; } /* output: (19576,0x10e00a5c0) malloc: *** error for object 0x7fcfe8c02ab0: pointer being freed was not allocated (19576,0x10e00a5c0) malloc: *** set a breakpoint in malloc_error_break to debug Construct UniquePointer 0x7ffee28a9a10 constructor called. UniquePointer 0x7ffee28a9a00 constructor called. UniquePointer 0x7ffee28a9a00 destructor called. Destruct UniquePointer 0x7ffee28a9a10 destructor called. Destruct */ 还是产生调用两次析构函数的错误。\n总结 UniquePointer成功地解决了所有权转移和内存泄漏的问题，但还有诸如重复析构的问题存在。\nunique_ptr源码 template \u0026lt;class _Tp, class _Dp = default_delete\u0026lt;_Tp\u0026gt; \u0026gt; class _LIBCPP_TEMPLATE_VIS unique_ptr { public: typedef _Tp element_type; typedef _Dp deleter_type; typedef typename __pointer_type\u0026lt;_Tp, deleter_type\u0026gt;::type pointer; static_assert(!is_rvalue_reference\u0026lt;deleter_type\u0026gt;::value, \u0026#34;the specified deleter type cannot be an rvalue reference\u0026#34;); private: __compressed_pair\u0026lt;pointer, deleter_type\u0026gt; __ptr_; struct __nat { int __for_bool_; }; #ifndef _LIBCPP_CXX03_LANG typedef __unique_ptr_deleter_sfinae\u0026lt;_Dp\u0026gt; _DeleterSFINAE; template \u0026lt;bool _Dummy\u0026gt; using _LValRefType = typename __dependent_type\u0026lt;_DeleterSFINAE, _Dummy\u0026gt;::__lval_ref_type; template \u0026lt;bool _Dummy\u0026gt; using _GoodRValRefType = typename __dependent_type\u0026lt;_DeleterSFINAE, _Dummy\u0026gt;::__good_rval_ref_type; template \u0026lt;bool _Dummy\u0026gt; using _BadRValRefType = typename __dependent_type\u0026lt;_DeleterSFINAE, _Dummy\u0026gt;::__bad_rval_ref_type; template \u0026lt;bool _Dummy, class _Deleter = typename __dependent_type\u0026lt; __identity\u0026lt;deleter_type\u0026gt;, _Dummy\u0026gt;::type\u0026gt; using _EnableIfDeleterDefaultConstructible = typename enable_if\u0026lt;is_default_constructible\u0026lt;_Deleter\u0026gt;::value \u0026amp;\u0026amp; !is_pointer\u0026lt;_Deleter\u0026gt;::value\u0026gt;::type; template \u0026lt;class _ArgType\u0026gt; using _EnableIfDeleterConstructible = typename enable_if\u0026lt;is_constructible\u0026lt;deleter_type, _ArgType\u0026gt;::value\u0026gt;::type; template \u0026lt;class _UPtr, class _Up\u0026gt; using _EnableIfMoveConvertible = typename enable_if\u0026lt; is_convertible\u0026lt;typename _UPtr::pointer, pointer\u0026gt;::value \u0026amp;\u0026amp; !is_array\u0026lt;_Up\u0026gt;::value \u0026gt;::type; template \u0026lt;class _UDel\u0026gt; using _EnableIfDeleterConvertible = typename enable_if\u0026lt; (is_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp; is_same\u0026lt;_Dp, _UDel\u0026gt;::value) || (!is_reference\u0026lt;_Dp\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;_UDel, _Dp\u0026gt;::value) \u0026gt;::type; template \u0026lt;class _UDel\u0026gt; using _EnableIfDeleterAssignable = typename enable_if\u0026lt; is_assignable\u0026lt;_Dp\u0026amp;, _UDel\u0026amp;\u0026amp;\u0026gt;::value \u0026gt;::type; public: template \u0026lt;bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible\u0026lt;_Dummy\u0026gt;\u0026gt; _LIBCPP_INLINE_VISIBILITY constexpr unique_ptr() noexcept : __ptr_(pointer()) {} template \u0026lt;bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible\u0026lt;_Dummy\u0026gt;\u0026gt; _LIBCPP_INLINE_VISIBILITY constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {} template \u0026lt;bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible\u0026lt;_Dummy\u0026gt;\u0026gt; _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {} template \u0026lt;bool _Dummy = true, class = _EnableIfDeleterConstructible\u0026lt;_LValRefType\u0026lt;_Dummy\u0026gt;\u0026gt;\u0026gt; _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, _LValRefType\u0026lt;_Dummy\u0026gt; __d) noexcept : __ptr_(__p, __d) {} template \u0026lt;bool _Dummy = true, class = _EnableIfDeleterConstructible\u0026lt;_GoodRValRefType\u0026lt;_Dummy\u0026gt;\u0026gt;\u0026gt; _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, _GoodRValRefType\u0026lt;_Dummy\u0026gt; __d) noexcept : __ptr_(__p, _VSTD::move(__d)) { static_assert(!is_reference\u0026lt;deleter_type\u0026gt;::value, \u0026#34;rvalue deleter bound to reference\u0026#34;); } template \u0026lt;bool _Dummy = true, class = _EnableIfDeleterConstructible\u0026lt;_BadRValRefType\u0026lt;_Dummy\u0026gt;\u0026gt;\u0026gt; _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, _BadRValRefType\u0026lt;_Dummy\u0026gt; __d) = delete; _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr\u0026amp;\u0026amp; __u) noexcept : __ptr_(__u.release(), _VSTD::forward\u0026lt;deleter_type\u0026gt;(__u.get_deleter())) { } template \u0026lt;class _Up, class _Ep, class = _EnableIfMoveConvertible\u0026lt;unique_ptr\u0026lt;_Up, _Ep\u0026gt;, _Up\u0026gt;, class = _EnableIfDeleterConvertible\u0026lt;_Ep\u0026gt; \u0026gt; _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr\u0026lt;_Up, _Ep\u0026gt;\u0026amp;\u0026amp; __u) _NOEXCEPT : __ptr_(__u.release(), _VSTD::forward\u0026lt;_Ep\u0026gt;(__u.get_deleter())) {} #if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR) template \u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr\u0026lt;_Up\u0026gt;\u0026amp;\u0026amp; __p, typename enable_if\u0026lt;is_convertible\u0026lt;_Up*, _Tp*\u0026gt;::value \u0026amp;\u0026amp; is_same\u0026lt;_Dp, default_delete\u0026lt;_Tp\u0026gt;\u0026gt;::value, __nat\u0026gt;::type = __nat()) _NOEXCEPT : __ptr_(__p.release()) {} #endif _LIBCPP_INLINE_VISIBILITY unique_ptr\u0026amp; operator=(unique_ptr\u0026amp;\u0026amp; __u) _NOEXCEPT { reset(__u.release()); __ptr_.second() = _VSTD::forward\u0026lt;deleter_type\u0026gt;(__u.get_deleter()); return *this; } template \u0026lt;class _Up, class _Ep, class = _EnableIfMoveConvertible\u0026lt;unique_ptr\u0026lt;_Up, _Ep\u0026gt;, _Up\u0026gt;, class = _EnableIfDeleterAssignable\u0026lt;_Ep\u0026gt; \u0026gt; _LIBCPP_INLINE_VISIBILITY unique_ptr\u0026amp; operator=(unique_ptr\u0026lt;_Up, _Ep\u0026gt;\u0026amp;\u0026amp; __u) _NOEXCEPT { reset(__u.release()); __ptr_.second() = _VSTD::forward\u0026lt;_Ep\u0026gt;(__u.get_deleter()); return *this; } #else // _LIBCPP_CXX03_LANG private: unique_ptr(unique_ptr\u0026amp;); template \u0026lt;class _Up, class _Ep\u0026gt; unique_ptr(unique_ptr\u0026lt;_Up, _Ep\u0026gt;\u0026amp;); unique_ptr\u0026amp; operator=(unique_ptr\u0026amp;); template \u0026lt;class _Up, class _Ep\u0026gt; unique_ptr\u0026amp; operator=(unique_ptr\u0026lt;_Up, _Ep\u0026gt;\u0026amp;); public: _LIBCPP_INLINE_VISIBILITY unique_ptr() : __ptr_(pointer()) { static_assert(!is_pointer\u0026lt;deleter_type\u0026gt;::value, \u0026#34;unique_ptr constructed with null function pointer deleter\u0026#34;); static_assert(is_default_constructible\u0026lt;deleter_type\u0026gt;::value, \u0026#34;unique_ptr::deleter_type is not default constructible\u0026#34;); } _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t) : __ptr_(pointer()) { static_assert(!is_pointer\u0026lt;deleter_type\u0026gt;::value, \u0026#34;unique_ptr constructed with null function pointer deleter\u0026#34;); } _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) : __ptr_(_VSTD::move(__p)) { static_assert(!is_pointer\u0026lt;deleter_type\u0026gt;::value, \u0026#34;unique_ptr constructed with null function pointer deleter\u0026#34;); } _LIBCPP_INLINE_VISIBILITY operator __rv\u0026lt;unique_ptr\u0026gt;() { return __rv\u0026lt;unique_ptr\u0026gt;(*this); } _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv\u0026lt;unique_ptr\u0026gt; __u) : __ptr_(__u-\u0026gt;release(), _VSTD::forward\u0026lt;deleter_type\u0026gt;(__u-\u0026gt;get_deleter())) {} template \u0026lt;class _Up, class _Ep\u0026gt; _LIBCPP_INLINE_VISIBILITY typename enable_if\u0026lt; !is_array\u0026lt;_Up\u0026gt;::value \u0026amp;\u0026amp; is_convertible\u0026lt;typename unique_ptr\u0026lt;_Up, _Ep\u0026gt;::pointer, pointer\u0026gt;::value \u0026amp;\u0026amp; is_assignable\u0026lt;deleter_type\u0026amp;, _Ep\u0026amp;\u0026gt;::value, unique_ptr\u0026amp;\u0026gt;::type operator=(unique_ptr\u0026lt;_Up, _Ep\u0026gt; __u) { reset(__u.release()); __ptr_.second() = _VSTD::forward\u0026lt;_Ep\u0026gt;(__u.get_deleter()); return *this; } _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d) : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {} #endif // _LIBCPP_CXX03_LANG #if _LIBCPP_STD_VER \u0026lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR) template \u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY typename enable_if\u0026lt;is_convertible\u0026lt;_Up*, _Tp*\u0026gt;::value \u0026amp;\u0026amp; is_same\u0026lt;_Dp, default_delete\u0026lt;_Tp\u0026gt; \u0026gt;::value, unique_ptr\u0026amp;\u0026gt;::type operator=(auto_ptr\u0026lt;_Up\u0026gt; __p) { reset(__p.release()); return *this; } #endif _LIBCPP_INLINE_VISIBILITY ~unique_ptr() { reset(); } _LIBCPP_INLINE_VISIBILITY unique_ptr\u0026amp; operator=(nullptr_t) _NOEXCEPT { reset(); return *this; } _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference\u0026lt;_Tp\u0026gt;::type operator*() const { return *__ptr_.first(); } _LIBCPP_INLINE_VISIBILITY pointer operator-\u0026gt;() const _NOEXCEPT { return __ptr_.first(); } _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT { return __ptr_.first(); } _LIBCPP_INLINE_VISIBILITY deleter_type\u0026amp; get_deleter() _NOEXCEPT { return __ptr_.second(); } _LIBCPP_INLINE_VISIBILITY const deleter_type\u0026amp; get_deleter() const _NOEXCEPT { return __ptr_.second(); } _LIBCPP_INLINE_VISIBILITY _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT { return __ptr_.first() != nullptr; } _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT { pointer __t = __ptr_.first(); __ptr_.first() = pointer(); return __t; } _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT { pointer __tmp = __ptr_.first(); __ptr_.first() = __p; if (__tmp) __ptr_.second()(__tmp); } _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr\u0026amp; __u) _NOEXCEPT { __ptr_.swap(__u.__ptr_); } }; ","permalink":"https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-2/","summary":"\u003ch1 id=\"c智能指针2unique_ptr\"\u003eC++智能指针（2）：unique_ptr\u003c/h1\u003e\n\u003ch2 id=\"分析\"\u003e分析\u003c/h2\u003e\n\u003cp\u003e在使用 AutoPointer 的时候会发生所有权转移和内存泄漏的问题，所以我们可以对 AutoPointer 类稍加修改，修复这两个问题\b。\u003c/p\u003e\n\u003ch3 id=\"所有权转移\"\u003e所有权转移\u003c/h3\u003e\n\u003cp\u003e为了规避可能发生所有权转移的情况，我们可以直接禁止它使用拷贝构造函数和赋值操作符。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    UniquePointer(UniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    UniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e UniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\b但很多时候我们都需要使用到传递指针的操作，如果只是使用 deleted 函数禁止拷贝构造函数和赋值操作符，那么这个智能指针存在的意义就不大了，我们可以通过 move 语义来实现移动构造函数和移动赋值操作符，从而在使用 UniquePointer 的时候可以在特定情况下进行所有权转移。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    UniquePointer(UniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#66d9ef\"\u003enoexcept\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    UniquePointer \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(UniquePointer \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#66d9ef\"\u003enoexcept\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"内存泄漏\"\u003e内存泄漏\u003c/h3\u003e\n\u003cp\u003e为了防止发生内存泄漏，我们可以在UniquePointer的私有成员中增加一个删除器，并\b根据当前指针对象的类型指定删除器，从而防止发生内存泄漏。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDeleter\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e()(T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (p)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e p;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eUniquePointer\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003epointer;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Deleter deleter;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"实现\"\u003e实现\u003c/h2\u003e\n\u003cp\u003e根据unique_ptr的源码，能够大致实现UniquePointer类\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eUniquePointer\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eexplicit\u003c/span\u003e UniquePointer(T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003et, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e D \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ed);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e~\u003c/span\u003eUniquePointer();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    T \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erelease\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereset\u003c/span\u003e(T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    UniquePointer(UniquePointer \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#66d9ef\"\u003enoexcept\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    UniquePointer \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(UniquePointer \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#66d9ef\"\u003enoexcept\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    UniquePointer(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e UniquePointer \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    UniquePointer \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e UniquePointer \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edelete\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003epointer;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    D deleter;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eUniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003eUniquePointer(T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003et, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e D \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ed) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;UniquePointer \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; constructor called.\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e t;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003edeleter \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e d;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eUniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::~\u003c/span\u003eUniquePointer() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;UniquePointer \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; destructor called.\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    deleter(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eT \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eUniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eT \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eUniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eT \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eUniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003erelease() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003enew_pointer \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e new_pointer;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e UniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003ereset(T \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e p) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        deleter(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e p;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eUniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003eUniquePointer(UniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#66d9ef\"\u003enoexcept\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;UniquePointer \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; move constructor called.\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e other.release();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    deleter(std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003emove(other.deleter));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T, \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eUniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eUniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(UniquePointer\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, D\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#66d9ef\"\u003enoexcept\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;UniquePointer \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; assignment operator called.\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003epointer \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e other.pointer) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        reset(other.release());\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        deleter \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003emove(other.deleter);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"测试\"\u003e测试\u003c/h2\u003e\n\u003cp\u003e尝试使用移动构造函数\u003c/p\u003e","title":"C++ 智能指针（2）：unique_ptr"},{"content":"Cookie和Session 为了获取我们自己的提交记录，我们首先要进行登录的操作。但我们都知道HTTP是一种无状态的协议，它的每个请求都是独立的。无论是GET还是POST请求，都包含了处理当前这一条请求的所有信息，\b但它并不会涉及到状态的变化。因此，为了在无状态的HTTP协议上维护一个持久的状态，引入了Cookie和Session的概念，两者都是为了辨识用户相关信息而储存在内存或硬盘上的加密数据。\nCookie是由客户端浏览器维护的。客户端浏览器会在需要时把Cookie保存在内存中，当其再次向该域名相关的网站发出request时，浏览器会把url和Cookie一起作为request的一部分发送给服务器。服务器通过\b解析该Cookie来确认用户的状态，并对Cookie的内容作出相应的修改。一般来说，如果不设置过期时间，非持久\bCookie会保存在内存中，浏览器关闭后就被删除了。\nSession是由服务器维护的。当客户端第一次向服务器发出request后，服务器会为该客户端创建一个Session。当该客户端再次访问服务器时，服务器会根据该Session来\b获取相关信息。一般来说，服务器会为Seesion设置一个失效时间，当距离接收到客户端上一次发送request\b的时间超过这个失效时间后，服务器会主动删除Session。\n两种方法都可以用来维护登录的状态。为了简便起见，本项目目前使用Session作为维护登录状态的方法。\n获取数据 分析 首先我们进入登录页面，打开开发者工具，勾选Preserve log。为了知道在登录时浏览器向服务器提交了哪些数据，我们可以先输入一个错误的用户名和密码，\b\b便于抓包。\n通过分析\u0026quot;login/\u0026ldquo;这条request，我们可以知道我们所需要的一些关键信息，例如headers中的user-agent和referer，表单数据（form data）中的csrfmiddlewaretoken，login和password。显然，user-agent和referer我们可以直接复制下来，login和password是我们填写的用户名和密码。还有一个很陌生的csrfmiddlewaretoken。这是CSRF的中间件token，CSRF是Cross-Site Request Forgery，相关知识可以查询跨站请求伪造的维基百科。那么现在我们就要分析这个token是从何而来。\n获取csrfmiddlewaretoken 我们将刚才获取到的csrfmiddlewaretoken复制下来，在开发者工具中使用搜索功能，可以发现这个csrfmiddlewaretoken出现在了登录之前的一些request对应的response中。例如在刚才打开登录页面，发送GET请求时，response的headers的set-cookie\b中出现了\u0026quot;csrftoken=\u0026hellip;\u0026ldquo;\b，而这里csrftoken的值与我们需要在登录表单中提交的值完全相同。因此，我们可以通过获取刚才的response中的Cookies来获取csrfmiddlewaretoken的值。\n首先我们\b通过发送GET请求来分析一下Cookies的构成\nlogin_url = \u0026#34;https://leetcode.com/accounts/login/\u0026#34; session = requests.session() result = session.get(login_url) print(result) print(type(result.cookies)) for cookie in result.cookies: print(type(cookie)) print(cookie) 得到的结果是\n\u0026lt;Response [200]\u0026gt; 状态码200，表示请求成功 \u0026lt;class 'requests.cookies.RequestsCookieJar'\u0026gt; cookies的类型是CookieJar \u0026lt;class 'http.cookiejar.Cookie'\u0026gt; 第一条cookie的类型是Cookie \u0026lt;Cookie__cfduid=d3e02d4309b848f9369e21671fabbce571548041181 for .leetcode.com/\u0026gt; 第一条\bcookie的信息 \u0026lt;class 'http.cookiejar.Cookie'\u0026gt; 第二条cookie的类型是Cookie \u0026lt;Cookie csrftoken=13mQWE9tYN6g2IrlKY8oMLRc4VhVNoet4j328YdDapW2WC2nf93y5iCuzorovTDl for leetcode.com/\u0026gt; 第二条cookie的信息，也就是我们所需要的csrftoken 这样一来我们便获取到了在提交表单信息时所需要的csrfmiddlewaretoken，之后我们便可以开始着手写登录的相关代码了。\b顺便一提，在使用Django进行后端开发的时候自动生成的\bcsrf token的键也叫csrfmiddlewaretoken，不知道LeetCode是不是用\bDjango作为后端开发框架的。\n实现 首先我们需要在爬虫开始运行之前获取登录信息，将Session作为类的成员变量保存下来，方便在获取submissions时使用。同时我们需要在与爬虫文件\b\b相同的目录下新建config.json，将自己的用户名和密码保存在\b该json文件里，这样就能顺利登陆了。\ndef start_requests(self): self.Login() # 登录 questionset_url = \u0026#34;https://leetcode.com/api/problems/all/\u0026#34; yield scrapy.Request(url=questionset_url, callback=self.ParseQuestionSet) def Login(self): login_url = \u0026#34;https://leetcode.com/accounts/login/\u0026#34; login_headers = { \u0026#34;user_agent\u0026#34;: \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\u0026#39;\u0026#34;, \u0026#34;referer\u0026#34;: \u0026#34;https://leetcode.com/accounts/login/\u0026#34;, # \u0026#34;content-type\u0026#34;: \u0026#34;multipart/form-data; boundary=----WebKitFormBoundary70YlQBtroATwu9Jx\u0026#34; } self.session = requests.session() result = self.session.get(login_url) file = open(\u0026#39;./config.json\u0026#39;, \u0026#39;r\u0026#39;) info = json.load(file) data = {\u0026#34;login\u0026#34;: info[\u0026#34;username\u0026#34;], \u0026#34;password\u0026#34;: inf[\u0026#34;password\u0026#34;], \u0026#34;csrfmiddlewaretoken\u0026#34;: self.session.cookies[\u0026#39;csrftoken\u0026#39;]} self.session.post(login_url, data=data,headers=login_headers) print(\u0026#34;login info: \u0026#34; + str(result)) 注意如果在headers中填写了content-type的值，可能会产生一些奇怪的错误信息，并且后续不能正确地获取自己的submissions，\b只需要user_agent和refere的信息即可。\b\n如果看到输出login info: \u0026lt;Response [200]\u0026gt;\b就代表登录成功了！\n参考资料 Scrapy官方文档\n","permalink":"https://prov1dence.top/posts/leetcode-archiver/leetcode-archiver3/","summary":"\u003ch2 id=\"cookie和session\"\u003eCookie和Session\u003c/h2\u003e\n\u003cp\u003e为了获取我们自己的提交记录，我们首先要进行登录的操作。但我们都知道HTTP是一种无状态的协议，它的每个请求都是独立的。无论是GET还是POST请求，都包含了处理当前这一条请求的所有信息，\b但它并不会涉及到状态的变化。因此，为了在无状态的HTTP协议上维护一个持久的状态，引入了Cookie和Session的概念，两者都是为了辨识用户相关信息而储存在内存或硬盘上的加密数据。\u003c/p\u003e\n\u003cp\u003eCookie是由客户端浏览器维护的。客户端浏览器会在需要时把Cookie保存在内存中，当其再次向该域名相关的网站发出request时，浏览器会把url和Cookie一起作为request的一部分发送给服务器。服务器通过\b解析该Cookie来确认用户的状态，并对Cookie的内容作出相应的修改。一般来说，如果不设置过期时间，非持久\bCookie会保存在内存中，浏览器关闭后就被删除了。\u003c/p\u003e\n\u003cp\u003eSession是由服务器维护的。当客户端第一次向服务器发出request后，服务器会为该客户端创建一个Session。当该客户端再次访问服务器时，服务器会根据该Session来\b获取相关信息。一般来说，服务器会为Seesion设置一个失效时间，当距离接收到客户端上一次发送request\b的时间超过这个失效时间后，服务器会主动删除Session。\u003c/p\u003e\n\u003cp\u003e两种方法都可以用来维护登录的状态。为了简便起见，本项目目前使用Session作为维护登录状态的方法。\u003c/p\u003e\n\u003ch2 id=\"获取数据\"\u003e获取数据\u003c/h2\u003e\n\u003ch3 id=\"分析\"\u003e分析\u003c/h3\u003e\n\u003cp\u003e首先我们进入\u003ca href=\"https://leetcode.com/accounts/login/\"\u003e登录页面\u003c/a\u003e，打开开发者工具，勾选Preserve log。为了知道在登录时浏览器向服务器提交了哪些数据，我们可以先输入一个错误的用户名和密码，\b\b便于抓包。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"7\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Use-Scrapy-to-Crawl-LeetCode/7.png\"\u003e\u003c/p\u003e\n\u003cp\u003e通过分析\u0026quot;login/\u0026ldquo;这条request，我们可以知道我们所需要的一些关键信息，例如headers中的user-agent和referer，表单数据（form data）中的csrfmiddlewaretoken，login和password。显然，user-agent和referer我们可以直接复制下来，login和password是我们填写的用户名和密码。还有一个很陌生的csrfmiddlewaretoken。这是CSRF的中间件token，CSRF是Cross-Site Request Forgery，相关知识可以查询\u003ca href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\"\u003e跨站请求伪造的维基百科\u003c/a\u003e。那么现在我们就要分析这个token是从何而来。\u003c/p\u003e\n\u003ch4 id=\"获取csrfmiddlewaretoken\"\u003e获取csrfmiddlewaretoken\u003c/h4\u003e\n\u003cp\u003e我们将刚才获取到的csrfmiddlewaretoken复制下来，在开发者工具中使用搜索功能，可以发现这个csrfmiddlewaretoken出现在了登录之前的一些request对应的response中。例如在刚才打开登录页面，发送GET请求时，response的headers的set-cookie\b中出现了\u0026quot;csrftoken=\u0026hellip;\u0026ldquo;\b，而这里csrftoken的值与我们需要在登录表单中提交的值完全相同。因此，我们可以通过获取刚才的response中的Cookies来获取csrfmiddlewaretoken的值。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"8\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Use-Scrapy-to-Crawl-LeetCode/8.png\"\u003e\u003c/p\u003e\n\u003cp\u003e首先我们\b通过发送GET请求来分析一下Cookies的构成\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elogin_url = \u0026#34;https://leetcode.com/accounts/login/\u0026#34;\nsession = requests.session()\nresult = session.get(login_url)\nprint(result)\nprint(type(result.cookies))\nfor cookie in result.cookies:\n    print(type(cookie))\n    print(cookie)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e得到的结果是\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;Response [200]\u0026gt;\u003c/code\u003e 状态码200，表示请求成功\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;class 'requests.cookies.RequestsCookieJar'\u0026gt;\u003c/code\u003e cookies的类型是CookieJar\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;class 'http.cookiejar.Cookie'\u0026gt;\u003c/code\u003e 第一条cookie的类型是Cookie\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;Cookie__cfduid=d3e02d4309b848f9369e21671fabbce571548041181 for .leetcode.com/\u0026gt;\u003c/code\u003e 第一条\bcookie的信息\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;class 'http.cookiejar.Cookie'\u0026gt;\u003c/code\u003e 第二条cookie的类型是Cookie\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;Cookie csrftoken=13mQWE9tYN6g2IrlKY8oMLRc4VhVNoet4j328YdDapW2WC2nf93y5iCuzorovTDl for leetcode.com/\u0026gt;\u003c/code\u003e 第二条cookie的信息，也就是我们所需要的csrftoken\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这样一来我们便获取到了在提交表单信息时所需要的csrfmiddlewaretoken，之后我们便可以开始着手写登录的相关代码了。\b顺便一提，在使用Django进行后端开发的时候自动生成的\bcsrf token的键也叫csrfmiddlewaretoken，不知道LeetCode是不是用\bDjango作为后端开发框架的。\u003c/p\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003cp\u003e首先我们需要在爬虫开始运行之前获取登录信息，将Session作为类的成员变量保存下来，方便在获取submissions时使用。同时我们需要在与爬虫文件\b\b相同的目录下新建config.json，将自己的用户名和密码保存在\b该json文件里，这样就能顺利登陆了。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    def start_requests(self):\n        self.Login()    # 登录\n        questionset_url = \u0026#34;https://leetcode.com/api/problems/all/\u0026#34;\n        yield scrapy.Request(url=questionset_url, callback=self.ParseQuestionSet)\n\n    def Login(self):\n    login_url = \u0026#34;https://leetcode.com/accounts/login/\u0026#34;\n    login_headers = {\n        \u0026#34;user_agent\u0026#34;: \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\u0026#39;\u0026#34;,\n        \u0026#34;referer\u0026#34;: \u0026#34;https://leetcode.com/accounts/login/\u0026#34;,\n        # \u0026#34;content-type\u0026#34;: \u0026#34;multipart/form-data; boundary=----WebKitFormBoundary70YlQBtroATwu9Jx\u0026#34;\n    }\n    self.session = requests.session()\n    result = self.session.get(login_url)\n    file = open(\u0026#39;./config.json\u0026#39;, \u0026#39;r\u0026#39;)\n    info = json.load(file)\n    data = {\u0026#34;login\u0026#34;: info[\u0026#34;username\u0026#34;], \u0026#34;password\u0026#34;: inf[\u0026#34;password\u0026#34;],\n            \u0026#34;csrfmiddlewaretoken\u0026#34;: self.session.cookies[\u0026#39;csrftoken\u0026#39;]}\n    self.session.post(login_url, data=data,headers=login_headers)\n    print(\u0026#34;login info: \u0026#34; + str(result))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意如果在headers中填写了content-type的值，可能会产生一些奇怪的错误信息，并且后续不能正确地获取自己的submissions，\b只需要user_agent和refere的信息即可。\b\u003c/p\u003e","title":"LeetCode Archiver(3)： 登录"},{"content":"C++智能指针（1.5）：move语义 move语义 定义 右值引用（Rvalue Referene）是 C++ 11中引入的新特性，它实现了转移语义（Move Sementics）和精确传递（Perfect Forwarding），其主要目的有\n消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 实现 move 语义的实现非常简单，它将传入的参数 _Tp\u0026amp;\u0026amp; __t 使用静态类型转换 static_cast\u0026lt;_Up\u0026amp;\u0026amp;\u0026gt;(__t) 转变成了成了对应类型的右值，也就是说使用 move 语义之后，编译器窃取（一般会在移动构造函数和移动赋值操作符里将原有对象指向 nullptr）了原有对象的右值，并延长了这个右值的生命周期并将其用来赋值给其他的对象，而没有\b对右值做任何拷贝操作。\ntemplate \u0026lt;class _Tp\u0026gt; typename remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp; move(_Tp\u0026amp;\u0026amp; __t) _NOEXCEPT { typedef typename remove_reference\u0026lt;_Tp\u0026gt;::type _Up; return static_cast\u0026lt;_Up\u0026amp;\u0026amp;\u0026gt;(__t); } 测试 \b定义一个 Object 类和一个 MoveObject 函数使用 move 语义返回一个 Object 的类对象，可以看到在 MoveObject 函数返回右值后，obj 对象调用了移动构造函数。\nclass Object { public: Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Construct\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(const Object \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(Object \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Destruct\u0026#34; \u0026lt;\u0026lt; std::endl; } void Print() { std::cout \u0026lt;\u0026lt; \u0026#34;Print\u0026#34; \u0026lt;\u0026lt; std::endl; } }; Object MoveObject() { Object obj; return move(obj); } int main() { Object obj = MoveObject(); return 0; } /* output: Construct Move Destruct Destruct */ 返回值优化（RVO，Return value optimisation） 返回值优化是一种编译器优化技术，允许编译器在调用点（call site）直接构造函数的返回值。\n定义一个 CopyObject 函数返回一个 Object 的类对象，原本 Function 函数在返回时应该会进行一次拷贝，然而调试结果却显示 obj 对象只在 Function 函数中被构造了一次，在程序结束时被析构了一次。这是因为编译器使用了 RVO 机制，这里 Function 函数返回的是一个左值，\b所以又称命名返回值优化（NRVO），在 C++ 11 里被称为拷贝省略（Copy Elision）。\nObject CopyObject() { Object obj; return obj; // NRVO (named return value optimisation) } int main() { Obj obj = Function(); return 0; } /* output: Construct Destruct */ 如果在 MoveObject 函数中使用move语义进行返回，函数实际返回的\b是一个右值\b引用（Obj\u0026amp;\u0026amp;），而不是函数定义中的对象（Obj），没有触发 RVO。也就是说，要触发 RVO 机制，必须保证函数实际的返回值类型和函数定义中的返回值类型一致。\nObject MoveObject() { Object obj; return move(obj); } int main() { Object obj = MoveObject(); return 0; } /* output: Construct Move Destruct Destruct */ 如果把函数返回值类型也改为右值引用，那么 main 函数中的 obj 对象也会使用移动构造函数，触发 RVO 机制。\nObject \u0026amp;\u0026amp;MoveObject() { Object obj; return move(obj); } int main() { Object obj = MoveObject(); return 0; } /* output: Construct Destruct Move Destruct */ 在 CopyObject 函数返回时增加判断条件，会发现其返回时也会调用移动构造函数，而没有触发 RVO 机制。没有触发 RVO 机制是因为编译器会使用父堆栈帧（parent stack frame）来避免返回值拷贝，但如果在返回时使用了判断语句，编译器在编译时将不能确定将哪一个作为返回值，因此不会触发 RVO 机制；而调用移动构造函数是因为在使用左值返回时编译器会优先使用移动构造函数，不支持移动构造时才调用拷贝构造函数。\nObject CopyObject(bool flag) { Object obj1, obj2; if (flag) return obj1; return obj2; } int main() { Object obj = CopyObject(true); return 0; } /* output: Construct Construct Move Destruct Destruct Destruct */ 参考 RVO V.S. std::move\n右值引用与转移语义\n","permalink":"https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1.5/","summary":"\u003ch1 id=\"c智能指针15move语义\"\u003eC++智能指针（1.5）：move语义\u003c/h1\u003e\n\u003ch2 id=\"move语义\"\u003emove语义\u003c/h2\u003e\n\u003ch3 id=\"定义\"\u003e定义\u003c/h3\u003e\n\u003cp\u003e右值引用（Rvalue Referene）是 C++ 11中引入的新特性，它实现了转移语义（Move Sementics）和精确传递（Perfect Forwarding），其主要目的有\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。\u003c/li\u003e\n\u003cli\u003e能够更简洁明确地定义泛型函数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003cp\u003emove 语义的实现非常简单，它将传入的参数 _Tp\u0026amp;\u0026amp; __t 使用静态类型转换 static_cast\u0026lt;_Up\u0026amp;\u0026amp;\u0026gt;(__t) 转变成了成了对应类型的右值，也就是说使用 move 语义之后，编译器窃取（一般会在移动构造函数和移动赋值操作符里将原有对象指向 nullptr）了原有对象的右值，并延长了这个右值的生命周期并将其用来赋值给其他的对象，而没有\b对右值做任何拷贝操作。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_Tp\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e remove_reference\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e_Tp\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003etype\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emove(_Tp\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e __t) _NOEXCEPT\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e remove_reference\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e_Tp\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003etype _Up;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estatic_cast\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e_Up\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u0026gt;\u003c/span\u003e(__t);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"测试\"\u003e测试\u003c/h3\u003e\n\u003cp\u003e\b定义一个 Object 类和一个 MoveObject 函数使用 move 语义返回一个 Object 的类对象，可以看到在 MoveObject 函数返回右值后，obj 对象调用了移动构造函数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eObject\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object() { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Construct\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Object \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eother) { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Copy\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object(Object \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#66d9ef\"\u003enoexcept\u003c/span\u003e { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Move\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e~\u003c/span\u003eObject() { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Destruct\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePrint\u003c/span\u003e() { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Print\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eObject \u003cspan style=\"color:#a6e22e\"\u003eMoveObject\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object obj;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e move(obj);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object obj \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e MoveObject();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eoutput:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eConstruct\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eMove\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eDestruct\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eDestruct\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"返回值优化rvoreturn-value-optimisation\"\u003e返回值优化（RVO，Return value optimisation）\u003c/h3\u003e\n\u003cp\u003e返回值优化是一种编译器优化技术，允许编译器在调用点（\u003ca href=\"https://en.wikipedia.org/wiki/Call_site\"\u003ecall site\u003c/a\u003e）直接构造函数的返回值。\u003c/p\u003e","title":"C++ 智能指针（1.5）：move 语义"},{"content":"C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类\nclass Object { public: Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Construct\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(const Object \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(Object \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Destruct\u0026#34; \u0026lt;\u0026lt; std::endl; } void Print() { std::cout \u0026lt;\u0026lt; \u0026#34;Print\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 创建一个指向 Object 类型的指针\nint main() { Object *o = new Object(); o-\u0026gt;Print(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象\nint main() { Object *o1 = new Object(); o1-\u0026gt;Print(); Object o2 = Object(); o2.Print(); return 0; } /* output: Construct Print Construct Print Destruct */ 产生这样的结果是因为对象创建在栈（stack）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。\n实现 根据auto_ptr的源码，能够大致实现 AutoPointer 类\ntemplate\u0026lt;typename T\u0026gt; class AutoPointer { public: explicit AutoPointer(T *t); ~AutoPointer(); T \u0026amp;operator*(); T *operator-\u0026gt;(); T *release(); void reset(T *p); AutoPointer(AutoPointer\u0026lt;T\u0026gt; \u0026amp;other); AutoPointer\u0026lt;T\u0026gt; \u0026amp;operator=(AutoPointer\u0026lt;T\u0026gt; const \u0026amp;other); private: T *pointer; }; template\u0026lt;typename T\u0026gt; AutoPointer\u0026lt;T\u0026gt;::AutoPointer(T *t) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; this-\u0026gt;pointer = t; } template\u0026lt;typename T\u0026gt; AutoPointer\u0026lt;T\u0026gt;::~AutoPointer() { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; delete this-\u0026gt;pointer; } template\u0026lt;typename T\u0026gt; T \u0026amp;AutoPointer\u0026lt;T\u0026gt;::operator*() { return *this-\u0026gt;pointer; } template\u0026lt;typename T\u0026gt; T *AutoPointer\u0026lt;T\u0026gt;::operator-\u0026gt;() { return this-\u0026gt;pointer; } template\u0026lt;typename T\u0026gt; T *AutoPointer\u0026lt;T\u0026gt;::release() { T *new_pointer = this-\u0026gt;pointer; this-\u0026gt;pointer = nullptr; return new_pointer; } template\u0026lt;typename T\u0026gt; void AutoPointer\u0026lt;T\u0026gt;::reset(T *p) { if (this-\u0026gt;pointer != p) { delete this-\u0026gt;pointer; this-\u0026gt;pointer = p; } } template\u0026lt;typename T\u0026gt; AutoPointer\u0026lt;T\u0026gt;::AutoPointer(AutoPointer\u0026lt;T\u0026gt; \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; copy constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; this-\u0026gt;pointer = other.release(); } template\u0026lt;typename T\u0026gt; AutoPointer\u0026lt;T\u0026gt; \u0026amp;AutoPointer\u0026lt;T\u0026gt;::operator=(AutoPointer\u0026lt;T\u0026gt; const \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;AutoPointer \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; assignment operator called.\u0026#34; \u0026lt;\u0026lt; std::endl; if (this-\u0026gt;pointer != other.pointer) this-\u0026gt;reset(other.release()); return *this; } 构造函数直接将 AutoPointer 类的 pointer 指针指向传入的参数指针所指向的地址 拷贝构造函数先对参数对象的指针进行 release 操作，也就是将参数对象的私有成员 pointer 指针置为 nullptr 并返回其原本指向的地址，然后将自身的 pointer 指向这个地址 赋值操作符先判断传入的参数是否是当前的 AutoPointer 类对象本身，如果是的话直接返回 this 指针，否则先对参数对象的指针进行 release 操作，并 delete 掉当前对象的 pointer，再将 pointer 指向参数对象的 pointer 原本指向的地址，这样的实现有效地规避了迷途指针（也称悬空指针或野指针）。 测试 创建单个 AutoPointer 类对象时能够正常使用。\nint main() { Object *o = new Object(); AutoPointer\u0026lt;Object\u0026gt; a1(o); (*a1).Print(); a1-\u0026gt;Print(); return 0; } /* output: Construct AutoPointer 0x7fe680c02ab0 constructor called. Print Print AutoPointer 0x7fe680c02ab0 destructor called. Destruct */ 创建两个 AutoPointer 类对象时如果使用同一个 Object 指针进行初始化，那么在程序退出时 Object 对象会被两个 AutoPointer 类对象各析构一次，也就是说同一块地址会被 delete 两次，造成运行时报错。\nint main() { Object *o = new Object(); AutoPointer\u0026lt;Object\u0026gt; a1(o); AutoPointer\u0026lt;Object\u0026gt; a2(o); return 0; } /* output: Construct AutoPointer 0x7ffee3fa0178 constructor called. AutoPointer 0x7ffee3fa0170 constructor called. AutoPointer 0x7ffee3fa0170 destructor called. Destruct AutoPointer 0x7ffee3fa0178 destructor called. Destruct cpp(9015,0x1197a25c0) malloc: *** error for object 0x7fe9dec02b40: pointer being freed was not allocated cpp(9015,0x1197a25c0) malloc: *** set a breakpoint in malloc_error_break to debug */ 使用拷贝构造函数将一个 AutoPointer 类对象 a1 拷贝给另一个 AutoPointer 类对象 a2 时，Object 指针 o 原本是属于 a1 的，在 a2 调用拷贝构造函数之后，a1 的 pointer 变成了空指针，而 s2 拥有了指针 o，造成了所有权转移。\nint main() { Object *o = new Object(); AutoPointer\u0026lt;Object\u0026gt; a1(o); AutoPointer\u0026lt;Object\u0026gt; a2(a1); return 0; } /* output: Construct AutoPointer 0x7fd15bc02ab0 constructor called. AutoPointer 0x7fd15bc02ab0 copy constructor called. AutoPointer 0x7fd15bc02ab0 destructor called. Destruct AutoPointer 0x0 destructor called. */ 使用赋值操作符也会有所有权转移的问题。\nint main() { Object *o = new Object(); AutoPointer\u0026lt;Object\u0026gt; a1(o); AutoPointer\u0026lt;Object\u0026gt; a2 = a1; return 0; } /* output: Construct AutoPointer 0x7ff5d5402ab0 constructor called. AutoPointer 0x7ff5d5402ab0 copy constructor called. AutoPointer 0x7ff5d5402ab0 destructor called. Destruct AutoPointer 0x0 destructor called. */ 总结 AutoPointer 有效地解决了野指针问题，但又会引入一些其他的问题，例如\n所有权转移\n将 AutoPointer 作为参数进行拷贝构造或赋值操作时造成所有权转移 内存泄漏\n在析构函数中使用了delete进行指针的销毁，但如果以数组指针进行初始化 AutoPointer\u0026lt;int\u0026gt; s1(new int[10]) 会因为没有销毁数组\b的其它元素而造成内存泄漏\b auto_ptr源码 template\u0026lt;class _Tp\u0026gt; class _LIBCPP_TEMPLATE_VIS auto_ptr { private: _Tp* __ptr_; public: typedef _Tp element_type; _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {} _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr\u0026amp; __p) throw() : __ptr_(__p.release()) {} template\u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr\u0026lt;_Up\u0026gt;\u0026amp; __p) throw() : __ptr_(__p.release()) {} _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026amp; operator=(auto_ptr\u0026amp; __p) throw() {reset(__p.release()); return *this;} template\u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026amp; operator=(auto_ptr\u0026lt;_Up\u0026gt;\u0026amp; __p) throw() {reset(__p.release()); return *this;} _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026amp; operator=(auto_ptr_ref\u0026lt;_Tp\u0026gt; __p) throw() {reset(__p.__ptr_); return *this;} _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp\u0026amp; operator*() const throw() {return *__ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* operator-\u0026gt;() const throw() {return __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* release() throw() { _Tp* __t = __ptr_; __ptr_ = 0; return __t; } _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw() { if (__ptr_ != __p) delete __ptr_; __ptr_ = __p; } _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref\u0026lt;_Tp\u0026gt; __p) throw() : __ptr_(__p.__ptr_) {} template\u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref\u0026lt;_Up\u0026gt;() throw() {auto_ptr_ref\u0026lt;_Up\u0026gt; __t; __t.__ptr_ = release(); return __t;} template\u0026lt;class _Up\u0026gt; _LIBCPP_INLINE_VISIBILITY operator auto_ptr\u0026lt;_Up\u0026gt;() throw() {return auto_ptr\u0026lt;_Up\u0026gt;(release());} }; ","permalink":"https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1/","summary":"\u003ch1 id=\"c智能指针1auto_ptr\"\u003eC++智能指针（1）：auto_ptr\u003c/h1\u003e\n\u003ch2 id=\"分析\"\u003e分析\u003c/h2\u003e\n\u003cp\u003eC++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eObject\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object() { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Construct\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Object \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003eother) { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Copy\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object(Object \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003eother) \u003cspan style=\"color:#66d9ef\"\u003enoexcept\u003c/span\u003e { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Move\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e~\u003c/span\u003eObject() { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Destruct\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePrint\u003c/span\u003e() { std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Print\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e创建一个指向 Object 类型的指针\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eo \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Object();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    o\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003ePrint();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eoutput:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eConstruct\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003ePrint\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eo1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Object();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    o1\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003ePrint();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Object o2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Object();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    o2.Print();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eoutput:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eConstruct\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003ePrint\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eConstruct\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003ePrint\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003eDestruct\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e产生这样的结果是因为对象创建在栈（\u003ca href=\"https://isocpp.org/blog/2015/09/stack-heap-pool-tony-bulldozer00-bd00-dasilva\"\u003estack\u003c/a\u003e）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。\u003c/p\u003e","title":"C++ 智能指针（1）：auto_ptr"},{"content":"创建爬虫 在新建好项目后，用PyCharm或其他IDE打开该项目。进入该项目文件夹，使用genspider命令新建一个爬虫：\ncd scrapy_project scrapy genspider QuestionSetSpider leetcode.com 其中QuestionSetSpider是爬虫的名字，leetcode.com是我们打算爬取的网站的域名。\b\n新建好爬虫之后可以看到在项目的spiders文件夹下新增了一个名为 QuestionSetSpider.py的文件，这就是我们刚才新建的爬虫文件。这个爬虫文件会自动生成以下代码\n# -*- coding: utf-8 -*- import scrapy class QuestionSetSpider(scrapy.Spider): name = \u0026#39;QuestionSetSpider\u0026#39; allowed_domains = [\u0026#39;leetcode.com\u0026#39;] start_urls = [\u0026#39;http://leetcode.com/\u0026#39;] def parse(self, response): pass QuestionSetSpider类继承自scrapy.Spider，也就是scrapy框架中所有爬虫的基类； self.name属性是该爬虫的名字，在该爬虫文件的外部可以通过这个属性获取\b当前爬虫； self.allowed_domains是当前爬虫文件可以访问的域名列表，如果在爬取页面时进入了一个该域名以外的url会抛出错误； self.start_urls是一个url列表，基类中定义了start_requests函数，它会遍历self.start_urls，并对每一个url调用scrapy.Request(url, dont_filter=True)，为了实现爬取题目的需求，我们需要重写self.start_urls函数 获取题目详细信息 分析 LeetCode使用了GraphQL进行数据的查询和传输，大部分页面都是通过JS渲染生成的动态页面，所以无法直接从页面上获取标签，即使使用提供JavaScript渲染服务的库（例如Splash）也无法获取全部的数据，所以\b只能通过发送请求来获取数据。\n为了爬取题目的详细信息，我们首先要从题目列表进入每个题目对应的链接。\n首先打开leetcode的problem列表，按F12打开Chrome的开发者工具，进入Network标签栏，勾选上Preserve log，刷新该页面。\n可以看到，网页向 https://leetcode.com/api/problems/all/ 发送了一个名为\u0026quot;all/\u0026ldquo;的GET类型的Request，这就是获取所有题目链接和相关信息的请求。如果此时已经安装了Toggle JavaScript插件，我们可以直接右键点击“Open in new tab”，查看该请求返回的Response。\n更方便的方法是使用postman向服务器发送一个相同的Request，并将其保存下来，这样如果我们下次需要查看相应的Response的时候就不需要再使用开发者工具了。\n返回的Response是一个json对象，其中的\u0026quot;stat_status_pairs\u0026quot;\b键所对应的值是所有包含题目信息\b的list，而列表中的[\u0026ldquo;stat\u0026rdquo;][\u0026ldquo;question__title_slug\u0026rdquo;]就是题目所在的页面。以Largest Perimeter Triangle为例，将其title_slug拼接到https://leetcode.com/problems/ 后，进入页面https://leetcode.com/problems/largest-perimeter-triangle/ 。同样地，打开开发者工具，\b刷新页面，可以看到服务器返回了很多项graphql的查询数据，通过查看Request Payload可以找到其中operationName为\u0026quot;questionData\u0026quot;的一项，这就是当前题目的详细信息。\n将Payload复制粘贴到postman的Body中，在Headers中\b设置Content-Type为application/json，发送请求，可以看到返回的是一个json对象，\b包含了该题目所对应的所有信息。\n接下来我们就可以对该题目的信息进行处理了。\n实现 为了获取题目列表的json对象，我们需要先重写start_requests函数。\ndef start_requests(self): self.Login() # 用户登录，\b后续会用到 questionset_url = \u0026#34;https://leetcode.com/api/problems/all/\u0026#34; yield scrapy.Request(url=questionset_url, callback=self.ParseQuestionSet) Request是scrapy的一个类对象，功能类似于requests库中的get函数，可以让scrapy框架中的Downloader向url发送一个get请求，并将获取的response交给指定的爬虫文件中的回调函数进行相应的处理，其构造函数如下\nclass Request(object_ref): def __init__(self, url, callback=None, method=\u0026#39;GET\u0026#39;, headers=None, body=None, cookies=None, meta=None, encoding=\u0026#39;utf-8\u0026#39;, priority=0, dont_filter=False, errback=None, flags=None): ... 在获取到json对象之后，可以通过遍历\u0026quot;stat_status_pairs\u0026quot;键所对应的列表，并取出[\u0026ldquo;stat\u0026rdquo;][\u0026ldquo;question__title_slug\u0026rdquo;]的值，得到题目的title_slug。此时我们不再需要进行\b打开题目相关页面的操作，直接向\bGraphQL发送查询详细信息的\brequest即可。\n我们可以从postman直接获取到发送请求相关的代码。因为每个题目的title_slug不同，我们可以将Payload中titleSlug后的字段改为一个不会重复的独特的字符串，在每一次获取到新的title_slug之后用replace函数替换它，\b发送新的请求，然后再将其替换回独特的字符串。\n准备好Payload和Headers之后，我们可以使用FormRequest发送POST请求向GraphQL查询数据。FormRequest是scrapy的一个类对象，功能类似于requests库中的post函数，让scrapy框架中的Downloader向url发送一个post请求，并将获取的response交给指定的爬虫文件中的回调函数进行相应的处理。此处在发送\bPOST请求之后response被交给ParseQuestionData函数进行处理。\nquestion_payload = \u0026#34;{\\n \\\u0026#34;operationName\\\u0026#34;: \\\u0026#34;questionData\\\u0026#34;,\\n \\\u0026#34;variables\\\u0026#34;: {\\n \\\u0026#34;titleSlug\\\u0026#34;: \\\u0026#34;QuestionName\\\u0026#34;\\n },\\n \\\u0026#34;query\\\u0026#34;: \\\u0026#34;query questionData($titleSlug: String!) {\\\\n question(titleSlug: $titleSlug) {\\\\n questionId\\\\n questionFrontendId\\\\n boundTopicId\\\\n title\\\\n titleSlug\\\\n content\\\\n translatedTitle\\\\n translatedContent\\\\n isPaidOnly\\\\n difficulty\\\\n likes\\\\n dislikes\\\\n isLiked\\\\n similarQuestions\\\\n contributors {\\\\n username\\\\n profileUrl\\\\n avatarUrl\\\\n __typename\\\\n }\\\\n langToValidPlayground\\\\n topicTags {\\\\n name\\\\n slug\\\\n translatedName\\\\n __typename\\\\n }\\\\n companyTagStats\\\\n codeSnippets {\\\\n lang\\\\n langSlug\\\\n code\\\\n __typename\\\\n }\\\\n stats\\\\n hints\\\\n solution {\\\\n id\\\\n canSeeDetail\\\\n __typename\\\\n }\\\\n status\\\\n sampleTestCase\\\\n metaData\\\\n judgerAvailable\\\\n judgeType\\\\n mysqlSchemas\\\\n enableRunCode\\\\n enableTestMode\\\\n envInfo\\\\n __typename\\\\n }\\\\n}\\\\n\\\u0026#34;\\n}\\n\u0026#34; graphql_url = \u0026#34;https://leetcode.com/graphql\u0026#34; def ParseQuestionSet(self, response): headers = { \u0026#34;user_agent\u0026#34;: \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\u0026#39;\u0026#34;, \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34; # necessary } questionSet = json.loads(response.text) questionSet = questionSet[\u0026#34;stat_status_pairs\u0026#34;] for question in questionSet: title_slug = question[\u0026#34;stat\u0026#34;][\u0026#34;question__title_slug\u0026#34;] self.question_payload = self.question_payload.replace(\u0026#34;QuestionName\u0026#34;, title_slug) yield scrapy.FormRequest(url=self.graphql_url, callback=self.ParseQuestionData, headers=headers, body=self.question_payload) self.question_payload = self.question_payload.replace(title_slug, \u0026#34;QuestionName\u0026#34;) 现在数据已经获取到了，我们需要在items.py文件中定义一个类用来存储题目的详细信息。\bitems.py文件中的类继承自scrapy.Item类，是提供给scrapy框架中的组件Item Pipeline进行处理的统一的的数据结构。\nimport scrapy class QuestionDataItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() id = scrapy.Field() title = scrapy.Field() content = scrapy.Field() submission_list = scrapy.Field() topics = scrapy.Field() difficulty = scrapy.Field() ac_rate = scrapy.Field() likes = scrapy.Field() dislikes = scrapy.Field() slug = scrapy.Field() \b定义了QuestionDataItem类之后可以进\b入ParseQuestionData函数开始对题目详细信息的提取，我们可以根据需求提取出题目的id，title，content，topics，difficulty等信息，用一个QuestionDataItem对象来存储这些数据，然后\b进行yield questionDataItem操作，将这个对象\b交给Item Pipeline进行处理。\ndef ParseQuestionData(self, response): questionData = json.loads(response.text)[\u0026#34;data\u0026#34;][\u0026#34;question\u0026#34;] questionDataItem = QuestionDataItem() questionDataItem[\u0026#34;id\u0026#34;] = questionData[\u0026#34;questionFrontendId\u0026#34;] questionDataItem[\u0026#34;title\u0026#34;] = questionData[\u0026#34;title\u0026#34;] questionDataItem[\u0026#34;content\u0026#34;] = questionData[\u0026#34;content\u0026#34;] topics = [] for topic in questionData[\u0026#34;topicTags\u0026#34;]: topics.append(topic[\u0026#34;name\u0026#34;]) if len(topics) == 0: topics.append(\u0026#34;None\u0026#34;) questionDataItem[\u0026#34;topics\u0026#34;] = topics questionDataItem[\u0026#34;difficulty\u0026#34;] = questionData[\u0026#34;difficulty\u0026#34;] stats = json.loads(questionData[\u0026#34;stats\u0026#34;]) questionDataItem[\u0026#34;ac_rate\u0026#34;] = stats[\u0026#34;acRate\u0026#34;] questionDataItem[\u0026#34;likes\u0026#34;] = questionData[\u0026#34;likes\u0026#34;] questionDataItem[\u0026#34;dislikes\u0026#34;] = questionData[\u0026#34;dislikes\u0026#34;] questionDataItem[\u0026#34;slug\u0026#34;] = questionData[\u0026#34;titleSlug\u0026#34;] submission_list = self.GetSubmissionList(questionDataItem[\u0026#34;slug\u0026#34;]) questionDataItem[\u0026#34;submission_list\u0026#34;] = submission_list yield questionDataItem 至此题目信息的爬取就完成了。\n参考资料 Scrapy官方文档\nPostman官方文档\n","permalink":"https://prov1dence.top/posts/leetcode-archiver/leetcode-archiver2/","summary":"\u003ch2 id=\"创建爬虫\"\u003e创建爬虫\u003c/h2\u003e\n\u003cp\u003e在新建好项目后，用PyCharm或其他IDE打开该项目。进入该项目文件夹，使用\u003ccode\u003egenspider\u003c/code\u003e命令新建一个爬虫：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecd scrapy_project\nscrapy genspider QuestionSetSpider leetcode.com\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e其中QuestionSetSpider是爬虫的名字，leetcode.com是我们打算爬取的网站的域名。\b\u003c/p\u003e\n\u003cp\u003e新建好爬虫之后可以看到在项目的spiders文件夹下新增了一个名为 QuestionSetSpider.py的文件，这就是我们刚才新建的爬虫文件。这个爬虫文件会自动生成以下代码\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# -*- coding: utf-8 -*-\nimport scrapy\n\nclass QuestionSetSpider(scrapy.Spider):\n    name = \u0026#39;QuestionSetSpider\u0026#39;\n    allowed_domains = [\u0026#39;leetcode.com\u0026#39;]\n    start_urls = [\u0026#39;http://leetcode.com/\u0026#39;]\n\n    def parse(self, response):\n        pass\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eQuestionSetSpider类继承自scrapy.Spider，也就是scrapy框架中所有爬虫的基类；\u003c/li\u003e\n\u003cli\u003eself.name属性是该爬虫的名字，在该爬虫文件的外部可以通过这个属性获取\b当前爬虫；\u003c/li\u003e\n\u003cli\u003eself.allowed_domains是当前爬虫文件可以访问的域名列表，如果在爬取页面时进入了一个该域名以外的url会抛出错误；\u003c/li\u003e\n\u003cli\u003eself.start_urls是一个url列表，基类中定义了start_requests函数，它会遍历self.start_urls，并对每一个url调用scrapy.Request(url, dont_filter=True)，为了实现爬取题目的需求，我们需要重写self.start_urls函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"获取题目详细信息\"\u003e获取题目详细信息\u003c/h2\u003e\n\u003ch3 id=\"分析\"\u003e分析\u003c/h3\u003e\n\u003cp\u003eLeetCode使用了GraphQL进行数据的查询和传输，大部分页面都是通过JS渲染生成的动态页面，所以无法直接从页面上获取标签，即使使用提供JavaScript渲染服务的库（例如Splash）也无法获取全部的数据，所以\b只能通过发送请求来获取数据。\u003c/p\u003e\n\u003cp\u003e为了爬取题目的详细信息，我们首先要从题目列表进入每个题目对应的链接。\u003c/p\u003e\n\u003cp\u003e首先打开leetcode的\u003ca href=\"https://leetcode.com/problemset/all/\"\u003eproblem\u003c/a\u003e列表，按F12打开Chrome的开发者工具，进入Network标签栏，勾选上Preserve log，刷新该页面。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"1\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Use-Scrapy-to-Crawl-LeetCode/1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到，网页向 \u003ca href=\"https://leetcode.com/api/problems/all/\"\u003ehttps://leetcode.com/api/problems/all/\u003c/a\u003e 发送了一个名为\u0026quot;all/\u0026ldquo;的GET类型的Request，这就是获取所有题目链接和相关信息的请求。如果此时已经安装了Toggle JavaScript插件，我们可以直接右键点击“Open in new tab”，查看该请求返回的Response。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"2\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Use-Scrapy-to-Crawl-LeetCode/2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e更方便的方法是使用postman向服务器发送一个相同的Request，并将其保存下来，这样如果我们下次需要查看相应的Response的时候就不需要再使用开发者工具了。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"3\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Use-Scrapy-to-Crawl-LeetCode/3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e返回的Response是一个json对象，其中的\u0026quot;stat_status_pairs\u0026quot;\b键所对应的值是所有包含题目信息\b的list，而列表中的[\u0026ldquo;stat\u0026rdquo;][\u0026ldquo;question__title_slug\u0026rdquo;]就是题目所在的页面。以Largest Perimeter Triangle为例，将其title_slug拼接到https://leetcode.com/problems/ 后，进入页面https://leetcode.com/problems/largest-perimeter-triangle/ 。同样地，打开开发者工具，\b刷新页面，可以看到服务器返回了很多项graphql的查询数据，通过查看Request Payload可以找到其中operationName为\u0026quot;questionData\u0026quot;的一项，这就是当前题目的详细信息。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"4\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Use-Scrapy-to-Crawl-LeetCode/4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e将Payload复制粘贴到postman的Body中，在Headers中\b设置Content-Type为application/json，发送请求，可以看到返回的是一个json对象，\b包含了该题目所对应的所有信息。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"5\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Use-Scrapy-to-Crawl-LeetCode/5.png\"\u003e\u003c/p\u003e\n\u003cp\u003e接下来我们就可以对该题目的信息进行处理了。\u003c/p\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003cp\u003e为了获取题目列表的json对象，我们需要先重写start_requests函数。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edef start_requests(self):\n        self.Login() # 用户登录，\b后续会用到\n        questionset_url = \u0026#34;https://leetcode.com/api/problems/all/\u0026#34;\n        yield scrapy.Request(url=questionset_url, callback=self.ParseQuestionSet)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRequest是scrapy的一个类对象，功能类似于requests库中的get函数，可以让scrapy框架中的Downloader向url发送一个get请求，并将获取的response交给指定的爬虫文件中的回调函数进行相应的处理，其构造函数如下\u003c/p\u003e","title":"LeetCode Archiver(2)：获取题目信息"},{"content":"在Google Cloud Platform上运行Jupyter Notebook 简介 本文取材自 Amulya Aankul 发布在 Medium 的 Running Jupyter Notebook on Google Cloud Platform in 15 min，主要介绍如何在Google Cloud Platform上搭建服务器，并在服务器上安装和运行Jupyter Notebook。\n服务器搭建 \b创建账号 首先在Google Cloud Platform上创建一个账号。\n创建新项目 点击左上角\u0026quot;Google Cloud Platform\u0026quot;右边的三个点，点击\u0026quot;NEW PROJECT\u0026quot;创建新项目。\n创建虚拟机 进入刚才创建的项目，从左侧边栏点击 Compute Engine -\u0026gt; VM instances 进入虚拟机页面。点击Create创建一个新的虚拟机实例（VM instance）\n)\n根据需求填写和选择 Name, Region, Zone, Machine Type和Boot Disk。在\b Firewall 选项中选中 Allow HTTP traffic 和 Allow HTTPS traffic, 在下方的 Disks 选项卡中取消勾选 Delete boot disk when instance is deleted。最后点击\b Create，虚拟机实例就创建好了。\n设置静态IP 默认情况下，外网IP是动态变化的，为了方便访问服务器，我们可以将其设置为静态的。\n从左侧边栏点击 VPC Network -\u0026gt; External IP Address，可以看到当前项目下的所有虚拟机，依次点击虚拟机实例对应的Type标签和Static标签，将外网IP设置为静态的。\n设置防火墙 从左侧边栏点击 VPC Network -\u0026gt; Firewall rules，点击上方的 CREATE FIREWALL RULE，创建一个新的防火墙规则。\n根据需求填写 Name，将 Targets 勾选为 All instances in the network，在 Source IP ranges 中填写 0.0.0.0/0，在 Protocols and ports 中勾选 tcp，填写一个端口范围，用于之后访问 Jupyter Notebook。\n连接虚拟机 回到VM instances，根据外网IP\b连接上刚才创建的虚拟机。可以直接从谷歌提供的web终端连接，也可以通过其他途径连接。Windows 下可以使用Putty，\bLinux \b和 Unix 系统可以直接使用SSH连接。\n配置 Jupyter Notebook 安装 Jupyter Notebook 在终端中输入wget http://repo.continuum.io/archive/Anaconda3-4.0.0-Linux-x86_64.sh 获取 Anaconda 3 \b的安装文件\n接下来输入bash Anaconda3-4.0.0-Linux-x86_64.sh 运行该文件，并根据屏幕提示安装 Anaconda 3。\n安装好之后读取启动文件source ~/.bashrc 以使用 Anaconda 3\n修改配置文件 创建 Jupyter Notebook 的配置文件jupyter notebook --generate-config\n使用Vim或其他编辑器打开该配置文件vi ~/.jupyter/jupyter_notebook_config.py\n在该文件中加入相应的设置\nc = get_config() c.NotebookApp.ip = \u0026#39;*\u0026#39; c.NotebookApp.open_browser = False c.NotebookApp.port = \u0026lt;Port Number\u0026gt; 在 \u0026lt;Port Number\u0026gt; 处填写 Jupyter Notebook 使用的端口号，\b该端口号应该是在防火墙规则的端口范围之内的，否则将不能够通过外网IP和端口号访问 Jupyter Notebook。填写完之后使用:wq命令保存该文件。\n启动 Jupyter Notebook 最后，在终端中输入 jupyter-notebook --no-browser --port=\u0026lt;Port Number\u0026gt; \b来启动\b Jupyter Notebook，当然也可以使用 nohup jupyter-notebook --no-browser --port=\u0026lt;Port Number\u0026gt; \u0026gt; jupyter.log \u0026amp; 指令忽略挂起信号，让 Jupyter Notebook 一直在后台运行，并将控制台信息输出到 jupyter.log 文件中。\n最后在浏览器中输入 IP\b 地址和端口号（例如156.73.83.51:4813）就能打开 Jupyter Notebook 了！\n参考资料 Running Jupyter Notebook on Google Cloud Platform in 15 min\n","permalink":"https://prov1dence.top/posts/cloud/run-jupyter-notebook-on-gcp/","summary":"\u003ch1 id=\"在google-cloud-platform上运行jupyter-notebook\"\u003e在Google Cloud Platform上运行Jupyter Notebook\u003c/h1\u003e\n\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e本文取材自 \u003ca href=\"https://towardsdatascience.com/@aankul.a\"\u003eAmulya Aankul\u003c/a\u003e 发布在 \u003ca href=\"https://medium.com/\"\u003eMedium\u003c/a\u003e 的 \u003ca href=\"https://towardsdatascience.com/running-jupyter-notebook-in-google-cloud-platform-in-15-min-61e16da34d52\"\u003eRunning Jupyter Notebook on Google Cloud Platform in 15 min\u003c/a\u003e，主要介绍如何在Google Cloud Platform上搭建服务器，并在服务器上安装和运行Jupyter Notebook。\u003c/p\u003e\n\u003ch2 id=\"服务器搭建\"\u003e服务器搭建\u003c/h2\u003e\n\u003ch3 id=\"创建账号\"\u003e\b创建账号\u003c/h3\u003e\n\u003cp\u003e首先在\u003ca href=\"https://cloud.google.com/\"\u003eGoogle Cloud Platform\u003c/a\u003e上创建一个账号。\u003c/p\u003e\n\u003ch3 id=\"创建新项目\"\u003e创建新项目\u003c/h3\u003e\n\u003cp\u003e点击左上角\u0026quot;Google Cloud Platform\u0026quot;右边的三个点，点击\u0026quot;NEW PROJECT\u0026quot;创建新项目。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"1\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Run-Jupyter-Notebook-on-GCP/1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"2\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Run-Jupyter-Notebook-on-GCP/2.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"创建虚拟机\"\u003e创建虚拟机\u003c/h3\u003e\n\u003cp\u003e进入刚才创建的项目，从左侧边栏点击 Compute Engine -\u0026gt; VM instances 进入虚拟机页面。点击Create创建一个新的虚拟机实例（VM instance）\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"3\" loading=\"lazy\" src=\"https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Run-Jupyter-Notebook-on-GCP/3.png\"\u003e)\u003c/p\u003e\n\u003cp\u003e根据需求填写和选择 Name, Region, Zone, Machine Type和Boot Disk。在\b Firewall 选项中选中 Allow HTTP traffic 和 Allow HTTPS traffic, 在下方的 Disks 选项卡中取消勾选 Delete boot disk when instance is deleted。最后点击\b Create，虚拟机实例就创建好了。\u003c/p\u003e","title":"在Google Cloud Platform上运行Jupyter Notebook"},{"content":"简介 Scrapy官方文档对Scrapy的介绍如下：\nScrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。\n其最初是为了页面抓取（更确切来说, 网络抓取）所设计的，也可以应用在获取API所返回的数据（例如 Amazon Associates Web Services ）或者通用的网络爬虫。\n简而言之，Scrapy是基于Twisted库开发的，封装了http请求、代理信息、数据存储等功能的Python爬虫框架。\n组件和数据流 下图是Scrapy官方文档中的架构概览图：\n图中绿色箭头表示数据流，其他均为组件。\nScrapy Engine（引擎） 引擎负责控制数据流在系统的组件中流动，并在相应动作发生时触发事件。\b\nScheduler（调度器） 调度器从引擎接收request并将其保存，以便在引擎请求时提供给引擎。\nDownloader（下载器） 下载器负责下载页面数据，并将其提供给引擎，而后再由引擎提供给爬虫。\nSpiders（爬虫） Spider是由用户编写的用于分析response并提取item或额外跟进url的类。\b一个Scrapy项目中可以有很多Spider，他们分别被用于爬取不同的页面和网站。\nItem Pipeline（管道） Item Pipeline负责处理被爬虫提取出来的item。\b可以对其进行数据清洗，验证和持久化（例如存储到数据库中）。\nDownloader middlewares（下载器中间件） 下载器中间件是在引擎及下载器之间的组件，用于处理下载器传递给引擎的response。更多内容请参考下载器中间件。\nSpider middlewares（爬虫中间件） Spider中间件是在引擎及Spider之间的组件，用于处理爬虫的输入（response）和输出（items和requests）。更多内容请参考爬虫中间件。\nData flow（数据流） Scrapy中的数据流由引擎控制，其过程如下:\n1.引擎打开一个网站，找到处理该网站的爬虫并向该爬虫请求要爬取的url。\n2.引擎从爬虫中获取到要爬取的url并将其作为request发送给调度器。\n3.引擎向调度器请求下一个要爬取的url。\n4.调度器返回下一个要爬取的url给引擎，引擎将url通过下载器中间件发送给下载器。\n5.下载器下载页面成功后，生成一个该页面的response对象，并将其通过下载器中间件发送给引擎。\n6.引擎接收从下载器中间件发送过来的response，并将其通过爬虫中间件发送给爬虫处理。\n7.爬虫处理response，并将爬取到的item及跟进的新的request发送给引擎。\n8.引擎将爬虫返回的item发送给管道，将爬虫返回的新的request发送给调度器。\n9.管道\b对item进行相应的处理。\n10.重复第二步，直到调度器中没有更多的request，此时引擎关闭该网站。\n安装 1.下载\b安装最新版的Python3\n\b2.使用pip指令安装Scrapy\npip3 install scrapy 创建项目 首先进入你的代码存储目录，在命令行中输入以下命令：\nscrapy startproject LeetCode_Crawler 注意项目名称是不能包含连字符 \u0026lsquo;-\u0026rsquo; 的\n新建成功后，可以看到在当前目录下新建了一个名为LeetCode_Crawler的Scrapy项目，进入该目录，其项目结构如下：\nscrapy.cfg #\b该项目的配置文件 scrapy_project #该项目的Python模块 __init__.py items.py #可自定义的item类文件 middlewares.py #中间件文件 pipelines.py #管道文件 settings.py #设置文件 __pycache__ spiders #爬虫文件夹，所有爬虫文件都应在该文件夹下 __init__.py __pycache__ 至此Scrapy项目的创建就完成了。\n参考资料 Scrapy官方文档\n","permalink":"https://prov1dence.top/posts/leetcode-archiver/leetcode-archiver1/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003eScrapy官方文档对Scrapy的介绍如下：\u003c/p\u003e\n\u003cp\u003eScrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。\u003cbr\u003e其最初是为了页面抓取（更确切来说, 网络抓取）所设计的，也可以应用在获取API所返回的数据（例如 Amazon Associates Web Services ）或者通用的网络爬虫。\u003c/p\u003e\n\u003cp\u003e简而言之，Scrapy是基于Twisted库开发的，封装了http请求、代理信息、数据存储等功能的Python爬虫框架。\u003c/p\u003e\n\u003ch2 id=\"组件和数据流\"\u003e组件和数据流\u003c/h2\u003e\n\u003cp\u003e下图是Scrapy官方文档中的架构概览图：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Architecture\" loading=\"lazy\" src=\"https://scrapy-chs.readthedocs.io/zh_CN/0.24/_images/scrapy_architecture.png\"\u003e\u003c/p\u003e\n\u003cp\u003e图中绿色箭头表示\u003ca href=\"#head\"\u003e数据流\u003c/a\u003e，其他均为组件。\u003c/p\u003e\n\u003ch3 id=\"scrapy-engine引擎\"\u003eScrapy Engine（引擎）\u003c/h3\u003e\n\u003cp\u003e引擎负责控制数据流在系统的组件中流动，并在相应动作发生时触发事件。\b\u003c/p\u003e\n\u003ch3 id=\"scheduler调度器\"\u003eScheduler（调度器）\u003c/h3\u003e\n\u003cp\u003e调度器从引擎接收request并将其保存，以便在引擎请求时提供给引擎。\u003c/p\u003e\n\u003ch3 id=\"downloader下载器\"\u003eDownloader（下载器）\u003c/h3\u003e\n\u003cp\u003e下载器负责下载页面数据，并将其提供给引擎，而后再由引擎提供给爬虫。\u003c/p\u003e\n\u003ch3 id=\"spiders爬虫\"\u003eSpiders（爬虫）\u003c/h3\u003e\n\u003cp\u003eSpider是由用户编写的用于\u003cstrong\u003e分析response\u003c/strong\u003e并\u003cstrong\u003e提取item\u003c/strong\u003e或额外\u003cstrong\u003e跟进url\u003c/strong\u003e的类。\b一个Scrapy项目中可以有很多Spider，他们分别被用于爬取不同的页面和网站。\u003c/p\u003e\n\u003ch3 id=\"item-pipeline管道\"\u003eItem Pipeline（管道）\u003c/h3\u003e\n\u003cp\u003eItem Pipeline负责处理被爬虫\u003cstrong\u003e提取出来的item\u003c/strong\u003e。\b可以对其进行数据清洗，验证和持久化（例如存储到数据库中）。\u003c/p\u003e\n\u003ch3 id=\"downloader-middlewares下载器中间件\"\u003eDownloader middlewares（下载器中间件）\u003c/h3\u003e\n\u003cp\u003e下载器中间件是在引擎及下载器之间的组件，用于处理下载器传递给引擎的response。更多内容请参考\u003ca href=\"https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/downloader-middleware.html#topics-downloader-middleware\"\u003e下载器中间件\u003c/a\u003e。\u003c/p\u003e\n\u003ch3 id=\"spider-middlewares爬虫中间件\"\u003eSpider middlewares（爬虫中间件）\u003c/h3\u003e\n\u003cp\u003eSpider中间件是在引擎及Spider之间的组件，用于处理爬虫的输入（response）和输出（items和requests）。更多内容请参考\u003ca href=\"https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/spider-middleware.html#topics-spider-middleware\"\u003e爬虫中间件\u003c/a\u003e。\u003c/p\u003e\n\u003ch3 id=\"a-idhead-data-flow数据流a\"\u003e\u003ca id=\"head\"/\u003e Data flow（数据流）\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eScrapy中的数据流由引擎控制，其过程如下:\u003cbr\u003e\n1.引擎打开一个网站，找到处理该网站的爬虫并向该爬虫请求要爬取的url。\u003cbr\u003e\n2.引擎从爬虫中获取到要爬取的url并将其作为request发送给调度器。\u003cbr\u003e\n3.引擎向调度器请求下一个要爬取的url。\u003cbr\u003e\n4.调度器返回下一个要爬取的url给引擎，引擎将url通过下载器中间件发送给下载器。\u003cbr\u003e\n5.下载器下载页面成功后，生成一个该页面的response对象，并将其通过下载器中间件发送给引擎。\u003cbr\u003e\n6.引擎接收从下载器中间件发送过来的response，并将其通过爬虫中间件发送给爬虫处理。\u003cbr\u003e\n7.爬虫处理response，并将爬取到的item及跟进的新的request发送给引擎。\u003cbr\u003e\n8.引擎将爬虫返回的item发送给管道，将爬虫返回的新的request发送给调度器。\u003cbr\u003e\n9.管道\b对item进行相应的处理。\u003cbr\u003e\n10.重复第二步，直到调度器中没有更多的request，此时引擎关闭该网站。\u003cbr\u003e\u003c/p\u003e\n\u003ch2 id=\"安装\"\u003e安装\u003c/h2\u003e\n\u003cp\u003e1.下载\b安装最新版的\u003ca href=\"https://www.python.org/downloads/\"\u003ePython3\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\b2.使用pip指令安装Scrapy\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epip3 install scrapy\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"创建项目\"\u003e创建项目\u003c/h2\u003e\n\u003cp\u003e首先进入你的代码存储目录，在命令行中输入以下命令：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003escrapy startproject LeetCode_Crawler\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意项目名称是不能包含连字符 \u0026lsquo;-\u0026rsquo; 的\u003c/p\u003e\n\u003cp\u003e新建成功后，可以看到在当前目录下新建了一个名为LeetCode_Crawler的Scrapy项目，进入该目录，其项目结构如下：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003escrapy.cfg              #\b该项目的配置文件\nscrapy_project          #该项目的Python模块\n    __init__.py\n    items.py            #可自定义的item类文件\n    middlewares.py      #中间件文件\n    pipelines.py        #管道文件\n    settings.py         #设置文件\n    __pycache__\n    spiders             #爬虫文件夹，所有爬虫文件都应在该文件夹下\n        __init__.py\n        __pycache__\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e至此Scrapy项目的创建就完成了。\u003c/p\u003e","title":"LeetCode Archiver(1)：Scrapy框架和Requests库"},{"content":"C++ 基础知识 const 相关 #define，typedef，const\n# 是宏，宏不做类型检查，只进行简单替换；在编译前被处理，编译阶段的程序是宏处理后的结果 typedef 用于声明自定义数据类型，简化代码 const 用于定义常量，有数据类型，编译器会对进行类型检查 const 和指针\nconst char *p: p is a pointer to const char char const *p: p is a pointer to char const（同上） char *const p: p is a const pointer to char int main() { const char *p1 = new char(\u0026#39;a\u0026#39;); char const *p2 = new char(\u0026#39;b\u0026#39;); char *const p3 = new char(\u0026#39;c\u0026#39;); *p1 = \u0026#39;d\u0026#39;; // error: read-only variable is notassignable *p2 = \u0026#39;e\u0026#39;; // error: read-only variable is notassignable p3 = new char(\u0026#39;f\u0026#39;); // error: cannot assign tovariable \u0026#39;p3\u0026#39; with const-qualified type \u0026#39;char *const\u0026#39; p3 = nullptr; // error: cannot assign to variable\u0026#39;p3\u0026#39; with const-qualified type \u0026#39;char *const\u0026#39; } const 和类\nconst 修饰类的成员函数时，该成员函数不能修改类的成员变量，不能调用类的非 const 成员函数 const 修饰函数参数时，在函数内部不能修改参数的值 const 修饰函数返回值时，接收返回值的变量也要用 const 修饰 class Base { public: int i = 1; const int *Func(const int \u0026amp;j) const { const int *k = new int(1); i = 1; // error: cannot assign to non-static data member within const member function \u0026#39;Func\u0026#39; j = 1; // error: cannot assign to variable \u0026#39;j\u0026#39; with const-qualified type \u0026#39;const int \u0026amp;\u0026#39; return k; } void Test() { i = 2; } }; int main() { Base obj; int j = 1; int *k = obj.Func(j); // error: cannot initialize a variable of type \u0026#39;int *\u0026#39; with an rvalue of type \u0026#39;const int *\u0026#39; return 0; } static 相关 1. 面向过程 修饰全局变量时，该静态全局变量的作用域只在当前源文件 全局变量的构造在 main 函数之前执行 修饰全局函数时，该静态全局函数的作用域只在当前源文件 修饰局部变量时，该静态局部变量的作用域只在当前函数中；该变量只在第一次执行到声明时被初始化，其内存被分配在全局数据区，当程序结束时才被回收 2. 面向对象 修饰类的成员变量时，该静态成员变量作用于类的所有实例对象，其内存被分配在全局数据区；该变量可以直接通过类名调用 修饰类的成员函数时，该静态成员函数不能操作类中的其他非静态成员函数；该函数可以直接通过类名调用 3. 类型转换 static_cast\n不执类型检查；接近于 C 的强制类型转换，通常用于数值数据类型的转换，例如把 int 转换成 char，或把 void* 转换成其他类型的指针（不安全） ，基本数据类型之间的转换，如把 int 转换成 char 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法） dynamic_cast\n运行时执行类型检查 只适用于指针或引用，对不明确的指针的转换将失败（返回 nullptr），但不引发异常 如果强制转换为引用类型失败，dynamic_cast 运算符会引发 bad_cast 异常 用于多态类型的转换，可以在整个类层次结构中移动指针，包括向上转换、向下转换 const_cast\n用于删除 const，volatile，__unaligned 特性，比如将 const int 类型转换为 int 类型 reinterpret_cast\n用于位的简单重新解释 允许将任何指针转换为任何其他指针类型，比如 char* 到 int* 允许将任何整数类型转换为任何指针类型以及反向转换 一个实际用途是在哈希函数中，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引 内存分配 栈区 stack\n由编译器分配和释放，存储函数参数，局部变量等 当系统剩余空间小于申请空间时，抛出异常提示栈溢出 在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用 堆区 heap\n由程序分配和释放，例如使用 malloc, new 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整 若程序不进行释放，则在程序结束时被回收 系统维护一个记录空闲内存地址的链表；申请内存时，系统遍历该链表，寻找第一个空间大于所申请内存的堆结点，将该结点从链表中删除，并分配此节点的空间；这块内存的首地址会记录本次分配的大小，执行 delete 语句的时候根据记录释放内存空间；因为堆结点空间一般会大于申请的空间，系统会将多余的空间放入空闲的链表中 自由存储区，存储由 malloc 等分配的内存，用 free 来回收\n全局/静态存储区，存储全局变量和静态变量\n在 C 语言中，全局变量分为初始化的和未初始化的，未被初始化的对象存储区可以通过 void* 来访问 在 C++ 中它们共同占用同一块内存区域 常量存储区，存储常量\nnew 分配失败\nint* p = new (std::nothrow) int(1); 返回空指针 用 try {} catch (const bad_alloc \u0026amp;b) {} 捕捉异常 内存分配方式 malloc：申请指定字节数的内存。申请到的内存中的初始值不确定 calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0 realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存；alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。 指针和引用 void *\nvoid * 是一个指针，它指向了内存里的某个区域，但是它所指向的内存区域没有任何类型信息或辅助信息，所以它可以随意地解读其指向的内存区域内的数据，它可以按 int 类型来解读，也可以按照 double 类型来解读；在使用前需要告知系统从其指向的内存区域取出多少个字节 不能对void * 进行解引用操作 区分指针类型\nint *p[10] int *p[10] 表示指针数组，强调数组概念，是一个数组变量，数组大小为 10，数组内每个元素都是指向 int 类型的指针变量 int (*p)[10] int (*p)[10] 表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个 int 类型的数组，这个数组大小是 10 int *p(int) int *p(int) 是函数声明，函数名是 p，参数是 int 类型的，返回值是 int * 类型的 int (*p)(int) int (*p)(int) 是函数指针，强调是指针，该指针指向的函数具有 int 类型参数，并且返回值是 int 类型的 数组和指针\nint a[10]; int (*p)[10] = \u0026amp;a; a是数组名，也是数组首元素的地址，+1 表示地址值加上一个int类型的大小，如果 a 的值是 0x00000001，加 1 操作后变为 0x00000005，*(a + 1) = a[1] \u0026amp;a 是数组的地址，其类型为int (*)[10]，+1 表示数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址 若 (int *)p ，此时输出 *p 时，其值为 a[0] 的值，因为被转为int * 类型，解引用时按照int类型大小来读取 数组名和指向数组首元素的指针的区别\n均可通过增减偏移量来访问数组中的元素 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了 野指针\n空悬指针，是指向垃圾内存的指针 产生原因 指针变量未初始化 指针 free 或 delete 之后没有置空 常引用\n常引用类似于常量指针，const typename \u0026amp;refname = varname 使用常引用时，原变量的值不会被常引用所修改 常引用通常用作只读变量别名或是形参传递 智能指针 unique_ptr unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象 一旦拥有者被销毁，或拥有了另一个对象，之前拥有的那个指针对象就会被销毁，相应的资源会被释放 可以移交拥有权 用于避免内存泄漏（resource leak），比如 new 后忘记 delete shared_ptr shared_ptr 实现共享式拥有（shared ownership）概念 多个智能指针指向相同对象，该对象和其相关资源会在最后一个 reference 被销毁时被释放；需要使用 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类来实现 支持定制型删除器（custom deleter） 可防范 Cross-DLL 问题（对象在动态链接库 DLL 中被 new 创建，却在另一个 DLL 内被 delete 销毁），自动解除互斥锁 weak_ptr weak_ptr 允许共享但不拥有某对象 一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty） 因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 接受一个 shared_ptr 的构造函数 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 auto_ptr 缺乏语言特性，比如针对构造和赋值的 std::move 语义 auto_ptr 与 unique_ptr 对比 auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义 auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ） Lambda 表达式 1. Lambda 表达式的形式 [capture list] (params list) mutable exception-\u0026gt; return type { function body }\ncapture list：捕获外部变量列表 params list：形参列表 mutable：指示符，用来指明是否可以修改捕获的变量 exception：异常设定 return type：返回类型 function body：函数体 只有捕获外部变量列表和函数题是必须有的 2. 捕获外部变量列表 Lambda 表达式可以使用其可见范围内的外部变量，但必须明确声明哪些外部变量可以被该 Lambda 表达式使用 Lambda 表达式通过在最前面的方括号 [] 来指明其内部可以访问的外部变量，这一过程也称为 Lambda 表达式捕获了外部变量，类似于参数传递 外部变量的捕获方式有三种 值捕获 值捕获和参数传递中的值传递类似，被捕获的变量的值在 Lambda 表达式创建时通过值拷贝的方式传入，在函数体内对该变量的修改不会影响外部的值 引用捕获 使用 \u0026amp;a 的方式传递引用，值捕获和引用捕获都要显式地列出外部变量 隐式捕获 让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获 隐式捕获有两种方式，分别是 [=] 和 [\u0026amp;]；[=] 表示以值捕获的方式捕获外部变量，[\u0026amp;] 表示以引用捕获的方式捕获外部变量。 修改捕获变量 如果以传值方式捕获外部变量，在函数体中将不能修改该外部变量，否则会引发编译错误 使用 mutable 关键字可以修改值捕获的变量 3. 形参列表 Lambda 表达式中传递参数时有一些限制 参数列表中不能有默认参数 不支持可变参数 所有参数必须有参数名 RTTI Runtime Type Identification 运行时类型识别 1. 目的 让程序在运行时根据基类的指针或引用来获得该指针或引用所指的对象的实际类型 通过 typeid 操作符识别出所有的基本类型的变量对应的类型 2. 使用 typeid 运算符，该运算符返回其表达式或类型名的实际类型 dynamic_cast 运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用 模板 实现范型编程 template \u0026lt;class type\u0026gt; ret-type func-name(parameter list) { }\n模板类中可以使用虚函数\n模板类的成员函数不能是虚函数\n关键字 volatile\n用 volatile 关键字声明的变量可能会被某些未知的因素更改 volatile 变量在被访问时，编译器都会从内存地址中取出它的值；非 volatile 修饰的变量由于编译器优化，可以直接从 CPU 寄存器中取值 没有用 volatile 关键字声明的变量在被访问时，编译器可能直接从 CPU 的寄存器中取值（因为变量之前被访问过，之前从内存中值保存在某个寄存器中） inline\n内联函数在编译时被展开，不执行进入函数的步骤，直接执行函数体 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数 优点 内联函数在调用处进行展开，省去了参数压栈、栈帧开辟与回收，结果返回等 内联函数安全检查或自动类型转换，而宏不会 在类中声明并定义的成员函数，会被隐式地转化为内联函数 缺点 代码膨胀；内联是以代码膨胀（复制）为代价，将使程序的总代码量增大，消耗更多的内存空间 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接 friend 友元\n友元类和友元函数能访问其他类地私有成员 破坏封装性，不可传递，单向性 decltype\n获取变量类型 检查实体的声明类型或表达式的类型及值分类 C++ 编译 编译预处理（.i） 编译优化（.s） 汇编程序（.obj、.o） 链接（可执行文件） 1. 编译：把文本形式的源代码翻译成机器语言，并形成目标文件 编译预\n编译器执行预处理指令（以#开头，例如#include），包括拷贝 #include 包含的文件代码，进行 #define 宏定义的替换，处理条件编译指令（#ifndef #ifdef #endif）等 生成 .i 文件 编译\n语法分析，词法分析，语义分析，中间代码生成，代码优化，代码生成等 翻译成汇编代码 生成 .s 文件 汇编\n翻译成机器指令 生成 .o 目标文件 目标文件通常至少有两个段 代码段：包换主要程序的指令。该段是可读和可执行的，一般不可写 数据段：存放程序用到的全局变量或静态数据。可读、可写、可执行 2. 链接 ：把目标文件和操作系统的启动代码和库文件组织起来形成可执行程序 将有关的目标文件连接起来 原因 在程序中调用了某个库函数 某个源文件调用了另一个源文件中的函数或常量 生成可执行文件 C++ 函数调用 参数入栈 把参数从右往左 push 进入栈中 保存现场（返回地址入栈） 将当前代码区调用指令的下一条指令地址 push 入栈中，供函数返回时继续执行 执行子函数 代码区跳转：处理器从当前代码区跳转到被调用函数的入口处 栈帧调整，包括 保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈） 将当前栈帧切换到新栈帧（将ESP值装入EBP，更新栈帧底部） 给新栈帧分配空间（把ESP减去所需空间的大小，抬高栈顶） 恢复现场 STL 容器 所有容器 容器 实现 查询 插入删除 特点 array 数组 O(1) O(1) 大小固定 vector 数组 O(1) 尾部 O(1)，其他 O(n) 大小可变，扩容耗时 deque 双端队列 O(n) 头尾 O(1)，其他 O(n) 一个中央控制器，多个缓冲区 list 双向链表 O(n) O(1) forward_list 单向链表 O(n) O(1) stack deque / list / O(1) 先进后出 queue deque / list / O(1) 先进先出 priority_queue vector / O(logn) 堆，完全二叉树 set 红黑树 O(logn) O(logn) multiset 红黑树 O(logn) O(logn) map 红黑树 O(logn) O(logn) multimap 红黑树 O(logn) O(logn) unordered_set 哈希表 平均 O(1) 平均 O(1) unordered_multiset 哈希表 平均 O(1) 平均 O(1) unordered_map 哈希表 平均 O(1) 平均 O(1) unordered_multimap 哈希表 平均 O(1) 平均 O(1) vector vector 的内存释放\n对于vector，string 等容器，执行 clear() 函数后只会将其 size 置为 0，而不会改变它们的 capacity 可以用 swap() 函数来清理 vector 和 string 容器的内存，用一个右值 vector 来替换需要清理的容器 其它的 stl 容器调用 clear() 时会清空内存 测试 vector\u0026lt;int\u0026gt; v; printf(\u0026#34;v.size() = %d, v.capacity() = %d\\n\u0026#34;, v.size(), v.capacity()); for (int i = 0; i \u0026lt; 100000; ++i) v.push_back(i); printf(\u0026#34;v.size() = %d, v.capacity() = %d\\n\u0026#34;, v.size(), v.capacity()); vector\u0026lt;int\u0026gt;().swap(v); printf(\u0026#34;v.size() = %d, v.capacity() = %d\\n\u0026#34;, v.size(), v.capacity()); /* output: v.size() = 0, v.capacity() = 0 v.size() = 100000, v.capacity() = 131072 v.size() = 0, v.capacity() = 0 */ resize 报错\nvector 的类型是自定义类或结构体的时候，在执行 resize() 的时候如果参数大于当前的 size，编译器会将超过当前 size 的部分初始化；如果自定义的类没有构造函数那么编译器会报错 红黑树 特征\n节点是红色或黑色 根是黑色 所有叶子（空节点）都是黑色 每个红色节点必须有两个黑色的子节点；从每个叶子到根的所有路径上不能有两个连续的红色节点 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点 非严格平衡，通过变色，左旋，右旋来调整\n左值和右值 左值可以取地址；右值是将要销毁的临时变量\n右值的生命周期在表达式结束时结束，常量左值引用会延长临时变量的生命\n左值引用\n普通引用，一般表示对象的身份/别名 右值引用\n必须绑定到右值的引用，一般表示对象的值 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding） 主要目的是消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率 能够更简洁明确地定义泛型函数 排序 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性 冒泡排序 O(n2) O(n2) O(1) 稳定 选择排序 O(n2) O(n2) O(1) 数组实现不稳定 插入排序 O(n2) O(n2) O(1) 稳定 快速排序 O(n*log2n) O(n2) O(log2n) 不稳定 堆排序 O(n*log2n) O(n*log2n) O(1) 不稳定 归并排序 O(n*log2n) O(n*log2n) O(n) 稳定 希尔排序 O(n*log2n) O(n2) O(1) 不稳定 计数排序 O(n+m) O(n+m) O(n+m) 稳定 桶排序 O(n) O(n) O(m) 稳定 基数排序 O(k*n) O(n2) 稳定 其他 重载操作符 new\nvoid *operator new(size_t size) { cout \u0026lt;\u0026lt; \u0026#34;in threee_d new\\n\u0026#34;; return malloc(size); } throw(std::bad_alloc) const std::nothrow_t\u0026amp; 不抛出异常 参考 《C++ Primer》\n《Effective C++》\n《More Effective C++》\n《深度探索 C++ 对象模型》\n《深入理解 C++11》\n《STL 源码剖析》\n《剑指 Offer》\n《编程珠玑》\n《程序员面试宝典》\n《深入理解计算机系统》\n《Windows 核心编程》\n《Unix 环境高级编程》\n《Unix 网络编程》\n《TCP/IP 详解》\n《程序员的自我修养》\n","permalink":"https://prov1dence.top/posts/cpp/basics/basics/","summary":"\u003ch1 id=\"c-基础知识\"\u003eC++ 基础知识\u003c/h1\u003e\n\u003ch2 id=\"const-相关\"\u003econst 相关\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e#define，typedef，const\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e# 是宏，宏不做类型检查，只进行简单替换；在编译前被处理，编译阶段的程序是宏处理后的结果\u003c/li\u003e\n\u003cli\u003etypedef 用于声明自定义数据类型，简化代码\u003c/li\u003e\n\u003cli\u003econst 用于定义常量，有数据类型，编译器会对进行类型检查\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003econst 和指针\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econst char *p: p is a pointer to const char\u003c/li\u003e\n\u003cli\u003echar const *p: p is a pointer to char const（同上）\u003c/li\u003e\n\u003cli\u003echar *const p: p is a const pointer to char\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;a\u0026#39;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;b\u0026#39;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e p3 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;c\u0026#39;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;d\u0026#39;\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// error: read-only variable is notassignable\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;e\u0026#39;\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// error: read-only variable is notassignable\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003ep3 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;f\u0026#39;\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// error: cannot assign tovariable \u0026#39;p3\u0026#39; with const-qualified type \u0026#39;char *const\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003ep3 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enullptr\u003c/span\u003e;  \u003cspan style=\"color:#75715e\"\u003e// error: cannot assign to variable\u0026#39;p3\u0026#39; with const-qualified type \u0026#39;char *const\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003econst 和类\u003c/p\u003e","title":"C++ 基础知识整理"},{"content":"查看 container 的 log file 所在的目录：docker inspect \u0026lt;containername\u0026gt; | grep log\n","permalink":"https://prov1dence.top/posts/cloud-computing/docker/","summary":"\u003cp\u003e查看 container 的 log file 所在的目录：\u003ccode\u003edocker inspect \u0026lt;containername\u0026gt; | grep log\u003c/code\u003e\u003c/p\u003e","title":""},{"content":"Linux:\n我平时的学习基本上都在Linux下完成的，我现在有两台电脑，一台iMac，一台笔记本，笔记本上就装的Linux，然后每天都会用很多指令， 比如说用pipeline管道输出后用grep做正则搜索，用ifconfig和netstat查看网络状态，用top看进程资源，用iostat看cpu和硬盘状态 还有就是最基础的cd ls cp rm mkdir find whereis，还有远程的scp 还有一个查看程序运行时的系统调用，在Linux下是strace，Mac下是dtruss，有些命令在两个平台不一样 Linux下对文件操作有两种方式：系统调用（底层调用，面向硬件），和库函数调用（应用）。系统调用：open, close, read, write, ioctl等，用于底层文件访问\n调试： 用vim编辑（会一些vim的快捷键，比如dd删除一行，gg定位到头部，6$定位到某一行），用gdb调试，打log出来看，用过有个叫log4cplus的框架，有内存错误或者内存泄漏的问题就用valgrind调试。还有用GNU profiler来查看一些函数的调用次数，调用点相关的信息（编译器的话在Linux上GCC，在MAC上用自带的clang，单元测试用gtest。）\nC++ 内存分配\n栈区：参数，局部变量 2.堆区：new，向高地址扩展，不连续 3.自由存储区，malloc 4.全局/静态存储区，存储全局变量和静态变量 5.常量存储区，存储常量 new 分配失败： 1. int* p = new (std::nothrow) int(1); 返回空指针 2. 用 try {} catch (const bad_alloc \u0026amp;b) {} 捕捉异常 auto_ptr：有拷贝构造和赋值操作，所有权转移 unique_ptr：独占式拥有，保证同一时间内只有一个智能指针可以指向特定指针，同时销毁，可以移交拥有权 shared_ptr：多个智能指针指向相同指针对象，在最后一个shared_ptr被销毁时对象被释放；搭配 weak_ptr、bad_weak_ptr等辅助类来实现，可以定制型删除器，因为默认只会把指针删掉，如果是个数组不会删后面的 循环引用就是说有两个类对象的智能指针，他们分别有一个成员变量是对方的类型，并且指向了对方的智能指针，形成了一个环状，那么他们就无法被正确的释放掉 weak_ptr：只引用，不计数，如果一个指针被一些shared_ptr和weak_ptr同时引用，当这些shared_ptr都释放掉，不管还有没有weak_ptr引用该内存，内存都会被释放，解决了循环引用\n线程通信：锁（互斥锁，读写所，自旋锁，条件变量，原子变量，临界区），信号量，信号，屏障\n","permalink":"https://prov1dence.top/posts/computer-science/temp/","summary":"\u003cp\u003eLinux:\u003c/p\u003e\n\u003cp\u003e我平时的学习基本上都在Linux下完成的，我现在有两台电脑，一台iMac，一台笔记本，笔记本上就装的Linux，然后每天都会用很多指令，\n比如说用pipeline管道输出后用grep做正则搜索，用ifconfig和netstat查看网络状态，用top看进程资源，用iostat看cpu和硬盘状态\n还有就是最基础的cd ls cp rm mkdir find whereis，还有远程的scp\n还有一个查看程序运行时的系统调用，在Linux下是strace，Mac下是dtruss，有些命令在两个平台不一样\nLinux下对文件操作有两种方式：系统调用（底层调用，面向硬件），和库函数调用（应用）。系统调用：open, close, read, write, ioctl等，用于底层文件访问\u003c/p\u003e\n\u003cp\u003e调试：\n用vim编辑（会一些vim的快捷键，比如dd删除一行，gg定位到头部，6$定位到某一行），用gdb调试，打log出来看，用过有个叫log4cplus的框架，有内存错误或者内存泄漏的问题就用valgrind调试。还有用GNU profiler来查看一些函数的调用次数，调用点相关的信息（编译器的话在Linux上GCC，在MAC上用自带的clang，单元测试用gtest。）\u003c/p\u003e\n\u003cp\u003eC++ 内存分配\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e栈区：参数，局部变量 2.堆区：new，向高地址扩展，不连续 3.自由存储区，malloc 4.全局/静态存储区，存储全局变量和静态变量 5.常量存储区，存储常量\nnew 分配失败： 1. int* p = new (std::nothrow) int(1); 返回空指针  2. 用 try {} catch (const bad_alloc \u0026amp;b) {} 捕捉异常\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eauto_ptr：有拷贝构造和赋值操作，所有权转移\nunique_ptr：独占式拥有，保证同一时间内只有一个智能指针可以指向特定指针，同时销毁，可以移交拥有权\nshared_ptr：多个智能指针指向相同指针对象，在最后一个shared_ptr被销毁时对象被释放；搭配 weak_ptr、bad_weak_ptr等辅助类来实现，可以定制型删除器，因为默认只会把指针删掉，如果是个数组不会删后面的\n循环引用就是说有两个类对象的智能指针，他们分别有一个成员变量是对方的类型，并且指向了对方的智能指针，形成了一个环状，那么他们就无法被正确的释放掉\nweak_ptr：只引用，不计数，如果一个指针被一些shared_ptr和weak_ptr同时引用，当这些shared_ptr都释放掉，不管还有没有weak_ptr引用该内存，内存都会被释放，解决了循环引用\u003c/p\u003e\n\u003cp\u003e线程通信：锁（互斥锁，读写所，自旋锁，条件变量，原子变量，临界区），信号量，信号，屏障\u003c/p\u003e","title":""}]