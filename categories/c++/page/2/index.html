<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content="Prov1dence Portfolio"><meta name=author content><link rel=canonical href=https://prov1dence.top/categories/c++/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://prov1dence.top/categories/c++/index.xml><link rel=alternate hreflang=en href=https://prov1dence.top/categories/c++/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/categories/c++/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="C++"><meta property="og:description" content="Prov1dence Portfolio"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++"><meta name=twitter:description content="Prov1dence Portfolio"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>C++</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++ 协程（1）：函数和协程</h2></header><div class=entry-content><p>C++ 协程（1）：函数和协程 这篇文章的目的是探究 C++ 中协程的机制和用法，以及怎样利用协程的特性来构建上层的库和应用。
1. 栈帧和函数 栈帧是一个函数执行的环境，包括函数参数、函数返回地址、局部变量等信息。操作系统每次调用一个函数，都会为其分配一个新的栈帧，相关的概念有：
ESP：栈指针寄存器（Extended Stack Pointer），其内存中存放一个始终指向系统栈最顶部栈帧栈顶的指针 EBP：基址指针寄存器（Extended Base Pointer），其内存中存放一个始终指向系统最顶部栈帧栈底的指针 函数栈帧：ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部 对于普通的函数来说，一般我们可以对其进行两种操作：call（调用）和 return（返回）。为了方便对比，此处不讨论 throw exception 的情况。在运行一个 C++ 程序时，编译器会先执行 C++ runtime，然后会调用 main 函数，再由 main 函数调用其他的函数。
call 操作一般包含以下几个步骤：
参数入栈：参数从右向左依次入栈 返回地址入栈：将当前代码区的下一条待执行的指令入栈，以便在函数 return 之后执行 代码区跳转：处理器跳转到被调函数的入口 栈帧调整，包括： 保存当前栈帧状态值，EBP 入栈 从当前栈帧切换到新的栈帧，更新 EBP，将 EBP 的值设置为 ESP 的值 给新的栈帧分配内存空间，更新 ESP，将 ESP 的值减去所需空间的大小 当一个函数通过 return 语句返回时，执行的步骤与调用时相反：
2. 协程 协程由程序所控制，即在用户态执行，而不是像线程一样由操作系统内核管理，使用协程时，不需要如线程一般频繁地进行上下文切换，性能能够得到很大的提升，因此协程的开销远远小于线程的开销。一般来说协程有三种特性：
suspend 悬停：暂停当前协程的执行，将执行权交还给调用者，但是保留当前栈帧。和函数的 return 类似，协程的 suspend 只能由协程自身发起 resume 恢复：继续执行已经 suspend 的协程，重新激活协程的栈帧 destroy 销毁：销毁协程的栈帧和其对应的内存 可以看到，协程可以在不清除栈帧的情况下被挂起而不被销毁，因此我们不能够使用调用栈这样的数据结构来严格保证活动栈帧的生命周期，我们可以把协程存储在堆中。我们可以把协程的栈帧分为两部分，一部分是执行栈帧，这部分仅在当前协程执行期间存在，在执行结束，即协程 suspend 的时候被释放；另一部分是数据栈帧，这部分即使在协程 suspend 的时候依然存在。
...</p></div><footer class=entry-footer><span title='2020-01-20 20:15:05 +0800 +0800'>January 20, 2020</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to C++ 协程（1）：函数和协程" href=https://prov1dence.top/posts/cpp/coroutine/c++-coroutine---function-and-coroutine/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++ 智能指针（3）：shared_ptr</h2></header><div class=entry-content><p>C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器
private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。
template&lt;typename T, typename D> void SharedPointer&lt;T, D>::release() { if (pointer) { std::cout &lt;&lt; "SharedPointer " &lt;&lt; this &lt;&lt; " counter remains " &lt;&lt; *counter &lt;&lt; std::endl; if (--(*counter) == 0) { std::cout &lt;&lt; "SharedPointer " &lt;&lt; this &lt;&lt; " destructor called." &lt;&lt; std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针
template&lt;typename T, typename D> void SharedPointer&lt;T, D>::reset(const SharedPointer&lt;T, D> &amp;other) { pointer = other.pointer; counter = other.counter; deleter = other.deleter; if (pointer) ++(*counter); } 析构函数可以直接调用release函数
...</p></div><footer class=entry-footer><span title='2019-01-25 17:47:38 +1100 AEDT'>January 25, 2019</span>&nbsp;·&nbsp;7 min</footer><a class=entry-link aria-label="post link to C++ 智能指针（3）：shared_ptr" href=https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-3/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++ 智能指针（2）：unique_ptr</h2></header><div class=entry-content><p>C++智能指针（2）：unique_ptr 分析 在使用 AutoPointer 的时候会发生所有权转移和内存泄漏的问题，所以我们可以对 AutoPointer 类稍加修改，修复这两个问题。
所有权转移 为了规避可能发生所有权转移的情况，我们可以直接禁止它使用拷贝构造函数和赋值操作符。
UniquePointer(UniquePointer&lt;T> &amp;other) = delete; UniquePointer&lt;T> &amp;operator=(const UniquePointer&lt;T> &amp;other) = delete; 但很多时候我们都需要使用到传递指针的操作，如果只是使用 deleted 函数禁止拷贝构造函数和赋值操作符，那么这个智能指针存在的意义就不大了，我们可以通过 move 语义来实现移动构造函数和移动赋值操作符，从而在使用 UniquePointer 的时候可以在特定情况下进行所有权转移。
UniquePointer(UniquePointer&lt;T> &&amp;other) noexcept; UniquePointer &amp;operator=(UniquePointer &&amp;other) noexcept; 内存泄漏 为了防止发生内存泄漏，我们可以在UniquePointer的私有成员中增加一个删除器，并根据当前指针对象的类型指定删除器，从而防止发生内存泄漏。
class Deleter { template&lt;typename T> void operator()(T *p) { if (p) delete p; } }; template&lt;typename T, typename D> class UniquePointer { ... private: T *pointer; Deleter deleter; }; 实现 根据unique_ptr的源码，能够大致实现UniquePointer类
template&lt;typename T, typename D> class UniquePointer { public: explicit UniquePointer(T *t, const D &amp;d); ~UniquePointer(); T &amp;operator*(); T *operator->(); T *release(); void reset(T *p); UniquePointer(UniquePointer &&amp;other) noexcept; UniquePointer &amp;operator=(UniquePointer &&amp;other) noexcept; UniquePointer(const UniquePointer &amp;other) = delete; UniquePointer &amp;operator=(const UniquePointer &amp;other) = delete; private: T *pointer; D deleter; }; template&lt;typename T, typename D> UniquePointer&lt;T, D>::UniquePointer(T *t, const D &amp;d) { std::cout &lt;&lt; "UniquePointer " &lt;&lt; this &lt;&lt; " constructor called." &lt;&lt; std::endl; this->pointer = t; this->deleter = d; } template&lt;typename T, typename D> UniquePointer&lt;T, D>::~UniquePointer() { std::cout &lt;&lt; "UniquePointer " &lt;&lt; this &lt;&lt; " destructor called." &lt;&lt; std::endl; deleter(this->pointer); } template&lt;typename T, typename D> T &amp;UniquePointer&lt;T, D>::operator*() { return *this->pointer; } template&lt;typename T, typename D> T *UniquePointer&lt;T, D>::operator->() { return this->pointer; } template&lt;typename T, typename D> T *UniquePointer&lt;T, D>::release() { T *new_pointer = this->pointer; this->pointer = nullptr; return new_pointer; } template&lt;typename T, typename D> void UniquePointer&lt;T, D>::reset(T *p) { if (this->pointer != p) { deleter(this->pointer); this->pointer = p; } } template&lt;typename T, typename D> UniquePointer&lt;T, D>::UniquePointer(UniquePointer&lt;T, D> &&amp;other) noexcept { std::cout &lt;&lt; "UniquePointer " &lt;&lt; this &lt;&lt; " move constructor called." &lt;&lt; std::endl; this->pointer = other.release(); deleter(std::move(other.deleter)); } template&lt;typename T, typename D> UniquePointer&lt;T, D> &amp;UniquePointer&lt;T, D>::operator=(UniquePointer&lt;T, D> &&amp;other) noexcept { std::cout &lt;&lt; "UniquePointer " &lt;&lt; this &lt;&lt; " assignment operator called." &lt;&lt; std::endl; if (this->pointer != other.pointer) { reset(other.release()); deleter = std::move(other.deleter); } return *this; } 测试 尝试使用移动构造函数
...</p></div><footer class=entry-footer><span title='2019-01-19 01:02:02 +1100 AEDT'>January 19, 2019</span>&nbsp;·&nbsp;6 min</footer><a class=entry-link aria-label="post link to C++ 智能指针（2）：unique_ptr" href=https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++ 智能指针（1.5）：move 语义</h2></header><div class=entry-content><p>C++智能指针（1.5）：move语义 move语义 定义 右值引用（Rvalue Referene）是 C++ 11中引入的新特性，它实现了转移语义（Move Sementics）和精确传递（Perfect Forwarding），其主要目的有
消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 实现 move 语义的实现非常简单，它将传入的参数 _Tp&& __t 使用静态类型转换 static_cast&lt;_Up&&>(__t) 转变成了成了对应类型的右值，也就是说使用 move 语义之后，编译器窃取（一般会在移动构造函数和移动赋值操作符里将原有对象指向 nullptr）了原有对象的右值，并延长了这个右值的生命周期并将其用来赋值给其他的对象，而没有对右值做任何拷贝操作。
template &lt;class _Tp> typename remove_reference&lt;_Tp>::type&& move(_Tp&& __t) _NOEXCEPT { typedef typename remove_reference&lt;_Tp>::type _Up; return static_cast&lt;_Up&&>(__t); } 测试 定义一个 Object 类和一个 MoveObject 函数使用 move 语义返回一个 Object 的类对象，可以看到在 MoveObject 函数返回右值后，obj 对象调用了移动构造函数。
class Object { public: Object() { std::cout &lt;&lt; "Construct" &lt;&lt; std::endl; } Object(const Object &amp;other) { std::cout &lt;&lt; "Copy" &lt;&lt; std::endl; } Object(Object &&amp;other) noexcept { std::cout &lt;&lt; "Move" &lt;&lt; std::endl; } ~Object() { std::cout &lt;&lt; "Destruct" &lt;&lt; std::endl; } void Print() { std::cout &lt;&lt; "Print" &lt;&lt; std::endl; } }; Object MoveObject() { Object obj; return move(obj); } int main() { Object obj = MoveObject(); return 0; } /* output: Construct Move Destruct Destruct */ 返回值优化（RVO，Return value optimisation） 返回值优化是一种编译器优化技术，允许编译器在调用点（call site）直接构造函数的返回值。
...</p></div><footer class=entry-footer><span title='2019-01-02 09:55:05 +1100 AEDT'>January 2, 2019</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to C++ 智能指针（1.5）：move 语义" href=https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1.5/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++ 智能指针（1）：auto_ptr</h2></header><div class=entry-content><p>C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类
class Object { public: Object() { std::cout &lt;&lt; "Construct" &lt;&lt; std::endl; } Object(const Object &amp;other) { std::cout &lt;&lt; "Copy" &lt;&lt; std::endl; } Object(Object &&amp;other) noexcept { std::cout &lt;&lt; "Move" &lt;&lt; std::endl; } ~Object() { std::cout &lt;&lt; "Destruct" &lt;&lt; std::endl; } void Print() { std::cout &lt;&lt; "Print" &lt;&lt; std::endl; } }; 创建一个指向 Object 类型的指针
int main() { Object *o = new Object(); o->Print(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象
int main() { Object *o1 = new Object(); o1->Print(); Object o2 = Object(); o2.Print(); return 0; } /* output: Construct Print Construct Print Destruct */ 产生这样的结果是因为对象创建在栈（stack）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。
...</p></div><footer class=entry-footer><span title='2018-12-27 15:21:35 +1100 AEDT'>December 27, 2018</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to C++ 智能指针（1）：auto_ptr" href=https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://prov1dence.top/categories/c++/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://prov1dence.top/categories/c++/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>