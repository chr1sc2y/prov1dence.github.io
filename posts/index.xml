<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ZinBlog</title>
    <link>http://zintrulcre.vip/posts/</link>
    <description>Recent content in Posts on ZinBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Tue, 12 Feb 2019 21:44:35 +1100</lastBuildDate>
    
	<atom:link href="http://zintrulcre.vip/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode 98 验证二叉搜索树</title>
      <link>http://zintrulcre.vip/posts/leetcode/98/</link>
      <pubDate>Tue, 12 Feb 2019 21:44:35 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/leetcode/98/</guid>
      <description>LeetCode 98 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点</description>
    </item>
    
    <item>
      <title>LeetCode 560 和为K的子数组</title>
      <link>http://zintrulcre.vip/posts/leetcode/560/</link>
      <pubDate>Wed, 06 Feb 2019 22:11:18 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/leetcode/560/</guid>
      <description>LeetCode 560 和为K的子数组 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1: 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1]</description>
    </item>
    
    <item>
      <title>Machine Learning Algorithm Implementation (3): Perceptron</title>
      <link>http://zintrulcre.vip/posts/machine-learning/machine-learning-algorithm-implementation-3/</link>
      <pubDate>Tue, 05 Feb 2019 00:58:34 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/machine-learning/machine-learning-algorithm-implementation-3/</guid>
      <description>Click here to see the implementation in Jupyter Notebook
Perceptron  Goal
 implement the perceptron (a building block of neural networks) to assess how the perceptron behaves in two distinct scenarios (separable vs. non-separable data)  Verification
 compare our output to the output of using LogisticRegression function from library sklearn.    1. Import Library Firstly we should import the relevant libraries (numpy, matplotlib, etc.).
%matplotlib inline import numpy as np import matplotlib.</description>
    </item>
    
    <item>
      <title>Machine Learning Algorithm Implementation (2): Logistic Regression</title>
      <link>http://zintrulcre.vip/posts/machine-learning/machine-learning-algorithm-implementation-2/</link>
      <pubDate>Fri, 01 Feb 2019 14:00:16 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/machine-learning/machine-learning-algorithm-implementation-2/</guid>
      <description>Click here to see the implementation in Jupyter Notebook
Logistic Regression  Goal  implementing L2-regularised logistic regression, using scipy and numpy library apply polynomial basis expansion and L2 regularisation.  Implementation Methods  hill-climbing algorithm  Verification  compare our output to the output of using library sklearn.    1. Import Library Firstly we should import the relevant libraries (numpy, matplotlib, etc.).
%matplotlib inline import numpy as np import matplotlib.</description>
    </item>
    
    <item>
      <title>Machine Learning Algorithm Implementation (1): Linear Regression</title>
      <link>http://zintrulcre.vip/posts/machine-learning/machine-learning-algorithm-implementation-1/</link>
      <pubDate>Wed, 30 Jan 2019 14:38:43 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/machine-learning/machine-learning-algorithm-implementation-1/</guid>
      <description>Click here to see the implementation in Jupyter Notebook
Linear regression  Goal  fit a linear model, using only the numpy library visualize the output, using the matplotlib library  Implementation Methods  iterative updates (coordinate descent) linear algebra  Verification  compare our output to the output of using library sklearn.   1. Import Library Firstly we should import the relevant libraries (numpy, matplotlib, etc.).
import numpy as np import matplotlib.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（3）：shared_ptr</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-3/</link>
      <pubDate>Fri, 25 Jan 2019 17:47:38 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-3/</guid>
      <description>分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器 private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（2）：unique_ptr</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-2/</link>
      <pubDate>Sat, 19 Jan 2019 01:02:02 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-2/</guid>
      <description>分析 在使用auto_ptr的时候会发生所有权转移和内存泄漏的问题，所以我们可以对AutoPointer类稍加修改，修复这两个问题。 所有权转</description>
    </item>
    
    <item>
      <title>使用Scrapy爬取LeetCode（3）：登录</title>
      <link>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode/use-scrapy-to-crawl-leetcode-3/</link>
      <pubDate>Fri, 11 Jan 2019 13:15:17 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode/use-scrapy-to-crawl-leetcode-3/</guid>
      <description>本项目ZintrulCre/LeetCode_Crawler已完成，并正在维护中，欢迎在GitHub上star和fork。 Cookie和Se</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（1.5）：move语义</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1.5/</link>
      <pubDate>Wed, 02 Jan 2019 09:55:05 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1.5/</guid>
      <description>move语义 定义 右值引用（Rvalue Referene）是 C++ 11中引入的新特性，它实现了转移语义（Move Sementics）和精确传递（P</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（1）：auto_ptr</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1/</link>
      <pubDate>Thu, 27 Dec 2018 15:21:35 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1/</guid>
      <description>分析 C++中经常会出现因为没有delete指针而造成的内存泄漏，例如有下面一个类 class Obj { public: Obj() { std::cout &amp;lt;&amp;lt; &amp;#34;Construct&amp;#34; &amp;lt;&amp;lt; std::endl; } Obj(const Obj &amp;amp;other) { std::cout &amp;lt;&amp;lt; &amp;#34;Copy&amp;#34; &amp;lt;&amp;lt; std::endl; } Obj(Obj &amp;amp;&amp;amp;other) noexcept { std::cout &amp;lt;&amp;lt; &amp;#34;Move&amp;#34; &amp;lt;&amp;lt;</description>
    </item>
    
  </channel>
</rss>