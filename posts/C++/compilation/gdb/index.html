<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>GDB 调试入门 | 尾張</title>
<meta name=keywords content>
<meta name=description content="GDB 调试入门 0. 序 调试程序是开发过程中必不可少的一环，在 Windows 或 MacOS 上开发时，可以使用 VS 和 CLion 等 IDE 上自带的调试功能来打断点或查看变量和堆栈，但 Linux 并没有图形化的操作界面，而如果只通过打 log 的方式来查找问题的话效率将会非常低下，此时我们可以利用 GDB 来提升我们的开发效率。
GDB 是 GNU Debugger 的简写，是 GNU 软件系统中的标准调试器。GDB 具备各种调试功能，包括但不限于打断点、单步执行、打印变量、查看寄存器、查看函数调用堆栈等，能够有效地针对函数的运行进行追踪和警告；使用 GDB 调试时，可以监督和修改程序的变量，并且这些修改是独立于主程序之外的。GDB 主要用于调试编译型语言，对 C，C++，Go，Fortran 等语言有内置的支持，但它不支持解释型语言。
1. 环境搭建 1.1 编写程序 为了进行调试，我们需要准备一个简单的 C++ 程序：
$ cat test.cpp #include <iostream> void Func(const char *s) { int *p = nullptr; int &r = static_cast<int&>(*p); int num = std::atoi(s); r = num; printf(&#34;%d\n&#34;, r); } int main (int argc, char *argv[]) { if (argc !">
<meta name=author content>
<link rel=canonical href=http://zintrulcre.github.io/posts/c++/compilation/gdb/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="GDB 调试入门">
<meta property="og:description" content="GDB 调试入门 0. 序 调试程序是开发过程中必不可少的一环，在 Windows 或 MacOS 上开发时，可以使用 VS 和 CLion 等 IDE 上自带的调试功能来打断点或查看变量和堆栈，但 Linux 并没有图形化的操作界面，而如果只通过打 log 的方式来查找问题的话效率将会非常低下，此时我们可以利用 GDB 来提升我们的开发效率。
GDB 是 GNU Debugger 的简写，是 GNU 软件系统中的标准调试器。GDB 具备各种调试功能，包括但不限于打断点、单步执行、打印变量、查看寄存器、查看函数调用堆栈等，能够有效地针对函数的运行进行追踪和警告；使用 GDB 调试时，可以监督和修改程序的变量，并且这些修改是独立于主程序之外的。GDB 主要用于调试编译型语言，对 C，C++，Go，Fortran 等语言有内置的支持，但它不支持解释型语言。
1. 环境搭建 1.1 编写程序 为了进行调试，我们需要准备一个简单的 C++ 程序：
$ cat test.cpp #include <iostream> void Func(const char *s) { int *p = nullptr; int &r = static_cast<int&>(*p); int num = std::atoi(s); r = num; printf(&#34;%d\n&#34;, r); } int main (int argc, char *argv[]) { if (argc !">
<meta property="og:type" content="article">
<meta property="og:url" content="http://zintrulcre.github.io/posts/c++/compilation/gdb/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-04-22T17:46:06+08:00">
<meta property="article:modified_time" content="2020-04-22T17:46:06+08:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="GDB 调试入门">
<meta name=twitter:description content="GDB 调试入门 0. 序 调试程序是开发过程中必不可少的一环，在 Windows 或 MacOS 上开发时，可以使用 VS 和 CLion 等 IDE 上自带的调试功能来打断点或查看变量和堆栈，但 Linux 并没有图形化的操作界面，而如果只通过打 log 的方式来查找问题的话效率将会非常低下，此时我们可以利用 GDB 来提升我们的开发效率。
GDB 是 GNU Debugger 的简写，是 GNU 软件系统中的标准调试器。GDB 具备各种调试功能，包括但不限于打断点、单步执行、打印变量、查看寄存器、查看函数调用堆栈等，能够有效地针对函数的运行进行追踪和警告；使用 GDB 调试时，可以监督和修改程序的变量，并且这些修改是独立于主程序之外的。GDB 主要用于调试编译型语言，对 C，C++，Go，Fortran 等语言有内置的支持，但它不支持解释型语言。
1. 环境搭建 1.1 编写程序 为了进行调试，我们需要准备一个简单的 C++ 程序：
$ cat test.cpp #include <iostream> void Func(const char *s) { int *p = nullptr; int &r = static_cast<int&>(*p); int num = std::atoi(s); r = num; printf(&#34;%d\n&#34;, r); } int main (int argc, char *argv[]) { if (argc !">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://zintrulcre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"GDB 调试入门","item":"http://zintrulcre.github.io/posts/c++/compilation/gdb/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GDB 调试入门","name":"GDB 调试入门","description":"GDB 调试入门 0. 序 调试程序是开发过程中必不可少的一环，在 Windows 或 MacOS 上开发时，可以使用 VS 和 CLion 等 IDE 上自带的调试功能来打断点或查看变量和堆栈，但 Linux 并没有图形化的操作界面，而如果只通过打 log 的方式来查找问题的话效率将会非常低下，此时我们可以利用 GDB 来提升我们的开发效率。\nGDB 是 GNU Debugger 的简写，是 GNU 软件系统中的标准调试器。GDB 具备各种调试功能，包括但不限于打断点、单步执行、打印变量、查看寄存器、查看函数调用堆栈等，能够有效地针对函数的运行进行追踪和警告；使用 GDB 调试时，可以监督和修改程序的变量，并且这些修改是独立于主程序之外的。GDB 主要用于调试编译型语言，对 C，C++，Go，Fortran 等语言有内置的支持，但它不支持解释型语言。\n1. 环境搭建 1.1 编写程序 为了进行调试，我们需要准备一个简单的 C++ 程序：\n$ cat test.cpp #include \u0026lt;iostream\u0026gt; void Func(const char *s) { int *p = nullptr; int \u0026amp;r = static_cast\u0026lt;int\u0026amp;\u0026gt;(*p); int num = std::atoi(s); r = num; printf(\u0026#34;%d\\n\u0026#34;, r); } int main (int argc, char *argv[]) { if (argc !","keywords":[],"articleBody":"GDB 调试入门 0. 序 调试程序是开发过程中必不可少的一环，在 Windows 或 MacOS 上开发时，可以使用 VS 和 CLion 等 IDE 上自带的调试功能来打断点或查看变量和堆栈，但 Linux 并没有图形化的操作界面，而如果只通过打 log 的方式来查找问题的话效率将会非常低下，此时我们可以利用 GDB 来提升我们的开发效率。\nGDB 是 GNU Debugger 的简写，是 GNU 软件系统中的标准调试器。GDB 具备各种调试功能，包括但不限于打断点、单步执行、打印变量、查看寄存器、查看函数调用堆栈等，能够有效地针对函数的运行进行追踪和警告；使用 GDB 调试时，可以监督和修改程序的变量，并且这些修改是独立于主程序之外的。GDB 主要用于调试编译型语言，对 C，C++，Go，Fortran 等语言有内置的支持，但它不支持解释型语言。\n1. 环境搭建 1.1 编写程序 为了进行调试，我们需要准备一个简单的 C++ 程序：\n$ cat test.cpp #include  void Func(const char *s) { int *p = nullptr; int \u0026r = static_castint\u0026(*p); int num = std::atoi(s); r = num; printf(\"%d\\n\", r); } int main (int argc, char *argv[]) { if (argc != 2) { printf(\"test [int]\\n\"); return -1; } Func(argv[1]); return 0; } 1.2 编译 对于 C/C++ 程序，在使用 gcc/clang 编译的时候需要加上参数 -g，才能生成完整的调试信息并在 GDB 中调试：\n$ clang++ -g -std=c++11 -m64 -o test test.cpp 2. 调试示例 GDB 有非常多的功能，当我们忘记如何使用这些功能时，可以在 GDB 交互界面里输入 help 或 help all 来查看指令：\n(gdb) help List of classes of commands: ... 2.1 启动 我们可以使用 gdb [executable file] 来启动调试：\n$ gdb test.cpp ... Reading symbols from test...done. (gdb) 也可以直接使用 gdb 来进入交互界面，再使用 file 来指定要调试的程序：\n$ gdb ... (gdb) file test Reading symbols from test...done. 2.2 运行 对于带参数的程序，我们可以使用 set args [arg] ... 设置参数，再使用 run 来运行：\n(gdb) set args 1 (gdb) run Starting program: test 1 ... 当然也可以直接在 run 后加上参数来运行：\n(gdb) run 1 Starting program: test 1 Program received signal SIGSEGV, Segmentation fault. 0x0000000000400749 in Func (s=0x7fffffffe167 \"/data/home/joelzychen/test/test\") at test.cpp:8 8 r = num; 我们发现程序出现了 Segmentation fault，此时可以通过打断点来调试程序。\n2.3 断点 通过错误信息我们可以看到是函数 Func 中，test.cpp 的第 8 行出现了错误，于是我们可以打上两个断点，一个在进入 Func 函数时，一个在 test.cpp 文件的第 8 行，并使用 info breakpoints 或 info b 来查看我们设置了哪些断点：\n(gdb) b test.cpp:8 Breakpoint 1 at 0x400742: file test.cpp, line 8. (gdb) b Func Breakpoint 2 at 0x40071c: file test.cpp, line 4. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000400742 in Func(char const*) at test.cpp:8 2 breakpoint keep y 0x000000000040071c in Func(char const*) at test.cpp:4 2.4 调试 设置好断点之后就可以使用 run 开始运行了：\n(gdb) run Starting program: test 1 Breakpoint 2, Func (s=0x7fffffffe167 \"/data/home/joelzychen/test/test\") at test.cpp:4 4 int *p = nullptr; 因为我们在 Func 函数的开头设置了一个断点，所以程序在进入 Func 函数时暂停了；我们可以使用 list 或 l [function name] 来查看函数的上下文：\n(gdb) l Func 1 #include  2 3 void Func(const char *s) { 4 int *p = nullptr; 5 int \u0026r = static_cast(*p); 6 7 int num = std::atoi(s); 8 r = num; 9 printf(\"%d\\n\", r); 10 } 此时我们可以使用 print 或 p 来查看变量：\n(gdb) p s $1 = 0x7fffffffe187 \"1\" (gdb) p *s $2 = 49 '1' 到目前为止还没有出现问题，我们可以使用 continue 或 c 走到下一个断点处：\n(gdb) c Continuing. Breakpoint 2, Func (s=0x7fffffffe187 \"1\") at test.cpp:8 8 r = num; 查看一下当前作用域的一些变量：\n(gdb) p s $8 = 0x7fffffffe187 \"1\" (gdb) p p $9 = (int *) 0x0 (gdb) p *p Cannot access memory at address 0x0 (gdb) p r $10 = (int \u0026) @0x0: (gdb) p \u0026r $11 = (int *) 0x0 (gdb) p num $12 = 1 会发现 r 这个 int\u0026 绑定到了一个被解引用的空指针上，所以 \u0026r == nullptr，因此不能读取 r 的值，我们可以用 next 或 n 来进行单步执行，看看接下来会发生什么：\n(gdb) n Program received signal SIGSEGV, Segmentation fault. 0x0000000000400749 in Func (s=0x7fffffffe187 \"1\") at test.cpp:8 8 r = num; 果然发生了 Segmentation fault。\n3. GDB 命令 根据刚才的示例程序，可以整理出一些常用的 GDB 命令。\n3.1 启动   将 GDB 链接到一个可执行文件并启动\ngdb [executable file] gdb (gdb) file [executable file]   将 GDB 链接到一个正在运行的进程并启动\ngdb (gdb) attach [PID]   3.2 断点   增加断点\n b [function name] b [file:line]    查看断点\n info b    删除断点\ndelete [breakpoint number] d [breakpoint number] clear # 删除当前行的断点 clear [function name] # 删除某个函数处的断点 clear [file:line] # 删除某一行的断点   禁用和启用断点\ndisable # 禁用所有断点 disable [breakpoint number] # 禁用某个断点 enable # 启用所有断点 enable [breakpoint number] # 启用某个断点   3.3 运行  从头开始运行  run   单步执行  next 或 n   进入函数内部  step 或 s stepi 执行一条机器指令    3.4 查看   查看代码\nlist # 从头开始依次打印，默认每次打印 10 行 l # 同上 l [function name] # 从函数定义开始打印 l [file:line] # 从某一行开始打印 set listsize 20 # 修改每次打印的行数   查看变量\nprint [expression] # 打印表达式 p [expression] # 同上 ptype [expression] # 打印表达式的类型 info args # 打印函数参数 info locals # 打印局部变量 info registers # 打印寄存器信息   3.5 修改   修改变量\nset variable i = 10 # 将变量 i 设置为 10 set var i = 10 # 同上 p i = 10 # 将变量 i 设置为 10，并打印   3.6 调用信息  查看函数调用栈信息  backtrace 或 bt where   查看当前栈帧  frame 或 f    4. corefile core dump / crash dump / memory dump / system dump 都是指一个程序在特定时间崩溃（crash）时的内存记录，它包含了很多关键信息，比如寄存器（包括程序计数器和堆栈指针），内存管理信息，操作系统标志信息等。corefile 就是转储（dump）时的快照，corefile可以被重新执行用以调试错误信息。\n4.1 生成 为了让系统能够生成 corefile，需要先检查配置：\n$ ulimit -c unlimited 如果结果是 0 则说明系统禁止了 corefile 的生成，需要执行 ulimit -c unlimited 来让 corefile 能够正常生成。以刚才的示例程序为例，先执行 test 文件，生成一个 corefile：\n$ ./test 1 段错误 (core dumped) $ ll /data/corefile -rw------- 1 joelzychen dev 450560 4月 22 17:07 core_test_1587546447.28284 能够看到系统在特定的目录下（可以修改）生成了一个 corefile 叫做 core_test_1587546447.28284，我们使用 gdb 来对这个 corefile 进行调试。\n4.2 调试 要执行 corefile 还需要准备对应的可执行文件，运行 gdb [executable file] [corefile] 就能开始调试了：\n$ gdb test /data/corefile/core_test_1587546447.28284 ... Core was generated by `./test 1'. Program terminated with signal 11, Segmentation fault. #0 0x0000000000400749 in Func (s=0x7ffed098c19e \"1\") at test.cpp:8 8 r = num; 因为示例程序比较简单，因此函数调用栈也比较少，我们可以先使用 bt 打印函数调用栈信息：\n(gdb) bt #0 0x0000000000400749 in Func (s=0x7ffed098c19e \"1\") at test.cpp:8 #1 0x00000000004007c0 in main (argc=2, argv=0x7ffed098afb8) at test.cpp:17 我们通过 frame 0 或 f 0 进入程序崩溃的栈帧来查看相关信息：\n(gdb) f 0 #0 0x0000000000400749 in Func (s=0x7ffed098c19e \"1\") at test.cpp:8 8 r = num; (gdb) info args s = 0x7ffed098c19e \"1\" (gdb) info locals p = 0x0 r = @0x0: num = 1 (gdb) ptype r type = int \u0026 (gdb) ptype p type = int * 查看一下当前栈帧的汇编代码：\n(gdb) disas Dump of assembler code for function Func(char const*): 0x0000000000400710 : push %rbp 0x0000000000400711 : mov %rsp,%rbp 0x0000000000400714 : sub $0x20,%rsp 0x0000000000400718 : mov %rdi,-0x8(%rbp) 0x000000000040071c : movq $0x0,-0x10(%rbp) 0x0000000000400724 : mov -0x10(%rbp),%rdi 0x0000000000400728 : mov %rdi,-0x18(%rbp) 0x000000000040072c : mov -0x8(%rbp),%rdi 0x0000000000400730 : callq 0x4005a0  0x0000000000400735 : movabs $0x400860,%rdi 0x000000000040073f : mov %eax,-0x1c(%rbp) 0x0000000000400742 : mov -0x1c(%rbp),%eax 0x0000000000400745 : mov -0x18(%rbp),%rcx = 0x0000000000400749 : mov %eax,(%rcx) 0x000000000040074b : mov -0x18(%rbp),%rcx 0x000000000040074f : mov (%rcx),%esi 0x0000000000400751 : mov $0x0,%al 0x0000000000400753 : callq 0x400550  0x0000000000400758 : mov %eax,-0x20(%rbp) 0x000000000040075b : add $0x20,%rsp 0x000000000040075f : pop %rbp 0x0000000000400760 : retq End of assembler dump. 查看寄存器状态：\n(gdb) i r rax 0x1 1 rbx 0x0 0 rcx 0x0 0 rdx 0xa 10 rsi 0x0 0 rdi 0x400860 4196448 rbp 0x7ffed098aea0 0x7ffed098aea0 rsp 0x7ffed098ae80 0x7ffed098ae80 r8 0x7f9c88bbf060 140310285643872 r9 0x7ffed098c19f 140732398092703 r10 0x1 1 r11 0x0 0 r12 0x40061c 4195868 r13 0x7ffed098afb0 140732398088112 r14 0x0 0 r15 0x0 0 rip 0x400749 0x400749 eflags 0x10206 [ PF IF RF ] cs 0x33 51 ss 0x2b 43 ds 0x0 0 es 0x0 0 fs 0x0 0 gs 0x0 0 5. 总结 本文主要通过一个示例程序演示了在 Linux 环境下 GDB 的基本使用方法，整理了 GDB 的常用指令，以及调试 C/C++ 程序和 corefile 的步骤。在实际应用中 GDB 能个极大程度地提高开发和调试效率，更多的使用技巧还需要结合实践来练习。\n","wordCount":"1037","inLanguage":"en","datePublished":"2020-04-22T17:46:06+08:00","dateModified":"2020-04-22T17:46:06+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://zintrulcre.github.io/posts/c++/compilation/gdb/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://zintrulcre.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://zintrulcre.github.io/archives/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=http://zintrulcre.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://zintrulcre.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://zintrulcre.github.io/posts/>Posts</a></div>
<h1 class=post-title>
GDB 调试入门
</h1>
<div class=post-meta><span title="2020-04-22 17:46:06 +0800 CST">April 22, 2020</span>&nbsp;·&nbsp;5 min
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#gdb-%e8%b0%83%e8%af%95%e5%85%a5%e9%97%a8 aria-label="GDB 调试入门">GDB 调试入门</a><ul>
<li>
<a href=#0-%e5%ba%8f aria-label="0. 序">0. 序</a></li>
<li>
<a href=#1-%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba aria-label="1. 环境搭建">1. 环境搭建</a><ul>
<li>
<a href=#11-%e7%bc%96%e5%86%99%e7%a8%8b%e5%ba%8f aria-label="1.1 编写程序">1.1 编写程序</a></li>
<li>
<a href=#12-%e7%bc%96%e8%af%91 aria-label="1.2 编译">1.2 编译</a></li></ul>
</li>
<li>
<a href=#2-%e8%b0%83%e8%af%95%e7%a4%ba%e4%be%8b aria-label="2. 调试示例">2. 调试示例</a><ul>
<li>
<a href=#21-%e5%90%af%e5%8a%a8 aria-label="2.1 启动">2.1 启动</a></li>
<li>
<a href=#22-%e8%bf%90%e8%a1%8c aria-label="2.2 运行">2.2 运行</a></li>
<li>
<a href=#23-%e6%96%ad%e7%82%b9 aria-label="2.3 断点">2.3 断点</a></li>
<li>
<a href=#24-%e8%b0%83%e8%af%95 aria-label="2.4 调试">2.4 调试</a></li></ul>
</li>
<li>
<a href=#3-gdb-%e5%91%bd%e4%bb%a4 aria-label="3. GDB 命令">3. GDB 命令</a><ul>
<li>
<a href=#31-%e5%90%af%e5%8a%a8 aria-label="3.1 启动">3.1 启动</a></li>
<li>
<a href=#32-%e6%96%ad%e7%82%b9 aria-label="3.2 断点">3.2 断点</a></li>
<li>
<a href=#33-%e8%bf%90%e8%a1%8c aria-label="3.3 运行">3.3 运行</a></li>
<li>
<a href=#34-%e6%9f%a5%e7%9c%8b aria-label="3.4 查看">3.4 查看</a></li>
<li>
<a href=#35-%e4%bf%ae%e6%94%b9 aria-label="3.5 修改">3.5 修改</a></li>
<li>
<a href=#36-%e8%b0%83%e7%94%a8%e4%bf%a1%e6%81%af aria-label="3.6 调用信息">3.6 调用信息</a></li></ul>
</li>
<li>
<a href=#4-corefile aria-label="4. corefile">4. corefile</a><ul>
<li>
<a href=#41-%e7%94%9f%e6%88%90 aria-label="4.1 生成">4.1 生成</a></li>
<li>
<a href=#42-%e8%b0%83%e8%af%95 aria-label="4.2 调试">4.2 调试</a></li></ul>
</li>
<li>
<a href=#5-%e6%80%bb%e7%bb%93 aria-label="5. 总结">5. 总结</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=gdb-调试入门>GDB 调试入门<a hidden class=anchor aria-hidden=true href=#gdb-调试入门>#</a></h1>
<h2 id=0-序>0. 序<a hidden class=anchor aria-hidden=true href=#0-序>#</a></h2>
<p>调试程序是开发过程中必不可少的一环，在 Windows 或 MacOS 上开发时，可以使用 VS 和 CLion 等 IDE 上自带的调试功能来打断点或查看变量和堆栈，但 Linux 并没有图形化的操作界面，而如果只通过打 log 的方式来查找问题的话效率将会非常低下，此时我们可以利用 GDB 来提升我们的开发效率。</p>
<p><a href=https://en.wikipedia.org/wiki/GNU_Debugger>GDB</a> 是 GNU Debugger 的简写，是 <a href=https://zh.wikipedia.org/wiki/GNU>GNU</a> 软件系统中的标准<a href=https://en.wikipedia.org/wiki/Debugger>调试器</a>。GDB 具备各种调试功能，包括但不限于打断点、单步执行、打印变量、查看寄存器、查看函数调用堆栈等，能够有效地针对函数的运行进行追踪和警告；使用 GDB 调试时，可以监督和修改程序的变量，并且这些修改是独立于主程序之外的。GDB 主要用于调试编译型语言，对 C，C++，Go，Fortran 等语言有内置的支持，但它不支持解释型语言。</p>
<h2 id=1-环境搭建>1. 环境搭建<a hidden class=anchor aria-hidden=true href=#1-环境搭建>#</a></h2>
<h3 id=11-编写程序>1.1 编写程序<a hidden class=anchor aria-hidden=true href=#11-编写程序>#</a></h3>
<p>为了进行调试，我们需要准备一个简单的 C++ 程序：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#960050;background-color:#1e0010>$</span> cat test.cpp
<span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> Func(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>s) {
    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
    <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>r <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&gt;</span>(<span style=color:#f92672>*</span>p);

    <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>atoi(s);
    r <span style=color:#f92672>=</span> num;
    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, r);
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> (<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[]) {
    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>) {
        printf(<span style=color:#e6db74>&#34;test [int]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    }
    Func(argv[<span style=color:#ae81ff>1</span>]);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

</code></pre></div><h3 id=12-编译>1.2 编译<a hidden class=anchor aria-hidden=true href=#12-编译>#</a></h3>
<p>对于 C/C++ 程序，在使用 gcc/clang 编译的时候需要加上参数 -g，才能生成完整的调试信息并在 GDB 中调试：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#960050;background-color:#1e0010>$</span> clang<span style=color:#f92672>++</span> <span style=color:#f92672>-</span>g <span style=color:#f92672>-</span>std<span style=color:#f92672>=</span>c<span style=color:#f92672>++</span><span style=color:#ae81ff>11</span> <span style=color:#f92672>-</span>m64 <span style=color:#f92672>-</span>o test test.cpp
</code></pre></div><h2 id=2-调试示例>2. 调试示例<a hidden class=anchor aria-hidden=true href=#2-调试示例>#</a></h2>
<p>GDB 有非常多的功能，当我们忘记如何使用这些功能时，可以在 GDB 交互界面里输入 <code>help</code> 或 <code>help all</code> 来查看指令：</p>
<pre tabindex=0><code>(gdb) help
List of classes of commands:
...
</code></pre><h3 id=21-启动>2.1 启动<a hidden class=anchor aria-hidden=true href=#21-启动>#</a></h3>
<p>我们可以使用 <code>gdb [executable file]</code> 来启动调试：</p>
<pre tabindex=0><code>$ gdb test.cpp
...
Reading symbols from test...done.
(gdb)
</code></pre><p>也可以直接使用 <code>gdb</code> 来进入交互界面，再使用 <code>file</code> 来指定要调试的程序：</p>
<pre tabindex=0><code>$ gdb
...
(gdb) file test
Reading symbols from test...done.
</code></pre><h3 id=22-运行>2.2 运行<a hidden class=anchor aria-hidden=true href=#22-运行>#</a></h3>
<p>对于带参数的程序，我们可以使用 <code>set args [arg] ...</code> 设置参数，再使用 <code>run</code> 来运行：</p>
<pre tabindex=0><code>(gdb) set args 1
(gdb) run
Starting program: test 1
...
</code></pre><p>当然也可以直接在 <code>run</code> 后加上参数来运行：</p>
<pre tabindex=0><code>(gdb) run 1
Starting program: test 1

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400749 in Func (s=0x7fffffffe167 &quot;/data/home/joelzychen/test/test&quot;) at test.cpp:8
8           r = num;
</code></pre><p>我们发现程序出现了 Segmentation fault，此时可以通过打断点来调试程序。</p>
<h3 id=23-断点>2.3 断点<a hidden class=anchor aria-hidden=true href=#23-断点>#</a></h3>
<p>通过错误信息我们可以看到是函数 Func 中，test.cpp 的第 8 行出现了错误，于是我们可以打上两个断点，一个在进入 Func 函数时，一个在 test.cpp 文件的第 8 行，并使用 <code>info breakpoints</code> 或 <code>info b</code> 来查看我们设置了哪些断点：</p>
<pre tabindex=0><code>(gdb) b test.cpp:8
Breakpoint 1 at 0x400742: file test.cpp, line 8.
(gdb) b Func
Breakpoint 2 at 0x40071c: file test.cpp, line 4.
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400742 in Func(char const*) at test.cpp:8
2       breakpoint     keep y   0x000000000040071c in Func(char const*) at test.cpp:4
</code></pre><h3 id=24-调试>2.4 调试<a hidden class=anchor aria-hidden=true href=#24-调试>#</a></h3>
<p>设置好断点之后就可以使用 <code>run</code> 开始运行了：</p>
<pre tabindex=0><code>(gdb) run
Starting program: test 1

Breakpoint 2, Func (s=0x7fffffffe167 &quot;/data/home/joelzychen/test/test&quot;) at test.cpp:4
4           int *p = nullptr;
</code></pre><p>因为我们在 Func 函数的开头设置了一个断点，所以程序在进入 Func 函数时暂停了；我们可以使用 <code>list</code> 或 <code>l [function name]</code> 来查看函数的上下文：</p>
<pre tabindex=0><code>(gdb) l Func
1       #include &lt;iostream&gt;
2
3       void Func(const char *s) {
4           int *p = nullptr;
5           int &amp;r = static_cast&lt;int&amp;&gt;(*p);
6
7           int num = std::atoi(s);
8           r = num;
9           printf(&quot;%d\n&quot;, r);
10      }
</code></pre><p>此时我们可以使用 <code>print</code> 或 <code>p</code> 来查看变量：</p>
<pre tabindex=0><code>(gdb) p s
$1 = 0x7fffffffe187 &quot;1&quot;
(gdb) p *s
$2 = 49 '1'
</code></pre><p>到目前为止还没有出现问题，我们可以使用 <code>continue</code> 或 <code>c</code> 走到下一个断点处：</p>
<pre tabindex=0><code>(gdb) c
Continuing.

Breakpoint 2, Func (s=0x7fffffffe187 &quot;1&quot;) at test.cpp:8
8           r = num;
</code></pre><p>查看一下当前作用域的一些变量：</p>
<pre tabindex=0><code>(gdb) p s
$8 = 0x7fffffffe187 &quot;1&quot;
(gdb) p p
$9 = (int *) 0x0
(gdb) p *p
Cannot access memory at address 0x0
(gdb) p r
$10 = (int &amp;) @0x0: &lt;error reading variable&gt;
(gdb) p &amp;r
$11 = (int *) 0x0
(gdb) p num
$12 = 1
</code></pre><p>会发现 r 这个 int& 绑定到了一个被解引用的空指针上，所以 &r == nullptr，因此不能读取 r 的值，我们可以用 <code>next</code> 或 <code>n</code> 来进行单步执行，看看接下来会发生什么：</p>
<pre tabindex=0><code>(gdb) n

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400749 in Func (s=0x7fffffffe187 &quot;1&quot;) at test.cpp:8
8           r = num;
</code></pre><p>果然发生了 Segmentation fault。</p>
<h2 id=3-gdb-命令>3. GDB 命令<a hidden class=anchor aria-hidden=true href=#3-gdb-命令>#</a></h2>
<p>根据刚才的示例程序，可以整理出一些常用的 GDB 命令。</p>
<h3 id=31-启动>3.1 启动<a hidden class=anchor aria-hidden=true href=#31-启动>#</a></h3>
<ol>
<li>
<p>将 GDB 链接到一个可执行文件并启动</p>
<pre tabindex=0><code>gdb [executable file]

gdb
(gdb) file [executable file]
</code></pre></li>
<li>
<p>将 GDB 链接到一个正在运行的进程并启动</p>
<pre tabindex=0><code>gdb
(gdb) attach [PID]
</code></pre></li>
</ol>
<h3 id=32-断点>3.2 断点<a hidden class=anchor aria-hidden=true href=#32-断点>#</a></h3>
<ol>
<li>
<p>增加断点</p>
<ul>
<li><code>b [function name]</code></li>
<li><code>b [file:line]</code></li>
</ul>
</li>
<li>
<p>查看断点</p>
<ul>
<li><code>info b</code></li>
</ul>
</li>
<li>
<p>删除断点</p>
<pre tabindex=0><code>delete [breakpoint number]
d [breakpoint number]
clear # 删除当前行的断点
clear [function name] # 删除某个函数处的断点
clear [file:line] # 删除某一行的断点
</code></pre></li>
<li>
<p>禁用和启用断点</p>
<pre tabindex=0><code>disable # 禁用所有断点
disable [breakpoint number] # 禁用某个断点
enable # 启用所有断点
enable [breakpoint number] # 启用某个断点
</code></pre></li>
</ol>
<h3 id=33-运行>3.3 运行<a hidden class=anchor aria-hidden=true href=#33-运行>#</a></h3>
<ol>
<li>从头开始运行
<ul>
<li><code>run</code></li>
</ul>
</li>
<li>单步执行
<ul>
<li><code>next</code> 或 <code>n</code></li>
</ul>
</li>
<li>进入函数内部
<ul>
<li><code>step</code> 或 <code>s</code></li>
<li><code>stepi</code> 执行一条机器指令</li>
</ul>
</li>
</ol>
<h3 id=34-查看>3.4 查看<a hidden class=anchor aria-hidden=true href=#34-查看>#</a></h3>
<ol>
<li>
<p>查看代码</p>
<pre tabindex=0><code>list # 从头开始依次打印，默认每次打印 10 行
l # 同上
l [function name] # 从函数定义开始打印
l [file:line] # 从某一行开始打印
set listsize 20 # 修改每次打印的行数
</code></pre></li>
<li>
<p>查看变量</p>
<pre tabindex=0><code>print [expression] # 打印表达式
p [expression] # 同上
ptype [expression] # 打印表达式的类型
info args # 打印函数参数
info locals # 打印局部变量
info registers # 打印寄存器信息
</code></pre></li>
</ol>
<h3 id=35-修改>3.5 修改<a hidden class=anchor aria-hidden=true href=#35-修改>#</a></h3>
<ol>
<li>
<p>修改变量</p>
<pre tabindex=0><code>set variable i = 10 # 将变量 i 设置为 10
set var i = 10 # 同上
p i = 10 # 将变量 i 设置为 10，并打印
</code></pre></li>
</ol>
<h3 id=36-调用信息>3.6 调用信息<a hidden class=anchor aria-hidden=true href=#36-调用信息>#</a></h3>
<ol>
<li>查看函数调用栈信息
<ul>
<li><code>backtrace</code> 或 <code>bt</code></li>
<li><code>where</code></li>
</ul>
</li>
<li>查看当前栈帧
<ul>
<li><code>frame</code> 或 <code>f</code></li>
</ul>
</li>
</ol>
<h2 id=4-corefile>4. corefile<a hidden class=anchor aria-hidden=true href=#4-corefile>#</a></h2>
<p><a href=https://en.wikipedia.org/wiki/Core_dump>core dump</a> / crash dump / memory dump / system dump 都是指一个程序在特定时间崩溃（crash）时的内存记录，它包含了很多关键信息，比如寄存器（包括程序计数器和堆栈指针），内存管理信息，操作系统标志信息等。corefile 就是转储（dump）时的快照，corefile可以被重新执行用以调试错误信息。</p>
<h3 id=41-生成>4.1 生成<a hidden class=anchor aria-hidden=true href=#41-生成>#</a></h3>
<p>为了让系统能够生成 corefile，需要先检查配置：</p>
<pre tabindex=0><code>$ ulimit -c
unlimited
</code></pre><p>如果结果是 0 则说明系统禁止了 corefile 的生成，需要执行 <code>ulimit -c unlimited</code> 来让 corefile 能够正常生成。以刚才的示例程序为例，先执行 test 文件，生成一个 corefile：</p>
<pre tabindex=0><code>$ ./test 1
段错误 (core dumped)
$ ll /data/corefile
-rw------- 1 joelzychen dev      450560 4月  22 17:07 core_test_1587546447.28284
</code></pre><p>能够看到系统在特定的目录下（可以修改）生成了一个 corefile 叫做 core_test_1587546447.28284，我们使用 gdb 来对这个 corefile 进行调试。</p>
<h3 id=42-调试>4.2 调试<a hidden class=anchor aria-hidden=true href=#42-调试>#</a></h3>
<p>要执行 corefile 还需要准备对应的可执行文件，运行 <code>gdb [executable file] [corefile]</code> 就能开始调试了：</p>
<pre tabindex=0><code>$ gdb test /data/corefile/core_test_1587546447.28284
...
Core was generated by `./test 1'.
Program terminated with signal 11, Segmentation fault.
#0  0x0000000000400749 in Func (s=0x7ffed098c19e &quot;1&quot;) at test.cpp:8
8           r = num;
</code></pre><p>因为示例程序比较简单，因此函数调用栈也比较少，我们可以先使用 <code>bt</code> 打印函数调用栈信息：</p>
<pre tabindex=0><code>(gdb) bt
#0  0x0000000000400749 in Func (s=0x7ffed098c19e &quot;1&quot;) at test.cpp:8
#1  0x00000000004007c0 in main (argc=2, argv=0x7ffed098afb8) at test.cpp:17
</code></pre><p>我们通过 <code>frame 0</code> 或 <code>f 0</code> 进入程序崩溃的栈帧来查看相关信息：</p>
<pre tabindex=0><code>(gdb) f 0
#0  0x0000000000400749 in Func (s=0x7ffed098c19e &quot;1&quot;) at test.cpp:8
8           r = num;
(gdb) info args
s = 0x7ffed098c19e &quot;1&quot;
(gdb) info locals
p = 0x0
r = @0x0: &lt;error reading variable&gt;
num = 1
(gdb) ptype r
type = int &amp;
(gdb) ptype p
type = int *
</code></pre><p>查看一下当前栈帧的汇编代码：</p>
<pre tabindex=0><code>(gdb) disas
Dump of assembler code for function Func(char const*):
   0x0000000000400710 &lt;+0&gt;:     push   %rbp
   0x0000000000400711 &lt;+1&gt;:     mov    %rsp,%rbp
   0x0000000000400714 &lt;+4&gt;:     sub    $0x20,%rsp
   0x0000000000400718 &lt;+8&gt;:     mov    %rdi,-0x8(%rbp)
   0x000000000040071c &lt;+12&gt;:    movq   $0x0,-0x10(%rbp)
   0x0000000000400724 &lt;+20&gt;:    mov    -0x10(%rbp),%rdi
   0x0000000000400728 &lt;+24&gt;:    mov    %rdi,-0x18(%rbp)
   0x000000000040072c &lt;+28&gt;:    mov    -0x8(%rbp),%rdi
   0x0000000000400730 &lt;+32&gt;:    callq  0x4005a0 &lt;atoi@plt&gt;
   0x0000000000400735 &lt;+37&gt;:    movabs $0x400860,%rdi
   0x000000000040073f &lt;+47&gt;:    mov    %eax,-0x1c(%rbp)
   0x0000000000400742 &lt;+50&gt;:    mov    -0x1c(%rbp),%eax
   0x0000000000400745 &lt;+53&gt;:    mov    -0x18(%rbp),%rcx
=&gt; 0x0000000000400749 &lt;+57&gt;:    mov    %eax,(%rcx)
   0x000000000040074b &lt;+59&gt;:    mov    -0x18(%rbp),%rcx
   0x000000000040074f &lt;+63&gt;:    mov    (%rcx),%esi
   0x0000000000400751 &lt;+65&gt;:    mov    $0x0,%al
   0x0000000000400753 &lt;+67&gt;:    callq  0x400550 &lt;printf@plt&gt;
   0x0000000000400758 &lt;+72&gt;:    mov    %eax,-0x20(%rbp)
   0x000000000040075b &lt;+75&gt;:    add    $0x20,%rsp
   0x000000000040075f &lt;+79&gt;:    pop    %rbp
   0x0000000000400760 &lt;+80&gt;:    retq
End of assembler dump.
</code></pre><p>查看寄存器状态：</p>
<pre tabindex=0><code>(gdb) i r
rax            0x1      1
rbx            0x0      0
rcx            0x0      0
rdx            0xa      10
rsi            0x0      0
rdi            0x400860 4196448
rbp            0x7ffed098aea0   0x7ffed098aea0
rsp            0x7ffed098ae80   0x7ffed098ae80
r8             0x7f9c88bbf060   140310285643872
r9             0x7ffed098c19f   140732398092703
r10            0x1      1
r11            0x0      0
r12            0x40061c 4195868
r13            0x7ffed098afb0   140732398088112
r14            0x0      0
r15            0x0      0
rip            0x400749 0x400749 &lt;Func(char const*)+57&gt;
eflags         0x10206  [ PF IF RF ]
cs             0x33     51
ss             0x2b     43
ds             0x0      0
es             0x0      0
fs             0x0      0
gs             0x0      0
</code></pre><h2 id=5-总结>5. 总结<a hidden class=anchor aria-hidden=true href=#5-总结>#</a></h2>
<p>本文主要通过一个示例程序演示了在 Linux 环境下 GDB 的基本使用方法，整理了 GDB 的常用指令，以及调试 C/C++ 程序和 corefile 的步骤。在实际应用中 GDB 能个极大程度地提高开发和调试效率，更多的使用技巧还需要结合实践来练习。</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=http://zintrulcre.github.io/posts/c++/compilation/cmake/>
<span class=title>« Prev Page</span>
<br>
<span>CMake 入门</span>
</a>
<a class=next href=http://zintrulcre.github.io/posts/c++/basics/wrapper_escape-in-coverity/>
<span class=title>Next Page »</span>
<br>
<span>coverity 的 WRAPPER_ESCAPE 告警</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>
Zhengyu &copy; 2022
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>