<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>C++ 智能指针（3）：shared_ptr | 尾張</title>
<meta name=keywords content>
<meta name=description content="C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器
private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。
template<typename T, typename D> void SharedPointer<T, D>::release() { if (pointer) { std::cout << &#34;SharedPointer &#34; << this << &#34; counter remains &#34; << *counter << std::endl; if (--(*counter) == 0) { std::cout << &#34;SharedPointer &#34; << this << &#34; destructor called.&#34; << std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针">
<meta name=author content>
<link rel=canonical href=http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-3/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="C++ 智能指针（3）：shared_ptr">
<meta property="og:description" content="C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器
private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。
template<typename T, typename D> void SharedPointer<T, D>::release() { if (pointer) { std::cout << &#34;SharedPointer &#34; << this << &#34; counter remains &#34; << *counter << std::endl; if (--(*counter) == 0) { std::cout << &#34;SharedPointer &#34; << this << &#34; destructor called.&#34; << std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针">
<meta property="og:type" content="article">
<meta property="og:url" content="http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-3/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-01-25T17:47:38+11:00">
<meta property="article:modified_time" content="2019-01-25T17:47:38+11:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="C++ 智能指针（3）：shared_ptr">
<meta name=twitter:description content="C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器
private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。
template<typename T, typename D> void SharedPointer<T, D>::release() { if (pointer) { std::cout << &#34;SharedPointer &#34; << this << &#34; counter remains &#34; << *counter << std::endl; if (--(*counter) == 0) { std::cout << &#34;SharedPointer &#34; << this << &#34; destructor called.&#34; << std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://zintrulcre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ 智能指针（3）：shared_ptr","item":"http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-3/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 智能指针（3）：shared_ptr","name":"C\u002b\u002b 智能指针（3）：shared_ptr","description":"C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器\nprivate: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使\u0008其计数器自减1。\u0008如果计数器等于0，则表示已经没有其他的对象在使用当前指针，\u0008此时则可以销毁指针，计数器和删除器。\ntemplate\u0026lt;typename T, typename D\u0026gt; void SharedPointer\u0026lt;T, D\u0026gt;::release() { if (pointer) { std::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; counter remains \u0026quot; \u0026lt;\u0026lt; *counter \u0026lt;\u0026lt; std::endl; if (--(*counter) == 0) { std::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; destructor called.\u0026quot; \u0026lt;\u0026lt; std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针","keywords":[],"articleBody":"C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器\nprivate: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使\u0008其计数器自减1。\u0008如果计数器等于0，则表示已经没有其他的对象在使用当前指针，\u0008此时则可以销毁指针，计数器和删除器。\ntemplatevoid SharedPointer::release() { if (pointer) { std::cout reset函数将指针设为other的指针\ntemplatevoid SharedPointer::reset(const SharedPointer\u0026other) { pointer = other.pointer; counter = other.counter; deleter = other.deleter; if (pointer) ++(*counter); } 析构函数可以直接调用release函数\ntemplateSharedPointer::~SharedPointer() { release(); } 拷贝构造函数可以直接调用reset函数\ntemplateSharedPointer::SharedPointer(const SharedPointer\u0026other) { std::cout 使用赋值操作符时先调用release函数，再调用reset函数\ntemplateSharedPointer\u0026SharedPointer::operator=(const SharedPointer\u0026other) { std::cout 实现 根据shared_ptr的源码，能够大致实现SharedPointer类\ntemplateclass SharedPointer { public: explicit SharedPointer(T *t = nullptr, D *d = nullptr); ~SharedPointer(); T \u0026operator*(); T *operator-(); void reset(const SharedPointer \u0026other); void release(); SharedPointer(const SharedPointer \u0026other); SharedPointer \u0026operator=(const SharedPointer \u0026other); private: int *counter; T *pointer; D *deleter; }; templatevoid SharedPointer::reset(const SharedPointer\u0026other) { pointer = other.pointer; counter = other.counter; deleter = other.deleter; if (pointer) ++(*counter); } templatevoid SharedPointer::release() { if (pointer) { std::cout SharedPointer::SharedPointer(T *t, D *d): pointer(t), deleter(d) { if (pointer) counter = new int(1); else counter = nullptr; std::cout SharedPointer::SharedPointer(const SharedPointer\u0026other) { std::cout SharedPointer::~SharedPointer() { release(); } templateT \u0026SharedPointer::operator*() { return *pointer; } templateT *SharedPointer::operator-() { return pointer; } templateSharedPointer\u0026SharedPointer::operator=(const SharedPointer\u0026other) { std::cout 测试 尝试使用拷贝构造函数和赋值操作符使多个SharedPointer对象使用同一个指针，以及使用reset函数清空智能指针对象的指针\nint main() { Deleter *deleter = new Deleter(); Obj *o = new Obj(); SharedPointers1(o, deleter); SharedPointers2(s1); SharedPointers3; s3 = s1; return 0; } /* output: Construct SharedPointer 0x7ffeeebdda00 constructor called. SharedPointer 0x7ffeeebdd9e8 copy constructor called. SharedPointer 0x7ffeeebdd9d0 constructor called. SharedPointer 0x7ffeeebdd9d0 assignment operator called. SharedPointer 0x7ffeeebdd9d0 counter remains 3 SharedPointer 0x7ffeeebdd9e8 counter remains 2 SharedPointer 0x7ffeeebdda00 counter remains 1 SharedPointer 0x7ffeeebdda00 destructor called. Destruct */ 考虑如下一个类\nclass Object : public Obj { public: SharedPointerS; }; 创建两个Object类型的对象\nint main() { SharedPointers1(new Object()); SharedPointers2(new Object()); s1-S = s2; s2-S = s1; return 0; } /* output: Construct SharedPointer 0x7f88eac02ab0 constructor called. SharedPointer 0x7ffee0bfaa20 constructor called. Construct SharedPointer 0x7f88eac02ae0 constructor called. SharedPointer 0x7ffee0bfa9f8 constructor called. SharedPointer 0x7f88eac02ab0 assignment operator called. SharedPointer 0x7f88eac02ae0 assignment operator called. SharedPointer 0x7ffee0bfa9f8 counter remains 2 SharedPointer 0x7ffee0bfaa20 counter remains 2 */ 两个Object类型的指针都包含了一个SharedPointer类型的智能指针对象，但这两个指针又依赖于SharedPointer对象去进行销毁，导致最后s1和s2的计数器都不能减为0，从而不能正确地\u0008销毁指针，导致了内存泄漏。这种现象叫做交叉引用。\n总结 SharedPointer利用Reference counting（计数引用）解决了多个对象使用同一个指针时自动销毁指针的问题，但又会发生交叉引用时不能够正确销毁指针的问题。\u0008\nshared_pointer源码 templateclass _LIBCPP_TEMPLATE_VIS shared_ptr { public: typedef _Tp element_type; #if _LIBCPP_STD_VER  14 typedef weak_ptr weak_type; #endif private: element_type* __ptr_; __shared_weak_count* __cntrl_; struct __nat {int __for_bool_;}; public: _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT; _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT; templateexplicit shared_ptr(_Yp* __p, typename enable_if::value, __nat::type = __nat()); templateshared_ptr(_Yp* __p, _Dp __d, typename enable_if::value, __nat::type = __nat()); templateshared_ptr(_Yp* __p, _Dp __d, _Alloc __a, typename enable_if::value, __nat::type = __nat()); template shared_ptr(nullptr_t __p, _Dp __d); template shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a); template_LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026 __r, element_type* __p) _NOEXCEPT; _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026 __r) _NOEXCEPT; template_LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026 __r, typename enable_if::value, __nat::type = __nat()) _NOEXCEPT; #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY shared_ptr(shared_ptr\u0026\u0026 __r) _NOEXCEPT; template_LIBCPP_INLINE_VISIBILITY shared_ptr(shared_ptr\u0026\u0026 __r, typename enable_if::value, __nat::type = __nat()) _NOEXCEPT; #endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES templateexplicit shared_ptr(const weak_ptr\u0026 __r, typename enable_if::value, __nat::type= __nat()); #if _LIBCPP_STD_VER shared_ptr(auto_ptr\u0026\u0026 __r, typename enable_if::value, __nat::type = __nat()); #else templateshared_ptr(auto_ptr __r, typename enable_if::value, __nat::type = __nat()); #endif #endif #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES template shared_ptr(unique_ptr\u0026\u0026, typename enable_if ::value \u0026\u0026 !is_array::value \u0026\u0026 is_convertible::pointer, element_type*::value, __nat ::type = __nat()); template shared_ptr(unique_ptr\u0026\u0026, typename enable_if ::value \u0026\u0026 !is_array::value \u0026\u0026 is_convertible::pointer, element_type*::value, __nat ::type = __nat()); #else // _LIBCPP_HAS_NO_RVALUE_REFERENCES template shared_ptr(unique_ptr, typename enable_if ::value \u0026\u0026 !is_array::value \u0026\u0026 is_convertible::pointer, element_type*::value, __nat ::type = __nat()); template shared_ptr(unique_ptr, typename enable_if ::value \u0026\u0026 !is_array::value \u0026\u0026 is_convertible::pointer, element_type*::value, __nat ::type = __nat()); #endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES ~shared_ptr(); _LIBCPP_INLINE_VISIBILITY shared_ptr\u0026 operator=(const shared_ptr\u0026 __r) _NOEXCEPT; templatetypename enable_if ::value, shared_ptr\u0026 ::type _LIBCPP_INLINE_VISIBILITY operator=(const shared_ptr\u0026 __r) _NOEXCEPT; #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY shared_ptr\u0026 operator=(shared_ptr\u0026\u0026 __r) _NOEXCEPT; templatetypename enable_if ::value, shared_ptr\u0026 ::type _LIBCPP_INLINE_VISIBILITY operator=(shared_ptr\u0026\u0026 __r); #if _LIBCPP_STD_VER _LIBCPP_INLINE_VISIBILITY typename enable_if ::value \u0026\u0026 is_convertible::value, shared_ptr ::type\u0026 operator=(auto_ptr\u0026\u0026 __r); #endif #else // _LIBCPP_HAS_NO_RVALUE_REFERENCES #if _LIBCPP_STD_VER _LIBCPP_INLINE_VISIBILITY typename enable_if ::value \u0026\u0026 is_convertible::value, shared_ptr\u0026 ::type operator=(auto_ptr __r); #endif #endif template typename enable_if ::value \u0026\u0026 is_convertible::pointer, element_type*::value, shared_ptr\u0026 ::type #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY operator=(unique_ptr\u0026\u0026 __r); #else // _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY operator=(unique_ptr__r); #endif _LIBCPP_INLINE_VISIBILITY void swap(shared_ptr\u0026 __r) _NOEXCEPT; _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT; templatetypename enable_if ::value, void ::type _LIBCPP_INLINE_VISIBILITY reset(_Yp* __p); templatetypename enable_if ::value, void ::type _LIBCPP_INLINE_VISIBILITY reset(_Yp* __p, _Dp __d); templatetypename enable_if ::value, void ::type _LIBCPP_INLINE_VISIBILITY reset(_Yp* __p, _Dp __d, _Alloc __a); _LIBCPP_INLINE_VISIBILITY element_type* get() const _NOEXCEPT {return __ptr_;} _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference::type operator*() const _NOEXCEPT {return *__ptr_;} _LIBCPP_INLINE_VISIBILITY element_type* operator-() const _NOEXCEPT {return __ptr_;} _LIBCPP_INLINE_VISIBILITY long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_-use_count() : 0;} _LIBCPP_INLINE_VISIBILITY bool unique() const _NOEXCEPT {return use_count() == 1;} _LIBCPP_INLINE_VISIBILITY _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;} template _LIBCPP_INLINE_VISIBILITY bool owner_before(shared_ptr const\u0026 __p) const _NOEXCEPT {return __cntrl_ _LIBCPP_INLINE_VISIBILITY bool owner_before(weak_ptr const\u0026 __p) const _NOEXCEPT {return __cntrl_ _LIBCPP_INLINE_VISIBILITY _Dp* __get_deleter() const _NOEXCEPT {return static_cast(__cntrl_ ? const_cast(__cntrl_-__get_deleter(typeid(_Dp))) : nullptr);} #endif // _LIBCPP_NO_RTTI #ifndef _LIBCPP_HAS_NO_VARIADICS templatestatic shared_ptr make_shared(_Args\u0026\u0026 ...__args); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a, _Args\u0026\u0026 ...__args); #else // _LIBCPP_HAS_NO_VARIADICS static shared_ptr make_shared(); templatestatic shared_ptr make_shared(_A0\u0026); templatestatic shared_ptr make_shared(_A0\u0026, _A1\u0026); templatestatic shared_ptr make_shared(_A0\u0026, _A1\u0026, _A2\u0026); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a, _A0\u0026 __a0); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a, _A0\u0026 __a0, _A1\u0026 __a1); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a, _A0\u0026 __a0, _A1\u0026 __a1, _A2\u0026 __a2); #endif // _LIBCPP_HAS_NO_VARIADICS private: template ::value struct __shared_ptr_default_allocator { typedef allocator type; }; template struct __shared_ptr_default_allocator{ typedef allocator type; }; template _LIBCPP_INLINE_VISIBILITY typename enable_if* ::value, void::type __enable_weak_this(const enable_shared_from_this* __e, _OrigPtr* __ptr) _NOEXCEPT { typedef typename remove_cv::type _RawYp; if (__e \u0026\u0026 __e-__weak_this_.expired()) { __e-__weak_this_ = shared_ptr(*this, const_cast(static_cast(__ptr))); } } _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {} template friend class _LIBCPP_TEMPLATE_VIS shared_ptr; template friend class _LIBCPP_TEMPLATE_VIS weak_ptr; }; ","wordCount":"1323","inLanguage":"en","datePublished":"2019-01-25T17:47:38+11:00","dateModified":"2019-01-25T17:47:38+11:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-3/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://zintrulcre.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://zintrulcre.github.io/archives/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=http://zintrulcre.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://zintrulcre.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://zintrulcre.github.io/posts/>Posts</a></div>
<h1 class=post-title>
C++ 智能指针（3）：shared_ptr
</h1>
<div class=post-meta><span title="2019-01-25 17:47:38 +1100 +1100">January 25, 2019</span>&nbsp;·&nbsp;7 min
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#c%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%883shared_ptr aria-label=C++智能指针（3）：shared_ptr>C++智能指针（3）：shared_ptr</a><ul>
<li>
<a href=#%e5%88%86%e6%9e%90 aria-label=分析>分析</a></li>
<li>
<a href=#%e5%ae%9e%e7%8e%b0 aria-label=实现>实现</a></li>
<li>
<a href=#%e6%b5%8b%e8%af%95 aria-label=测试>测试</a></li>
<li>
<a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li>
<li>
<a href=#shared_pointer%e6%ba%90%e7%a0%81 aria-label=shared_pointer源码>shared_pointer源码</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=c智能指针3shared_ptr>C++智能指针（3）：shared_ptr<a hidden class=anchor aria-hidden=true href=#c智能指针3shared_ptr>#</a></h1>
<h2 id=分析>分析<a hidden class=anchor aria-hidden=true href=#分析>#</a></h2>
<p>UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器</p>
<pre tabindex=0><code>private:
    int *counter;
    T *pointer;
    D *deleter;
</code></pre><p>计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
void SharedPointer&lt;T, D&gt;::release() {
    if (pointer) {
        std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; counter remains &quot; &lt;&lt; *counter &lt;&lt; std::endl;
        if (--(*counter) == 0) {
            std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; destructor called.&quot; &lt;&lt; std::endl;
            (*deleter)(pointer);
            (*deleter)(counter);
            (*deleter)(deleter);
            pointer = nullptr;
            counter = nullptr;
            deleter = nullptr;
        }
    }
}
</code></pre><p>reset函数将指针设为other的指针</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
void SharedPointer&lt;T, D&gt;::reset(const SharedPointer&lt;T, D&gt; &amp;other) {
    pointer = other.pointer;
    counter = other.counter;
    deleter = other.deleter;
    if (pointer)
        ++(*counter);
}
</code></pre><p>析构函数可以直接调用release函数</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::~SharedPointer() {
    release();
}
</code></pre><p>拷贝构造函数可以直接调用reset函数</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::SharedPointer(const SharedPointer&lt;T, D&gt; &amp;other) {
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; copy constructor called.&quot; &lt;&lt; std::endl;
    reset(other);
}
</code></pre><p>使用赋值操作符时先调用release函数，再调用reset函数</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt; &amp;SharedPointer&lt;T, D&gt;::operator=(const SharedPointer&lt;T, D&gt; &amp;other) {
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; assignment operator called.&quot; &lt;&lt; std::endl;
    if (this != &amp;other) {
        release();
        reset(other);
    }
    return *this;
}
</code></pre><h2 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h2>
<p>根据shared_ptr的源码，能够大致实现SharedPointer类</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
class SharedPointer {
public:
    explicit SharedPointer(T *t = nullptr, D *d = nullptr);

    ~SharedPointer();

    T &amp;operator*();

    T *operator-&gt;();

    void reset(const SharedPointer &amp;other);

    void release();

    SharedPointer(const SharedPointer &amp;other);

    SharedPointer &amp;operator=(const SharedPointer &amp;other);

private:

    int *counter;
    T *pointer;
    D *deleter;
};

template&lt;typename T, typename D&gt;
void SharedPointer&lt;T, D&gt;::reset(const SharedPointer&lt;T, D&gt; &amp;other) {
    pointer = other.pointer;
    counter = other.counter;
    deleter = other.deleter;
    if (pointer)
        ++(*counter);
}

template&lt;typename T, typename D&gt;
void SharedPointer&lt;T, D&gt;::release() {
    if (pointer) {
        std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; counter remains &quot; &lt;&lt; *counter &lt;&lt; std::endl;
        if (--(*counter) == 0) {
            std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; destructor called.&quot; &lt;&lt; std::endl;
            (*deleter)(pointer);
            (*deleter)(counter);
            (*deleter)(deleter);
            pointer = nullptr;
            counter = nullptr;
            deleter = nullptr;
        }
    }
}

template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::SharedPointer(T *t, D *d): pointer(t), deleter(d) {
    if (pointer)
        counter = new int(1);
    else
        counter = nullptr;
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; constructor called.&quot; &lt;&lt; std::endl;
}

template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::SharedPointer(const SharedPointer&lt;T, D&gt; &amp;other) {
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; copy constructor called.&quot; &lt;&lt; std::endl;
    reset(other);
}


template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::~SharedPointer() {
    release();
}

template&lt;typename T, typename D&gt;
T &amp;SharedPointer&lt;T, D&gt;::operator*() {
    return *pointer;
}

template&lt;typename T, typename D&gt;
T *SharedPointer&lt;T, D&gt;::operator-&gt;() {
    return pointer;
}

template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt; &amp;SharedPointer&lt;T, D&gt;::operator=(const SharedPointer&lt;T, D&gt; &amp;other) {
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; assignment operator called.&quot; &lt;&lt; std::endl;
    if (this != &amp;other) {
        release();
        reset(other);
    }
    return *this;
}
</code></pre><h2 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h2>
<p>尝试使用拷贝构造函数和赋值操作符使多个SharedPointer对象使用同一个指针，以及使用reset函数清空智能指针对象的指针</p>
<pre tabindex=0><code>int main() {
    Deleter *deleter = new Deleter();
    Obj *o = new Obj();
    SharedPointer&lt;Obj, Deleter&gt; s1(o, deleter);
    SharedPointer&lt;Obj, Deleter&gt; s2(s1);
    SharedPointer&lt;Obj, Deleter&gt; s3;
    s3 = s1;
    return 0;
}
/*
output:
Construct
SharedPointer 0x7ffeeebdda00 constructor called.
SharedPointer 0x7ffeeebdd9e8 copy constructor called.
SharedPointer 0x7ffeeebdd9d0 constructor called.
SharedPointer 0x7ffeeebdd9d0 assignment operator called.
SharedPointer 0x7ffeeebdd9d0 counter remains 3
SharedPointer 0x7ffeeebdd9e8 counter remains 2
SharedPointer 0x7ffeeebdda00 counter remains 1
SharedPointer 0x7ffeeebdda00 destructor called.
Destruct
*/
</code></pre><p>考虑如下一个类</p>
<pre tabindex=0><code>class Object : public Obj {
public:
    SharedPointer&lt;Object, Deleter&gt; S;
};
</code></pre><p>创建两个Object类型的对象</p>
<pre tabindex=0><code>int main() {
    SharedPointer&lt;Object, Deleter&gt; s1(new Object());
    SharedPointer&lt;Object, Deleter&gt; s2(new Object());
    s1-&gt;S = s2;
    s2-&gt;S = s1;
    return 0;
}
/*
output:
Construct
SharedPointer 0x7f88eac02ab0 constructor called.
SharedPointer 0x7ffee0bfaa20 constructor called.
Construct
SharedPointer 0x7f88eac02ae0 constructor called.
SharedPointer 0x7ffee0bfa9f8 constructor called.
SharedPointer 0x7f88eac02ab0 assignment operator called.
SharedPointer 0x7f88eac02ae0 assignment operator called.
SharedPointer 0x7ffee0bfa9f8 counter remains 2
SharedPointer 0x7ffee0bfaa20 counter remains 2
*/
</code></pre><p>两个Object类型的指针都包含了一个SharedPointer类型的智能指针对象，但这两个指针又依赖于SharedPointer对象去进行销毁，导致最后s1和s2的计数器都不能减为0，从而不能正确地销毁指针，导致了内存泄漏。这种现象叫做交叉引用。</p>
<h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2>
<p>SharedPointer利用<a href=https://en.wikipedia.org/wiki/Reference_counting>Reference counting</a>（计数引用）解决了多个对象使用同一个指针时自动销毁指针的问题，但又会发生交叉引用时不能够正确销毁指针的问题。</p>
<h2 id=shared_pointer源码>shared_pointer源码<a hidden class=anchor aria-hidden=true href=#shared_pointer源码>#</a></h2>
<pre tabindex=0><code>template&lt;class _Tp&gt;
class _LIBCPP_TEMPLATE_VIS shared_ptr
{
public:
    typedef _Tp element_type;

#if _LIBCPP_STD_VER &gt; 14
    typedef weak_ptr&lt;_Tp&gt; weak_type;
#endif
private:
    element_type*      __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;
    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;
    template&lt;class _Yp&gt;
        explicit shared_ptr(_Yp* __p,
                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
    template&lt;class _Yp, class _Dp&gt;
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
    template&lt;class _Yp, class _Dp, class _Alloc&gt;
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
    template &lt;class _Dp&gt; shared_ptr(nullptr_t __p, _Dp __d);
    template &lt;class _Dp, class _Alloc&gt; shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template&lt;class _Yp&gt; _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r, element_type* __p) _NOEXCEPT;
    _LIBCPP_INLINE_VISIBILITY
    shared_ptr(const shared_ptr&amp; __r) _NOEXCEPT;
    template&lt;class _Yp&gt;
        _LIBCPP_INLINE_VISIBILITY
        shared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat())
                       _NOEXCEPT;
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY
    shared_ptr(shared_ptr&amp;&amp; __r) _NOEXCEPT;
    template&lt;class _Yp&gt; _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat())
                       _NOEXCEPT;
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template&lt;class _Yp&gt; explicit shared_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type= __nat());
#if _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template&lt;class _Yp&gt;
        shared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
#else
    template&lt;class _Yp&gt;
        shared_ptr(auto_ptr&lt;_Yp&gt; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
#endif
#endif
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template &lt;class _Yp, class _Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp;,
                   typename enable_if
                   &lt;
                       !is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
                       __nat
                   &gt;::type = __nat());
    template &lt;class _Yp, class _Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp;,
                   typename enable_if
                   &lt;
                       is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
                       __nat
                   &gt;::type = __nat());
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template &lt;class _Yp, class _Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;,
                   typename enable_if
                   &lt;
                       !is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
                       __nat
                   &gt;::type = __nat());
    template &lt;class _Yp, class _Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;,
                   typename enable_if
                   &lt;
                       is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
                       __nat
                   &gt;::type = __nat());
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

    ~shared_ptr();

    _LIBCPP_INLINE_VISIBILITY
    shared_ptr&amp; operator=(const shared_ptr&amp; __r) _NOEXCEPT;
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr&amp;
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        operator=(const shared_ptr&lt;_Yp&gt;&amp; __r) _NOEXCEPT;
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY
    shared_ptr&amp; operator=(shared_ptr&amp;&amp; __r) _NOEXCEPT;
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr&lt;_Tp&gt;&amp;
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        operator=(shared_ptr&lt;_Yp&gt;&amp;&amp; __r);
#if _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
    template&lt;class _Yp&gt;
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if
        &lt;
            !is_array&lt;_Yp&gt;::value &amp;&amp;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr
        &gt;::type&amp;
        operator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);
#endif
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
#if _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
    template&lt;class _Yp&gt;
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if
        &lt;
            !is_array&lt;_Yp&gt;::value &amp;&amp;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr&amp;
        &gt;::type
        operator=(auto_ptr&lt;_Yp&gt; __r);
#endif
#endif
    template &lt;class _Yp, class _Dp&gt;
        typename enable_if
        &lt;
            !is_array&lt;_Yp&gt;::value &amp;&amp;
            is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
            shared_ptr&amp;
        &gt;::type
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        _LIBCPP_INLINE_VISIBILITY
        operator=(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp; __r);
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        _LIBCPP_INLINE_VISIBILITY
        operator=(unique_ptr&lt;_Yp, _Dp&gt; __r);
#endif

    _LIBCPP_INLINE_VISIBILITY
    void swap(shared_ptr&amp; __r) _NOEXCEPT;
    _LIBCPP_INLINE_VISIBILITY
    void reset() _NOEXCEPT;
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            void
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        reset(_Yp* __p);
    template&lt;class _Yp, class _Dp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            void
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        reset(_Yp* __p, _Dp __d);
    template&lt;class _Yp, class _Dp, class _Alloc&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            void
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    _LIBCPP_INLINE_VISIBILITY
    element_type* get() const _NOEXCEPT {return __ptr_;}
    _LIBCPP_INLINE_VISIBILITY
    typename add_lvalue_reference&lt;element_type&gt;::type operator*() const _NOEXCEPT
        {return *__ptr_;}
    _LIBCPP_INLINE_VISIBILITY
    element_type* operator-&gt;() const _NOEXCEPT {return __ptr_;}
    _LIBCPP_INLINE_VISIBILITY
    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_-&gt;use_count() : 0;}
    _LIBCPP_INLINE_VISIBILITY
    bool unique() const _NOEXCEPT {return use_count() == 1;}
    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}
    template &lt;class _Up&gt;
        _LIBCPP_INLINE_VISIBILITY
        bool owner_before(shared_ptr&lt;_Up&gt; const&amp; __p) const _NOEXCEPT
        {return __cntrl_ &lt; __p.__cntrl_;}
    template &lt;class _Up&gt;
        _LIBCPP_INLINE_VISIBILITY
        bool owner_before(weak_ptr&lt;_Up&gt; const&amp; __p) const _NOEXCEPT
        {return __cntrl_ &lt; __p.__cntrl_;}
    _LIBCPP_INLINE_VISIBILITY
    bool
    __owner_equivalent(const shared_ptr&amp; __p) const
        {return __cntrl_ == __p.__cntrl_;}

#ifndef _LIBCPP_NO_RTTI
    template &lt;class _Dp&gt;
        _LIBCPP_INLINE_VISIBILITY
        _Dp* __get_deleter() const _NOEXCEPT
            {return static_cast&lt;_Dp*&gt;(__cntrl_
                    ? const_cast&lt;void *&gt;(__cntrl_-&gt;__get_deleter(typeid(_Dp)))
                      : nullptr);}
#endif  // _LIBCPP_NO_RTTI

#ifndef _LIBCPP_HAS_NO_VARIADICS

    template&lt;class ..._Args&gt;
        static
        shared_ptr&lt;_Tp&gt;
        make_shared(_Args&amp;&amp; ...__args);

    template&lt;class _Alloc, class ..._Args&gt;
        static
        shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp; ...__args);

#else  // _LIBCPP_HAS_NO_VARIADICS

    static shared_ptr&lt;_Tp&gt; make_shared();

    template&lt;class _A0&gt;
        static shared_ptr&lt;_Tp&gt; make_shared(_A0&amp;);

    template&lt;class _A0, class _A1&gt;
        static shared_ptr&lt;_Tp&gt; make_shared(_A0&amp;, _A1&amp;);

    template&lt;class _A0, class _A1, class _A2&gt;
        static shared_ptr&lt;_Tp&gt; make_shared(_A0&amp;, _A1&amp;, _A2&amp;);

    template&lt;class _Alloc&gt;
        static shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a);

    template&lt;class _Alloc, class _A0&gt;
        static shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a, _A0&amp; __a0);

    template&lt;class _Alloc, class _A0, class _A1&gt;
        static shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a, _A0&amp; __a0, _A1&amp; __a1);

    template&lt;class _Alloc, class _A0, class _A1, class _A2&gt;
        static shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a, _A0&amp; __a0, _A1&amp; __a1, _A2&amp; __a2);

#endif  // _LIBCPP_HAS_NO_VARIADICS

private:
    template &lt;class _Yp, bool = is_function&lt;_Yp&gt;::value&gt;
        struct __shared_ptr_default_allocator
        {
            typedef allocator&lt;_Yp&gt; type;
        };

    template &lt;class _Yp&gt;
        struct __shared_ptr_default_allocator&lt;_Yp, true&gt;
        {
            typedef allocator&lt;__shared_ptr_dummy_rebind_allocator_type&gt; type;
        };

    template &lt;class _Yp, class _OrigPtr&gt;
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if&lt;is_convertible&lt;_OrigPtr*,
                                          const enable_shared_from_this&lt;_Yp&gt;*
        &gt;::value,
            void&gt;::type
        __enable_weak_this(const enable_shared_from_this&lt;_Yp&gt;* __e,
                           _OrigPtr* __ptr) _NOEXCEPT
        {
            typedef typename remove_cv&lt;_Yp&gt;::type _RawYp;
            if (__e &amp;&amp; __e-&gt;__weak_this_.expired())
            {
                __e-&gt;__weak_this_ = shared_ptr&lt;_RawYp&gt;(*this,
                    const_cast&lt;_RawYp*&gt;(static_cast&lt;const _Yp*&gt;(__ptr)));
            }
        }

    _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {}

    template &lt;class _Up&gt; friend class _LIBCPP_TEMPLATE_VIS shared_ptr;
    template &lt;class _Up&gt; friend class _LIBCPP_TEMPLATE_VIS weak_ptr;
};
</code></pre>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=http://zintrulcre.github.io/posts/deep-learning/methods-to-prevent-overfitting-in-deep-learning/>
<span class=title>« Prev Page</span>
<br>
<span>Methods to Prevent Overfitting in Deep Learning</span>
</a>
<a class=next href=http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-2/>
<span class=title>Next Page »</span>
<br>
<span>C++ 智能指针（2）：unique_ptr</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>
Zhengyu &copy; 2022
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>