<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>C++ 智能指针（1）：auto_ptr | 尾張</title>
<meta name=keywords content>
<meta name=description content="C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类
class Object { public: Object() { std::cout << &#34;Construct&#34; << std::endl; } Object(const Object &other) { std::cout << &#34;Copy&#34; << std::endl; } Object(Object &&other) noexcept { std::cout << &#34;Move&#34; << std::endl; } ~Object() { std::cout << &#34;Destruct&#34; << std::endl; } void Print() { std::cout << &#34;Print&#34; << std::endl; } }; 创建一个指向 Object 类型的指针
int main() { Object *o = new Object(); o->Print(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象">
<meta name=author content>
<link rel=canonical href=http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-1/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="C++ 智能指针（1）：auto_ptr">
<meta property="og:description" content="C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类
class Object { public: Object() { std::cout << &#34;Construct&#34; << std::endl; } Object(const Object &other) { std::cout << &#34;Copy&#34; << std::endl; } Object(Object &&other) noexcept { std::cout << &#34;Move&#34; << std::endl; } ~Object() { std::cout << &#34;Destruct&#34; << std::endl; } void Print() { std::cout << &#34;Print&#34; << std::endl; } }; 创建一个指向 Object 类型的指针
int main() { Object *o = new Object(); o->Print(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象">
<meta property="og:type" content="article">
<meta property="og:url" content="http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-1/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-12-27T15:21:35+11:00">
<meta property="article:modified_time" content="2018-12-27T15:21:35+11:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="C++ 智能指针（1）：auto_ptr">
<meta name=twitter:description content="C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类
class Object { public: Object() { std::cout << &#34;Construct&#34; << std::endl; } Object(const Object &other) { std::cout << &#34;Copy&#34; << std::endl; } Object(Object &&other) noexcept { std::cout << &#34;Move&#34; << std::endl; } ~Object() { std::cout << &#34;Destruct&#34; << std::endl; } void Print() { std::cout << &#34;Print&#34; << std::endl; } }; 创建一个指向 Object 类型的指针
int main() { Object *o = new Object(); o->Print(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://zintrulcre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ 智能指针（1）：auto_ptr","item":"http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-1/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 智能指针（1）：auto_ptr","name":"C\u002b\u002b 智能指针（1）：auto_ptr","description":"C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类\nclass Object { public: Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Construct\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(const Object \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(Object \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Destruct\u0026#34; \u0026lt;\u0026lt; std::endl; } void Print() { std::cout \u0026lt;\u0026lt; \u0026#34;Print\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 创建一个指向 Object 类型的指针\nint main() { Object *o = new Object(); o-\u0026gt;Print(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象","keywords":[],"articleBody":"C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类\nclass Object { public: Object() { std::cout  \"Construct\"  std::endl; } Object(const Object \u0026other) { std::cout  \"Copy\"  std::endl; } Object(Object \u0026\u0026other) noexcept { std::cout  \"Move\"  std::endl; } ~Object() { std::cout  \"Destruct\"  std::endl; } void Print() { std::cout  \"Print\"  std::endl; } }; 创建一个指向 Object 类型的指针\nint main() { Object *o = new Object(); o-Print(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象\nint main() { Object *o1 = new Object(); o1-Print(); Object o2 = Object(); o2.Print(); return 0; } /* output: Construct Print Construct Print Destruct */ 产生这样的结果是因为对象创建在栈（stack）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。\n实现 根据auto_ptr的源码，能够大致实现 AutoPointer 类\ntemplatetypename T class AutoPointer { public: explicit AutoPointer(T *t); ~AutoPointer(); T \u0026operator*(); T *operator-(); T *release(); void reset(T *p); AutoPointer(AutoPointerT \u0026other); AutoPointerT \u0026operator=(AutoPointerT const \u0026other); private: T *pointer; }; templatetypename T AutoPointerT::AutoPointer(T *t) { std::cout  \"AutoPointer \"  this  \" constructor called.\"  std::endl; this-pointer = t; } templatetypename T AutoPointerT::~AutoPointer() { std::cout  \"AutoPointer \"  this  \" destructor called.\"  std::endl; delete this-pointer; } templatetypename T T \u0026AutoPointerT::operator*() { return *this-pointer; } templatetypename T T *AutoPointerT::operator-() { return this-pointer; } templatetypename T T *AutoPointerT::release() { T *new_pointer = this-pointer; this-pointer = nullptr; return new_pointer; } templatetypename T void AutoPointerT::reset(T *p) { if (this-pointer != p) { delete this-pointer; this-pointer = p; } } templatetypename T AutoPointerT::AutoPointer(AutoPointerT \u0026other) { std::cout  \"AutoPointer \"  this  \" copy constructor called.\"  std::endl; this-pointer = other.release(); } templatetypename T AutoPointerT \u0026AutoPointerT::operator=(AutoPointerT const \u0026other) { std::cout  \"AutoPointer \"  this  \" assignment operator called.\"  std::endl; if (this-pointer != other.pointer) this-reset(other.release()); return *this; }  构造函数直接将 AutoPointer 类的 pointer 指针指向传入的参数指针所指向的地址 拷贝构造函数先对参数对象的指针进行 release 操作，也就是将参数对象的私有成员 pointer 指针置为 nullptr 并返回其原本指向的地址，然后将自身的 pointer 指向这个地址 赋值操作符先判断传入的参数是否是当前的 AutoPointer 类对象本身，如果是的话直接返回 this 指针，否则先对参数对象的指针进行 release 操作，并 delete 掉当前对象的 pointer，再将 pointer 指向参数对象的 pointer 原本指向的地址，这样的实现有效地规避了迷途指针（也称悬空指针或野指针）。  测试 创建单个 AutoPointer 类对象时能够正常使用。\nint main() { Object *o = new Object(); AutoPointerObject a1(o); (*a1).Print(); a1-Print(); return 0; } /* output: Construct AutoPointer 0x7fe680c02ab0 constructor called. Print Print AutoPointer 0x7fe680c02ab0 destructor called. Destruct */ 创建两个 AutoPointer 类对象时如果使用同一个 Object 指针进行初始化，那么在程序退出时 Object 对象会被两个 AutoPointer 类对象各析构一次，也就是说同一块地址会被 delete 两次，造成运行时报错。\nint main() { Object *o = new Object(); AutoPointerObject a1(o); AutoPointerObject a2(o); return 0; } /* output: Construct AutoPointer 0x7ffee3fa0178 constructor called. AutoPointer 0x7ffee3fa0170 constructor called. AutoPointer 0x7ffee3fa0170 destructor called. Destruct AutoPointer 0x7ffee3fa0178 destructor called. Destruct cpp(9015,0x1197a25c0) malloc: *** error for object 0x7fe9dec02b40: pointer being freed was not allocated cpp(9015,0x1197a25c0) malloc: *** set a breakpoint in malloc_error_break to debug */ 使用拷贝构造函数将一个 AutoPointer 类对象 a1 拷贝给另一个 AutoPointer 类对象 a2 时，Object 指针 o 原本是属于 a1 的，在 a2 调用拷贝构造函数之后，a1 的 pointer 变成了空指针，而 s2 拥有了指针 o，造成了所有权转移。\nint main() { Object *o = new Object(); AutoPointerObject a1(o); AutoPointerObject a2(a1); return 0; } /* output: Construct AutoPointer 0x7fd15bc02ab0 constructor called. AutoPointer 0x7fd15bc02ab0 copy constructor called. AutoPointer 0x7fd15bc02ab0 destructor called. Destruct AutoPointer 0x0 destructor called. */ 使用赋值操作符也会有所有权转移的问题。\nint main() { Object *o = new Object(); AutoPointerObject a1(o); AutoPointerObject a2 = a1; return 0; } /* output: Construct AutoPointer 0x7ff5d5402ab0 constructor called. AutoPointer 0x7ff5d5402ab0 copy constructor called. AutoPointer 0x7ff5d5402ab0 destructor called. Destruct AutoPointer 0x0 destructor called. */ 总结 AutoPointer 有效地解决了野指针问题，但又会引入一些其他的问题，例如\n  所有权转移\n 将 AutoPointer 作为参数进行拷贝构造或赋值操作时造成所有权转移    内存泄漏\n 在析构函数中使用了delete进行指针的销毁，但如果以数组指针进行初始化 AutoPointer s1(new int[10]) 会因为没有销毁数组\u0008的其它元素而造成内存泄漏\u0008    auto_ptr源码 templateclass _Tp class _LIBCPP_TEMPLATE_VIS auto_ptr { private: _Tp* __ptr_; public: typedef _Tp element_type; _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {} _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr\u0026 __p) throw() : __ptr_(__p.release()) {} templateclass _Up _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_Up\u0026 __p) throw() : __ptr_(__p.release()) {} _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026 operator=(auto_ptr\u0026 __p) throw() {reset(__p.release()); return *this;} templateclass _Up _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026 operator=(auto_ptr_Up\u0026 __p) throw() {reset(__p.release()); return *this;} _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026 operator=(auto_ptr_ref_Tp __p) throw() {reset(__p.__ptr_); return *this;} _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp\u0026 operator*() const throw() {return *__ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* operator-() const throw() {return __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* release() throw() { _Tp* __t = __ptr_; __ptr_ = 0; return __t; } _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw() { if (__ptr_ != __p) delete __ptr_; __ptr_ = __p; } _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref_Tp __p) throw() : __ptr_(__p.__ptr_) {} templateclass _Up _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref_Up() throw() {auto_ptr_ref_Up __t; __t.__ptr_ = release(); return __t;} templateclass _Up _LIBCPP_INLINE_VISIBILITY operator auto_ptr_Up() throw() {return auto_ptr_Up(release());} }; ","wordCount":"677","inLanguage":"en","datePublished":"2018-12-27T15:21:35+11:00","dateModified":"2018-12-27T15:21:35+11:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-1/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://zintrulcre.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://zintrulcre.github.io/archives/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=http://zintrulcre.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://zintrulcre.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://zintrulcre.github.io/posts/>Posts</a></div>
<h1 class=post-title>
C++ 智能指针（1）：auto_ptr
</h1>
<div class=post-meta><span title="2018-12-27 15:21:35 +1100 +1100">December 27, 2018</span>&nbsp;·&nbsp;4 min
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#c%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%881auto_ptr aria-label=C++智能指针（1）：auto_ptr>C++智能指针（1）：auto_ptr</a><ul>
<li>
<a href=#%e5%88%86%e6%9e%90 aria-label=分析>分析</a></li>
<li>
<a href=#%e5%ae%9e%e7%8e%b0 aria-label=实现>实现</a></li>
<li>
<a href=#%e6%b5%8b%e8%af%95 aria-label=测试>测试</a></li>
<li>
<a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li>
<li>
<a href=#auto_ptr%e6%ba%90%e7%a0%81 aria-label=auto_ptr源码>auto_ptr源码</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=c智能指针1auto_ptr>C++智能指针（1）：auto_ptr<a hidden class=anchor aria-hidden=true href=#c智能指针1auto_ptr>#</a></h1>
<h2 id=分析>分析<a hidden class=anchor aria-hidden=true href=#分析>#</a></h2>
<p>C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Object</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    Object() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Construct&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }

    Object(<span style=color:#66d9ef>const</span> Object <span style=color:#f92672>&amp;</span>other) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Copy&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }

    Object(Object <span style=color:#f92672>&amp;&amp;</span>other) <span style=color:#66d9ef>noexcept</span> { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Move&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }

    <span style=color:#f92672>~</span>Object() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Destruct&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Print</span>() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Print&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
};
</code></pre></div><p>创建一个指向 Object 类型的指针</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
    o<span style=color:#f92672>-&gt;</span>Print();
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
<span style=color:#75715e>/*
</span><span style=color:#75715e>output:
</span><span style=color:#75715e>Construct
</span><span style=color:#75715e>Print
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Object <span style=color:#f92672>*</span>o1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
    o1<span style=color:#f92672>-&gt;</span>Print();
    Object o2 <span style=color:#f92672>=</span> Object();
    o2.Print();
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
<span style=color:#75715e>/*
</span><span style=color:#75715e>output:
</span><span style=color:#75715e>Construct
</span><span style=color:#75715e>Print
</span><span style=color:#75715e>Construct
</span><span style=color:#75715e>Print
</span><span style=color:#75715e>Destruct
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>产生这样的结果是因为对象创建在栈（<a href=https://isocpp.org/blog/2015/09/stack-heap-pool-tony-bulldozer00-bd00-dasilva>stack</a>）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。</p>
<h2 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h2>
<p>根据auto_ptr的源码，能够大致实现 AutoPointer 类</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AutoPointer</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>explicit</span> AutoPointer(T <span style=color:#f92672>*</span>t);

    <span style=color:#f92672>~</span>AutoPointer();

    T <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>();

    T <span style=color:#f92672>*</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>();

    T <span style=color:#f92672>*</span><span style=color:#a6e22e>release</span>();

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reset</span>(T <span style=color:#f92672>*</span>p);

    AutoPointer(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>other);

    AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>&amp;</span>other);

<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    T <span style=color:#f92672>*</span>pointer;
};

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>AutoPointer(T <span style=color:#f92672>*</span>t) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; constructor called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>=</span> t;
}

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::~</span>AutoPointer() {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; destructor called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
}

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
T <span style=color:#f92672>&amp;</span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
}

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
T <span style=color:#f92672>*</span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
}

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
T <span style=color:#f92672>*</span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>release() {
    T <span style=color:#f92672>*</span>new_pointer <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
    <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
    <span style=color:#66d9ef>return</span> new_pointer;
}

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>void</span> AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>reset(T <span style=color:#f92672>*</span>p) {
    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>!=</span> p) {
        <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>=</span> p;
    }
}

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>AutoPointer(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>other) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; copy constructor called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>=</span> other.release();
}

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>&amp;</span>other) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; assignment operator called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>!=</span> other.pointer)
        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>reset(other.release());
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
}
</code></pre></div><ul>
<li>构造函数直接将 AutoPointer 类的 pointer 指针指向传入的参数指针所指向的地址</li>
<li>拷贝构造函数先对参数对象的指针进行 release 操作，也就是将参数对象的私有成员 pointer 指针置为 nullptr 并返回其原本指向的地址，然后将自身的 pointer 指向这个地址</li>
<li>赋值操作符先判断传入的参数是否是当前的 AutoPointer 类对象本身，如果是的话直接返回 this 指针，否则先对参数对象的指针进行 release 操作，并 delete 掉当前对象的 pointer，再将 pointer 指向参数对象的 pointer 原本指向的地址，这样的实现有效地规避了<a href=https://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88>迷途指针</a>（也称悬空指针或野指针）。</li>
</ul>
<h2 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h2>
<p>创建单个 AutoPointer 类对象时能够正常使用。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a1(o);
    (<span style=color:#f92672>*</span>a1).Print();
    a1<span style=color:#f92672>-&gt;</span>Print();
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
<span style=color:#75715e>/*
</span><span style=color:#75715e>output:
</span><span style=color:#75715e>Construct
</span><span style=color:#75715e>AutoPointer 0x7fe680c02ab0 constructor called.
</span><span style=color:#75715e>Print
</span><span style=color:#75715e>Print
</span><span style=color:#75715e>AutoPointer 0x7fe680c02ab0 destructor called.
</span><span style=color:#75715e>Destruct
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>创建两个 AutoPointer 类对象时如果使用同一个 Object 指针进行初始化，那么在程序退出时 Object 对象会被两个 AutoPointer 类对象各析构一次，也就是说同一块地址会被 delete 两次，造成运行时报错。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a1(o);
    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a2(o);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
<span style=color:#75715e>/*
</span><span style=color:#75715e>output:
</span><span style=color:#75715e>Construct
</span><span style=color:#75715e>AutoPointer 0x7ffee3fa0178 constructor called.
</span><span style=color:#75715e>AutoPointer 0x7ffee3fa0170 constructor called.
</span><span style=color:#75715e>AutoPointer 0x7ffee3fa0170 destructor called.
</span><span style=color:#75715e>Destruct
</span><span style=color:#75715e>AutoPointer 0x7ffee3fa0178 destructor called.
</span><span style=color:#75715e>Destruct
</span><span style=color:#75715e>cpp(9015,0x1197a25c0) malloc: *** error for object 0x7fe9dec02b40: pointer being freed was not allocated
</span><span style=color:#75715e>cpp(9015,0x1197a25c0) malloc: *** set a breakpoint in malloc_error_break to debug
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>使用拷贝构造函数将一个 AutoPointer 类对象 a1 拷贝给另一个 AutoPointer 类对象 a2 时，Object 指针 o 原本是属于 a1 的，在 a2 调用拷贝构造函数之后，a1 的 pointer 变成了空指针，而 s2 拥有了指针 o，造成了所有权转移。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a1(o);
    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a2(a1);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
<span style=color:#75715e>/*
</span><span style=color:#75715e>output:
</span><span style=color:#75715e>Construct
</span><span style=color:#75715e>AutoPointer 0x7fd15bc02ab0 constructor called.
</span><span style=color:#75715e>AutoPointer 0x7fd15bc02ab0 copy constructor called.
</span><span style=color:#75715e>AutoPointer 0x7fd15bc02ab0 destructor called.
</span><span style=color:#75715e>Destruct
</span><span style=color:#75715e>AutoPointer 0x0 destructor called.
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>使用赋值操作符也会有所有权转移的问题。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a1(o);
    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a2 <span style=color:#f92672>=</span> a1;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
<span style=color:#75715e>/*
</span><span style=color:#75715e>output:
</span><span style=color:#75715e>Construct
</span><span style=color:#75715e>AutoPointer 0x7ff5d5402ab0 constructor called.
</span><span style=color:#75715e>AutoPointer 0x7ff5d5402ab0 copy constructor called.
</span><span style=color:#75715e>AutoPointer 0x7ff5d5402ab0 destructor called.
</span><span style=color:#75715e>Destruct
</span><span style=color:#75715e>AutoPointer 0x0 destructor called.
</span><span style=color:#75715e>*/</span>
</code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2>
<p>AutoPointer 有效地解决了野指针问题，但又会引入一些其他的问题，例如</p>
<ol>
<li>
<p>所有权转移</p>
<ul>
<li>将 AutoPointer 作为参数进行拷贝构造或赋值操作时造成所有权转移</li>
</ul>
</li>
<li>
<p>内存泄漏</p>
<ul>
<li>在析构函数中使用了delete进行指针的销毁，但如果以数组指针进行初始化 <code>AutoPointer&lt;int> s1(new int[10])</code> 会因为没有销毁数组的其它元素而造成内存泄漏</li>
</ul>
</li>
</ol>
<h2 id=auto_ptr源码>auto_ptr源码<a hidden class=anchor aria-hidden=true href=#auto_ptr源码>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Tp</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_LIBCPP_TEMPLATE_VIS</span> auto_ptr
{
<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    _Tp<span style=color:#f92672>*</span> __ptr_;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>typedef</span> _Tp element_type;

    _LIBCPP_INLINE_VISIBILITY <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>auto_ptr</span>(_Tp<span style=color:#f92672>*</span> __p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>throw</span>() <span style=color:#f92672>:</span> __ptr_(__p) {}
    _LIBCPP_INLINE_VISIBILITY <span style=color:#a6e22e>auto_ptr</span>(auto_ptr<span style=color:#f92672>&amp;</span> __p) <span style=color:#66d9ef>throw</span>() <span style=color:#f92672>:</span> __ptr_(__p.release()) {}
    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Up</span><span style=color:#f92672>&gt;</span> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;&amp;</span> __p) <span style=color:#66d9ef>throw</span>()
        <span style=color:#f92672>:</span> __ptr_(__p.release()) {}
    _LIBCPP_INLINE_VISIBILITY auto_ptr<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(auto_ptr<span style=color:#f92672>&amp;</span> __p) <span style=color:#66d9ef>throw</span>()
        {reset(__p.release()); <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;}
    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Up</span><span style=color:#f92672>&gt;</span> _LIBCPP_INLINE_VISIBILITY auto_ptr<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(auto_ptr<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;&amp;</span> __p) <span style=color:#66d9ef>throw</span>()
        {reset(__p.release()); <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;}
    _LIBCPP_INLINE_VISIBILITY auto_ptr<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(auto_ptr_ref<span style=color:#f92672>&lt;</span>_Tp<span style=color:#f92672>&gt;</span> __p) <span style=color:#66d9ef>throw</span>()
        {reset(__p.__ptr_); <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;}
    _LIBCPP_INLINE_VISIBILITY <span style=color:#f92672>~</span>auto_ptr() <span style=color:#66d9ef>throw</span>() {<span style=color:#66d9ef>delete</span> __ptr_;}

    _LIBCPP_INLINE_VISIBILITY _Tp<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>throw</span>()
        {<span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>__ptr_;}
    _LIBCPP_INLINE_VISIBILITY _Tp<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>throw</span>() {<span style=color:#66d9ef>return</span> __ptr_;}
    _LIBCPP_INLINE_VISIBILITY _Tp<span style=color:#f92672>*</span> <span style=color:#a6e22e>get</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>throw</span>() {<span style=color:#66d9ef>return</span> __ptr_;}
    _LIBCPP_INLINE_VISIBILITY _Tp<span style=color:#f92672>*</span> <span style=color:#a6e22e>release</span>() <span style=color:#66d9ef>throw</span>()
    {
        _Tp<span style=color:#f92672>*</span> __t <span style=color:#f92672>=</span> __ptr_;
        __ptr_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>return</span> __t;
    }
    _LIBCPP_INLINE_VISIBILITY <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reset</span>(_Tp<span style=color:#f92672>*</span> __p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>throw</span>()
    {
        <span style=color:#66d9ef>if</span> (__ptr_ <span style=color:#f92672>!=</span> __p)
            <span style=color:#66d9ef>delete</span> __ptr_;
        __ptr_ <span style=color:#f92672>=</span> __p;
    }

    _LIBCPP_INLINE_VISIBILITY <span style=color:#a6e22e>auto_ptr</span>(auto_ptr_ref<span style=color:#f92672>&lt;</span>_Tp<span style=color:#f92672>&gt;</span> __p) <span style=color:#66d9ef>throw</span>() <span style=color:#f92672>:</span> __ptr_(__p.__ptr_) {}
    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Up</span><span style=color:#f92672>&gt;</span> _LIBCPP_INLINE_VISIBILITY <span style=color:#66d9ef>operator</span> auto_ptr_ref<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;</span>() <span style=color:#66d9ef>throw</span>()
        {auto_ptr_ref<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;</span> __t; __t.__ptr_ <span style=color:#f92672>=</span> release(); <span style=color:#66d9ef>return</span> __t;}
    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Up</span><span style=color:#f92672>&gt;</span> _LIBCPP_INLINE_VISIBILITY <span style=color:#66d9ef>operator</span> auto_ptr<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;</span>() <span style=color:#66d9ef>throw</span>()
        {<span style=color:#66d9ef>return</span> auto_ptr<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;</span>(release());}
};
</code></pre></div>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=http://zintrulcre.github.io/posts/c++/smart-pointer/c++-smart-pointer-1.5/>
<span class=title>« Prev Page</span>
<br>
<span>C++ 智能指针（1.5）：move 语义</span>
</a>
<a class=next href=http://zintrulcre.github.io/posts/leetcode-archiver/leetcode-archiver2/>
<span class=title>Next Page »</span>
<br>
<span>LeetCode Archiver(2)：获取题目信息</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>
Zhengyu &copy; 2022
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>