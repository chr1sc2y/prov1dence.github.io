<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kick Start 2019 Round B | 尾張</title>
<meta name=keywords content><meta name=description content="Kick Start 2019 Round B
Building Palindromes (5pts, 12pts)
判断给定区间内的子字符串是否是回文串。
Solution: Prefix Sum
判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。

时间复杂度：O(N)
空间复杂度：O(N)

// C++
#include <iostream>
#include <cmath>
#include <cstdio>
#include <math.h>
#include <limits>
#include <algorithm>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>

using namespace std;


int main() {
    int total_test_case_number;
    cin >> total_test_case_number;
    for (int case_number = 1; case_number <= total_test_case_number; ++case_number) {
        int N, Q, m, n, total = 0;
        cin >> N >> Q;
        string words;
        cin >> words;
        vector<vector<int>> odds(N + 1, vector<int>(26));
        for (int i = 1; i <= N; ++i) {
            for (int j = 0; j < 26; ++j)
                odds[i][j] = odds[i - 1][j];
            ++odds[i][words[i - 1] - 'A'];
        }
        for (int q = 0; q < Q; ++q) {
            cin >> m >> n;
            int odd = 0;
            for (int j = 0; j < 26; ++j)
                odd += ((odds[n][j] - odds[m - 1][j]) % 2 != 0);
            total += odd <= 1;
        }
        printf(&#34;Case #%d: %d\n&#34;, case_number, total);
    }

    return 0;
}
Energy Stones (17pts, 24pts)
在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于背包问题。"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/kick-start/2019-round-b/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.143.1"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/kick-start/2019-round-b/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Kick Start 2019 Round B"><meta property="og:description" content="Kick Start 2019 Round B
Building Palindromes (5pts, 12pts)
判断给定区间内的子字符串是否是回文串。
Solution: Prefix Sum
判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。

时间复杂度：O(N)
空间复杂度：O(N)

// C++
#include <iostream>
#include <cmath>
#include <cstdio>
#include <math.h>
#include <limits>
#include <algorithm>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>

using namespace std;


int main() {
    int total_test_case_number;
    cin >> total_test_case_number;
    for (int case_number = 1; case_number <= total_test_case_number; ++case_number) {
        int N, Q, m, n, total = 0;
        cin >> N >> Q;
        string words;
        cin >> words;
        vector<vector<int>> odds(N + 1, vector<int>(26));
        for (int i = 1; i <= N; ++i) {
            for (int j = 0; j < 26; ++j)
                odds[i][j] = odds[i - 1][j];
            ++odds[i][words[i - 1] - 'A'];
        }
        for (int q = 0; q < Q; ++q) {
            cin >> m >> n;
            int odd = 0;
            for (int j = 0; j < 26; ++j)
                odd += ((odds[n][j] - odds[m - 1][j]) % 2 != 0);
            total += odd <= 1;
        }
        printf(&#34;Case #%d: %d\n&#34;, case_number, total);
    }

    return 0;
}
Energy Stones (17pts, 24pts)
在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于背包问题。"><meta property="og:type" content="article"><meta property="og:url" content="https://prov1dence.top/posts/kick-start/2019-round-b/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-21T14:41:22+10:00"><meta property="article:modified_time" content="2019-04-21T14:41:22+10:00"><meta property="og:site_name" content="尾張"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kick Start 2019 Round B"><meta name=twitter:description content="Kick Start 2019 Round B
Building Palindromes (5pts, 12pts)
判断给定区间内的子字符串是否是回文串。
Solution: Prefix Sum
判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。

时间复杂度：O(N)
空间复杂度：O(N)

// C++
#include <iostream>
#include <cmath>
#include <cstdio>
#include <math.h>
#include <limits>
#include <algorithm>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>

using namespace std;


int main() {
    int total_test_case_number;
    cin >> total_test_case_number;
    for (int case_number = 1; case_number <= total_test_case_number; ++case_number) {
        int N, Q, m, n, total = 0;
        cin >> N >> Q;
        string words;
        cin >> words;
        vector<vector<int>> odds(N + 1, vector<int>(26));
        for (int i = 1; i <= N; ++i) {
            for (int j = 0; j < 26; ++j)
                odds[i][j] = odds[i - 1][j];
            ++odds[i][words[i - 1] - 'A'];
        }
        for (int q = 0; q < Q; ++q) {
            cin >> m >> n;
            int odd = 0;
            for (int j = 0; j < 26; ++j)
                odd += ((odds[n][j] - odds[m - 1][j]) % 2 != 0);
            total += odd <= 1;
        }
        printf(&#34;Case #%d: %d\n&#34;, case_number, total);
    }

    return 0;
}
Energy Stones (17pts, 24pts)
在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于背包问题。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"Kick Start 2019 Round B","item":"https://prov1dence.top/posts/kick-start/2019-round-b/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kick Start 2019 Round B","name":"Kick Start 2019 Round B","description":"Kick Start 2019 Round B Building Palindromes (5pts, 12pts) 判断给定区间内的子字符串是否是回文串。\nSolution: Prefix Sum 判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。\n时间复杂度：O(N) 空间复杂度：O(N) // C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; int main() { int total_test_case_number; cin \u0026gt;\u0026gt; total_test_case_number; for (int case_number = 1; case_number \u0026lt;= total_test_case_number; ++case_number) { int N, Q, m, n, total = 0; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; string words; cin \u0026gt;\u0026gt; words; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; odds(N + 1, vector\u0026lt;int\u0026gt;(26)); for (int i = 1; i \u0026lt;= N; ++i) { for (int j = 0; j \u0026lt; 26; ++j) odds[i][j] = odds[i - 1][j]; ++odds[i][words[i - 1] - \u0026#39;A\u0026#39;]; } for (int q = 0; q \u0026lt; Q; ++q) { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; int odd = 0; for (int j = 0; j \u0026lt; 26; ++j) odd += ((odds[n][j] - odds[m - 1][j]) % 2 != 0); total += odd \u0026lt;= 1; } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, case_number, total); } return 0; } Energy Stones (17pts, 24pts) 在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于背包问题。\n","keywords":[],"articleBody":"Kick Start 2019 Round B Building Palindromes (5pts, 12pts) 判断给定区间内的子字符串是否是回文串。\nSolution: Prefix Sum 判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。\n时间复杂度：O(N) 空间复杂度：O(N) // C++ #include #include #include #include #include #include #include #include #include #include #include #include #include #include using namespace std; int main() { int total_test_case_number; cin \u003e\u003e total_test_case_number; for (int case_number = 1; case_number \u003c= total_test_case_number; ++case_number) { int N, Q, m, n, total = 0; cin \u003e\u003e N \u003e\u003e Q; string words; cin \u003e\u003e words; vector\u003cvector\u003cint\u003e\u003e odds(N + 1, vector\u003cint\u003e(26)); for (int i = 1; i \u003c= N; ++i) { for (int j = 0; j \u003c 26; ++j) odds[i][j] = odds[i - 1][j]; ++odds[i][words[i - 1] - 'A']; } for (int q = 0; q \u003c Q; ++q) { cin \u003e\u003e m \u003e\u003e n; int odd = 0; for (int j = 0; j \u003c 26; ++j) odd += ((odds[n][j] - odds[m - 1][j]) % 2 != 0); total += odd \u003c= 1; } printf(\"Case #%d: %d\\n\", case_number, total); } return 0; } Energy Stones (17pts, 24pts) 在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于背包问题。\nSolution 1: Dynamic Programming (Visible Test Set) 对于Visible Test Set，吃掉每一件物品所消耗的seconds都是相同的，因此可以简化为一个单纯的背包问题。为了最大化获得的energy（最小化所有物品的总lost），应该先吃掉lost高的物品，所以按照lost排序。\n初始状态是dp[index][time] = 0，index = 0, time = 0。状态转移方程是\n如果当前物品还有剩余的energy则吃掉当前的物品 if (stones[index].energy \u003e stones[index].lost * time) res = max(res, stones[index].energy - stones[index].lost * time + DP(index + 1, time + stones[index].seconds)); 不吃当前的物品 res = max(res, DP(index + 1, time)); 时间复杂度：O(N * (S * N)) 空间复杂度：O(N * (S * N)) //C++ #include #include #include #include #include #include #include #include #include #include #include #include #include #include using namespace std; struct Stone { int seconds; int energy; int lost; }; vector\u003cStone\u003e stones; vector\u003cvector\u003cint\u003e\u003e dp; int N; int DP(int index, int time) { if (index \u003e= N) return 0; int \u0026res = dp[index][time]; if (res != -1) return res; if (stones[index].energy \u003e stones[index].lost * time) res = max(res, stones[index].energy - stones[index].lost * time + DP(index + 1, time + stones[index].seconds)); res = max(res, DP(index + 1, time)); return res; } int solve(const int \u0026T) { cin \u003e\u003e N; stones = vector\u003cStone\u003e(N); for (int i = 0; i \u003c N; ++i) cin \u003e\u003e stones[i].seconds \u003e\u003e stones[i].energy \u003e\u003e stones[i].lost; dp = vector\u003cvector\u003cint\u003e\u003e(N, vector\u003cint\u003e(stones[0].seconds * N, -1)); sort(stones.begin(), stones.end(), [](const Stone \u0026s1, const Stone \u0026s2) { return s1.lost \u003e s2.lost; }); return DP(0, 0); } int main() { int T; cin \u003e\u003e T; for (int t = 1; t \u003c= T; ++t) printf(\"Case #%d: %d\\n\", t, solve(t)); return 0; } Solution 2: Dynamic Programming (Hidden Test Set) 对于Hidden Test Set，每一件物品消耗的时间并不相同，不能直接使用lost进行排序。对于每两件物品s1和s2，只要满足s1.lost * s2.seconds \u003e s2.lost * s1.seconds就可以保证得到更小的总lost。同时dp数组的大小需要按照每个物品的耗时来计算。\n时间复杂度：O(N * (S * N)) 空间复杂度：O(N * (S * N)) // C++ #include #include #include #include #include #include #include #include #include #include #include #include #include #include using namespace std; struct Stone { int seconds; int energy; int lost; }; vector\u003cStone\u003e stones; vector\u003cvector\u003cint\u003e\u003e dp; int N; void solve(const int \u0026T) { scanf(\"%d\", \u0026N); stones = vector\u003cStone\u003e(N); int total_time = 0; for (int i = 0; i \u003c N; ++i) { scanf(\"%d %d %d\", \u0026stones[i].seconds, \u0026stones[i].energy,\u0026stones[i].lost); total_time += stones[i].seconds; } sort(stones.begin(), stones.end(), [](const Stone \u0026s1, const Stone \u0026s2) { return s1.lost * s2.seconds \u003e s2.lost * s1.seconds; }); int res = 0; dp = vector\u003cvector\u003cint\u003e\u003e(N + 1, vector\u003cint\u003e(total_time + 1, -1)); for (int i = 1; i \u003c= N; ++i) { dp[i - 1][0] = 0; for (int j = 0; j \u003c stones[i - 1].seconds; ++j) dp[i][j] = dp[i - 1][j]; for (int j = stones[i - 1].seconds; j \u003c dp[i - 1].size(); ++j) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i - 1].seconds] + stones[i - 1].energy - (j - stones[i - 1].seconds) * stones[i - 1].lost); res = max(res, dp[i][j]); } } printf(\"Case #%d: %d\\n\", T, res); } int main() { int T; scanf(\"%d\", \u0026T); for (int t = 1; t \u003c= T; ++t) solve(t); return 0; } Diverse Subarray (14pts, 28pts) 给定最大值S，选取一段连续子数组，使得子数组中相同值的个数不超过S的总数最大化。\nSolution 1: Brute Force (Visible Test Set) Visible Test Set的数组长度N \u003c= 1000，只需要两层循环做穷举，每次计算符合要求的总数。\n时间复杂度：O(N^2) 空间复杂度：O(N) // C++ #include #include #include #include #include #include #include #include #include #include #include #include #include #include using namespace std; int main() { int total_test_case_number; cin \u003e\u003e total_test_case_number; for (int case_number = 1; case_number \u003c= total_test_case_number; ++case_number) { int N, S, res = 0; cin \u003e\u003e N \u003e\u003e S; vector\u003cint\u003e trinkets(N); for (int i = 0; i \u003c N; ++i) cin \u003e\u003e trinkets[i]; for (int j = 0; j \u003c N; ++j) { unordered_map\u003cint, int\u003e types; for (int i = j; i \u003e= 0; --i) { ++types[trinkets[i]]; int total = 0; for (auto t:types) { if (t.second \u003c= S) total += t.second; } res = max(res, total); } } printf(\"Case #%d: %d\\n\", case_number, res); } return 0; } Solution 2: Segment Tree (Hidden Test Set) // TODO\n","wordCount":"818","inLanguage":"en","datePublished":"2019-04-21T14:41:22+10:00","dateModified":"2019-04-21T14:41:22+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/kick-start/2019-round-b/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://prov1dence.top/>Home</a>&nbsp;»&nbsp;<a href=https://prov1dence.top/posts/>Posts</a></div><h1 class=post-title>Kick Start 2019 Round B</h1><div class=post-meta>&lt;span title='2019-04-21 14:41:22 AEST'>April 21, 2019&lt;/span>&amp;nbsp;·&amp;nbsp;4 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#kick-start-2019-round-bhttpscodingcompetitionswithgooglecomkickstartround0000000000050eda aria-label="Kick Start 2019 Round B"><a href=https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda>Kick Start 2019 Round B</a></a><ul><li><a href=#building-palindromes-5pts-12ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda0000000000119866 aria-label="Building Palindromes (5pts, 12pts)"><a href=https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/0000000000119866>Building Palindromes (5pts, 12pts)</a></a><ul><li><a href=#solution-prefix-sum aria-label="Solution: Prefix Sum">Solution: Prefix Sum</a></li></ul></li><li><a href=#energy-stones-17pts-24ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda00000000001198c3 aria-label="Energy Stones (17pts, 24pts)"><a href=https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/00000000001198c3>Energy Stones (17pts, 24pts)</a></a><ul><li><a href=#solution-1-dynamic-programming-visible-test-set aria-label="Solution 1: Dynamic Programming (Visible Test Set)">Solution 1: Dynamic Programming (Visible Test Set)</a></li><li><a href=#solution-2-dynamic-programming-hidden-test-set aria-label="Solution 2: Dynamic Programming (Hidden Test Set)">Solution 2: Dynamic Programming (Hidden Test Set)</a></li></ul></li><li><a href=#diverse-subarray-14pts-28ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda00000000001198c1 aria-label="Diverse Subarray (14pts, 28pts)"><a href=https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/00000000001198c1>Diverse Subarray (14pts, 28pts)</a></a><ul><li><a href=#solution-1-brute-force-visible-test-set aria-label="Solution 1: Brute Force (Visible Test Set)">Solution 1: Brute Force (Visible Test Set)</a></li><li><a href=#solution-2-segment-tree-hidden-test-set aria-label="Solution 2: Segment Tree (Hidden Test Set)">Solution 2: Segment Tree (Hidden Test Set)</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=kick-start-2019-round-bhttpscodingcompetitionswithgooglecomkickstartround0000000000050eda><a href=https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda>Kick Start 2019 Round B</a><a hidden class=anchor aria-hidden=true href=#kick-start-2019-round-bhttpscodingcompetitionswithgooglecomkickstartround0000000000050eda>#</a></h1><h2 id=building-palindromes-5pts-12ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda0000000000119866><a href=https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/0000000000119866>Building Palindromes (5pts, 12pts)</a><a hidden class=anchor aria-hidden=true href=#building-palindromes-5pts-12ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda0000000000119866>#</a></h2><p>判断给定区间内的子字符串是否是回文串。</p><h3 id=solution-prefix-sum>Solution: Prefix Sum<a hidden class=anchor aria-hidden=true href=#solution-prefix-sum>#</a></h3><p>判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。</p><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// C++
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;math.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;limits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stack&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> total_test_case_number;
</span></span><span style=display:flex><span>    cin <span style=color:#f92672>&gt;&gt;</span> total_test_case_number;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> case_number <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; case_number <span style=color:#f92672>&lt;=</span> total_test_case_number; <span style=color:#f92672>++</span>case_number) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> N, Q, m, n, total <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        cin <span style=color:#f92672>&gt;&gt;</span> N <span style=color:#f92672>&gt;&gt;</span> Q;
</span></span><span style=display:flex><span>        string words;
</span></span><span style=display:flex><span>        cin <span style=color:#f92672>&gt;&gt;</span> words;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> odds(N <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>26</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> N; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>26</span>; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>                odds[i][j] <span style=color:#f92672>=</span> odds[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>odds[i][words[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;A&#39;</span>];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> q <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; q <span style=color:#f92672>&lt;</span> Q; <span style=color:#f92672>++</span>q) {
</span></span><span style=display:flex><span>            cin <span style=color:#f92672>&gt;&gt;</span> m <span style=color:#f92672>&gt;&gt;</span> n;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> odd <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>26</span>; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>                odd <span style=color:#f92672>+=</span> ((odds[n][j] <span style=color:#f92672>-</span> odds[m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j]) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            total <span style=color:#f92672>+=</span> odd <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Case #%d: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, case_number, total);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=energy-stones-17pts-24ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda00000000001198c3><a href=https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/00000000001198c3>Energy Stones (17pts, 24pts)</a><a hidden class=anchor aria-hidden=true href=#energy-stones-17pts-24ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda00000000001198c3>#</a></h2><p>在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于<a href=https://zh.wikipedia.org/wiki/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98>背包问题</a>。</p><h3 id=solution-1-dynamic-programming-visible-test-set>Solution 1: Dynamic Programming (Visible Test Set)<a hidden class=anchor aria-hidden=true href=#solution-1-dynamic-programming-visible-test-set>#</a></h3><p>对于Visible Test Set，吃掉每一件物品所消耗的seconds都是相同的，因此可以简化为一个单纯的背包问题。为了最大化获得的energy（最小化所有物品的总lost），应该先吃掉lost高的物品，所以按照lost排序。</p><p>初始状态是dp[index][time] = 0，index = 0, time = 0。状态转移方程是</p><ol><li>如果当前物品还有剩余的energy则吃掉当前的物品</li></ol><pre tabindex=0><code>    if (stones[index].energy &gt; stones[index].lost * time)
        res = max(res, stones[index].energy - stones[index].lost * time + DP(index + 1, time + stones[index].seconds));
</code></pre><ol start=2><li>不吃当前的物品</li></ol><pre tabindex=0><code>    res = max(res, DP(index + 1, time));
</code></pre><ul><li>时间复杂度：O(N * (S * N))</li><li>空间复杂度：O(N * (S * N))</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>//C++
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;math.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;limits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stack&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Stone</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> seconds;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> energy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> lost;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>Stone<span style=color:#f92672>&gt;</span> stones;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> N;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>DP</span>(<span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>int</span> time) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>&gt;=</span> N)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>res <span style=color:#f92672>=</span> dp[index][time];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (res <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (stones[index].energy <span style=color:#f92672>&gt;</span> stones[index].lost <span style=color:#f92672>*</span> time)
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> max(res, stones[index].energy <span style=color:#f92672>-</span> stones[index].lost <span style=color:#f92672>*</span> time <span style=color:#f92672>+</span> DP(index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, time <span style=color:#f92672>+</span> stones[index].seconds));
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> max(res, DP(index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, time));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>solve</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>T) {
</span></span><span style=display:flex><span>    cin <span style=color:#f92672>&gt;&gt;</span> N;
</span></span><span style=display:flex><span>    stones <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>Stone<span style=color:#f92672>&gt;</span>(N);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> N; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        cin <span style=color:#f92672>&gt;&gt;</span> stones[i].seconds <span style=color:#f92672>&gt;&gt;</span> stones[i].energy <span style=color:#f92672>&gt;&gt;</span> stones[i].lost;
</span></span><span style=display:flex><span>    dp <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>(N, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(stones[<span style=color:#ae81ff>0</span>].seconds <span style=color:#f92672>*</span> N, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    sort(stones.begin(), stones.end(), [](<span style=color:#66d9ef>const</span> Stone <span style=color:#f92672>&amp;</span>s1, <span style=color:#66d9ef>const</span> Stone <span style=color:#f92672>&amp;</span>s2) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s1.lost <span style=color:#f92672>&gt;</span> s2.lost;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> DP(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> T;
</span></span><span style=display:flex><span>    cin <span style=color:#f92672>&gt;&gt;</span> T;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; t <span style=color:#f92672>&lt;=</span> T; <span style=color:#f92672>++</span>t)
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Case #%d: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, t, solve(t));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solution-2-dynamic-programming-hidden-test-set>Solution 2: Dynamic Programming (Hidden Test Set)<a hidden class=anchor aria-hidden=true href=#solution-2-dynamic-programming-hidden-test-set>#</a></h3><p>对于Hidden Test Set，每一件物品消耗的时间并不相同，不能直接使用lost进行排序。对于每两件物品s1和s2，只要满足s1.lost * s2.seconds > s2.lost * s1.seconds就可以保证得到更小的总lost。同时dp数组的大小需要按照每个物品的耗时来计算。</p><ul><li>时间复杂度：O(N * (S * N))</li><li>空间复杂度：O(N * (S * N))</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// C++
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;math.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;limits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stack&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Stone</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> seconds;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> energy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> lost;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>Stone<span style=color:#f92672>&gt;</span> stones;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> N;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>solve</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>T) {
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#f92672>&amp;</span>N);
</span></span><span style=display:flex><span>    stones <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>Stone<span style=color:#f92672>&gt;</span>(N);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> total_time <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> N; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%d %d %d&#34;</span>, <span style=color:#f92672>&amp;</span>stones[i].seconds, <span style=color:#f92672>&amp;</span>stones[i].energy,<span style=color:#f92672>&amp;</span>stones[i].lost);
</span></span><span style=display:flex><span>        total_time <span style=color:#f92672>+=</span> stones[i].seconds;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    sort(stones.begin(), stones.end(), [](<span style=color:#66d9ef>const</span> Stone <span style=color:#f92672>&amp;</span>s1, <span style=color:#66d9ef>const</span> Stone <span style=color:#f92672>&amp;</span>s2) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s1.lost <span style=color:#f92672>*</span> s2.seconds <span style=color:#f92672>&gt;</span> s2.lost <span style=color:#f92672>*</span> s1.seconds;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    dp <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>(N <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(total_time <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> N; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> stones[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].seconds; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>            dp[i][j] <span style=color:#f92672>=</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> stones[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].seconds; j <span style=color:#f92672>&lt;</span>  dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].size(); <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>            dp[i][j] <span style=color:#f92672>=</span> max(dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j], dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> stones[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].seconds] <span style=color:#f92672>+</span> stones[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].energy <span style=color:#f92672>-</span> (j <span style=color:#f92672>-</span> stones[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].seconds) <span style=color:#f92672>*</span> stones[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].lost);
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> max(res, dp[i][j]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Case #%d: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, T, res);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> T;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#f92672>&amp;</span>T);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; t <span style=color:#f92672>&lt;=</span> T; <span style=color:#f92672>++</span>t)
</span></span><span style=display:flex><span>        solve(t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=diverse-subarray-14pts-28ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda00000000001198c1><a href=https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/00000000001198c1>Diverse Subarray (14pts, 28pts)</a><a hidden class=anchor aria-hidden=true href=#diverse-subarray-14pts-28ptshttpscodingcompetitionswithgooglecomkickstartround0000000000050eda00000000001198c1>#</a></h2><p>给定最大值S，选取一段连续子数组，使得子数组中相同值的个数不超过S的总数最大化。</p><h3 id=solution-1-brute-force-visible-test-set>Solution 1: Brute Force (Visible Test Set)<a hidden class=anchor aria-hidden=true href=#solution-1-brute-force-visible-test-set>#</a></h3><p>Visible Test Set的数组长度N &lt;= 1000，只需要两层循环做穷举，每次计算符合要求的总数。</p><ul><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(N)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// C++
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;math.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;limits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stack&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> total_test_case_number;
</span></span><span style=display:flex><span>    cin <span style=color:#f92672>&gt;&gt;</span> total_test_case_number;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> case_number <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; case_number <span style=color:#f92672>&lt;=</span> total_test_case_number; <span style=color:#f92672>++</span>case_number) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> N, S, res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        cin <span style=color:#f92672>&gt;&gt;</span> N <span style=color:#f92672>&gt;&gt;</span> S;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> trinkets(N);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> N; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            cin <span style=color:#f92672>&gt;&gt;</span> trinkets[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> N; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>            unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> types;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> j; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>                <span style=color:#f92672>++</span>types[trinkets[i]];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> total <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> t:types) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (t.second <span style=color:#f92672>&lt;=</span> S)
</span></span><span style=display:flex><span>                        total <span style=color:#f92672>+=</span> t.second;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                res <span style=color:#f92672>=</span> max(res, total);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Case #%d: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, case_number, res);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solution-2-segment-tree-hidden-test-set>Solution 2: Segment Tree (Hidden Test Set)<a hidden class=anchor aria-hidden=true href=#solution-2-segment-tree-hidden-test-set>#</a></h3><p>// TODO</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://prov1dence.top/posts/code-jam/2019-round-1c/><span class=title>« Prev Page</span><br><span>Code Jam 2019 Round 1C</span>
</a><a class=next href=https://prov1dence.top/posts/code-jam/2019-round-1a/><span class=title>Next Page »</span><br><span>Code Jam 2019 Round 1A</span></a></nav></footer></article></main><footer class=footer><span>Zhengyu &copy; 2025</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>