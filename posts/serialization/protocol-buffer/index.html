<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ProtoBuf 语法和编码原理入门 | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content='ProtoBuf 语法和编码原理入门
序列化是指将结构化数据转换成易于存储或发送的数据格式的过程，Protocol Buffer 简称 ProtoBuf，是一种语言无关，平台无关的序列化工具，由谷歌在 2008 年开源。相较于常见的序列化工具 XML, JSON, YAML, CSV 等，ProtoBuf 的优势主要包括序列化后数据量小，序列化和反序列化过程速度快，使用时只需定义 proto 文件使得其维护成本低，可向后兼容等；但因为其数据以二进制数据流的形式存在，也有人类不可读的劣势。
本文主要介绍 ProtoBuf 的使用方法，包括 .proto 文件的语法，以及如何使用 protoc 工具来生成不通语言的代码；以及其编码原理。
1 语法
首先从 https://github.com/protocolbuffers/protobuf 找到最新版本的 ProtoBuf，下载预编译好的二进制文件 protoc 解压到环境变量目录，本文使用的是 3.15.7 版本：
$ protoc --version
libprotoc 3.15.7
以一个简单的 proto 文件为例，它的语法和 C++ 类似：
// msg.proto
syntax = "proto3";

package Message;

message SearchRequest {
  reserved 6, 9 to 12;
  reserved "foo", "bar";
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
}

message ResultType {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
}

message SearchResponse { 
  repeated ResultType.Result results = 1;
}
使用 protoc 工具生成指定语言的代码：'><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/serialization/protocol-buffer/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/serialization/protocol-buffer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/serialization/protocol-buffer/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="ProtoBuf 语法和编码原理入门"><meta property="og:description" content='ProtoBuf 语法和编码原理入门 序列化是指将结构化数据转换成易于存储或发送的数据格式的过程，Protocol Buffer 简称 ProtoBuf，是一种语言无关，平台无关的序列化工具，由谷歌在 2008 年开源。相较于常见的序列化工具 XML, JSON, YAML, CSV 等，ProtoBuf 的优势主要包括序列化后数据量小，序列化和反序列化过程速度快，使用时只需定义 proto 文件使得其维护成本低，可向后兼容等；但因为其数据以二进制数据流的形式存在，也有人类不可读的劣势。
本文主要介绍 ProtoBuf 的使用方法，包括 .proto 文件的语法，以及如何使用 protoc 工具来生成不通语言的代码；以及其编码原理。
1 语法 首先从 https://github.com/protocolbuffers/protobuf 找到最新版本的 ProtoBuf，下载预编译好的二进制文件 protoc 解压到环境变量目录，本文使用的是 3.15.7 版本：
$ protoc --version libprotoc 3.15.7 以一个简单的 proto 文件为例，它的语法和 C++ 类似：
// msg.proto syntax = "proto3"; package Message; message SearchRequest { reserved 6, 9 to 12; reserved "foo", "bar"; string query = 1; int32 page_number = 2; int32 result_per_page = 3; } message ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; } } message SearchResponse { repeated ResultType.Result results = 1; } 使用 protoc 工具生成指定语言的代码：'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-26T21:44:52+08:00"><meta property="article:modified_time" content="2021-04-26T21:44:52+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ProtoBuf 语法和编码原理入门"><meta name=twitter:description content='ProtoBuf 语法和编码原理入门
序列化是指将结构化数据转换成易于存储或发送的数据格式的过程，Protocol Buffer 简称 ProtoBuf，是一种语言无关，平台无关的序列化工具，由谷歌在 2008 年开源。相较于常见的序列化工具 XML, JSON, YAML, CSV 等，ProtoBuf 的优势主要包括序列化后数据量小，序列化和反序列化过程速度快，使用时只需定义 proto 文件使得其维护成本低，可向后兼容等；但因为其数据以二进制数据流的形式存在，也有人类不可读的劣势。
本文主要介绍 ProtoBuf 的使用方法，包括 .proto 文件的语法，以及如何使用 protoc 工具来生成不通语言的代码；以及其编码原理。
1 语法
首先从 https://github.com/protocolbuffers/protobuf 找到最新版本的 ProtoBuf，下载预编译好的二进制文件 protoc 解压到环境变量目录，本文使用的是 3.15.7 版本：
$ protoc --version
libprotoc 3.15.7
以一个简单的 proto 文件为例，它的语法和 C++ 类似：
// msg.proto
syntax = "proto3";

package Message;

message SearchRequest {
  reserved 6, 9 to 12;
  reserved "foo", "bar";
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
}

message ResultType {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
}

message SearchResponse { 
  repeated ResultType.Result results = 1;
}
使用 protoc 工具生成指定语言的代码：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"ProtoBuf 语法和编码原理入门","item":"https://prov1dence.top/posts/serialization/protocol-buffer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ProtoBuf 语法和编码原理入门","name":"ProtoBuf 语法和编码原理入门","description":"ProtoBuf 语法和编码原理入门 序列化是指将结构化数据转换成易于存储或发送的数据格式的过程，Protocol Buffer 简称 ProtoBuf，是一种语言无关，平台无关的序列化工具，由谷歌在 2008 年开源。相较于常见的序列化工具 XML, JSON, YAML, CSV 等，ProtoBuf 的优势主要包括序列化后数据量小，序列化和反序列化过程速度快，使用时只需定义 proto 文件使得其维护成本低，可向后兼容等；但因为其数据以二进制数据流的形式存在，也有人类不可读的劣势。\n本文主要介绍 ProtoBuf 的使用方法，包括 .proto 文件的语法，以及如何使用 protoc 工具来生成不通语言的代码；以及其编码原理。\n1 语法 首先从 https://github.com/protocolbuffers/protobuf 找到最新版本的 ProtoBuf，下载预编译好的二进制文件 protoc 解压到环境变量目录，本文使用的是 3.15.7 版本：\n$ protoc --version libprotoc 3.15.7 以一个简单的 proto 文件为例，它的语法和 C++ 类似：\n// msg.proto syntax = \u0026#34;proto3\u0026#34;; package Message; message SearchRequest { reserved 6, 9 to 12; reserved \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;; string query = 1; int32 page_number = 2; int32 result_per_page = 3; } message ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; } } message SearchResponse { repeated ResultType.Result results = 1; } 使用 protoc 工具生成指定语言的代码：\n","keywords":[],"articleBody":"ProtoBuf 语法和编码原理入门 序列化是指将结构化数据转换成易于存储或发送的数据格式的过程，Protocol Buffer 简称 ProtoBuf，是一种语言无关，平台无关的序列化工具，由谷歌在 2008 年开源。相较于常见的序列化工具 XML, JSON, YAML, CSV 等，ProtoBuf 的优势主要包括序列化后数据量小，序列化和反序列化过程速度快，使用时只需定义 proto 文件使得其维护成本低，可向后兼容等；但因为其数据以二进制数据流的形式存在，也有人类不可读的劣势。\n本文主要介绍 ProtoBuf 的使用方法，包括 .proto 文件的语法，以及如何使用 protoc 工具来生成不通语言的代码；以及其编码原理。\n1 语法 首先从 https://github.com/protocolbuffers/protobuf 找到最新版本的 ProtoBuf，下载预编译好的二进制文件 protoc 解压到环境变量目录，本文使用的是 3.15.7 版本：\n$ protoc --version libprotoc 3.15.7 以一个简单的 proto 文件为例，它的语法和 C++ 类似：\n// msg.proto syntax = \"proto3\"; package Message; message SearchRequest { reserved 6, 9 to 12; reserved \"foo\", \"bar\"; string query = 1; int32 page_number = 2; int32 result_per_page = 3; } message ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; } } message SearchResponse { repeated ResultType.Result results = 1; } 使用 protoc 工具生成指定语言的代码：\nprotoc --proto_path=./ --go_out=./go_out/ --cpp_out=./cpp_out/ msg.proto 其中 --proto_path 或 -I 用于参数指定生成所需的 proto 文件和被导入的 proto 文件所在的目录，不指定的话默认为当前目录；go_out 和 cpp_out 分别为生成的 go 文件和 cpp 文件指定目录；最后是我们所需要转换的所有 proto 文件；更多的参数可以输入 protoc --help 查看。\n1.1 数据结构 msg.proto 文件里包含了两部分内容：首先需要指定 ProtoBuf 的版本为 proto3，不指定的话编译器则会默认使用老版本的 proto2 语法；然后是定义我们所需要的 message 类型。message 类型中有很多字段，每个字段都对应一个独一无二的编号，这些编号是用来在序列化后的二进制数据流中识别字段用的。\n字段和编号 字段（field）分为两种类型：\n唯一的（singular）：字段的默认类型，这样的字段对应的数据只能是 0 个或 1 个； 重复的（repeated）：类似于数组，这样的字段对应的数据可以有任意多个，并且会保留其顺序。 在将字段对应到编号（number）上时，需要注意以下几点：\n我们可以使用 [1, 19000) 和 (19999, 2^29 - 1] 区间内的任意编号用来标识字段，中间 [19000, 19999] 是为 ProtoBuf 的实现所预留的； 在对 proto 文件进行编码时，编号 1 到 15 需要占用 1 个字节，16 到 2047 需要占用 2 个字节，因此一般会将常用的字段对应到编号 1 到 15上以节约空间； 一旦使用了某个编号就不能修改其对应字段的类型了，否则会造成无法兼容的问题。 组合和嵌套结构 我们可以直接在一个 message 类型里直接嵌套声明并使用另一个 message 结构：\nmessage SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1; } 如果要使用在另一个 message 类型里嵌套声明的子 message 类型，则需要在定义时加上其父 message 类型的名称：\nmessage ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; } } message SearchResponse { repeated ResultType.Result results = 1; } 类似的，我们也可以以组合的方式在一个 message 类型里引入另一个 message 类型作为字段，并为其赋予 repeated 属性；如果引入的 message 类型在另一个 proto 文件中则需要 import 对应的文件：\n// msg.proto import \"result.proto\"; message SearchResponse { repeated Result results = 1; } // result.proto message Result { string url = 1; string title = 2; repeated string snippets = 3; } import import 的方式有两种，一种是以相对路径的方式 import，如上面的例子；另一种是在使用 protoc 工具生成代码时使用 -I 指令指定所需要包含的 proto 文件所在的目录，并以绝对路径的方式 import：\n$ tree . |-- msg.proto `-- result `-- result.proto 1 directory, 2 files $ protoc -I. -I./result/ --go_out=./ msg.proto 1.2 关键字 包 包（package）的功能很简单，类似于 C 语言中的 namespace，它可以用来避免不同的 ProtoBuf 消息之间的命名冲突：\npackage Message; 服务 服务（service）是用来定义 RPC 所使用的消息类型的，在 gPRC 有非常充分的应用，它的定义和 Go 的函数定义比较类似：\nservice SearchService { rpc Search (SearchRequest) returns (SearchResponse); } 选项 选项（option）可以改变 proto 文件中某些预定义上下文的处理方式，包括但不限于：\noptimize_for 修改代码生成的方式，有 SPEED 高度优化，CODE_SIZE 减少代码，以及 LITE_RUNTIME 精简功能三种类型； packed 针对 repeated 类型的字段，生成更紧凑的代码； deprecated 针对字段，表明已经废弃，一般只会生成注释，应该尽量搭配 reserved 关键字使用。 option optimize_for = CODE_SIZE; // ... repeated int32 samples = 4 [packed=true]; int32 old_field = 6 [deprecated=true]; 版本兼容 为了使得新版本的 proto 文件能够兼容老版本的，我们不能修改任何已有字段的类型，防止在使用以往版本的老代码在解析新版本的数据结构时发生兼容性问题。\n当我们不再使用某些字段时，我们可以将字段及其对应的编号都删除或注释掉；为了防止我们不小心再次使用相同的编号并将其对应到不同类型的字段上，我们可以使用 reserved 关键字来对已经被删除的字段和编号进行标注，让编译器在编译时检查这些字段和编号是否有被再次使用：\n// msg.proto message SearchRequest { reserved 3, 6, 9 to 12; reserved \"foo\", \"bar\"; string query = 1; int32 page_number = 2; int32 result_per_page = 3; } $ protoc -I. --go_out=./ msg.proto msg.proto: Field \"result_per_page\" uses reserved number 3. 1.3 数据类型 基础类型 下面的列表列出了 proto 文件中可以使用的所有基础数据类型\n类型 默认值 说明 C++ 类型 Python 类型 Go 类型 double 0 double float float64 float 0 float float float32 int32 0 使用 varint 编码，因此如果有负数建议使用 sint32 int32 int int32 int64 0 使用 varint 编码，因此如果有负数建议使用 sint64 int64 int/long[3] int64 uint32 0 使用 varint 编码 uint32 int/long[3] uint32 uint64 0 使用 varint 编码 uint64 int/long[3] uint64 sint32 0 使用 varint 编码，有符号 int32 int int32 sint64 0 使用 varint 编码，有符号 int64 int/long[3] int64 fixed32 0 固定 4 字节，如果数值超过 228 则比 uint32 效率更高 uint32 int/long[3] uint32 fixed64 0 固定 8 字节，如果数值超过 256 则比 uint64 效率更高 uint64 int/long[3] uint64 sfixed32 0 固定 4 字节 int32 int int32 sfixed64 0 固定 8 字节 int64 int/long[3] int64 bool false bool bool bool string \"\" 必须以 UTF-8 或 7位 ASCII 编码，长度不能超过 232 string str/unicode[4] string bytes \"\" 长度不超过 232 的任意字节序列 string str []byte 除了这些基础类型之外，枚举类型（enums）的默认是 0（也就是定义的第一个枚举值），repeated 字段的默认值为空。\nmap ProtoBuf 的一大亮点就是内置了 map 数据类型，其 key_type 可以是任意整数类型或字符串类型：\nmap map_field = N; map 目前不能被 repeated 修饰，但可以通过自定义一个类似于 map 的结构来实现其效果，需要自行解决从 key_type 到 value_type 的映射关系：\nmessage MapFieldEntry { key_type key = 1; value_type value = 2; } repeated MapFieldEntry map_field = N; 枚举类型 proto 文件中的枚举类型定义大致如下：\nmessage EnumRequest { enum Corpus { option allow_alias = true; UNIVERSAL = 0; WEB = 1; NET = 1; IMAGES = 2; LOCAL = 3; } Corpus corpus = 1; } 在使用枚举类型时需要注意几点：\n枚举值定义必须在 32 位整数整数范围内，并且不建议使用负数（因为枚举值在序列化时使用 varint 编码）； 在枚举类型的定义中必须有一个值为 0 的枚举变量； 如果要定义值相同的枚举类型，必须加上 option allow_alias = true。 特殊类型 除了 double, float, int32 等基础数据类型，proto 文件里还可以定义一些特殊的数据类型：\nAny 包含任意字节数的序列化消息； Oneof 类似于 union，表示多个字段共享同一块内存，并且只有其中一个能够被赋值； 2 编码过程 ProtoBuf 的编码过程分为两部分：先对字段的定义进行编码，以便在解码过程中识别其类型；再对数据的值进行编码，对其进行压缩。其中第一部分实际上是使用一定的规则对字段的类型和编号进行编码，得到字段的标签 Tag，而并没有用到字段的名字，因此在实际使用中即使修改字段的名字也是不会发生兼容性问题的；第二部分则是使用不同的算法对不同类型的数据进行压缩得到值 Value，主要用到的两种算法分别是 Varint 和 ZigZag。将这两部分编码完成后，再将标签 Tag，字节长度 Length（只有变长类型需要），值 Value 拼接在一起，就得到了编码后的二进制数据。\n2.1 标签编码 对标签的编码步骤是先将字段类型映射到一个数字 wire_type 上，再将字段编号 field_num 向左位移 3 位，并将两者进行或操作，即 (field_number \u003c\u003c 3) | wire_type。字段类型和 wire_type 的映射关系如下：\nwire_type 含义 存储结构 对应的字段类型 0 使用 Varint 压缩 [Tag Value] int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64 位 [Tag Value] fixed64, sfixed64, double 2 按长度区分 [Tag Length Value] string, bytes, embedded messages, packed repeated fields 3 Start group groups (弃用) 4 End group groups (弃用) 5 32 位 [Tag Value] fixed32, sfixed32, float 解码时为了能够获取存储结构的定义，必须提供正确的 proto 文件。\n举个例子，假设要对一个字段编号 field_number = 2，字段类型为 sint64 的字段进行编码，它的 wire_type = 0，能够知道 (field_number \u003c\u003c 3) | wire_type = 10000，即编码后得到 10；\n类似的，在解码时会先取其后三位 \u0026 111 得到 wire_type = 0，再向右位移 3 位得到 field_number = 2。\n总结一下，对于字段编码后的字节，后三位表示类型，前置位表示字段编号。\n2.2 Varint 对 WireType == 0 的整数类型的主要编码方式是使用 Varint，使用 Varint 编码后的二进制数据长度是不固定的，数值越小的数字编码后的字节长度越小。其步骤分为 3 步：\n对于一个数字的二进制位表示，将其拆分为 7 个一组的字节； 在每一组的头部添加一个最高有效位（most significant bit），只有最大一组有 msb = 0，其他组的 msb 都等于 1； 按照小端序排列这些字节。 举一个简单的例子，对于数字 582963 来说：\n它的二进制表示是 10001110010100110011，将其拆分为三组，分别是 0100011, 1001010, 0110011，即 35, 74, 51； 在最大的一组前加上最高有效位 0，得到 00100011，仍然是 35；在其他组前加上最高有效位 1，得到 11001010，10110011，分别是 202, 179； 将这三个字节按小端序排列，得到 10110011 11001010 00100011，分别是 179, 202, 35，即通过 Varint 编码最后得到的结果。 用 ProtoBuf 对数字 582963 进行编码测试：\nmessage SingleNumber { int32 Num = 1; } func main() { sn := SingleNumber { Num: 582963, } bytes, err := proto.Marshal(\u0026sn) if err != nil { panic(err) } fmt.Println(bytes) } 得到的结果与上述步骤相同，其中第一个字节 8 是对字段进行编码得到的 key：\n$ go run main.go msg.pb.go [8 179 202 35] 解码过程也是类似的：\nfunc main() { b := []byte{8, 179, 202, 35} var sn SingleNumber err := proto.Unmarshal(b, \u0026sn) if err != nil { panic(err) } fmt.Println(sn.GetNum()) } $ go run main.go msg.pb.go 582963 2.3 ZigZag Varint 编码的本质在于去掉数字二进制表示的前置 0 从而减少数据所占用的字节数；而对于用补码表示的负数来说，使用 Varint 进行编码的话，32 位的数字会占用 5 个字节，64 位的数字会占用 10 个字节，效果就显得非常差了。对此 ProtoBuf 采用了 ZigZag 来进行优化，ZigZag 可以将有符号整数映射为无符号整数；正数的编码结果相当于将其乘以 2，负数的编码结果相当于将其绝对值乘以 2 并减 1，编码后的值对应的原始数据在正负数之间摇摆，如下表：\n原始的有符号整数 编码后的无符号整数 0 0 -1 1 1 2 -2 3 2147483647 4294967294 -2147483648 4294967295 它的过程也非常简单：\n假设被编码数的二进制表示是 num，将 num 左移 1 位得到 x 将 num 右移 31 位（num 本身的位数 - 1）得到 y，即用符号位覆盖 num 的每一位 将 x 和 y 进行异或操作，得到结果 z = x ^ y 举个例子，对于正数 5：\nx = 5 « 1 = 00000000 00000000 00000000 00001010 y = 5 » 31 = 00000000 00000000 00000000 00000000 z = x ^ y = 00000000 00000000 00000000 00001010，得到 10 对于负数 -5：\nx = -5 « 1 = 11111111 11111111 11111111 11110110 y = -5 » 31 = 11111111 11111111 11111111 11111111 z = x ^ y = 00000000 00000000 00000000 00001001，得到 9 在 ProtoBuf 中，负数会先用 ZigZag，再用 Varint 进行编码，达到进一步压缩数据的效果。\n2.4 其他编码过程 变长类型 对于 WireType == 2 的变长类型（string, bytes 等）来说，其序列化后的二进制数据流是以 [Tag Length Value] 的方式存储的，其中 Length 是变长部分的长度，例如：\nmessage SingleNumber { int32 Num = 1; string Str = 2; } func main() { sn := SingleNumber { Num: 582963, Str: \"helloworld\" } bytes, err := proto.Marshal(\u0026sn) if err != nil { panic(err) } fmt.Println(bytes) } $ go run main.go msg.pb.go [8 179 202 35 18 10 104 101 108 108 111 119 111 114 108 100] 在输出的结果中，第五个字节 18 是 string Str = 2 的 Tag，其中 field_num = 2, wire_type = 2；第六个字节 10 代表这个变长类型的 Length，即从第七个字节到第十六个字节都是存储的 Value，每一个值均是用 ASCII 码存储的字符。\n固定长度类型 对于 WireType == 1 或 WireType == 5 的固定长度类型（fixed32, fixed64 等）来说，其序列化后的二进制数据的长度固定为 4 或 8 个字节，例如：\nmessage SingleNumber { int32 Num = 1; string Str = 2; fixed32 A = 3; fixed64 B = 4; float C = 5; } func main() { sn := SingleNumber { // Num: 582963, // Str: \"helloworld\", A: 256, B: 257, } bytes, err := proto.Marshal(\u0026sn) if err != nil { fmt.Println(err) return } fmt.Println(bytes) } $ go run main.go msg.pb.go [29 0 1 0 0 33 1 1 0 0 0 0 0 0] 得到的结果中第 1 个字节是 fixed32 A = 3 的 tag，其中 field_num = 3, wire_type = 5，其后的 4 个字节按照字节序直接存储；第 5 个字节是 fixed64 B = 4 的 tag，其中 field_num = 4, wire_type = 1，其后的 8 个字节同样是按照字节序直接存储的。\n","wordCount":"1291","inLanguage":"en","datePublished":"2021-04-26T21:44:52+08:00","dateModified":"2021-04-26T21:44:52+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/serialization/protocol-buffer/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ProtoBuf 语法和编码原理入门</h1><div class=post-meta><span title='2021-04-26 21:44:52 +0800 +0800'>April 26, 2021</span>&nbsp;·&nbsp;7 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#protobuf-%e8%af%ad%e6%b3%95%e5%92%8c%e7%bc%96%e7%a0%81%e5%8e%9f%e7%90%86%e5%85%a5%e9%97%a8 aria-label="ProtoBuf 语法和编码原理入门">ProtoBuf 语法和编码原理入门</a><ul><li><a href=#1-%e8%af%ad%e6%b3%95 aria-label="1 语法">1 语法</a><ul><li><a href=#11-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="1.1 数据结构">1.1 数据结构</a><ul><li><a href=#%e5%ad%97%e6%ae%b5%e5%92%8c%e7%bc%96%e5%8f%b7 aria-label=字段和编号>字段和编号</a></li><li><a href=#%e7%bb%84%e5%90%88%e5%92%8c%e5%b5%8c%e5%a5%97%e7%bb%93%e6%9e%84 aria-label=组合和嵌套结构>组合和嵌套结构</a><ul><li><a href=#import aria-label=import>import</a></li></ul></li></ul></li><li><a href=#12-%e5%85%b3%e9%94%ae%e5%ad%97 aria-label="1.2 关键字">1.2 关键字</a><ul><li><a href=#%e5%8c%85 aria-label=包>包</a></li><li><a href=#%e6%9c%8d%e5%8a%a1 aria-label=服务>服务</a></li><li><a href=#%e9%80%89%e9%a1%b9 aria-label=选项>选项</a></li><li><a href=#%e7%89%88%e6%9c%ac%e5%85%bc%e5%ae%b9 aria-label=版本兼容>版本兼容</a></li></ul></li><li><a href=#13-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label="1.3 数据类型">1.3 数据类型</a><ul><li><a href=#%e5%9f%ba%e7%a1%80%e7%b1%bb%e5%9e%8b aria-label=基础类型>基础类型</a></li><li><a href=#map aria-label=map>map</a></li><li><a href=#%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b aria-label=枚举类型>枚举类型</a></li><li><a href=#%e7%89%b9%e6%ae%8a%e7%b1%bb%e5%9e%8b aria-label=特殊类型>特殊类型</a></li></ul></li></ul></li><li><a href=#2-%e7%bc%96%e7%a0%81%e8%bf%87%e7%a8%8b aria-label="2 编码过程">2 编码过程</a><ul><li><a href=#21-%e6%a0%87%e7%ad%be%e7%bc%96%e7%a0%81 aria-label="2.1 标签编码">2.1 标签编码</a></li><li><a href=#22-varint aria-label="2.2 Varint">2.2 Varint</a></li><li><a href=#23-zigzag aria-label="2.3 ZigZag">2.3 ZigZag</a></li><li><a href=#24-%e5%85%b6%e4%bb%96%e7%bc%96%e7%a0%81%e8%bf%87%e7%a8%8b aria-label="2.4 其他编码过程">2.4 其他编码过程</a><ul><li><a href=#%e5%8f%98%e9%95%bf%e7%b1%bb%e5%9e%8b aria-label=变长类型>变长类型</a></li><li><a href=#%e5%9b%ba%e5%ae%9a%e9%95%bf%e5%ba%a6%e7%b1%bb%e5%9e%8b aria-label=固定长度类型>固定长度类型</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=protobuf-语法和编码原理入门>ProtoBuf 语法和编码原理入门<a hidden class=anchor aria-hidden=true href=#protobuf-语法和编码原理入门>#</a></h1><p><a href=https://en.wikipedia.org/wiki/Serialization>序列化</a>是指将结构化数据转换成易于存储或发送的数据格式的过程，Protocol Buffer 简称 ProtoBuf，是一种语言无关，平台无关的序列化工具，由谷歌在 2008 年开源。相较于常见的序列化工具 <a href=https://en.wikipedia.org/wiki/XML>XML</a>, JSON, YAML, CSV 等，ProtoBuf 的优势主要包括序列化后<strong>数据量小</strong>，序列化和反序列化过程<strong>速度快</strong>，使用时只需定义 proto 文件使得其<strong>维护成本低</strong>，可<strong>向后兼容</strong>等；但因为其数据以二进制数据流的形式存在，也有<strong>人类不可读</strong>的劣势。</p><p>本文主要介绍 ProtoBuf 的使用方法，包括 .proto 文件的语法，以及如何使用 protoc 工具来生成不通语言的代码；以及其编码原理。</p><h2 id=1-语法>1 语法<a hidden class=anchor aria-hidden=true href=#1-语法>#</a></h2><p>首先从 <a href=https://github.com/protocolbuffers/protobuf>https://github.com/protocolbuffers/protobuf</a> 找到最新版本的 ProtoBuf，下载预编译好的二进制文件 <code>protoc</code> 解压到环境变量目录，本文使用的是 3.15.7 版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ protoc --version
</span></span><span style=display:flex><span>libprotoc 3.15.7
</span></span></code></pre></div><p>以一个简单的 proto 文件为例，它的语法和 C++ 类似：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#75715e>// msg.proto
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#f92672>package</span> Message;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SearchRequest</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  reserved <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span> <span style=color:#66d9ef>to</span> <span style=color:#ae81ff>12</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  reserved <span style=color:#e6db74>&#34;foo&#34;</span>, <span style=color:#e6db74>&#34;bar&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> query <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> page_number <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> result_per_page <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>ResultType</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>message</span> <span style=color:#a6e22e>Result</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>string</span> url <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>string</span> title <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>string</span> snippets <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SearchResponse</span> { <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>repeated</span> ResultType.Result results <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>使用 protoc 工具生成指定语言的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>protoc --proto_path<span style=color:#f92672>=</span>./ --go_out<span style=color:#f92672>=</span>./go_out/ --cpp_out<span style=color:#f92672>=</span>./cpp_out/ msg.proto 
</span></span></code></pre></div><p>其中 <code>--proto_path</code> 或 <code>-I</code> 用于参数指定生成所需的 proto 文件和被导入的 proto 文件所在的目录，不指定的话默认为当前目录；<code>go_out</code> 和 <code>cpp_out</code> 分别为生成的 go 文件和 cpp 文件指定目录；最后是我们所需要转换的所有 proto 文件；更多的参数可以输入 <code>protoc --help</code> 查看。</p><h3 id=11-数据结构>1.1 数据结构<a hidden class=anchor aria-hidden=true href=#11-数据结构>#</a></h3><p>msg.proto 文件里包含了两部分内容：首先需要指定 ProtoBuf 的版本为 proto3，不指定的话编译器则会默认使用老版本的 proto2 语法；然后是定义我们所需要的 message 类型。message 类型中有很多<strong>字段</strong>，每个字段都对应一个独一无二的<strong>编号</strong>，这些编号是用来在序列化后的二进制数据流中识别字段用的。</p><h4 id=字段和编号>字段和编号<a hidden class=anchor aria-hidden=true href=#字段和编号>#</a></h4><p><strong>字段</strong>（field）分为两种类型：</p><ol><li>唯一的（singular）：字段的默认类型，这样的字段对应的数据只能是 0 个或 1 个；</li><li>重复的（repeated）：类似于数组，这样的字段对应的数据可以有任意多个，并且会保留其顺序。</li></ol><p>在将字段对应到<strong>编号</strong>（number）上时，需要注意以下几点：</p><ol><li>我们可以使用 [1, 19000) 和 (19999, 2^29 - 1] 区间内的任意编号用来标识字段，中间 [19000, 19999] 是为 ProtoBuf 的实现所预留的；</li><li>在对 proto 文件进行编码时，编号 1 到 15 需要占用 1 个字节，16 到 2047 需要占用 2 个字节，因此一般会将常用的字段对应到编号 1 到 15上以节约空间；</li><li>一旦使用了某个编号就<strong>不能修改</strong>其对应字段的<strong>类型</strong>了，否则会造成无法兼容的问题。</li></ol><h4 id=组合和嵌套结构>组合和嵌套结构<a hidden class=anchor aria-hidden=true href=#组合和嵌套结构>#</a></h4><p>我们可以直接在一个 message 类型里直接<strong>嵌套</strong>声明并使用另一个 message 结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SearchResponse</span> { <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>message</span> <span style=color:#a6e22e>Result</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>string</span> url <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>string</span> title <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>string</span> snippets <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>repeated</span> Result results <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>如果要使用在另一个 message 类型里嵌套声明的子 message 类型，则需要在定义时加上其父 message 类型的名称：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>ResultType</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>message</span> <span style=color:#a6e22e>Result</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>string</span> url <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>string</span> title <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>string</span> snippets <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SearchResponse</span> { <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>repeated</span> ResultType.Result results <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>类似的，我们也可以以组合的方式在一个 message 类型里引入另一个 message 类型作为字段，并为其赋予 repeated 属性；如果引入的 message 类型在另一个 proto 文件中则需要 import 对应的文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#75715e>// msg.proto
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#34;result.proto&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SearchResponse</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>repeated</span> Result results <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>// result.proto
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>Result</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> url <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> title <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>string</span> snippets <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h5 id=import>import<a hidden class=anchor aria-hidden=true href=#import>#</a></h5><p><strong>import</strong> 的方式有两种，一种是以<strong>相对路径</strong>的方式 import，如上面的例子；另一种是在使用 protoc 工具生成代码时使用 <code>-I</code> 指令指定所需要包含的 proto 文件所在的目录，并以<strong>绝对路径</strong>的方式 import：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ tree
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>|-- msg.proto
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>-- result
</span></span><span style=display:flex><span>    <span style=color:#e6db74>`</span>-- result.proto
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> directory, <span style=color:#ae81ff>2</span> files
</span></span><span style=display:flex><span>$ protoc -I. -I./result/ --go_out<span style=color:#f92672>=</span>./ msg.proto
</span></span></code></pre></div><h3 id=12-关键字>1.2 关键字<a hidden class=anchor aria-hidden=true href=#12-关键字>#</a></h3><h4 id=包>包<a hidden class=anchor aria-hidden=true href=#包>#</a></h4><p><strong>包</strong>（package）的功能很简单，类似于 C 语言中的 namespace，它可以用来避免不同的 ProtoBuf 消息之间的命名冲突：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#f92672>package</span> Message;<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=服务>服务<a hidden class=anchor aria-hidden=true href=#服务>#</a></h4><p><strong>服务</strong>（service）是用来定义 RPC 所使用的消息类型的，在 gPRC 有非常充分的应用，它的定义和 Go 的函数定义比较类似：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>service</span> SearchService {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> Search (SearchRequest) <span style=color:#66d9ef>returns</span> (SearchResponse);<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=选项>选项<a hidden class=anchor aria-hidden=true href=#选项>#</a></h4><p><strong>选项</strong>（option）可以改变 proto 文件中某些预定义上下文的处理方式，包括但不限于：</p><ol><li><code>optimize_for</code> 修改代码生成的方式，有 <code>SPEED</code> 高度优化，<code>CODE_SIZE</code> 减少代码，以及 <code>LITE_RUNTIME</code> 精简功能三种类型；</li><li><code>packed</code> 针对 repeated 类型的字段，生成更紧凑的代码；</li><li><code>deprecated</code> 针对字段，表明已经废弃，一般只会生成注释，应该尽量搭配 <code>reserved</code> 关键字使用。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>option</span> optimize_for <span style=color:#f92672>=</span> CODE_SIZE;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>int32</span> samples <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span> [<span style=color:#66d9ef>packed</span><span style=color:#f92672>=</span><span style=color:#66d9ef>true</span>];<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> old_field <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span> [deprecated<span style=color:#f92672>=</span><span style=color:#66d9ef>true</span>];<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=版本兼容>版本兼容<a hidden class=anchor aria-hidden=true href=#版本兼容>#</a></h4><p>为了使得新版本的 proto 文件能够兼容老版本的，我们<strong>不能修改任何已有字段的类型</strong>，防止在使用以往版本的老代码在解析新版本的数据结构时发生兼容性问题。</p><p>当我们不再使用某些字段时，我们可以将字段及其对应的编号都删除或注释掉；为了防止我们不小心再次使用相同的编号并将其对应到不同类型的字段上，我们可以使用 <code>reserved</code> 关键字来对已经被删除的字段和编号进行标注，让编译器在编译时检查这些字段和编号是否有被再次使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#75715e>// msg.proto
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SearchRequest</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  reserved <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span> <span style=color:#66d9ef>to</span> <span style=color:#ae81ff>12</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  reserved <span style=color:#e6db74>&#34;foo&#34;</span>, <span style=color:#e6db74>&#34;bar&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> query <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> page_number <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> result_per_page <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ protoc -I. --go_out<span style=color:#f92672>=</span>./ msg.proto 
</span></span><span style=display:flex><span>msg.proto: Field <span style=color:#e6db74>&#34;result_per_page&#34;</span> uses reserved number 3.
</span></span></code></pre></div><h3 id=13-数据类型>1.3 数据类型<a hidden class=anchor aria-hidden=true href=#13-数据类型>#</a></h3><h4 id=基础类型>基础类型<a hidden class=anchor aria-hidden=true href=#基础类型>#</a></h4><p>下面的列表列出了 proto 文件中可以使用的所有基础数据类型</p><table><thead><tr><th style=text-align:left>类型</th><th style=text-align:left>默认值</th><th style=text-align:left>说明</th><th style=text-align:left>C++ 类型</th><th style=text-align:left>Python 类型</th><th style=text-align:left>Go 类型</th></tr></thead><tbody><tr><td style=text-align:left>double</td><td style=text-align:left>0</td><td style=text-align:left></td><td style=text-align:left>double</td><td style=text-align:left>float</td><td style=text-align:left>float64</td></tr><tr><td style=text-align:left>float</td><td style=text-align:left>0</td><td style=text-align:left></td><td style=text-align:left>float</td><td style=text-align:left>float</td><td style=text-align:left>float32</td></tr><tr><td style=text-align:left>int32</td><td style=text-align:left>0</td><td style=text-align:left>使用 varint 编码，因此如果有负数建议使用 sint32</td><td style=text-align:left>int32</td><td style=text-align:left>int</td><td style=text-align:left>int32</td></tr><tr><td style=text-align:left>int64</td><td style=text-align:left>0</td><td style=text-align:left>使用 varint 编码，因此如果有负数建议使用 sint64</td><td style=text-align:left>int64</td><td style=text-align:left>int/long[3]</td><td style=text-align:left>int64</td></tr><tr><td style=text-align:left>uint32</td><td style=text-align:left>0</td><td style=text-align:left>使用 varint 编码</td><td style=text-align:left>uint32</td><td style=text-align:left>int/long[3]</td><td style=text-align:left>uint32</td></tr><tr><td style=text-align:left>uint64</td><td style=text-align:left>0</td><td style=text-align:left>使用 varint 编码</td><td style=text-align:left>uint64</td><td style=text-align:left>int/long[3]</td><td style=text-align:left>uint64</td></tr><tr><td style=text-align:left>sint32</td><td style=text-align:left>0</td><td style=text-align:left>使用 varint 编码，有符号</td><td style=text-align:left>int32</td><td style=text-align:left>int</td><td style=text-align:left>int32</td></tr><tr><td style=text-align:left>sint64</td><td style=text-align:left>0</td><td style=text-align:left>使用 varint 编码，有符号</td><td style=text-align:left>int64</td><td style=text-align:left>int/long[3]</td><td style=text-align:left>int64</td></tr><tr><td style=text-align:left>fixed32</td><td style=text-align:left>0</td><td style=text-align:left>固定 4 字节，如果数值超过 228 则比 uint32 效率更高</td><td style=text-align:left>uint32</td><td style=text-align:left>int/long[3]</td><td style=text-align:left>uint32</td></tr><tr><td style=text-align:left>fixed64</td><td style=text-align:left>0</td><td style=text-align:left>固定 8 字节，如果数值超过 256 则比 uint64 效率更高</td><td style=text-align:left>uint64</td><td style=text-align:left>int/long[3]</td><td style=text-align:left>uint64</td></tr><tr><td style=text-align:left>sfixed32</td><td style=text-align:left>0</td><td style=text-align:left>固定 4 字节</td><td style=text-align:left>int32</td><td style=text-align:left>int</td><td style=text-align:left>int32</td></tr><tr><td style=text-align:left>sfixed64</td><td style=text-align:left>0</td><td style=text-align:left>固定 8 字节</td><td style=text-align:left>int64</td><td style=text-align:left>int/long[3]</td><td style=text-align:left>int64</td></tr><tr><td style=text-align:left>bool</td><td style=text-align:left>false</td><td style=text-align:left></td><td style=text-align:left>bool</td><td style=text-align:left>bool</td><td style=text-align:left>bool</td></tr><tr><td style=text-align:left>string</td><td style=text-align:left>""</td><td style=text-align:left>必须以 UTF-8 或 7位 ASCII 编码，长度不能超过 232</td><td style=text-align:left>string</td><td style=text-align:left>str/unicode[4]</td><td style=text-align:left>string</td></tr><tr><td style=text-align:left>bytes</td><td style=text-align:left>""</td><td style=text-align:left>长度不超过 232 的任意字节序列</td><td style=text-align:left>string</td><td style=text-align:left>str</td><td style=text-align:left>[]byte</td></tr></tbody></table><p>除了这些基础类型之外，枚举类型（enums）的默认是 0（也就是定义的第一个枚举值），repeated 字段的默认值为空。</p><h4 id=map>map<a hidden class=anchor aria-hidden=true href=#map>#</a></h4><p>ProtoBuf 的一大亮点就是内置了 map 数据类型，其 <code>key_type</code> 可以是任意整数类型或字符串类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>map&lt;key_type, value_type&gt; map_field <span style=color:#f92672>=</span> N;<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>map 目前不能被 repeated 修饰，但可以通过自定义一个类似于 map 的结构来实现其效果，需要自行解决从 <code>key_type</code> 到 <code>value_type</code> 的映射关系：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>MapFieldEntry</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    key_type key <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    value_type value <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>repeated</span> MapFieldEntry map_field <span style=color:#f92672>=</span> N;<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=枚举类型>枚举类型<a hidden class=anchor aria-hidden=true href=#枚举类型>#</a></h4><p>proto 文件中的枚举类型定义大致如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>EnumRequest</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>enum</span> Corpus {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>option</span> allow_alias <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    UNIVERSAL <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    WEB <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    NET <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    IMAGES <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    LOCAL <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  Corpus corpus <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>在使用枚举类型时需要注意几点：</p><ol><li>枚举值定义必须在 32 位整数整数范围内，并且不建议使用负数（因为枚举值在序列化时使用 varint 编码）；</li><li>在枚举类型的定义中必须有一个值为 0 的枚举变量；</li><li>如果要定义值相同的枚举类型，必须加上 <code>option allow_alias = true</code>。</li></ol><h4 id=特殊类型>特殊类型<a hidden class=anchor aria-hidden=true href=#特殊类型>#</a></h4><p>除了 <code>double</code>, <code>float</code>, <code>int32</code> 等基础数据类型，proto 文件里还可以定义一些特殊的数据类型：</p><ol><li><code>Any</code> 包含任意字节数的序列化消息；</li><li><code>Oneof</code> 类似于 <code>union</code>，表示多个字段共享同一块内存，并且只有其中一个能够被赋值；</li></ol><h2 id=2-编码过程>2 编码过程<a hidden class=anchor aria-hidden=true href=#2-编码过程>#</a></h2><p>ProtoBuf 的编码过程分为两部分：先对字段的定义进行编码，以便在解码过程中识别其类型；再对数据的值进行编码，对其进行压缩。其中第一部分实际上是使用一定的规则<strong>对字段的类型和编号进行编码</strong>，得到字段的标签 Tag，而并没有用到字段的名字，因此在实际使用中即使修改字段的名字也是不会发生兼容性问题的；第二部分则是使用不同的算法对不同类型的数据进行压缩得到值 Value，主要用到的两种算法分别是 <strong>Varint</strong> 和 <strong>ZigZag</strong>。将这两部分编码完成后，再将<strong>标签 Tag</strong>，<strong>字节长度 Length</strong>（只有变长类型需要），<strong>值 Value</strong> 拼接在一起，就得到了编码后的二进制数据。</p><h3 id=21-标签编码>2.1 标签编码<a hidden class=anchor aria-hidden=true href=#21-标签编码>#</a></h3><p>对标签的编码步骤是先将字段类型映射到一个数字 wire_type 上，再将字段编号 field_num 向左位移 3 位，并将两者进行或操作，即 <code>(field_number &lt;&lt; 3) | wire_type</code>。字段类型和 wire_type 的映射关系如下：</p><table><thead><tr><th style=text-align:left>wire_type</th><th style=text-align:left>含义</th><th style=text-align:left>存储结构</th><th style=text-align:left>对应的字段类型</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left>使用 Varint 压缩</td><td style=text-align:left>[Tag Value]</td><td style=text-align:left>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>64 位</td><td style=text-align:left>[Tag Value]</td><td style=text-align:left>fixed64, sfixed64, double</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>按长度区分</td><td style=text-align:left>[Tag Length Value]</td><td style=text-align:left>string, bytes, embedded messages, packed repeated fields</td></tr><tr><td style=text-align:left>3</td><td style=text-align:left>Start group</td><td style=text-align:left></td><td style=text-align:left>groups (弃用)</td></tr><tr><td style=text-align:left>4</td><td style=text-align:left>End group</td><td style=text-align:left></td><td style=text-align:left>groups (弃用)</td></tr><tr><td style=text-align:left>5</td><td style=text-align:left>32 位</td><td style=text-align:left>[Tag Value]</td><td style=text-align:left>fixed32, sfixed32, float</td></tr></tbody></table><p>解码时为了能够获取存储结构的定义，必须提供正确的 proto 文件。</p><p>举个例子，假设要对一个字段编号 field_number = 2，字段类型为 sint64 的字段进行编码，它的 wire_type = 0，能够知道 <code>(field_number &lt;&lt; 3) | wire_type = 10000</code>，即编码后得到 10；</p><p><img alt=protobuf-encoding loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/serialization/protobuf-encoding.png></p><p>类似的，在解码时会先取其后三位 <code>& 111</code> 得到 wire_type = 0，再向右位移 3 位得到 field_number = 2。</p><p>总结一下，对于字段编码后的字节，<strong>后三位表示类型</strong>，<strong>前置位表示字段编号</strong>。</p><h3 id=22-varint>2.2 Varint<a hidden class=anchor aria-hidden=true href=#22-varint>#</a></h3><p>对 <code>WireType == 0</code> 的整数类型的主要编码方式是使用 Varint，使用 Varint 编码后的二进制数据长度是不固定的，数值越小的数字编码后的字节长度越小。其步骤分为 3 步：</p><ol><li>对于一个数字的二进制位表示，将其拆分为 7 个一组的字节；</li><li>在每一组的头部添加一个最高有效位（most significant bit），只有最大一组有 msb = 0，其他组的 msb 都等于 1；</li><li>按照<a href=https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F>小端序</a>排列这些字节。</li></ol><p>举一个简单的例子，对于数字 582963 来说：</p><ol><li>它的二进制表示是 10001110010100110011，将其拆分为三组，分别是 0100011, 1001010, 0110011，即 35, 74, 51；</li><li>在最大的一组前加上最高有效位 0，得到 00100011，仍然是 35；在其他组前加上最高有效位 1，得到 11001010，10110011，分别是 202, 179；</li><li>将这三个字节按小端序排列，得到 10110011 11001010 00100011，分别是 179, 202, 35，即通过 Varint 编码最后得到的结果。</li></ol><p><img alt=varint loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/serialization/varint.png></p><p>用 ProtoBuf 对数字 582963 进行编码测试：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SingleNumber</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> Num <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SingleNumber</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Num</span>: <span style=color:#ae81ff>582963</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bytes</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sn</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>bytes</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>得到的结果与上述步骤相同，其中第一个字节 8 是对字段进行编码得到的 key：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ go run main.go msg.pb.go 
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#ae81ff>8</span> <span style=color:#ae81ff>179</span> <span style=color:#ae81ff>202</span> 35<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>解码过程也是类似的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>byte</span>{<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>179</span>, <span style=color:#ae81ff>202</span>, <span style=color:#ae81ff>35</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sn</span> <span style=color:#a6e22e>SingleNumber</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>b</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sn</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sn</span>.<span style=color:#a6e22e>GetNum</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ go run main.go msg.pb.go 
</span></span><span style=display:flex><span><span style=color:#ae81ff>582963</span>
</span></span></code></pre></div><h3 id=23-zigzag>2.3 ZigZag<a hidden class=anchor aria-hidden=true href=#23-zigzag>#</a></h3><p>Varint 编码的本质在于去掉数字二进制表示的前置 0 从而减少数据所占用的字节数；而对于<a href=https://www.ruanyifeng.com/blog/2009/08/twos_complement.html>用补码表示的负数</a>来说，使用 Varint 进行编码的话，32 位的数字会占用 5 个字节，64 位的数字会占用 10 个字节，效果就显得非常差了。对此 ProtoBuf 采用了 ZigZag 来进行优化，ZigZag 可以将有符号整数映射为无符号整数；正数的编码结果相当于将其乘以 2，负数的编码结果相当于将其绝对值乘以 2 并减 1，编码后的值对应的原始数据在正负数之间摇摆，如下表：</p><table><thead><tr><th style=text-align:left>原始的有符号整数</th><th style=text-align:left>编码后的无符号整数</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left>0</td></tr><tr><td style=text-align:left>-1</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>2</td></tr><tr><td style=text-align:left>-2</td><td style=text-align:left>3</td></tr><tr><td style=text-align:left>2147483647</td><td style=text-align:left>4294967294</td></tr><tr><td style=text-align:left>-2147483648</td><td style=text-align:left>4294967295</td></tr></tbody></table><p>它的过程也非常简单：</p><ol><li>假设被编码数的二进制表示是 num，将 num 左移 1 位得到 x</li><li>将 num 右移 31 位（num 本身的位数 - 1）得到 y，即用符号位覆盖 num 的每一位</li><li>将 x 和 y 进行异或操作，得到结果 <code>z = x ^ y</code></li></ol><p>举个例子，对于正数 5：</p><ol><li>x = 5 &#171; 1 = 00000000 00000000 00000000 00001010</li><li>y = 5 &#187; 31 = 00000000 00000000 00000000 00000000</li><li>z = x ^ y = 00000000 00000000 00000000 00001010，得到 10</li></ol><p>对于负数 -5：</p><ol><li>x = -5 &#171; 1 = 11111111 11111111 11111111 11110110</li><li>y = -5 &#187; 31 = 11111111 11111111 11111111 11111111</li><li>z = x ^ y = 00000000 00000000 00000000 00001001，得到 9</li></ol><p>在 ProtoBuf 中，负数会先用 ZigZag，再用 Varint 进行编码，达到进一步压缩数据的效果。</p><h3 id=24-其他编码过程>2.4 其他编码过程<a hidden class=anchor aria-hidden=true href=#24-其他编码过程>#</a></h3><h4 id=变长类型>变长类型<a hidden class=anchor aria-hidden=true href=#变长类型>#</a></h4><p>对于 <code>WireType == 2</code> 的变长类型（string, bytes 等）来说，其序列化后的二进制数据流是以 [Tag Length Value] 的方式存储的，其中 Length 是变长部分的长度，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SingleNumber</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> Num <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> Str <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SingleNumber</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Num</span>: <span style=color:#ae81ff>582963</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Str</span>: <span style=color:#e6db74>&#34;helloworld&#34;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bytes</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sn</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>bytes</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ go run main.go msg.pb.go 
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#ae81ff>8</span> <span style=color:#ae81ff>179</span> <span style=color:#ae81ff>202</span> <span style=color:#ae81ff>35</span> <span style=color:#ae81ff>18</span> <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>104</span> <span style=color:#ae81ff>101</span> <span style=color:#ae81ff>108</span> <span style=color:#ae81ff>108</span> <span style=color:#ae81ff>111</span> <span style=color:#ae81ff>119</span> <span style=color:#ae81ff>111</span> <span style=color:#ae81ff>114</span> <span style=color:#ae81ff>108</span> 100<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>在输出的结果中，第五个字节 18 是 <code>string Str = 2</code> 的 Tag，其中 <code>field_num = 2, wire_type = 2</code>；第六个字节 10 代表这个变长类型的 Length，即从第七个字节到第十六个字节都是存储的 Value，每一个值均是用 ASCII 码存储的字符。</p><h4 id=固定长度类型>固定长度类型<a hidden class=anchor aria-hidden=true href=#固定长度类型>#</a></h4><p>对于 <code>WireType == 1</code> 或 <code>WireType == 5</code> 的固定长度类型（fixed32, fixed64 等）来说，其序列化后的二进制数据的长度固定为 4 或 8 个字节，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SingleNumber</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> Num <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> Str <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>fixed32</span> A <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>fixed64</span> B <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>float</span> C <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SingleNumber</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Num: 582963,</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Str: &#34;helloworld&#34;,</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>A</span>: <span style=color:#ae81ff>256</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>B</span>: <span style=color:#ae81ff>257</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bytes</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sn</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>bytes</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ go run main.go msg.pb.go 
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#ae81ff>29</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>33</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> 0<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>得到的结果中第 1 个字节是 <code>fixed32 A = 3</code> 的 tag，其中 <code>field_num = 3, wire_type = 5</code>，其后的 4 个字节按照字节序直接存储；第 5 个字节是 <code>fixed64 B = 4</code> 的 tag，其中 <code>field_num = 4, wire_type = 1</code>，其后的 8 个字节同样是按照字节序直接存储的。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/python/source-code-3-list-and-dict/><span class=title>« Prev</span><br><span>Python 源码学习（3）：list 类型</span>
</a><a class=next href=https://prov1dence.top/posts/python/source-code-2/><span class=title>Next »</span><br><span>Python 源码学习（2）：int 类型</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>