<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>LeetCode 深度优先搜索 | 尾張</title>
<meta name=keywords content>
<meta name=description content="LeetCode DFS 题目 78 子集 典型的回溯，找出所有可能情况。
class Solution { vector<vector<int>> res; public: vector<vector<int>> subsets(vector<int> &nums) { res = vector<vector<int>>(1, vector<int>()); vector<int> curr; DFS(nums, 0, curr); return res; } void DFS(vector<int> &nums, int idx, vector<int> &curr) { for (int i = idx; i < nums.size(); ++i) { curr.push_back(nums[i]); res.push_back(curr); DFS(nums, i + 1, curr); curr.pop_back(); } } }; 733 图像渲染 从给定的 image[sr][sc] 开始 DFS 或 BFS，将相邻的值相同的点的值全部修改为 newColor，注意要判断给定的 image[sr][sc] 是否等于 newColor，否则如果不使用额外空间的 visited 数组记录已经访问过的点的话会造成死循环栈溢出。">
<meta name=author content>
<link rel=canonical href=http://zintrulcre.github.io/posts/leetcode/dfs/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="LeetCode 深度优先搜索">
<meta property="og:description" content="LeetCode DFS 题目 78 子集 典型的回溯，找出所有可能情况。
class Solution { vector<vector<int>> res; public: vector<vector<int>> subsets(vector<int> &nums) { res = vector<vector<int>>(1, vector<int>()); vector<int> curr; DFS(nums, 0, curr); return res; } void DFS(vector<int> &nums, int idx, vector<int> &curr) { for (int i = idx; i < nums.size(); ++i) { curr.push_back(nums[i]); res.push_back(curr); DFS(nums, i + 1, curr); curr.pop_back(); } } }; 733 图像渲染 从给定的 image[sr][sc] 开始 DFS 或 BFS，将相邻的值相同的点的值全部修改为 newColor，注意要判断给定的 image[sr][sc] 是否等于 newColor，否则如果不使用额外空间的 visited 数组记录已经访问过的点的话会造成死循环栈溢出。">
<meta property="og:type" content="article">
<meta property="og:url" content="http://zintrulcre.github.io/posts/leetcode/dfs/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-07-27T12:12:25+10:00">
<meta property="article:modified_time" content="2019-07-27T12:12:25+10:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="LeetCode 深度优先搜索">
<meta name=twitter:description content="LeetCode DFS 题目 78 子集 典型的回溯，找出所有可能情况。
class Solution { vector<vector<int>> res; public: vector<vector<int>> subsets(vector<int> &nums) { res = vector<vector<int>>(1, vector<int>()); vector<int> curr; DFS(nums, 0, curr); return res; } void DFS(vector<int> &nums, int idx, vector<int> &curr) { for (int i = idx; i < nums.size(); ++i) { curr.push_back(nums[i]); res.push_back(curr); DFS(nums, i + 1, curr); curr.pop_back(); } } }; 733 图像渲染 从给定的 image[sr][sc] 开始 DFS 或 BFS，将相邻的值相同的点的值全部修改为 newColor，注意要判断给定的 image[sr][sc] 是否等于 newColor，否则如果不使用额外空间的 visited 数组记录已经访问过的点的话会造成死循环栈溢出。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://zintrulcre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode 深度优先搜索","item":"http://zintrulcre.github.io/posts/leetcode/dfs/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode 深度优先搜索","name":"LeetCode 深度优先搜索","description":"LeetCode DFS 题目 78 子集 典型的回溯，找出所有可能情况。\nclass Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt; \u0026amp;nums) { res = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(1, vector\u0026lt;int\u0026gt;()); vector\u0026lt;int\u0026gt; curr; DFS(nums, 0, curr); return res; } void DFS(vector\u0026lt;int\u0026gt; \u0026amp;nums, int idx, vector\u0026lt;int\u0026gt; \u0026amp;curr) { for (int i = idx; i \u0026lt; nums.size(); ++i) { curr.push_back(nums[i]); res.push_back(curr); DFS(nums, i + 1, curr); curr.pop_back(); } } }; 733 图像渲染 从给定的 image[sr][sc] 开始 DFS 或 BFS，将相邻的值相同的点的值全部修改为 newColor，注意要判断给定的 image[sr][sc] 是否等于 newColor，否则如果不使用额外空间的 visited 数组记录已经访问过的点的话会造成死循环栈溢出。","keywords":[],"articleBody":"LeetCode DFS 题目 78 子集 典型的回溯，找出所有可能情况。\nclass Solution { vectorvectorint res; public: vectorvectorint subsets(vectorint \u0026nums) { res = vectorvectorint(1, vectorint()); vectorint curr; DFS(nums, 0, curr); return res; } void DFS(vectorint \u0026nums, int idx, vectorint \u0026curr) { for (int i = idx; i  nums.size(); ++i) { curr.push_back(nums[i]); res.push_back(curr); DFS(nums, i + 1, curr); curr.pop_back(); } } }; 733 图像渲染 从给定的 image[sr][sc] 开始 DFS 或 BFS，将相邻的值相同的点的值全部修改为 newColor，注意要判断给定的 image[sr][sc] 是否等于 newColor，否则如果不使用额外空间的 visited 数组记录已经访问过的点的话会造成死循环栈溢出。\nclass Solution { int m, n; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; vectorvectorbool visited; public: vectorvectorint floodFill(vectorvectorint \u0026image, int sr, int sc, int newColor) { m = image.size(), n = m ? image[0].size() : 0; visited = vectorvectorbool(m, vectorbool(n, false)); if (image[sr][sc] != newColor) DFS(image, sr, sc, newColor); return image; } void DFS(vectorvectorint \u0026image, int r, int c, int val) { int ori = image[r][c]; image[r][c] = val; for (int d = 0; d  4; ++d) { int i = r + dir[d][0]; int j = c + dir[d][1]; if (i = 0 \u0026\u0026 i  m \u0026\u0026 j = 0 \u0026\u0026 j  n \u0026\u0026 image[i][j] == ori) DFS(image, i, j, val); } } }; 463 岛屿的周长 对小岛进行 DFS，根据一个点周围有几个相邻的点来计算当前点的周长。\nclass Solution { int x, y, res; vectorvectorbool visited; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int islandPerimeter(vectorvectorint \u0026grid) { x = grid.size(), y = x ? grid[0].size() : 0, res = 0; visited = vectorvectorbool(x, vectorbool(y, false)); if (x == 0) return 0; for (int i = 0; i  x; ++i) for (int j = 0; j  y; ++j) if (grid[i][j] == 1) { DFS(grid, i, j); return res; } return res; } void DFS(vectorvectorint \u0026grid, int i, int j) { visited[i][j] = true; int edge = 4; for (int l = 0; l  4; ++l) { int a = i + dir[l][0]; int b = j + dir[l][1]; if (a = 0 \u0026\u0026 a  x \u0026\u0026 b = 0 \u0026\u0026 b  y \u0026\u0026 grid[a][b] == 1) { --edge; if (!visited[a][b]) DFS(grid, a, b); } } res += edge; } }; 200 岛屿数量 每次进行 DFS 的全部节点即为一个岛屿，DFS 完整个数组即可。\nclass Solution { vectorvectorbool visited; int x, y, res; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int numIslands(vectorvectorchar \u0026grid) { x = grid.size(), y = x ? grid[0].size() : 0, res = 0; visited = vectorvectorbool(x, vectorbool(y, 0)); if (x == 0) return 0; for (int i = 0; i  x; ++i) for (int j = 0; j  y; ++j) if (grid[i][j] == '1' \u0026\u0026 !visited[i][j]) { ++res; DFS(grid, i, j); } return res; } void DFS(vectorvectorchar \u0026grid, int i, int j) { visited[i][j] = true; for (int d = 0; d  4; ++d) { int a = i + dir[d][0]; int b = j + dir[d][1]; if (a = 0 \u0026\u0026 a  x \u0026\u0026 b = 0 \u0026\u0026 b  y \u0026\u0026 grid[a][b] == '1' \u0026\u0026 !visited[a][b]) DFS(grid, a, b); } } }; 695 岛屿的最大面积 对每个岛屿进行 DFS，每次都更新最大面积即可。\nclass Solution { vectorvectorbool visited; int x, y, res; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int maxAreaOfIsland(vectorvectorint \u0026grid) { x = grid.size(), y = x ? grid[0].size() : 0, res = 0; visited = vectorvectorbool(x, vectorbool(y, 0)); if (x == 0) return 0; for (int i = 0; i  x; ++i) for (int j = 0; j  y; ++j) if (grid[i][j] == 1 \u0026\u0026 !visited[i][j]) { int area = 1; DFS(grid, i, j, area); } return res; } void DFS(vectorvectorint \u0026grid, int i, int j, int \u0026area) { visited[i][j] = true; res = max(res, area); for (int d = 0; d  4; ++d) { int a = i + dir[d][0]; int b = j + dir[d][1]; if (a = 0 \u0026\u0026 a  x \u0026\u0026 b = 0 \u0026\u0026 b  y \u0026\u0026 grid[a][b] == 1 \u0026\u0026 !visited[a][b]) { ++area; DFS(grid, a, b, area); } } } }; 841 钥匙和房间 对每个房间进行 DFS。\nclass Solution { vectorbool visited; int m, n; public: bool canVisitAllRooms(vectorvectorint \u0026rooms) { m = n = rooms.size(); visited = vectorbool(n, false); return DFS(rooms, 0); } bool DFS(vectorvectorint \u0026rooms, int room_num) { --m; visited[room_num] = true; if (m == 0) return true; for (auto \u0026r:rooms[room_num]) if (!visited[r] \u0026\u0026 DFS(rooms, r)) return true; return false; } }; 113 路径总和 II 对整个树进行 DFS，在叶子节点进行判断。\nclass Solution { vectorvectorint res; public: vectorvectorint pathSum(TreeNode *root, int sum) { res = vectorvectorint(); vectorint path; DFS(root, sum, path); return res; } void DFS(TreeNode *root, int sum, vectorint \u0026path) { if (!root) return; path.push_back(root-val); if (!root-left \u0026\u0026 !root-right) { if (sum - root-val == 0) res.push_back(path); } else { DFS(root-left, sum - root-val, path); DFS(root-right, sum - root-val, path); } path.pop_back(); } }; 130 被围绕的区域 对最外围的所有 ‘O’ 进行 DFS 并进行标记，最后在遍历一遍整个矩阵，将所有未被标记的 ‘O’ 改为 ‘X’。\nclass Solution { int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; int m, n; public: void solve(vectorvectorchar \u0026board) { m = board.size(), n = m ? board[0].size() : 0; for (int i = 0; i  m; ++i) { if (board[i][0] == 'O') DFS(board, i, 0); if (board[i][n - 1] == 'O') DFS(board, i, n - 1); } for (int j = 1; j  n - 1; ++j) { if (board[0][j] == 'O') DFS(board, 0, j); if (board[m - 1][j] == 'O') DFS(board, m - 1, j); } for (auto \u0026bo:board) for (auto \u0026b:bo) b = (b == 'O' ? 'X' : (b == 'M' ? 'O' : b)); } void DFS(vectorvectorchar \u0026board, int x, int y) { board[x][y] = 'M'; for (auto \u0026d:dir) { int i = x + d[0], j = y + d[1]; if (i = 0 \u0026\u0026 i  m \u0026\u0026 j = 0 \u0026\u0026 j  n \u0026\u0026 board[i][j] == 'O') DFS(board, i, j); } } }; 529 扫雷游戏 先计算出每个位置周围的 8 个位置的炸弹的数量，如果数量大于等于 1，那么标记出来并且结束搜索，如果数量为 0，那么继续向周围 8 个位置搜索。\nclass Solution { int m, n; public: vectorvectorchar updateBoard(vectorvectorchar \u0026board, vectorint \u0026click) { if (board[click[0]][click[1]] == 'M') { board[click[0]][click[1]] = 'X'; return board; } m = board.size(), n = m ? board[0].size() : 0; DFS(board, click[0], click[1]); return board; } void DFS(vectorvectorchar \u0026board, int x, int y) { int b = 0; for (int i = x - 1; i  x + 1; ++i) for (int j = y - 1; j  y + 1; ++j) if (i = 0 \u0026\u0026 i  m \u0026\u0026 j = 0 \u0026\u0026 j  n \u0026\u0026 board[i][j] == 'M') ++b; if (b != 0) { board[x][y] = static_castchar(b + '0'); return; } board[x][y] = 'B'; for (int i = x - 1; i  x + 1; ++i) for (int j = y - 1; j  y + 1; ++j) if (i = 0 \u0026\u0026 i  m \u0026\u0026 j = 0 \u0026\u0026 j  n \u0026\u0026 board[i][j] == 'E') DFS(board, i, j); } }; 473 火柴拼正方形 因为要求用所有的火柴来拼成正方形，所以先判断所有的火柴组成的是否是 4 的倍数以及是否有数字大于 sum / 4 ，然后将数组从大到小排序，这样可以用贪心的策略减少搜索的次数，否则需要进行回溯，最后对整个数组进行 DFS。\nclass Solution { int match, n, sum; vectorbool visited; public: bool makesquare(vectorint \u0026nums) { sort(nums.begin(), nums.end(), [](int \u0026a, int \u0026b) { return a  b; }); sum = accumulate(nums.begin(), nums.end(), 0), n = nums.size(), match = 4; visited = vectorbool(n, false); if (n == 0 || sum % 4 != 0) return false; for (auto \u0026m:nums) if (m  sum / 4) return false; for (int i = 0; i  n; ++i) { if (!visited[i] \u0026\u0026 DFS(nums, i, nums[i])) { visited[i] = true; --match; } } return match == 0; } bool DFS(vectorint \u0026nums, int m, int acc) { if (acc  sum / 4) return false; else if (acc == sum / 4) return true; for (int i = m + 1; i  n; ++i) if (!visited[i] \u0026\u0026 DFS(nums, i, acc + nums[i])) { visited[i] = true; return true; } return false; } }; 980 不同路径 III 用一个变量 zeros 把矩阵中 0 的数量记录下来，每次遍历到 0 即 zeros - 1，直到 zeros == 0 且当前点的四个方向上有终点，那么结果 +1 并返回，继续下一步的 DFS。\nclass Solution { int m, n, zeros, res; vectorvectorbool visited; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: int uniquePathsIII(vectorvectorint \u0026grid) { m = grid.size(), n = m ? grid[0].size() : 0, zeros = m * n - 2, res = 0; visited = vectorvectorbool(m, vectorbool(n, false)); int sr, sc, er, ec; for (int i = 0; i  m; ++i) for (int j = 0; j  n; ++j) if (grid[i][j] == 1) sr = i, sc = j; else if (grid[i][j] == -1) --zeros; DFS(grid, sr, sc, 0); return res; } void DFS(vectorvectorint \u0026grid, int r, int c, int count) { visited[r][c] = true; for (auto \u0026d:dir) { int i = r + d[0], j = c + d[1]; if (i = 0 \u0026\u0026 i  m \u0026\u0026 j = 0 \u0026\u0026 j  n) { if (grid[i][j] == 2 \u0026\u0026 count == zeros) { ++res; break; } if (grid[i][j] == 0 \u0026\u0026 !visited[i][j]) DFS(grid, i, j, count + 1); } } visited[r][c] = false; } }; 37 解数独 对每个 ‘.’ 格子进行从 ‘1’ 到 ‘9’ 的回溯，判断当前行，列，以及 3 * 3 的格子中是否有相同的值，直到到达矩阵的最后。\nclass Solution { int m, n; public: void solveSudoku(vectorvectorchar \u0026board) { m = board.size(), n = board[0].size(); DFS(board, 0, 0); } bool DFS(vectorvectorchar \u0026board, int i, int j) { if (j = n) return DFS(board, i + 1, 0); else if (i = m) return true; else if (board[i][j] != '.') return DFS(board, i, j + 1); for (char c = '1'; c  '9'; ++c) { if (CheckNum(board, i, j, c)) { board[i][j] = c; if (DFS(board, i, j + 1)) return true; board[i][j] = '.'; } } return false; } bool CheckNum(vectorvectorchar \u0026board, const int \u0026i, const int \u0026j, const char \u0026c) { for (int k = 0; k  9; ++k) if (board[k][j] == c || board[i][k] == c) return false; for (int a = 0; a  3; ++a) for (int b = 0; b  3; ++b) if (board[a + i / 3 * 3][b + j / 3 * 3] == c) return false; return true; } }; 79 单词搜索 在矩阵里进行一次 DFS 即可。\nclass Solution { int m, n; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; vectorvectorbool visited; public: bool exist(vectorvectorchar \u0026board, string word) { m = board.size(), n = m ? board[0].size() : 0; visited = vectorvectorbool(m, vectorbool(n, false)); for (int i = 0; i  m; ++i) for (int j = 0; j  n; ++j) if (board[i][j] == word[0] \u0026\u0026 DFS(board, i, j, word.substr(1))) return true; return false; } bool DFS(vectorvectorchar \u0026board, int i, int j, string word) { if (word == \"\") return true; visited[i][j] = true; for (auto \u0026d:dir) { int a = i + d[0], b = j + d[1]; if (a = 0 \u0026\u0026 a  m \u0026\u0026 b = 0 \u0026\u0026 b  n \u0026\u0026 board[a][b] == word[0] \u0026\u0026 !visited[a][b] \u0026\u0026 DFS(board, a, b, word.substr(1))) return true; } visited[i][j] = false; return false; } }; 212 单词搜索 II 最简单的方法是对每一个单词在矩阵里进行一次 DFS，这样的话时间复杂度是 O(m * n * k * l)，其中 m 是矩阵的长，n 是矩阵的宽，l是单词的数量，k 是所有单词的最长长度。我们可以为所有单词建立一个字典树，然后再在矩阵里进行一次 DFS，在矩阵的每个点处判断当前的字母是否在字典树的根节点的 next 数组中，如果是的话搜索其周围的字母以及继续遍历字典树，这样做的时间复杂度是 O(m * n * k)。\nclass Solution { struct TrieNode { vectorTrieNode * next; bool end; TrieNode() { next = vectorTrieNode *(26, nullptr); end = false; } }; TrieNode *root; int m, n; unordered_setstring res; vectorstring ret; vectorvectorbool visited; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; public: vectorstring findWords(vectorvectorchar \u0026board, vectorstring \u0026words) { res = unordered_setstring(); m = board.size(), n = board[0].size(); visited = vectorvectorbool(m, vectorbool(n, false)); BuildTrie(words); for (int i = 0; i  m; ++i) for (int j = 0; j  n; ++j) if (root-next[board[i][j] - 'a']) DFS(board, i, j, root-next[board[i][j] - 'a'], string(1, board[i][j])); ret = vectorstring(res.begin(), res.end()); return ret; } void BuildTrie(vectorstring \u0026words) { root = new TrieNode(); TrieNode *node; for (auto \u0026s:words) { node = root; for (auto c:s) { if (!node-next[c - 'a']) node-next[c - 'a'] = new TrieNode(); node = node-next[c - 'a']; } node-end = true; } } void DFS(vectorvectorchar \u0026board, int i, int j, TrieNode *node, string word) { if (!node) return; if (node-end) res.insert(word); visited[i][j] = true; for (auto \u0026d:dir) { int a = i + d[0], b = j + d[1]; if (a = 0 \u0026\u0026 a  m \u0026\u0026 b = 0 \u0026\u0026 b  n \u0026\u0026 node-next[board[a][b] - 'a'] \u0026\u0026 !visited[a][b]) DFS(board, a, b, node-next[board[a][b] - 'a'], word + board[a][b]); } visited[i][j] = false; } }; 749 隔离病毒 矩阵会持续地变化，每一轮 DFS 结束后需要进行两个操作，一是将已经隔离的病毒进行标记，二是将未隔离的病毒进行感染（延伸），可以先将所有的未隔离的病毒先保存下来再依次进行延伸，写起来比较复杂。\nclass Solution { int m, n; int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; vectorvectorbool visited; public: int containVirus(vectorvectorint \u0026grid) { m = grid.size(), n = m ? grid[0].size() : 0; int res = 0; bool exist = true; while (exist) { exist = false; int perimeter = 0, co_x = 0, co_y = 0; visited = vectorvectorbool(m, vectorbool(n, false)); for (int i = 0; i  m; ++i) { for (int j = 0; j  n; ++j) { if (grid[i][j] == 1 \u0026\u0026 !visited[i][j]) { exist = true; int peri = CalcPeri(grid, i, j); if (peri  perimeter) { perimeter = peri; co_x = i, co_y = j; } } } } res += perimeter; if (exist) { Contain(grid, co_x, co_y); Infect(grid); } } return res; } int CalcPeri(vectorvectorint \u0026grid, int i, int j) { int peri = 4, res = 0; visited[i][j] = true; for (auto \u0026d:dir) { int a = i + d[0], b = j + d[1]; if (a = 0 \u0026\u0026 a  m \u0026\u0026 b = 0 \u0026\u0026 b  n) { if (grid[a][b] != 0) --peri; if (grid[a][b] == 1 \u0026\u0026 !visited[a][b]) res += CalcPeri(grid, a, b); } else --peri; } return res + peri; } void Contain(vectorvectorint \u0026grid, int i, int j) { grid[i][j] = 2; for (auto \u0026d:dir) { int a = i + d[0], b = j + d[1]; if (a = 0 \u0026\u0026 a  m \u0026\u0026 b = 0 \u0026\u0026 b  n \u0026\u0026 grid[a][b] == 1) Contain(grid, a, b); } } void Infect(vectorvectorint \u0026grid) { vectorpairint, int infect; for (int i = 0; i  m; ++i) for (int j = 0; j  n; ++j) if (grid[i][j] == 1) infect.push_back(pairint, int(i, j)); for (auto \u0026f:infect) { for (auto \u0026d:dir) { int a = f.first + d[0], b = f.second + d[1]; if (a = 0 \u0026\u0026 a  m \u0026\u0026 b = 0 \u0026\u0026 b  n \u0026\u0026 grid[a][b] == 0) grid[a][b] = 1; } } } }; 51 N皇后 很经典的回溯问题，用 DFS 搜索每一种可能直到搜索完最后一行，用当前位置的横纵坐标的和和差分别判断两个对角线上是否有皇后即可。\nclass Solution { public: vectorvectorstring solveNQueens(int n) { vectorvectorstring res; string temp = \"\"; for (int i = 0; i  n; ++i) temp += \".\"; vectorstring board(n, temp); unordered_mapint, bool left_diagonal, right_diagonal; vectorbool row(n, false), col(n, false); for (int i = 0; i  n; ++i) { for (int j = 0; j  n; ++j) { left_diagonal[i + j] = false; right_diagonal[i - j] = false; } } Backtrack(0, n, board, res, col, left_diagonal, right_diagonal); return res; } void Backtrack(int i, int \u0026n, vectorstring \u0026board, vectorvectorstring \u0026res, vectorbool \u0026col, unordered_mapint, bool \u0026left_diagonal, unordered_mapint, bool \u0026right_diagonal) { if (i == n) { res.push_back(board); return; } for (int j = 0; j  n; ++j) { if (!col[j] \u0026\u0026 !left_diagonal[i + j] \u0026\u0026 !right_diagonal[i - j]) { col[j] = true; left_diagonal[i + j] = true; right_diagonal[i - j] = true; board[i][j] = 'Q'; Backtrack(i + 1, n, board, res, col, left_diagonal, right_diagonal); board[i][j] = '.'; col[j] = false; left_diagonal[i + j] = false; right_diagonal[i - j] = false; } } } }; ","wordCount":"2575","inLanguage":"en","datePublished":"2019-07-27T12:12:25+10:00","dateModified":"2019-07-27T12:12:25+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://zintrulcre.github.io/posts/leetcode/dfs/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://zintrulcre.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://zintrulcre.github.io/archives/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=http://zintrulcre.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://zintrulcre.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://zintrulcre.github.io/posts/>Posts</a></div>
<h1 class=post-title>
LeetCode 深度优先搜索
</h1>
<div class=post-meta><span title="2019-07-27 12:12:25 +1000 +1000">July 27, 2019</span>&nbsp;·&nbsp;13 min
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#leetcode-dfshttpsleetcode-cncomtagdepth-first-search aria-label="LeetCode DFS"><a href=https://leetcode-cn.com/tag/depth-first-search/>LeetCode DFS</a></a><ul>
<li>
<a href=#%e9%a2%98%e7%9b%ae aria-label=题目>题目</a><ul>
<ul>
<li>
<a href=#78-%e5%ad%90%e9%9b%86httpsleetcode-cncomproblemssubsets aria-label="78 子集"><a href=https://leetcode-cn.com/problems/subsets/>78 子集</a></a></li>
<li>
<a href=#733-%e5%9b%be%e5%83%8f%e6%b8%b2%e6%9f%93httpsleetcode-cncomproblemsflood-fill aria-label="733 图像渲染"><a href=https://leetcode-cn.com/problems/flood-fill/>733 图像渲染</a></a></li>
<li>
<a href=#463-%e5%b2%9b%e5%b1%bf%e7%9a%84%e5%91%a8%e9%95%bfhttpsleetcode-cncomproblemsisland-perimeter aria-label="463 岛屿的周长"><a href=https://leetcode-cn.com/problems/island-perimeter/>463 岛屿的周长</a></a></li>
<li>
<a href=#200-%e5%b2%9b%e5%b1%bf%e6%95%b0%e9%87%8fhttpsleetcode-cncomproblemsnumber-of-islands aria-label="200 岛屿数量"><a href=https://leetcode-cn.com/problems/number-of-islands/>200 岛屿数量</a></a></li>
<li>
<a href=#695-%e5%b2%9b%e5%b1%bf%e7%9a%84%e6%9c%80%e5%a4%a7%e9%9d%a2%e7%a7%afhttpsleetcode-cncomproblemsmax-area-of-island aria-label="695 岛屿的最大面积"><a href=https://leetcode-cn.com/problems/max-area-of-island/>695 岛屿的最大面积</a></a></li>
<li>
<a href=#841-%e9%92%a5%e5%8c%99%e5%92%8c%e6%88%bf%e9%97%b4httpsleetcode-cncomproblemskeys-and-rooms aria-label="841 钥匙和房间"><a href=https://leetcode-cn.com/problems/keys-and-rooms/>841 钥匙和房间</a></a></li>
<li>
<a href=#113-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c-iihttpsleetcode-cncomproblemspath-sum-ii aria-label="113 路径总和 II"><a href=https://leetcode-cn.com/problems/path-sum-ii/>113 路径总和 II</a></a></li>
<li>
<a href=#130-%e8%a2%ab%e5%9b%b4%e7%bb%95%e7%9a%84%e5%8c%ba%e5%9f%9fhttpsleetcode-cncomproblemssurrounded-regions aria-label="130 被围绕的区域"><a href=https://leetcode-cn.com/problems/surrounded-regions/>130 被围绕的区域</a></a></li>
<li>
<a href=#529-%e6%89%ab%e9%9b%b7%e6%b8%b8%e6%88%8fhttpsleetcode-cncomproblemsminesweepersubmissions aria-label="529 扫雷游戏"><a href=https://leetcode-cn.com/problems/minesweeper/submissions/>529 扫雷游戏</a></a></li>
<li>
<a href=#473-%e7%81%ab%e6%9f%b4%e6%8b%bc%e6%ad%a3%e6%96%b9%e5%bd%a2httpsleetcode-cncomproblemsmatchsticks-to-squaresubmissions aria-label="473 火柴拼正方形"><a href=https://leetcode-cn.com/problems/matchsticks-to-square/submissions/>473 火柴拼正方形</a></a></li>
<li>
<a href=#980-%e4%b8%8d%e5%90%8c%e8%b7%af%e5%be%84-iiihttpsleetcode-cncomproblemsunique-paths-iii aria-label="980 不同路径 III"><a href=https://leetcode-cn.com/problems/unique-paths-iii/>980 不同路径 III</a></a></li>
<li>
<a href=#37-%e8%a7%a3%e6%95%b0%e7%8b%achttpsleetcode-cncomproblemssudoku-solver aria-label="37 解数独"><a href=https://leetcode-cn.com/problems/sudoku-solver/>37 解数独</a></a></li>
<li>
<a href=#79-%e5%8d%95%e8%af%8d%e6%90%9c%e7%b4%a2httpsleetcode-cncomproblemsword-search aria-label="79 单词搜索"><a href=https://leetcode-cn.com/problems/word-search/>79 单词搜索</a></a></li>
<li>
<a href=#212-%e5%8d%95%e8%af%8d%e6%90%9c%e7%b4%a2-iihttpsleetcode-cncomproblemsword-search-ii aria-label="212 单词搜索 II"><a href=https://leetcode-cn.com/problems/word-search-ii/>212 单词搜索 II</a></a></li>
<li>
<a href=#749-%e9%9a%94%e7%a6%bb%e7%97%85%e6%af%92httpsleetcode-cncomproblemscontain-virus aria-label="749 隔离病毒"><a href=https://leetcode-cn.com/problems/contain-virus/>749 隔离病毒</a></a></li>
<li>
<a href=#51-n%e7%9a%87%e5%90%8ehttpsleetcode-cncomproblemsn-queens aria-label="51 N皇后"><a href=https://leetcode-cn.com/problems/n-queens/>51 N皇后</a></a>
</li>
</ul>
</li>
</ul>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=leetcode-dfshttpsleetcode-cncomtagdepth-first-search><a href=https://leetcode-cn.com/tag/depth-first-search/>LeetCode DFS</a><a hidden class=anchor aria-hidden=true href=#leetcode-dfshttpsleetcode-cncomtagdepth-first-search>#</a></h1>
<h2 id=题目>题目<a hidden class=anchor aria-hidden=true href=#题目>#</a></h2>
<h4 id=78-子集httpsleetcode-cncomproblemssubsets><a href=https://leetcode-cn.com/problems/subsets/>78 子集</a><a hidden class=anchor aria-hidden=true href=#78-子集httpsleetcode-cncomproblemssubsets>#</a></h4>
<p>典型的回溯，找出所有可能情况。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> subsets(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums) {
        res <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>(<span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> curr;
        DFS(nums, <span style=color:#ae81ff>0</span>, curr);
        <span style=color:#66d9ef>return</span> res;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums, <span style=color:#66d9ef>int</span> idx, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>curr) {
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> idx; i <span style=color:#f92672>&lt;</span> nums.size(); <span style=color:#f92672>++</span>i) {
            curr.push_back(nums[i]);
            res.push_back(curr);
            DFS(nums, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, curr);
            curr.pop_back();
        }
    }
};
</code></pre></div><h4 id=733-图像渲染httpsleetcode-cncomproblemsflood-fill><a href=https://leetcode-cn.com/problems/flood-fill/>733 图像渲染</a><a hidden class=anchor aria-hidden=true href=#733-图像渲染httpsleetcode-cncomproblemsflood-fill>#</a></h4>
<p>从给定的 image[sr][sc] 开始 DFS 或 BFS，将相邻的值相同的点的值全部修改为 newColor，注意要判断给定的 image[sr][sc] 是否等于 newColor，否则如果不使用额外空间的 visited 数组记录已经访问过的点的话会造成死循环栈溢出。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>int</span> m, n;
    <span style=color:#66d9ef>int</span> dir[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>}, {<span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>}, {<span style=color:#ae81ff>0</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>}, {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}};
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> visited;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> floodFill(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>image, <span style=color:#66d9ef>int</span> sr, <span style=color:#66d9ef>int</span> sc, <span style=color:#66d9ef>int</span> newColor) {
        m <span style=color:#f92672>=</span> image.size(), n <span style=color:#f92672>=</span> m <span style=color:#f92672>?</span> image[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
        visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span>(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(n, false));
        <span style=color:#66d9ef>if</span> (image[sr][sc] <span style=color:#f92672>!=</span> newColor)
            DFS(image, sr, sc, newColor);
        <span style=color:#66d9ef>return</span> image;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>image, <span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> val) {
        <span style=color:#66d9ef>int</span> ori <span style=color:#f92672>=</span> image[r][c];
        image[r][c] <span style=color:#f92672>=</span> val;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> d <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; d <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; <span style=color:#f92672>++</span>d) {
            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> dir[d][<span style=color:#ae81ff>0</span>];
            <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> c <span style=color:#f92672>+</span> dir[d][<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> image[i][j] <span style=color:#f92672>==</span> ori)
                DFS(image, i, j, val);
        }
    }
};
</code></pre></div><h4 id=463-岛屿的周长httpsleetcode-cncomproblemsisland-perimeter><a href=https://leetcode-cn.com/problems/island-perimeter/>463 岛屿的周长</a><a hidden class=anchor aria-hidden=true href=#463-岛屿的周长httpsleetcode-cncomproblemsisland-perimeter>#</a></h4>
<p>对小岛进行 DFS，根据一个点周围有几个相邻的点来计算当前点的周长。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>int</span> x, y, res;
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> visited;
    <span style=color:#66d9ef>int</span> dir[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>},
                     {<span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>},
                     {<span style=color:#ae81ff>0</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>},
                     {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}};
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> islandPerimeter(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid) {
        x <span style=color:#f92672>=</span> grid.size(), y <span style=color:#f92672>=</span> x <span style=color:#f92672>?</span> grid[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>, res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span>(x, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(y, false));
        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> x; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> y; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (grid[i][j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
                    DFS(grid, i, j);
                    <span style=color:#66d9ef>return</span> res;
                }
        <span style=color:#66d9ef>return</span> res;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
        visited[i][j] <span style=color:#f92672>=</span> true;
        <span style=color:#66d9ef>int</span> edge <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; l <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; <span style=color:#f92672>++</span>l) {
            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> dir[l][<span style=color:#ae81ff>0</span>];
            <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> dir[l][<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a <span style=color:#f92672>&lt;</span> x <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&lt;</span> y <span style=color:#f92672>&amp;&amp;</span> grid[a][b] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
                <span style=color:#f92672>--</span>edge;
                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>visited[a][b])
                    DFS(grid, a, b);
            }
        }
        res <span style=color:#f92672>+=</span> edge;
    }
};
</code></pre></div><h4 id=200-岛屿数量httpsleetcode-cncomproblemsnumber-of-islands><a href=https://leetcode-cn.com/problems/number-of-islands/>200 岛屿数量</a><a hidden class=anchor aria-hidden=true href=#200-岛屿数量httpsleetcode-cncomproblemsnumber-of-islands>#</a></h4>
<p>每次进行 DFS 的全部节点即为一个岛屿，DFS 完整个数组即可。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> visited;
    <span style=color:#66d9ef>int</span> x, y, res;
    <span style=color:#66d9ef>int</span> dir[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>}, {<span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>}, {<span style=color:#ae81ff>0</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>}, {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}};
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> numIslands(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid) {
        x <span style=color:#f92672>=</span> grid.size(), y <span style=color:#f92672>=</span> x <span style=color:#f92672>?</span> grid[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>, res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span>(x, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(y, <span style=color:#ae81ff>0</span>));
        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> x; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> y; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (grid[i][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;1&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[i][j]) {
                    <span style=color:#f92672>++</span>res;
                    DFS(grid, i, j);
                }
        <span style=color:#66d9ef>return</span> res;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
        visited[i][j] <span style=color:#f92672>=</span> true;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> d <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; d <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; <span style=color:#f92672>++</span>d) {
            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> dir[d][<span style=color:#ae81ff>0</span>];
            <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> dir[d][<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a <span style=color:#f92672>&lt;</span> x <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&lt;</span> y <span style=color:#f92672>&amp;&amp;</span> grid[a][b] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;1&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[a][b])
                DFS(grid, a, b);
        }
    }
};
</code></pre></div><h4 id=695-岛屿的最大面积httpsleetcode-cncomproblemsmax-area-of-island><a href=https://leetcode-cn.com/problems/max-area-of-island/>695 岛屿的最大面积</a><a hidden class=anchor aria-hidden=true href=#695-岛屿的最大面积httpsleetcode-cncomproblemsmax-area-of-island>#</a></h4>
<p>对每个岛屿进行 DFS，每次都更新最大面积即可。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> visited;
    <span style=color:#66d9ef>int</span> x, y, res;
    <span style=color:#66d9ef>int</span> dir[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>}, {<span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>}, {<span style=color:#ae81ff>0</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>}, {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}};
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> maxAreaOfIsland(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid) {
        x <span style=color:#f92672>=</span> grid.size(), y <span style=color:#f92672>=</span> x <span style=color:#f92672>?</span> grid[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>, res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span>(x, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(y, <span style=color:#ae81ff>0</span>));
        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> x; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> y; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (grid[i][j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[i][j]) {
                    <span style=color:#66d9ef>int</span> area <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
                    DFS(grid, i, j, area);
                }
        <span style=color:#66d9ef>return</span> res;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>area) {
        visited[i][j] <span style=color:#f92672>=</span> true;
        res <span style=color:#f92672>=</span> max(res, area);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> d <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; d <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; <span style=color:#f92672>++</span>d) {
            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> dir[d][<span style=color:#ae81ff>0</span>];
            <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> dir[d][<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a <span style=color:#f92672>&lt;</span> x <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&lt;</span> y <span style=color:#f92672>&amp;&amp;</span> grid[a][b] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[a][b]) {
                <span style=color:#f92672>++</span>area;
                DFS(grid, a, b, area);
            }
        }
    }
};
</code></pre></div><h4 id=841-钥匙和房间httpsleetcode-cncomproblemskeys-and-rooms><a href=https://leetcode-cn.com/problems/keys-and-rooms/>841 钥匙和房间</a><a hidden class=anchor aria-hidden=true href=#841-钥匙和房间httpsleetcode-cncomproblemskeys-and-rooms>#</a></h4>
<p>对每个房间进行 DFS。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> visited;
    <span style=color:#66d9ef>int</span> m, n;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>bool</span> canVisitAllRooms(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>rooms) {
        m <span style=color:#f92672>=</span> n <span style=color:#f92672>=</span> rooms.size();
        visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(n, false);
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>DFS</span>(rooms, <span style=color:#ae81ff>0</span>);
    }

    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>rooms, <span style=color:#66d9ef>int</span> room_num) {
        <span style=color:#f92672>--</span>m;
        visited[room_num] <span style=color:#f92672>=</span> true;
        <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> true;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>r:rooms[room_num])
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>visited[r] <span style=color:#f92672>&amp;&amp;</span> DFS(rooms, r))
                <span style=color:#66d9ef>return</span> true;
        <span style=color:#66d9ef>return</span> false;
    }
};
</code></pre></div><h4 id=113-路径总和-iihttpsleetcode-cncomproblemspath-sum-ii><a href=https://leetcode-cn.com/problems/path-sum-ii/>113 路径总和 II</a><a hidden class=anchor aria-hidden=true href=#113-路径总和-iihttpsleetcode-cncomproblemspath-sum-ii>#</a></h4>
<p>对整个树进行 DFS，在叶子节点进行判断。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> pathSum(TreeNode <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>int</span> sum) {
        res <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>();
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> path;
        DFS(root, sum, path);
        <span style=color:#66d9ef>return</span> res;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(TreeNode <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>int</span> sum, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>path) {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
            <span style=color:#66d9ef>return</span>;
        path.push_back(root<span style=color:#f92672>-&gt;</span>val);
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root<span style=color:#f92672>-&gt;</span>left <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>root<span style=color:#f92672>-&gt;</span>right) {
            <span style=color:#66d9ef>if</span> (sum <span style=color:#f92672>-</span> root<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
                res.push_back(path);
        } <span style=color:#66d9ef>else</span> {
            DFS(root<span style=color:#f92672>-&gt;</span>left, sum <span style=color:#f92672>-</span> root<span style=color:#f92672>-&gt;</span>val, path);
            DFS(root<span style=color:#f92672>-&gt;</span>right, sum <span style=color:#f92672>-</span> root<span style=color:#f92672>-&gt;</span>val, path);
        }
        path.pop_back();
    }
};
</code></pre></div><h4 id=130-被围绕的区域httpsleetcode-cncomproblemssurrounded-regions><a href=https://leetcode-cn.com/problems/surrounded-regions/>130 被围绕的区域</a><a hidden class=anchor aria-hidden=true href=#130-被围绕的区域httpsleetcode-cncomproblemssurrounded-regions>#</a></h4>
<p>对最外围的所有 &lsquo;O&rsquo; 进行 DFS 并进行标记，最后在遍历一遍整个矩阵，将所有未被标记的 &lsquo;O&rsquo; 改为 &lsquo;X&rsquo;。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>int</span> dir[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>}, {<span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>}, {<span style=color:#ae81ff>0</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>}, {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}};
    <span style=color:#66d9ef>int</span> m, n;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>void</span> solve(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board) {
        m <span style=color:#f92672>=</span> board.size(), n <span style=color:#f92672>=</span> m <span style=color:#f92672>?</span> board[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i) {
            <span style=color:#66d9ef>if</span> (board[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
                DFS(board, i, <span style=color:#ae81ff>0</span>);
            <span style=color:#66d9ef>if</span> (board[i][n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
                DFS(board, i, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
        }
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#f92672>++</span>j) {
            <span style=color:#66d9ef>if</span> (board[<span style=color:#ae81ff>0</span>][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
                DFS(board, <span style=color:#ae81ff>0</span>, j);
            <span style=color:#66d9ef>if</span> (board[m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
                DFS(board, m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, j);
        }
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>bo:board)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>b:bo)
                b <span style=color:#f92672>=</span> (b <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;X&#39;</span> <span style=color:#f92672>:</span> (b <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;M&#39;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;O&#39;</span> <span style=color:#f92672>:</span> b));
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
        board[x][y] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;M&#39;</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>d:dir) {
            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>0</span>], j <span style=color:#f92672>=</span> y <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> board[i][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
                DFS(board, i, j);
        }
    }
};
</code></pre></div><h4 id=529-扫雷游戏httpsleetcode-cncomproblemsminesweepersubmissions><a href=https://leetcode-cn.com/problems/minesweeper/submissions/>529 扫雷游戏</a><a hidden class=anchor aria-hidden=true href=#529-扫雷游戏httpsleetcode-cncomproblemsminesweepersubmissions>#</a></h4>
<p>先计算出每个位置周围的 8 个位置的炸弹的数量，如果数量大于等于 1，那么标记出来并且结束搜索，如果数量为 0，那么继续向周围 8 个位置搜索。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>int</span> m, n;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> updateBoard(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>click) {
        <span style=color:#66d9ef>if</span> (board[click[<span style=color:#ae81ff>0</span>]][click[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;M&#39;</span>) {
            board[click[<span style=color:#ae81ff>0</span>]][click[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;X&#39;</span>;
            <span style=color:#66d9ef>return</span> board;
        }
        m <span style=color:#f92672>=</span> board.size(), n <span style=color:#f92672>=</span> m <span style=color:#f92672>?</span> board[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
        DFS(board, click[<span style=color:#ae81ff>0</span>], click[<span style=color:#ae81ff>1</span>]);
        <span style=color:#66d9ef>return</span> board;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
        <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> board[i][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;M&#39;</span>)
                    <span style=color:#f92672>++</span>b;
        <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
            board[x][y] <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(b <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;0&#39;</span>);
            <span style=color:#66d9ef>return</span>;
        }
        board[x][y] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;B&#39;</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> board[i][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;E&#39;</span>)
                    DFS(board, i, j);
    }
};
</code></pre></div><h4 id=473-火柴拼正方形httpsleetcode-cncomproblemsmatchsticks-to-squaresubmissions><a href=https://leetcode-cn.com/problems/matchsticks-to-square/submissions/>473 火柴拼正方形</a><a hidden class=anchor aria-hidden=true href=#473-火柴拼正方形httpsleetcode-cncomproblemsmatchsticks-to-squaresubmissions>#</a></h4>
<p>因为要求用所有的火柴来拼成正方形，所以先判断所有的火柴组成的是否是 4 的倍数以及是否有数字大于 sum / 4 ，然后将数组从大到小排序，这样可以用贪心的策略减少搜索的次数，否则需要进行回溯，最后对整个数组进行 DFS。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>int</span> match, n, sum;
    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> visited;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>bool</span> makesquare(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums) {
        sort(nums.begin(), nums.end(), [](<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>a, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>b) { <span style=color:#66d9ef>return</span> a <span style=color:#f92672>&gt;</span> b; });
        sum <span style=color:#f92672>=</span> accumulate(nums.begin(), nums.end(), <span style=color:#ae81ff>0</span>), n <span style=color:#f92672>=</span> nums.size(), match <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
        visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(n, false);
        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> sum <span style=color:#f92672>%</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> false;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>m:nums)
            <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>&gt;</span> sum <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>)
                <span style=color:#66d9ef>return</span> false;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>visited[i] <span style=color:#f92672>&amp;&amp;</span> DFS(nums, i, nums[i])) {
                visited[i] <span style=color:#f92672>=</span> true;
                <span style=color:#f92672>--</span>match;
            }
        }
        <span style=color:#66d9ef>return</span> match <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>;
    }

    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> acc) {
        <span style=color:#66d9ef>if</span> (acc <span style=color:#f92672>&gt;</span> sum <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>)
            <span style=color:#66d9ef>return</span> false;
        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (acc <span style=color:#f92672>==</span> sum <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>)
            <span style=color:#66d9ef>return</span> true;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>visited[i] <span style=color:#f92672>&amp;&amp;</span> DFS(nums, i, acc <span style=color:#f92672>+</span> nums[i])) {
                visited[i] <span style=color:#f92672>=</span> true;
                <span style=color:#66d9ef>return</span> true;
            }
        <span style=color:#66d9ef>return</span> false;
    }
};
</code></pre></div><h4 id=980-不同路径-iiihttpsleetcode-cncomproblemsunique-paths-iii><a href=https://leetcode-cn.com/problems/unique-paths-iii/>980 不同路径 III</a><a hidden class=anchor aria-hidden=true href=#980-不同路径-iiihttpsleetcode-cncomproblemsunique-paths-iii>#</a></h4>
<p>用一个变量 zeros 把矩阵中 0 的数量记录下来，每次遍历到 0 即 zeros - 1，直到 zeros == 0 且当前点的四个方向上有终点，那么结果 +1 并返回，继续下一步的 DFS。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>int</span> m, n, zeros, res;
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> visited;
    <span style=color:#66d9ef>int</span> dir[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>},
                     {<span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>},
                     {<span style=color:#ae81ff>0</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>},
                     {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}};
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> uniquePathsIII(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid) {
        m <span style=color:#f92672>=</span> grid.size(), n <span style=color:#f92672>=</span> m <span style=color:#f92672>?</span> grid[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>, zeros <span style=color:#f92672>=</span> m <span style=color:#f92672>*</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>, res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span>(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(n, false));
        <span style=color:#66d9ef>int</span> sr, sc, er, ec;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (grid[i][j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
                    sr <span style=color:#f92672>=</span> i, sc <span style=color:#f92672>=</span> j;
                <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (grid[i][j] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
                    <span style=color:#f92672>--</span>zeros;
        DFS(grid, sr, sc, <span style=color:#ae81ff>0</span>);
        <span style=color:#66d9ef>return</span> res;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid, <span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> count) {
        visited[r][c] <span style=color:#f92672>=</span> true;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>d:dir) {
            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>0</span>], j <span style=color:#f92672>=</span> c <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> n) {
                <span style=color:#66d9ef>if</span> (grid[i][j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> count <span style=color:#f92672>==</span> zeros) {
                    <span style=color:#f92672>++</span>res;
                    <span style=color:#66d9ef>break</span>;
                }
                <span style=color:#66d9ef>if</span> (grid[i][j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[i][j])
                    DFS(grid, i, j, count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
            }
        }
        visited[r][c] <span style=color:#f92672>=</span> false;
    }
};
</code></pre></div><h4 id=37-解数独httpsleetcode-cncomproblemssudoku-solver><a href=https://leetcode-cn.com/problems/sudoku-solver/>37 解数独</a><a hidden class=anchor aria-hidden=true href=#37-解数独httpsleetcode-cncomproblemssudoku-solver>#</a></h4>
<p>对每个 &lsquo;.&rsquo; 格子进行从 &lsquo;1&rsquo; 到 &lsquo;9&rsquo; 的回溯，判断当前行，列，以及 3 * 3 的格子中是否有相同的值，直到到达矩阵的最后。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>int</span> m, n;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>void</span> solveSudoku(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board) {
        m <span style=color:#f92672>=</span> board.size(), n <span style=color:#f92672>=</span> board[<span style=color:#ae81ff>0</span>].size();
        DFS(board, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
    }

    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
        <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&gt;=</span> n)
            <span style=color:#66d9ef>return</span> DFS(board, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> m)
            <span style=color:#66d9ef>return</span> true;
        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (board[i][j] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;.&#39;</span>)
            <span style=color:#66d9ef>return</span> DFS(board, i, j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;1&#39;</span>; c <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;9&#39;</span>; <span style=color:#f92672>++</span>c) {
            <span style=color:#66d9ef>if</span> (CheckNum(board, i, j, c)) {
                board[i][j] <span style=color:#f92672>=</span> c;
                <span style=color:#66d9ef>if</span> (DFS(board, i, j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
                    <span style=color:#66d9ef>return</span> true;
                board[i][j] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;.&#39;</span>;
            }
        }
        <span style=color:#66d9ef>return</span> false;
    }

    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>CheckNum</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>i, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>j, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>&amp;</span>c) {
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>9</span>; <span style=color:#f92672>++</span>k)
            <span style=color:#66d9ef>if</span> (board[k][j] <span style=color:#f92672>==</span> c <span style=color:#f92672>||</span> board[i][k] <span style=color:#f92672>==</span> c)
                <span style=color:#66d9ef>return</span> false;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>; <span style=color:#f92672>++</span>a)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; b <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>; <span style=color:#f92672>++</span>b)
                <span style=color:#66d9ef>if</span> (board[a <span style=color:#f92672>+</span> i <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>][b <span style=color:#f92672>+</span> j <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>] <span style=color:#f92672>==</span> c)
                    <span style=color:#66d9ef>return</span> false;
        <span style=color:#66d9ef>return</span> true;
    }
};
</code></pre></div><h4 id=79-单词搜索httpsleetcode-cncomproblemsword-search><a href=https://leetcode-cn.com/problems/word-search/>79 单词搜索</a><a hidden class=anchor aria-hidden=true href=#79-单词搜索httpsleetcode-cncomproblemsword-search>#</a></h4>
<p>在矩阵里进行一次 DFS 即可。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>int</span> m, n;
    <span style=color:#66d9ef>int</span> dir[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>}, {<span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>}, {<span style=color:#ae81ff>0</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>}, {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}};
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> visited;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>bool</span> exist(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board, string word) {
        m <span style=color:#f92672>=</span> board.size(), n <span style=color:#f92672>=</span> m <span style=color:#f92672>?</span> board[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
        visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span>(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(n, false));
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (board[i][j] <span style=color:#f92672>==</span> word[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;&amp;</span> DFS(board, i, j, word.substr(<span style=color:#ae81ff>1</span>)))
                    <span style=color:#66d9ef>return</span> true;
        <span style=color:#66d9ef>return</span> false;
    }

    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j, string word) {
        <span style=color:#66d9ef>if</span> (word <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>)
            <span style=color:#66d9ef>return</span> true;
        visited[i][j] <span style=color:#f92672>=</span> true;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>d:dir) {
            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>0</span>], b <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> board[a][b] <span style=color:#f92672>==</span> word[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[a][b] <span style=color:#f92672>&amp;&amp;</span>
                DFS(board, a, b, word.substr(<span style=color:#ae81ff>1</span>)))
                <span style=color:#66d9ef>return</span> true;
        }
        visited[i][j] <span style=color:#f92672>=</span> false;
        <span style=color:#66d9ef>return</span> false;
    }
};
</code></pre></div><h4 id=212-单词搜索-iihttpsleetcode-cncomproblemsword-search-ii><a href=https://leetcode-cn.com/problems/word-search-ii/>212 单词搜索 II</a><a hidden class=anchor aria-hidden=true href=#212-单词搜索-iihttpsleetcode-cncomproblemsword-search-ii>#</a></h4>
<p>最简单的方法是对每一个单词在矩阵里进行一次 DFS，这样的话时间复杂度是 O(m * n * k * l)，其中 m 是矩阵的长，n 是矩阵的宽，l是单词的数量，k 是所有单词的最长长度。我们可以为所有单词建立一个字典树，然后再在矩阵里进行一次 DFS，在矩阵的每个点处判断当前的字母是否在字典树的根节点的 next 数组中，如果是的话搜索其周围的字母以及继续遍历字典树，这样做的时间复杂度是 O(m * n * k)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TrieNode</span> {
        vector<span style=color:#f92672>&lt;</span>TrieNode <span style=color:#f92672>*&gt;</span> next;
        <span style=color:#66d9ef>bool</span> end;

        TrieNode() {
            next <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>TrieNode <span style=color:#f92672>*&gt;</span>(<span style=color:#ae81ff>26</span>, <span style=color:#66d9ef>nullptr</span>);
            end <span style=color:#f92672>=</span> false;
        }
    };

    TrieNode <span style=color:#f92672>*</span>root;
    <span style=color:#66d9ef>int</span> m, n;
    unordered_set<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> res;
    vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> ret;
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> visited;
    <span style=color:#66d9ef>int</span> dir[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>}, {<span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>}, {<span style=color:#ae81ff>0</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>}, {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}};
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> findWords(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board, vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>words) {
        res <span style=color:#f92672>=</span> unordered_set<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>();
        m <span style=color:#f92672>=</span> board.size(), n <span style=color:#f92672>=</span> board[<span style=color:#ae81ff>0</span>].size();
        visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span>(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(n, false));
        BuildTrie(words);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (root<span style=color:#f92672>-&gt;</span>next[board[i][j] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>])
                    DFS(board, i, j, root<span style=color:#f92672>-&gt;</span>next[board[i][j] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>], string(<span style=color:#ae81ff>1</span>, board[i][j]));
        ret <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>(res.begin(), res.end());
        <span style=color:#66d9ef>return</span> ret;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>BuildTrie</span>(vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>words) {
        root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TrieNode();
        TrieNode <span style=color:#f92672>*</span>node;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>s:words) {
            node <span style=color:#f92672>=</span> root;
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> c:s) {
                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>node<span style=color:#f92672>-&gt;</span>next[c <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>])
                    node<span style=color:#f92672>-&gt;</span>next[c <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TrieNode();
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next[c <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>];
            }
            node<span style=color:#f92672>-&gt;</span>end <span style=color:#f92672>=</span> true;
        }
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j, TrieNode <span style=color:#f92672>*</span>node, string word) {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>node)
            <span style=color:#66d9ef>return</span>;
        <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>end)
            res.insert(word);
        visited[i][j] <span style=color:#f92672>=</span> true;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>d:dir) {
            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>0</span>], b <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> node<span style=color:#f92672>-&gt;</span>next[board[a][b] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[a][b])
                DFS(board, a, b, node<span style=color:#f92672>-&gt;</span>next[board[a][b] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>], word <span style=color:#f92672>+</span> board[a][b]);
        }
        visited[i][j] <span style=color:#f92672>=</span> false;
    }
};
</code></pre></div><h4 id=749-隔离病毒httpsleetcode-cncomproblemscontain-virus><a href=https://leetcode-cn.com/problems/contain-virus/>749 隔离病毒</a><a hidden class=anchor aria-hidden=true href=#749-隔离病毒httpsleetcode-cncomproblemscontain-virus>#</a></h4>
<p>矩阵会持续地变化，每一轮 DFS 结束后需要进行两个操作，一是将已经隔离的病毒进行标记，二是将未隔离的病毒进行感染（延伸），可以先将所有的未隔离的病毒先保存下来再依次进行延伸，写起来比较复杂。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    <span style=color:#66d9ef>int</span> m, n;
    <span style=color:#66d9ef>int</span> dir[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>},
                     {<span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>},
                     {<span style=color:#ae81ff>0</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>},
                     {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}};
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> visited;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> containVirus(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid) {
        m <span style=color:#f92672>=</span> grid.size(), n <span style=color:#f92672>=</span> m <span style=color:#f92672>?</span> grid[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>bool</span> exist <span style=color:#f92672>=</span> true;
        <span style=color:#66d9ef>while</span> (exist) {
            exist <span style=color:#f92672>=</span> false;
            <span style=color:#66d9ef>int</span> perimeter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, co_x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, co_y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
            visited <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span>(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(n, false));
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i) {
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j) {
                    <span style=color:#66d9ef>if</span> (grid[i][j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[i][j]) {
                        exist <span style=color:#f92672>=</span> true;
                        <span style=color:#66d9ef>int</span> peri <span style=color:#f92672>=</span> CalcPeri(grid, i, j);
                        <span style=color:#66d9ef>if</span> (peri <span style=color:#f92672>&gt;</span> perimeter) {
                            perimeter <span style=color:#f92672>=</span> peri;
                            co_x <span style=color:#f92672>=</span> i, co_y <span style=color:#f92672>=</span> j;
                        }
                    }
                }
            }
            res <span style=color:#f92672>+=</span> perimeter;
            <span style=color:#66d9ef>if</span> (exist) {
                Contain(grid, co_x, co_y);
                Infect(grid);
            }
        }
        <span style=color:#66d9ef>return</span> res;
    }

    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>CalcPeri</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
        <span style=color:#66d9ef>int</span> peri <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>, res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        visited[i][j] <span style=color:#f92672>=</span> true;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>d:dir) {
            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>0</span>], b <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&lt;</span> n) {
                <span style=color:#66d9ef>if</span> (grid[a][b] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
                    <span style=color:#f92672>--</span>peri;
                <span style=color:#66d9ef>if</span> (grid[a][b] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>visited[a][b])
                    res <span style=color:#f92672>+=</span> CalcPeri(grid, a, b);
            } <span style=color:#66d9ef>else</span>
                <span style=color:#f92672>--</span>peri;
        }
        <span style=color:#66d9ef>return</span> res <span style=color:#f92672>+</span> peri;
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Contain</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
        grid[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>d:dir) {
            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>0</span>], b <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>1</span>];
            <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> grid[a][b] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
                Contain(grid, a, b);
        }
    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Infect</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>grid) {
        vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> infect;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (grid[i][j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
                    infect.push_back(pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(i, j));
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>f:infect) {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>d:dir) {
                <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> f.first <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>0</span>], b <span style=color:#f92672>=</span> f.second <span style=color:#f92672>+</span> d[<span style=color:#ae81ff>1</span>];
                <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> grid[a][b] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
                    grid[a][b] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
            }
        }
    }
};
</code></pre></div><h4 id=51-n皇后httpsleetcode-cncomproblemsn-queens><a href=https://leetcode-cn.com/problems/n-queens/>51 N皇后</a><a hidden class=anchor aria-hidden=true href=#51-n皇后httpsleetcode-cncomproblemsn-queens>#</a></h4>
<p>很经典的回溯问题，用 DFS 搜索每一种可能直到搜索完最后一行，用当前位置的横纵坐标的和和差分别判断两个对角线上是否有皇后即可。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> solveNQueens(<span style=color:#66d9ef>int</span> n) {
        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> res;
        string temp <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i)
            temp <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;.&#34;</span>;
        vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> board(n, temp);
        unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> left_diagonal, right_diagonal;
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> row(n, false), col(n, false);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j) {
                left_diagonal[i <span style=color:#f92672>+</span> j] <span style=color:#f92672>=</span> false;
                right_diagonal[i <span style=color:#f92672>-</span> j] <span style=color:#f92672>=</span> false;
            }
        }
        Backtrack(<span style=color:#ae81ff>0</span>, n, board, res, col, left_diagonal, right_diagonal);
        <span style=color:#66d9ef>return</span> res;

    }

    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Backtrack</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>n, vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>board, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>res,
                   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>col, unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>left_diagonal,
                   unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>right_diagonal) {
        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> n) {
            res.push_back(board);
            <span style=color:#66d9ef>return</span>;
        }
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j) {
            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>col[j] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>left_diagonal[i <span style=color:#f92672>+</span> j] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>right_diagonal[i <span style=color:#f92672>-</span> j]) {
                col[j] <span style=color:#f92672>=</span> true;
                left_diagonal[i <span style=color:#f92672>+</span> j] <span style=color:#f92672>=</span> true;
                right_diagonal[i <span style=color:#f92672>-</span> j] <span style=color:#f92672>=</span> true;
                board[i][j] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Q&#39;</span>;
                Backtrack(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, n, board, res, col, left_diagonal, right_diagonal);
                board[i][j] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;.&#39;</span>;
                col[j] <span style=color:#f92672>=</span> false;
                left_diagonal[i <span style=color:#f92672>+</span> j] <span style=color:#f92672>=</span> false;
                right_diagonal[i <span style=color:#f92672>-</span> j] <span style=color:#f92672>=</span> false;
            }
        }
    }
};
</code></pre></div>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=http://zintrulcre.github.io/posts/leetcode/twopointers/>
<span class=title>« Prev Page</span>
<br>
<span>LeetCode 双指针</span>
</a>
<a class=next href=http://zintrulcre.github.io/posts/leetcode/concurrency/>
<span class=title>Next Page »</span>
<br>
<span>LeetCode 并发</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>
Zhengyu &copy; 2022
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>