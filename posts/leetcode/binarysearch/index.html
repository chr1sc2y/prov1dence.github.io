<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LeetCode 二分查找 | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content="LeetCode 二分查找
二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。
易错点


计算中间值的方法

k = i + (j - i) / 2
k = (i + j) / 2

第二种方法一般都会造成整型数据溢出，所以只用第一种方法。


循环条件


如果要找唯一的值，且下限i和上限j都会在更新时在中间值k的基础上+1或-1，那么循环条件是 i <= j，j能被取到，j = nums.size() - 1，计算中间值用 k = i + (j - i + 1) / 2


如果要找大于等于或小于等于某条件的值，且下限i和上限j其中之一不会在k的基础上+1或-1，那么循环条件是 i < j，j不能被取到，j = nums.size()，计算中间值用 k = i + (j - i) / 2


两种方法有各自的应用场景，没用对的话会出现边界值的问题，或是死循环导致TLE。


题目
1. 查找数
704 二分查找
在有序数组中搜索目标值，如果存在则返回下标，否则返回 -1。
最标准的二分查找。因为下限i和上限j都会在更新时+1和-1，所以让j = nums.size() - 1，循环条件是 i <= j。"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/leetcode/binarysearch/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/leetcode/binarysearch/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/leetcode/binarysearch/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="LeetCode 二分查找"><meta property="og:description" content="LeetCode 二分查找 二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。
易错点 计算中间值的方法
k = i + (j - i) / 2 k = (i + j) / 2 第二种方法一般都会造成整型数据溢出，所以只用第一种方法。
循环条件
如果要找唯一的值，且下限i和上限j都会在更新时在中间值k的基础上+1或-1，那么循环条件是 i <= j，j能被取到，j = nums.size() - 1，计算中间值用 k = i + (j - i + 1) / 2
如果要找大于等于或小于等于某条件的值，且下限i和上限j其中之一不会在k的基础上+1或-1，那么循环条件是 i < j，j不能被取到，j = nums.size()，计算中间值用 k = i + (j - i) / 2
两种方法有各自的应用场景，没用对的话会出现边界值的问题，或是死循环导致TLE。
题目 1. 查找数 704 二分查找 在有序数组中搜索目标值，如果存在则返回下标，否则返回 -1。
最标准的二分查找。因为下限i和上限j都会在更新时+1和-1，所以让j = nums.size() - 1，循环条件是 i <= j。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-23T19:26:39+10:00"><meta property="article:modified_time" content="2019-06-23T19:26:39+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode 二分查找"><meta name=twitter:description content="LeetCode 二分查找
二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。
易错点


计算中间值的方法

k = i + (j - i) / 2
k = (i + j) / 2

第二种方法一般都会造成整型数据溢出，所以只用第一种方法。


循环条件


如果要找唯一的值，且下限i和上限j都会在更新时在中间值k的基础上+1或-1，那么循环条件是 i <= j，j能被取到，j = nums.size() - 1，计算中间值用 k = i + (j - i + 1) / 2


如果要找大于等于或小于等于某条件的值，且下限i和上限j其中之一不会在k的基础上+1或-1，那么循环条件是 i < j，j不能被取到，j = nums.size()，计算中间值用 k = i + (j - i) / 2


两种方法有各自的应用场景，没用对的话会出现边界值的问题，或是死循环导致TLE。


题目
1. 查找数
704 二分查找
在有序数组中搜索目标值，如果存在则返回下标，否则返回 -1。
最标准的二分查找。因为下限i和上限j都会在更新时+1和-1，所以让j = nums.size() - 1，循环条件是 i <= j。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode 二分查找","item":"https://prov1dence.top/posts/leetcode/binarysearch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode 二分查找","name":"LeetCode 二分查找","description":"LeetCode 二分查找 二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。\n易错点 计算中间值的方法\nk = i + (j - i) / 2 k = (i + j) / 2 第二种方法一般都会造成整型数据溢出，所以只用第一种方法。\n循环条件\n如果要找唯一的值，且下限i和上限j都会在更新时在中间值k的基础上+1或-1，那么循环条件是 i \u0026lt;= j，j能被取到，j = nums.size() - 1，计算中间值用 k = i + (j - i + 1) / 2\n如果要找大于等于或小于等于某条件的值，且下限i和上限j其中之一不会在k的基础上+1或-1，那么循环条件是 i \u0026lt; j，j不能被取到，j = nums.size()，计算中间值用 k = i + (j - i) / 2\n两种方法有各自的应用场景，没用对的话会出现边界值的问题，或是死循环导致TLE。\n题目 1. 查找数 704 二分查找 在有序数组中搜索目标值，如果存在则返回下标，否则返回 -1。\n最标准的二分查找。因为下限i和上限j都会在更新时+1和-1，所以让j = nums.size() - 1，循环条件是 i \u0026lt;= j。\n","keywords":[],"articleBody":"LeetCode 二分查找 二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。\n易错点 计算中间值的方法\nk = i + (j - i) / 2 k = (i + j) / 2 第二种方法一般都会造成整型数据溢出，所以只用第一种方法。\n循环条件\n如果要找唯一的值，且下限i和上限j都会在更新时在中间值k的基础上+1或-1，那么循环条件是 i \u003c= j，j能被取到，j = nums.size() - 1，计算中间值用 k = i + (j - i + 1) / 2\n如果要找大于等于或小于等于某条件的值，且下限i和上限j其中之一不会在k的基础上+1或-1，那么循环条件是 i \u003c j，j不能被取到，j = nums.size()，计算中间值用 k = i + (j - i) / 2\n两种方法有各自的应用场景，没用对的话会出现边界值的问题，或是死循环导致TLE。\n题目 1. 查找数 704 二分查找 在有序数组中搜索目标值，如果存在则返回下标，否则返回 -1。\n最标准的二分查找。因为下限i和上限j都会在更新时+1和-1，所以让j = nums.size() - 1，循环条件是 i \u003c= j。\nclass Solution { public: int search(vector\u003cint\u003e \u0026nums, int target) { int i = 0, j = nums.size() - 1, k = 0; while (i \u003c= j) { k = i + (j - i + 1) / 2; if (nums[k] \u003e target) j = k - 1; else if (nums[k] \u003c target) i = k + 1; else return k; } return -1; } }; 374 猜数字大小 从 1 到 n 选择一个数字，通过一个预定义的接口 guess(int num)得到-1：数字打了；1：数字小了；0：猜对了。\n跟上一题几乎一模一样，只是把target换成了一个接口。\nint guess(int num); class Solution { public: int guessNumber(int n) { int i = 1, j = n, k = 0; while (i \u003c= j) { k = i + (j - i + 1) / 2; auto res = guess(k); if (res == 1) i = k + 1; else if (res == -1) j = k - 1; else return k; } return 0; } }; 367 有效的完全平方数 判断一个正整数是否是一个完全平方数。\n判断一个数是否是完全平方数。因为在二分的过程中平方得到的结果可能会超过32位int型的上限，所以用long long。\nclass Solution { public: bool isPerfectSquare(int num) { long long i = 0, j = num, k = 0, res = 0; while (i \u003c= j) { k = i + (j - i + 1) / 2; res = k * k; if (res \u003c num) i = k + 1; else if (res \u003e num) j = k - 1; else return true; } return j * j == num; } }; 69 x的平方根 计算一个数的平方根，只保留整数部分。\n实现int sqrt(int x)函数。用商来判断比用乘积来判断更直观。\nclass Solution { public: int mySqrt(int x) { if (x \u003c= 1) return x; int i = 1, j = x, k = 0, sqrt = 0; while (i \u003c= j) { k = i + (j - i + 1) / 2; sqrt = x / k; if (sqrt \u003c k) j = k - 1; else if (sqrt \u003e k) i = k + 1; else return k; } return j; } }; 2. 查找上界/下界 35 搜索插入位置 在有序数组中找到目标值，如果不存在则返回它将会被按顺序插入的位置，数组中无重复元素。\n找到大于等于target的第一个数。因为上限j在更新时会直接被赋给k的值，所以让j = nums.size()，循环条件是i \u003c j。\nclass Solution { public: int searchInsert(vector\u003cint\u003e\u0026 nums, int target) { int i = 0, j = nums.size(), k = 0; while (i \u003c j) { k = i + (j - i) / 2; if (nums[k] \u003c target) i = k + 1; else if (nums[k] \u003e target) j = k; else return k; } return j; } }; 744 寻找比目标字母大的最小字母 在有序数组中找到比目标字母大的最小字母，数组里的字母是循环的。\n找到大于target的第一个数，相比于上一题只是少了在循环内判断是否等于的情况。从int类型数组变成了char类型数组，不过这一点并没有任何影响。\nclass Solution { public: char nextGreatestLetter(vector\u003cchar\u003e\u0026 letters, char target) { int n = letters.size(), i = 0, j = n, k = 0; while (i \u003c j) { k = i + (j - i) / 2; if (letters[k] \u003c= target) i = k + 1; else if (letters[k] \u003e target) j = k; } return j \u003c n ? letters[j] : letters[0]; } }; 278 第一个错误的版本 产品都是基于之前的版本开发的，所有错误的版本之后的所有版本都是错的，找到出错的第一个版本。通过一个接口 bool isBadVersion(version) 来判断版本是否出错。\n很标准的找下界。\nbool isBadVersion(int version); class Solution { public: int firstBadVersion(long long n) { long long i = 0, j = n + 1, k = 0; while (i \u003c j) { k = i + (j - i) / 2; if (!isBadVersion(k)) i = k + 1; else j = k; } return j; } }; 875 爱吃香蕉的珂珂 有 N 堆香蕉，每小时内吃完一堆则不吃另外一堆，计算能在 H 小时内吃完的最慢速度。\n将速度作为二分查找的变量，每次判断以当前速度是否能吃完所有香蕉，如果能则 j = k，k 有可能是最后的结果，否则 i = k + 1，此时的 k 一定比结果小。\nclass Solution { public: int minEatingSpeed(vector\u003cint\u003e\u0026 piles, int H) { int i = 1, j = INT_MAX, k = 0; while (i \u003c j) { k = i + (j - i) / 2; int res = CanEatAll(k, H, piles); if (res) j = k; else i = k + 1; } return j; } bool CanEatAll(const int \u0026speed, int hour, vector\u003cint\u003e\u0026 piles) { for (auto \u0026p:piles) hour -= p / speed + (p % speed \u003e 0); return hour \u003e= 0; } }; 3. 根据位置关系查找 378 有序矩阵中第K小的元素 n x n 的矩阵中每行和每列均按升序排序，找到矩阵中第k小的元素。\n这道题可以用跟剑指offer里二维数组中的查找这道题的思路结合二分查找来做，二分的时候每次计算矩阵里小于等于中间值的数的个数就能得到结果了。时间复杂度是 O(logm * n)，m 是 matrix[n - 1][n - 1]，n 是 matrix.size()。\nclass Solution { public: int kthSmallest(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int m) { int n = matrix.size(), i = matrix[0][0], j = matrix[n - 1][n - 1] + 1, k = 0; while (i \u003c j) { k = i + (j - i) / 2; auto res = CountLess(matrix, k); if (res \u003c m) i = k + 1; else j = k; } return i; } int CountLess(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, const int \u0026target) { int n = matrix.size(), i = 0, j = n - 1, res = 0; while (i \u003c n \u0026\u0026 j \u003e= 0) { if (matrix[i][j] \u003c= target) res += j + 1, ++i; else --j; } return res; } }; 153 寻找旋转排序数组中的最小值 一个有序数组在某个点上进行了旋转，找出其中最小的元素。\n根据中间值与左右边值和其左右边一位的大小关系来判断，如果中间值k比左边值小，那么k有可能是结果，让 j = k ；否则比较中间值与其右边一位，如果中间值大于右边一位的值，那么右边一位的值就是结果，否则让 i = k + 1。\nclass Solution { public: int findMin(vector\u003cint\u003e\u0026 nums) { int n = nums.size(), i = 0, j = nums.size(), k = 0; if (n == 1 || nums[0] \u003c nums[n - 1]) return nums[0]; else if (n == 2) return min(nums[0], nums[1]); while (i \u003c j) { k = i + (j - i) / 2; if (nums[i] \u003e nums[k]) j = k; else if (k + 1 \u003c j \u0026\u0026 nums[k + 1] \u003e nums[i]) i = k + 1; else return nums[k + 1]; } return j \u003e= n ? nums[i] : min(nums[i], nums[j]); } }; 540 有序数组中的单一元素 一个有序数组中每个元素都会出现了两次，只有一个数出现了一次，找出这个数。\n有序数组里其他每个元素都出现两次，找到唯一只出现一次的数。在唯一的数出现之后奇偶位的相等关系会发生变化，利用这一点来做判断。比较直观的写法是分别判断 k % 2 == 0 和 k % 2 == 1 的情况，这样写起来比较复杂，可以直接在 k % 2 == 1 的时候 –k，再直接判断 nums[k] 和 nums[k + 1] 的关系。\nclass Solution { public: int singleNonDuplicate(vector\u003cint\u003e \u0026nums) { int i = 0, j = nums.size() - 1, k = 0, n = nums.size(); while (i \u003c= j) { k = i + (j - i + 1) / 2; cout \u003c\u003c k \u003c\u003c endl; if (k % 2 == 0) { if (k + 1 \u003c n \u0026\u0026 nums[k] == nums[k + 1]) i = k + 1; else if (k - 1 \u003e= 0 \u0026\u0026 nums[k] == nums[k - 1]) j = k - 1; else return nums[k]; } else { if (k + 1 \u003c n \u0026\u0026 nums[k] == nums[k + 1]) j = k - 1; else if (k - 1 \u003e= 0 \u0026\u0026 nums[k] == nums[k - 1]) i = k + 1; else return nums[k]; } } return 0; } }; class Solution { public: int singleNonDuplicate(vector\u003cint\u003e \u0026nums) { int i = 0, j = nums.size(), k = 0, n = nums.size(); while (i \u003c j) { k = i + (j - i) / 2; if (k % 2 == 1) --k; if (k + 1 \u003c n \u0026\u0026 nums[k] == nums[k + 1]) i = k + 2; else j = k; } return nums[j]; } }; 4. 综合 1095 山脉数组中查找目标值 在一个山脉数组中找到等于目标值的最小下标。\n因为已知数组一定是一个山脉数组，所以一定有唯一的山顶，用二分查找找到山顶的下标。如果山顶小于目标值那么数组中一定没有目标值存在，返回 -1，否则在山顶左边使用二分查找找目标值，没有的话则在山顶右边使用二分查找找目标值。\nclass Solution { public: int findInMountainArray(int target, MountainArray \u0026mountainArr) { int n = mountainArr.length(), i = 0, j = n - 1, k = 0, peak = 0; while (i \u003c= j) { k = i + (j - i + 1) / 2; if (mountainArr.get(k) \u003e mountainArr.get(k - 1) \u0026\u0026 mountainArr.get(k) \u003e mountainArr.get(k + 1)) break; else if (mountainArr.get(k) \u003c mountainArr.get(k - 1)) j = k - 1; else i = k + 1; } if (mountainArr.get(k) \u003c target) return -1; else if (mountainArr.get(k) == target) return k; peak = k; i = 0, j = peak; while (i \u003c j) { k = i + (j - i) / 2; if (mountainArr.get(k) \u003c target) i = k + 1; else j = k; } if (mountainArr.get(j) == target) return j; i = peak + 1, j = n; while (i \u003c j) { k = i + (j - i) / 2; if (mountainArr.get(k) \u003c target) j = k - 1; else if (mountainArr.get(k) \u003e target) i = k + 1; else j = k; } if (i \u003c n \u0026\u0026 mountainArr.get(i) == target) return i; return -1; } }; 5. 猜数 719 找出第 k 小的距离对 最简单的做法遍历两遍算出所有数对的差值保存在一个小根堆中，然后依次找到小于等于 k 的最小距离，但这样做时间复杂度是 O(n ^ 2) 会超时。我们可以先将数组排序，然后用 low = 0, high = nums[n - 1] - nums[0] 表示可能结果的最小值和最大值，用二分法来判断中间值 mid 是否满足小于等于 mid 的数对差值的数是否小于等于 k，判断时因为数组是有序的，可以使用双指针让中间的差值维持在小于等于 mid，从而计算出小于等于 mid 的数对差值的数，时间复杂度是 O(nlogn + nlogm)，其中 n 是数组的长度，m 是数组最大值与最小值之差，nlogn 是排序的平均时间复杂度，而 nlogm 中 n 是使用双指针判断的时间复杂度，logm 是二分法的时间复杂度。\nclass Solution { public: int smallestDistancePair(vector\u003cint\u003e \u0026nums, int k) { sort(nums.begin(), nums.end()); int n = nums.size(), low = 0, high = nums[n - 1] - nums[0], mid = 0; while (low \u003c high) { mid = low + (high - low) / 2; if (IsDistMoreThanK(nums, mid, k)) high = mid; else low = mid + 1; } return high; } bool IsDistMoreThanK(const vector\u003cint\u003e \u0026nums, int m, const int \u0026k) { int left = 0, right = 0, count = 0; while (right \u003c nums.size()) { while (nums[right] - nums[left] \u003e m) ++left; count += right - left; ++right; } return count \u003e= k; } }; ","wordCount":"1503","inLanguage":"en","datePublished":"2019-06-23T19:26:39+10:00","dateModified":"2019-06-23T19:26:39+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/leetcode/binarysearch/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">LeetCode 二分查找</h1><div class=post-meta><span title='2019-06-23 19:26:39 +1000 AEST'>June 23, 2019</span>&nbsp;·&nbsp;8 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#leetcode-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%behttpsleetcode-cncomtagbinary-search aria-label="LeetCode 二分查找">LeetCode 二分查找</a><ul><li><a href=#%e6%98%93%e9%94%99%e7%82%b9 aria-label=易错点>易错点</a></li><li><a href=#%e9%a2%98%e7%9b%ae aria-label=题目>题目</a><ul><li><a href=#1-%e6%9f%a5%e6%89%be%e6%95%b0 aria-label="1. 查找数">1. 查找数</a><ul><li><a href=#704-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%behttpsleetcode-cncomproblemsbinary-search aria-label="704 二分查找">704 二分查找</a></li><li><a href=#374-%e7%8c%9c%e6%95%b0%e5%ad%97%e5%a4%a7%e5%b0%8fhttpsleetcode-cncomproblemsguess-number-higher-or-lower aria-label="374 猜数字大小">374 猜数字大小</a></li><li><a href=#367-%e6%9c%89%e6%95%88%e7%9a%84%e5%ae%8c%e5%85%a8%e5%b9%b3%e6%96%b9%e6%95%b0httpsleetcode-cncomproblemsvalid-perfect-square aria-label="367 有效的完全平方数">367 有效的完全平方数</a></li><li><a href=#69-x%e7%9a%84%e5%b9%b3%e6%96%b9%e6%a0%b9httpsleetcode-cncomproblemssqrtx aria-label="69 x的平方根">69 x的平方根</a></li></ul></li><li><a href=#2-%e6%9f%a5%e6%89%be%e4%b8%8a%e7%95%8c%e4%b8%8b%e7%95%8c aria-label="2. 查找上界/下界">2. 查找上界/下界</a><ul><li><a href=#35-%e6%90%9c%e7%b4%a2%e6%8f%92%e5%85%a5%e4%bd%8d%e7%bd%aehttpsleetcode-cncomproblemssearch-insert-position aria-label="35 搜索插入位置">35 搜索插入位置</a></li><li><a href=#744-%e5%af%bb%e6%89%be%e6%af%94%e7%9b%ae%e6%a0%87%e5%ad%97%e6%af%8d%e5%a4%a7%e7%9a%84%e6%9c%80%e5%b0%8f%e5%ad%97%e6%af%8dhttpsleetcode-cncomproblemsfind-smallest-letter-greater-than-target aria-label="744 寻找比目标字母大的最小字母">744 寻找比目标字母大的最小字母</a></li><li><a href=#278-%e7%ac%ac%e4%b8%80%e4%b8%aa%e9%94%99%e8%af%af%e7%9a%84%e7%89%88%e6%9c%achttpsleetcode-cncomproblemsfirst-bad-version aria-label="278 第一个错误的版本">278 第一个错误的版本</a></li><li><a href=#875-%e7%88%b1%e5%90%83%e9%a6%99%e8%95%89%e7%9a%84%e7%8f%82%e7%8f%82httpsleetcode-cncomproblemskoko-eating-bananas aria-label="875 爱吃香蕉的珂珂">875 爱吃香蕉的珂珂</a></li></ul></li><li><a href=#3-%e6%a0%b9%e6%8d%ae%e4%bd%8d%e7%bd%ae%e5%85%b3%e7%b3%bb%e6%9f%a5%e6%89%be aria-label="3. 根据位置关系查找">3. 根据位置关系查找</a><ul><li><a href=#378-%e6%9c%89%e5%ba%8f%e7%9f%a9%e9%98%b5%e4%b8%ad%e7%ac%ack%e5%b0%8f%e7%9a%84%e5%85%83%e7%b4%a0httpsleetcode-cncomproblemskth-smallest-element-in-a-sorted-matrix aria-label="378 有序矩阵中第K小的元素">378 有序矩阵中第K小的元素</a></li><li><a href=#153-%e5%af%bb%e6%89%be%e6%97%8b%e8%bd%ac%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%9c%80%e5%b0%8f%e5%80%bchttpsleetcode-cncomproblemsfind-minimum-in-rotated-sorted-array aria-label="153 寻找旋转排序数组中的最小值">153 寻找旋转排序数组中的最小值</a></li><li><a href=#540-%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e5%8d%95%e4%b8%80%e5%85%83%e7%b4%a0httpsleetcode-cncomproblemssingle-element-in-a-sorted-array aria-label="540 有序数组中的单一元素">540 有序数组中的单一元素</a></li></ul></li><li><a href=#4-%e7%bb%bc%e5%90%88 aria-label="4. 综合">4. 综合</a><ul><li><a href=#1095-%e5%b1%b1%e8%84%89%e6%95%b0%e7%bb%84%e4%b8%ad%e6%9f%a5%e6%89%be%e7%9b%ae%e6%a0%87%e5%80%bchttpsleetcode-cncomproblemsfind-in-mountain-array aria-label="1095 山脉数组中查找目标值">1095 山脉数组中查找目标值</a></li></ul></li><li><a href=#5-%e7%8c%9c%e6%95%b0 aria-label="5. 猜数">5. 猜数</a><ul><li><a href=#719-%e6%89%be%e5%87%ba%e7%ac%ac-k-%e5%b0%8f%e7%9a%84%e8%b7%9d%e7%a6%bb%e5%af%b9httpsleetcode-cncomproblemsfind-k-th-smallest-pair-distance aria-label="719 找出第 k 小的距离对">719 找出第 k 小的距离对</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=leetcode-二分查找httpsleetcode-cncomtagbinary-search><a href=https://leetcode-cn.com/tag/binary-search/>LeetCode 二分查找</a><a hidden class=anchor aria-hidden=true href=#leetcode-二分查找httpsleetcode-cncomtagbinary-search>#</a></h1><p>二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。</p><h2 id=易错点>易错点<a hidden class=anchor aria-hidden=true href=#易错点>#</a></h2><ol><li><p>计算中间值的方法</p><ul><li>k = i + (j - i) / 2</li><li>k = (i + j) / 2</li></ul><p>第二种方法一般都会造成整型数据溢出，所以只用第一种方法。</p></li><li><p>循环条件</p><ul><li><p>如果要找唯一的值，且下限i和上限j都会在更新时在中间值k的基础上+1或-1，那么循环条件是 i &lt;= j，j能被取到，j = nums.size() - 1，计算中间值用 k = i + (j - i + 1) / 2</p></li><li><p>如果要找大于等于或小于等于某条件的值，且下限i和上限j其中之一不会在k的基础上+1或-1，那么循环条件是 i &lt; j，j不能被取到，j = nums.size()，计算中间值用 k = i + (j - i) / 2</p></li></ul><p>两种方法有各自的应用场景，没用对的话会出现边界值的问题，或是死循环导致TLE。</p></li></ol><h2 id=题目>题目<a hidden class=anchor aria-hidden=true href=#题目>#</a></h2><h3 id=1-查找数>1. 查找数<a hidden class=anchor aria-hidden=true href=#1-查找数>#</a></h3><h4 id=704-二分查找httpsleetcode-cncomproblemsbinary-search><a href=https://leetcode-cn.com/problems/binary-search/>704 二分查找</a><a hidden class=anchor aria-hidden=true href=#704-二分查找httpsleetcode-cncomproblemsbinary-search>#</a></h4><p>在有序数组中搜索目标值，如果存在则返回下标，否则返回 -1。</p><p>最标准的二分查找。因为下限i和上限j都会在更新时+1和-1，所以让j = nums.size() - 1，循环条件是 i &lt;= j。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> search(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> nums.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nums[k] <span style=color:#f92672>&gt;</span> target)
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (nums[k] <span style=color:#f92672>&lt;</span> target)
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=374-猜数字大小httpsleetcode-cncomproblemsguess-number-higher-or-lower><a href=https://leetcode-cn.com/problems/guess-number-higher-or-lower/>374 猜数字大小</a><a hidden class=anchor aria-hidden=true href=#374-猜数字大小httpsleetcode-cncomproblemsguess-number-higher-or-lower>#</a></h4><p>从 1 到 n 选择一个数字，通过一个预定义的接口 guess(int num)得到-1：数字打了；1：数字小了；0：猜对了。</p><p>跟上一题几乎一模一样，只是把target换成了一个接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>guess</span>(<span style=color:#66d9ef>int</span> num);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> guessNumber(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>=</span> n, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> res <span style=color:#f92672>=</span> guess(k);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (res <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (res <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=367-有效的完全平方数httpsleetcode-cncomproblemsvalid-perfect-square><a href=https://leetcode-cn.com/problems/valid-perfect-square/>367 有效的完全平方数</a><a hidden class=anchor aria-hidden=true href=#367-有效的完全平方数httpsleetcode-cncomproblemsvalid-perfect-square>#</a></h4><p>判断一个正整数是否是一个完全平方数。</p><p>判断一个数是否是完全平方数。因为在二分的过程中平方得到的结果可能会超过32位int型的上限，所以用long long。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> isPerfectSquare(<span style=color:#66d9ef>int</span> num) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> num, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> k <span style=color:#f92672>*</span> k;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (res <span style=color:#f92672>&lt;</span> num)
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (res <span style=color:#f92672>&gt;</span> num)
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> j <span style=color:#f92672>*</span> j <span style=color:#f92672>==</span> num;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=69-x的平方根httpsleetcode-cncomproblemssqrtx><a href=https://leetcode-cn.com/problems/sqrtx/>69 x的平方根</a><a hidden class=anchor aria-hidden=true href=#69-x的平方根httpsleetcode-cncomproblemssqrtx>#</a></h4><p>计算一个数的平方根，只保留整数部分。</p><p>实现int sqrt(int x)函数。用商来判断比用乘积来判断更直观。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mySqrt(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>=</span> x, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, sqrt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            sqrt <span style=color:#f92672>=</span> x <span style=color:#f92672>/</span> k;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (sqrt <span style=color:#f92672>&lt;</span> k)
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (sqrt <span style=color:#f92672>&gt;</span> k)
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=2-查找上界下界>2. 查找上界/下界<a hidden class=anchor aria-hidden=true href=#2-查找上界下界>#</a></h3><h4 id=35-搜索插入位置httpsleetcode-cncomproblemssearch-insert-position><a href=https://leetcode-cn.com/problems/search-insert-position/>35 搜索插入位置</a><a hidden class=anchor aria-hidden=true href=#35-搜索插入位置httpsleetcode-cncomproblemssearch-insert-position>#</a></h4><p>在有序数组中找到目标值，如果不存在则返回它将会被按顺序插入的位置，数组中无重复元素。</p><p>找到大于等于target的第一个数。因为上限j在更新时会直接被赋给k的值，所以让j = nums.size()，循环条件是i &lt; j。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> searchInsert(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> nums.size(), k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nums[k] <span style=color:#f92672>&lt;</span> target)
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (nums[k] <span style=color:#f92672>&gt;</span> target)
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=744-寻找比目标字母大的最小字母httpsleetcode-cncomproblemsfind-smallest-letter-greater-than-target><a href=https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/>744 寻找比目标字母大的最小字母</a><a hidden class=anchor aria-hidden=true href=#744-寻找比目标字母大的最小字母httpsleetcode-cncomproblemsfind-smallest-letter-greater-than-target>#</a></h4><p>在有序数组中找到比目标字母大的最小字母，数组里的字母是循环的。</p><p>找到大于target的第一个数，相比于上一题只是少了在循环内判断是否等于的情况。从int类型数组变成了char类型数组，不过这一点并没有任何影响。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> nextGreatestLetter(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&amp;</span> letters, <span style=color:#66d9ef>char</span> target) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> letters.size(), i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> n, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (letters[k] <span style=color:#f92672>&lt;=</span> target)
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (letters[k] <span style=color:#f92672>&gt;</span> target)
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> j <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>?</span> letters[j] <span style=color:#f92672>:</span> letters[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=278-第一个错误的版本httpsleetcode-cncomproblemsfirst-bad-version><a href=https://leetcode-cn.com/problems/first-bad-version/>278 第一个错误的版本</a><a hidden class=anchor aria-hidden=true href=#278-第一个错误的版本httpsleetcode-cncomproblemsfirst-bad-version>#</a></h4><p>产品都是基于之前的版本开发的，所有错误的版本之后的所有版本都是错的，找到出错的第一个版本。通过一个接口 bool isBadVersion(version) 来判断版本是否出错。</p><p>很标准的找下界。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isBadVersion</span>(<span style=color:#66d9ef>int</span> version);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> firstBadVersion(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isBadVersion(k))
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=875-爱吃香蕉的珂珂httpsleetcode-cncomproblemskoko-eating-bananas><a href=https://leetcode-cn.com/problems/koko-eating-bananas/>875 爱吃香蕉的珂珂</a><a hidden class=anchor aria-hidden=true href=#875-爱吃香蕉的珂珂httpsleetcode-cncomproblemskoko-eating-bananas>#</a></h4><p>有 N 堆香蕉，每小时内吃完一堆则不吃另外一堆，计算能在 H 小时内吃完的最慢速度。</p><p>将速度作为二分查找的变量，每次判断以当前速度是否能吃完所有香蕉，如果能则 j = k，k 有可能是最后的结果，否则 i = k + 1，此时的 k 一定比结果小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minEatingSpeed(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> piles, <span style=color:#66d9ef>int</span> H) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>=</span> INT_MAX, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> CanEatAll(k, H, piles);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (res)
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>CanEatAll</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>speed, <span style=color:#66d9ef>int</span> hour, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> piles) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>p:piles)
</span></span><span style=display:flex><span>            hour <span style=color:#f92672>-=</span> p <span style=color:#f92672>/</span> speed <span style=color:#f92672>+</span> (p <span style=color:#f92672>%</span> speed <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> hour <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=3-根据位置关系查找>3. 根据位置关系查找<a hidden class=anchor aria-hidden=true href=#3-根据位置关系查找>#</a></h3><h4 id=378-有序矩阵中第k小的元素httpsleetcode-cncomproblemskth-smallest-element-in-a-sorted-matrix><a href=https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/>378 有序矩阵中第K小的元素</a><a hidden class=anchor aria-hidden=true href=#378-有序矩阵中第k小的元素httpsleetcode-cncomproblemskth-smallest-element-in-a-sorted-matrix>#</a></h4><p>n x n 的矩阵中每行和每列均按升序排序，找到矩阵中第k小的元素。</p><p>这道题可以用跟剑指offer里二维数组中的查找这道题的思路结合二分查找来做，二分的时候每次计算矩阵里小于等于中间值的数的个数就能得到结果了。时间复杂度是 O(logm * n)，m 是 matrix[n - 1][n - 1]，n 是 matrix.size()。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> kthSmallest(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> matrix, <span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> matrix.size(), i <span style=color:#f92672>=</span> matrix[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], j <span style=color:#f92672>=</span> matrix[n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> res <span style=color:#f92672>=</span> CountLess(matrix, k);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (res <span style=color:#f92672>&lt;</span> m)
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>CountLess</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> matrix, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>target) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> matrix.size(), i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (matrix[i][j] <span style=color:#f92672>&lt;=</span> target)
</span></span><span style=display:flex><span>                res <span style=color:#f92672>+=</span> j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>++</span>i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>--</span>j;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=153-寻找旋转排序数组中的最小值httpsleetcode-cncomproblemsfind-minimum-in-rotated-sorted-array><a href=https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/>153 寻找旋转排序数组中的最小值</a><a hidden class=anchor aria-hidden=true href=#153-寻找旋转排序数组中的最小值httpsleetcode-cncomproblemsfind-minimum-in-rotated-sorted-array>#</a></h4><p>一个有序数组在某个点上进行了旋转，找出其中最小的元素。</p><p>根据中间值与左右边值和其左右边一位的大小关系来判断，如果中间值k比左边值小，那么k有可能是结果，让 j = k ；否则比较中间值与其右边一位，如果中间值大于右边一位的值，那么右边一位的值就是结果，否则让 i = k + 1。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> findMin(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> nums.size(), i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> nums.size(), k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> nums[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> nums[n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> nums[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> min(nums[<span style=color:#ae81ff>0</span>], nums[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nums[i] <span style=color:#f92672>&gt;</span> nums[k])
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> j <span style=color:#f92672>&amp;&amp;</span> nums[k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;</span> nums[i])
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> nums[k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> j <span style=color:#f92672>&gt;=</span> n <span style=color:#f92672>?</span> nums[i] <span style=color:#f92672>:</span> min(nums[i], nums[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=540-有序数组中的单一元素httpsleetcode-cncomproblemssingle-element-in-a-sorted-array><a href=https://leetcode-cn.com/problems/single-element-in-a-sorted-array/>540 有序数组中的单一元素</a><a hidden class=anchor aria-hidden=true href=#540-有序数组中的单一元素httpsleetcode-cncomproblemssingle-element-in-a-sorted-array>#</a></h4><p>一个有序数组中每个元素都会出现了两次，只有一个数出现了一次，找出这个数。</p><p>有序数组里其他每个元素都出现两次，找到唯一只出现一次的数。在唯一的数出现之后奇偶位的相等关系会发生变化，利用这一点来做判断。比较直观的写法是分别判断 k % 2 == 0 和 k % 2 == 1 的情况，这样写起来比较复杂，可以直接在 k % 2 == 1 的时候 &ndash;k，再直接判断 nums[k] 和 nums[k + 1] 的关系。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> singleNonDuplicate(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> nums.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, n <span style=color:#f92672>=</span> nums.size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> k <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> nums[k] <span style=color:#f92672>==</span> nums[k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                    i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> nums[k] <span style=color:#f92672>==</span> nums[k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                    j <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> nums[k];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> nums[k] <span style=color:#f92672>==</span> nums[k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                    j <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> nums[k] <span style=color:#f92672>==</span> nums[k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                    i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> nums[k];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> singleNonDuplicate(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> nums.size(), k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, n <span style=color:#f92672>=</span> nums.size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>--</span>k;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> nums[k] <span style=color:#f92672>==</span> nums[k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nums[j];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=4-综合>4. 综合<a hidden class=anchor aria-hidden=true href=#4-综合>#</a></h3><h4 id=1095-山脉数组中查找目标值httpsleetcode-cncomproblemsfind-in-mountain-array><a href=https://leetcode-cn.com/problems/find-in-mountain-array/>1095 山脉数组中查找目标值</a><a hidden class=anchor aria-hidden=true href=#1095-山脉数组中查找目标值httpsleetcode-cncomproblemsfind-in-mountain-array>#</a></h4><p>在一个山脉数组中找到等于目标值的最小下标。</p><p>因为已知数组一定是一个山脉数组，所以一定有唯一的山顶，用二分查找找到山顶的下标。如果山顶小于目标值那么数组中一定没有目标值存在，返回 -1，否则在山顶左边使用二分查找找目标值，没有的话则在山顶右边使用二分查找找目标值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> findInMountainArray(<span style=color:#66d9ef>int</span> target, MountainArray <span style=color:#f92672>&amp;</span>mountainArr) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> mountainArr.length(), i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, peak <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (mountainArr.get(k) <span style=color:#f92672>&gt;</span> mountainArr.get(k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;&amp;</span> mountainArr.get(k) <span style=color:#f92672>&gt;</span> mountainArr.get(k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (mountainArr.get(k) <span style=color:#f92672>&lt;</span> mountainArr.get(k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (mountainArr.get(k) <span style=color:#f92672>&lt;</span> target)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (mountainArr.get(k) <span style=color:#f92672>==</span> target)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> k;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        peak <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> peak;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (mountainArr.get(k) <span style=color:#f92672>&lt;</span> target)
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (mountainArr.get(j) <span style=color:#f92672>==</span> target)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> j;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> peak <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> (j <span style=color:#f92672>-</span> i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (mountainArr.get(k) <span style=color:#f92672>&lt;</span> target)
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (mountainArr.get(k) <span style=color:#f92672>&gt;</span> target)
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> mountainArr.get(i) <span style=color:#f92672>==</span> target)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=5-猜数>5. 猜数<a hidden class=anchor aria-hidden=true href=#5-猜数>#</a></h3><h4 id=719-找出第-k-小的距离对httpsleetcode-cncomproblemsfind-k-th-smallest-pair-distance><a href=https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/>719 找出第 k 小的距离对</a><a hidden class=anchor aria-hidden=true href=#719-找出第-k-小的距离对httpsleetcode-cncomproblemsfind-k-th-smallest-pair-distance>#</a></h4><p>最简单的做法遍历两遍算出所有数对的差值保存在一个小根堆中，然后依次找到小于等于 k 的最小距离，但这样做时间复杂度是 O(n ^ 2) 会超时。我们可以先将数组排序，然后用 low = 0, high = nums[n - 1] - nums[0] 表示可能结果的最小值和最大值，用二分法来判断中间值 mid 是否满足小于等于 mid 的数对差值的数是否小于等于 k，判断时因为数组是有序的，可以使用双指针让中间的差值维持在小于等于 mid，从而计算出小于等于 mid 的数对差值的数，时间复杂度是 O(nlogn + nlogm)，其中 n 是数组的长度，m 是数组最大值与最小值之差，nlogn 是排序的平均时间复杂度，而 nlogm 中 n 是使用双指针判断的时间复杂度，logm 是二分法的时间复杂度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> smallestDistancePair(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        sort(nums.begin(), nums.end());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> nums.size(), low <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, high <span style=color:#f92672>=</span> nums[n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> nums[<span style=color:#ae81ff>0</span>], mid <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (low <span style=color:#f92672>&lt;</span> high) {
</span></span><span style=display:flex><span>            mid <span style=color:#f92672>=</span> low <span style=color:#f92672>+</span> (high <span style=color:#f92672>-</span> low) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (IsDistMoreThanK(nums, mid, k))
</span></span><span style=display:flex><span>                high <span style=color:#f92672>=</span> mid;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                low <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> high;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>IsDistMoreThanK</span>(<span style=color:#66d9ef>const</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (right <span style=color:#f92672>&lt;</span> nums.size()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (nums[right] <span style=color:#f92672>-</span> nums[left] <span style=color:#f92672>&gt;</span> m)
</span></span><span style=display:flex><span>                <span style=color:#f92672>++</span>left;
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> right <span style=color:#f92672>-</span> left;
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>right;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count <span style=color:#f92672>&gt;=</span> k;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/leetcode/dynamicprogramming-1/><span class=title>« Prev</span><br><span>LeetCode 动态规划（1）</span>
</a><a class=next href=https://prov1dence.top/posts/leetcode/bitmanipulation/><span class=title>Next »</span><br><span>LeetCode 位运算</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>