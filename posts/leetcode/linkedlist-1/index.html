<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LeetCode 链表（1） | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content="LeetCode 链表（1）
题目
1. 常规题
2 两数相加
给两个链表分别代表两个正数的逆序表示，计算两个链表之和。
依次按位进行相加。
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        int acc = 0, val = 0;
        auto head = l1, tail = l1;
        while (l1 && l2) {
            val = l1->val + l2->val + acc;
            acc = val / 10;
            l1->val = val % 10;
            if (!l1->next)
                l1->next = l2->next, l2->next = nullptr;
            tail = l1;
            l1 = l1->next, l2 = l2->next;
        }
        while (l1) {
            val = l1->val + acc;
            acc = val / 10;
            l1->val = val % 10;
            tail = l1;
            l1 = l1->next;
        }
        if (acc)
            tail->next = new ListNode(1);
        return head;
    }
};
21 合并两个有序链表
合并两个有序链表。"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/leetcode/linkedlist-1/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/leetcode/linkedlist-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/leetcode/linkedlist-1/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="LeetCode 链表（1）"><meta property="og:description" content="LeetCode 链表（1） 题目 1. 常规题 2 两数相加 给两个链表分别代表两个正数的逆序表示，计算两个链表之和。
依次按位进行相加。
class Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { int acc = 0, val = 0; auto head = l1, tail = l1; while (l1 && l2) { val = l1->val + l2->val + acc; acc = val / 10; l1->val = val % 10; if (!l1->next) l1->next = l2->next, l2->next = nullptr; tail = l1; l1 = l1->next, l2 = l2->next; } while (l1) { val = l1->val + acc; acc = val / 10; l1->val = val % 10; tail = l1; l1 = l1->next; } if (acc) tail->next = new ListNode(1); return head; } }; 21 合并两个有序链表 合并两个有序链表。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-04T19:12:25+10:00"><meta property="article:modified_time" content="2019-07-04T19:12:25+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode 链表（1）"><meta name=twitter:description content="LeetCode 链表（1）
题目
1. 常规题
2 两数相加
给两个链表分别代表两个正数的逆序表示，计算两个链表之和。
依次按位进行相加。
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        int acc = 0, val = 0;
        auto head = l1, tail = l1;
        while (l1 && l2) {
            val = l1->val + l2->val + acc;
            acc = val / 10;
            l1->val = val % 10;
            if (!l1->next)
                l1->next = l2->next, l2->next = nullptr;
            tail = l1;
            l1 = l1->next, l2 = l2->next;
        }
        while (l1) {
            val = l1->val + acc;
            acc = val / 10;
            l1->val = val % 10;
            tail = l1;
            l1 = l1->next;
        }
        if (acc)
            tail->next = new ListNode(1);
        return head;
    }
};
21 合并两个有序链表
合并两个有序链表。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode 链表（1）","item":"https://prov1dence.top/posts/leetcode/linkedlist-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode 链表（1）","name":"LeetCode 链表（1）","description":"LeetCode 链表（1） 题目 1. 常规题 2 两数相加 给两个链表分别代表两个正数的逆序表示，计算两个链表之和。\n依次按位进行相加。\nclass Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { int acc = 0, val = 0; auto head = l1, tail = l1; while (l1 \u0026amp;\u0026amp; l2) { val = l1-\u0026gt;val + l2-\u0026gt;val + acc; acc = val / 10; l1-\u0026gt;val = val % 10; if (!l1-\u0026gt;next) l1-\u0026gt;next = l2-\u0026gt;next, l2-\u0026gt;next = nullptr; tail = l1; l1 = l1-\u0026gt;next, l2 = l2-\u0026gt;next; } while (l1) { val = l1-\u0026gt;val + acc; acc = val / 10; l1-\u0026gt;val = val % 10; tail = l1; l1 = l1-\u0026gt;next; } if (acc) tail-\u0026gt;next = new ListNode(1); return head; } }; 21 合并两个有序链表 合并两个有序链表。\n","keywords":[],"articleBody":"LeetCode 链表（1） 题目 1. 常规题 2 两数相加 给两个链表分别代表两个正数的逆序表示，计算两个链表之和。\n依次按位进行相加。\nclass Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { int acc = 0, val = 0; auto head = l1, tail = l1; while (l1 \u0026\u0026 l2) { val = l1-\u003eval + l2-\u003eval + acc; acc = val / 10; l1-\u003eval = val % 10; if (!l1-\u003enext) l1-\u003enext = l2-\u003enext, l2-\u003enext = nullptr; tail = l1; l1 = l1-\u003enext, l2 = l2-\u003enext; } while (l1) { val = l1-\u003eval + acc; acc = val / 10; l1-\u003eval = val % 10; tail = l1; l1 = l1-\u003enext; } if (acc) tail-\u003enext = new ListNode(1); return head; } }; 21 合并两个有序链表 合并两个有序链表。\n逐个比较大小并添加到当前节点后面，并移动对应的链表节点。\nclass Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head = new ListNode(0), *node = head; while (l1 \u0026\u0026 l2) { if (l1-\u003eval \u003c l2-\u003eval) head-\u003enext = l1, l1 = l1-\u003enext; else head-\u003enext = l2, l2 = l2-\u003enext; head = head-\u003enext; } while (l1) head-\u003enext = l1, l1 = l1-\u003enext, head = head-\u003enext; while (l2) head-\u003enext = l2, l2 = l2-\u003enext, head = head-\u003enext; return node-\u003enext; } }; 83 删除排序链表中的重复元素 删除链表中所有重复的节点。\n将每个节点与其后面的节点的值做对比，如果相同则删除后面的节点。\nclass Solution { public: ListNode* deleteDuplicates(ListNode* head) { auto ret = head; while (head) { while (head-\u003enext \u0026\u0026 head-\u003enext-\u003eval == head-\u003eval) { auto next = head-\u003enext; head-\u003enext = next-\u003enext; delete next; } head = head-\u003enext; } return ret; } }; 82 删除排序链表中的重复元素 II 删除链表中所有重复的节点，只保留原始链表中没有重复出现的数字。\n为了删除所有重复的节点并只保留所有没有出现过的数字，需要提前两个节点检查接下来的两个节点的值是否相同，如果相同的话需要将这两个节点及其后的所有重复节点都删除。\nclass Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode *node = new ListNode(0), *ret = node, *next = nullptr, *temp = nullptr; node-\u003enext = head; while (node \u0026\u0026 node-\u003enext) { next = node-\u003enext-\u003enext; while (next \u0026\u0026 node-\u003enext-\u003eval == next-\u003eval) { temp = next; next = next-\u003enext; delete temp; } if (next != node-\u003enext-\u003enext) { temp = node-\u003enext; node-\u003enext = next; delete temp; } else node = node-\u003enext; } return ret-\u003enext; } }; 203 移除链表元素 删除链表中等于给定值的所有节点。\n先判断头节点是否等于给定值，再判断其后面的节点是否等于给定值。\nclass Solution { public: ListNode* removeElements(ListNode* head, int val) { while (head \u0026\u0026 head-\u003eval == val) { auto prev = head; head = head-\u003enext; delete prev; } auto ret = head; while (head) { while (head-\u003enext \u0026\u0026 head-\u003enext-\u003eval == val) { auto next = head-\u003enext; head-\u003enext = next-\u003enext; delete next; } head = head-\u003enext; } return ret; } }; 817 链表组件 给一个链表和一个数组，找到链表中一段子链表的值都在数组中的子链表的个数。\n先将数组转换成哈希表方便查询，再依次遍历整个链表，判断一段子链表结束时或遍历结束时子链表是否是符合条件。\nclass Solution { public: int numComponents(ListNode* head, vector\u003cint\u003e\u0026 G) { unordered_set\u003cint\u003e exist(G.begin(), G.end()); bool cont = false, curr = false; int res = 0; while (head) { curr = exist.count(head-\u003eval); res += cont \u0026\u0026 !curr; cont = curr; head = head-\u003enext; } return res + cont; } }; 24 两两交换链表中的节点 给一个链表，返回两两交换其中相邻的节点后的结果。\n用三个指针把要交换的两个节点和他们的前驱节点保存下来，交换后再更新三个指针，按顺序交换即可。\nclass Solution { public: ListNode *swapPairs(ListNode *head) { if (!head || !head-\u003enext) return head; ListNode *root = new ListNode(0), *prev = root; root-\u003enext = head; auto first = head, second = head-\u003enext; while (first \u0026\u0026 second) { auto temp = second-\u003enext; prev-\u003enext = second; second-\u003enext = first; first-\u003enext = temp; prev = first; first = temp; second = temp ? temp-\u003enext : nullptr; } return root-\u003enext; } }; 430 扁平化多级双向链表 给一个带子节点的双向链表，将其扁平化并使所有结点出现在单级双链表中。\n对于某一个节点，如果它有 child 节点，那么需要将其 child 节点作为其新的 next 节点，将其 child 链表上的最后一个节点作为其原本 next 节点的 prev 节点，递归调用整个过程即可。\nclass Solution { public: Node *flatten(Node *head) { if (!head) return nullptr; Node *node = head, *next = nullptr; while (node) { if (node-\u003echild) { next = node-\u003enext; auto child = flatten(node-\u003echild); node-\u003enext = child; child-\u003eprev = node; node-\u003echild = nullptr; while (node-\u003enext) node = node-\u003enext; node-\u003enext = next; if (next) next-\u003eprev = node; } node = node-\u003enext; } return head; } }; 2. 链表反转 206 反转链表 class Solution { public: ListNode* reverseList(ListNode* head) { if (!head) return nullptr; ListNode *prev = nullptr, *curr = head, *next = head-\u003enext; while (curr) { next = curr-\u003enext; curr-\u003enext = prev; prev = curr; curr = next; } return prev; } }; 92 反转链表 II 将链表中从 m 到 n 位置的节点反转。\n先找到位置在 m - 1 的节点，将其后的节点截断，再找到位置在 n 的节点，将其后的节点截断，将中间的一段链表反转后再链接到愿链表上。\nclass Solution { public: ListNode *reverseBetween(ListNode *head, int m, int n) { ListNode *root = new ListNode(0), *r = root, *prev, *last; root-\u003enext = head; int cnt = 1; while (cnt \u003c m \u0026\u0026 r) r = r-\u003enext, ++cnt; prev = r; while (cnt \u003c= n \u0026\u0026 r \u0026\u0026 r-\u003enext) r = r-\u003enext, ++cnt; last = r-\u003enext; r-\u003enext = nullptr; prev-\u003enext = Reverse(prev-\u003enext); while (prev \u0026\u0026 prev-\u003enext) prev = prev-\u003enext; prev-\u003enext = last; return root-\u003enext; } ListNode *Reverse(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u003enext; curr-\u003enext = prev; prev = curr; curr = next; } return prev; } }; 369 给单链表加一 用一个单链表表示一个整数，计算将其加一的结果。\n先将链表反转方便进位，然后进行加一和进位的操作，最后再反转一次链表。\nclass Solution { public: ListNode* plusOne(ListNode* head) { if (!head) return nullptr; head = Reverse(head); auto root = head; while (head) { if (head-\u003eval == 9) { head-\u003eval = 0; if (!head-\u003enext) { head-\u003enext = new ListNode(1); break; } head = head-\u003enext; } else { ++head-\u003eval; break; } } return Reverse(root); } ListNode *Reverse(ListNode* head) { if (!head) return nullptr; ListNode *prev = nullptr, *curr = head, *next = head-\u003enext; while (curr) { next = curr-\u003enext; curr-\u003enext = prev; prev = curr; curr = next; } return prev; } }; 445 两数相加 II 给两个链表分别代表两个正数，计算两个链表之和。\n先将两个链表反转，再依次按位进行相加，最后再将得到的结果反转并返回。\nclass Solution { public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) { if (!l1 || !l2) return !l1 ? l2 : l1; l1 = Reverse(l1); l2 = Reverse(l2); int carry = 0, sum = 0; ListNode *head = l1, *prev = l1; while (l1 \u0026\u0026 l2) { prev = l1; sum = l1-\u003eval + l2-\u003eval + carry; carry = sum / 10; l1-\u003eval = sum - carry * 10; if (l2-\u003enext \u0026\u0026 !l1-\u003enext) l1-\u003enext = l2-\u003enext, l2-\u003enext = nullptr; l1 = l1-\u003enext; l2 = l2-\u003enext; } while (l1) { prev = l1; sum = l1-\u003eval + carry; carry = sum / 10; l1-\u003eval = sum - carry * 10; l1 = l1-\u003enext; } if (carry \u0026\u0026 prev) prev-\u003enext = new ListNode(1); return Reverse(head); } ListNode *Reverse(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u003enext; curr-\u003enext = prev; prev = curr; curr = next; } return prev; } }; 25 K 个一组翻转链表 给一个链表，每 k 个节点一组进行翻转。\n用几个指针记录下需要反转的部分的起始，终止位置，依次反转即可。\nclass Solution { ListNode *ReverseLinkedList(ListNode *head) { ListNode *prev = nullptr, *curr = head, *next = nullptr; while (curr) { next = curr-\u003enext; curr-\u003enext = prev; prev = curr; curr = next; } return prev; } public: ListNode *reverseKGroup(ListNode *head, int k) { ListNode *root = new ListNode(0), *prev = root; prev-\u003enext = head; while (prev) { int i = 1; ListNode *start = prev-\u003enext, *end = prev-\u003enext, *curr = end, *next = nullptr; while (curr \u0026\u0026 i \u003c k) curr = curr-\u003enext, ++i; if (i \u003c k || !curr) break; next = curr-\u003enext; curr-\u003enext = nullptr; start = ReverseLinkedList(start); prev-\u003enext = start; end-\u003enext = next; prev = end; } return root-\u003enext; } }; 3. 双链表 328 奇偶链表 把一个链表中的奇数位节点和偶数位节点分别排在一起。\n用两个头节点分别表示奇数位和偶数位节点的起始位置，遍历整个链表，将奇数位节点链接在奇数位起始节点后，将偶数位节点链接在偶数位起始节点后，最后将偶数位起始节点链接在奇数位最后节点后即可。\nclass Solution { public: ListNode* oddEvenList(ListNode* head) { if (!head || !head-\u003enext) return head; auto odd = head, even = head-\u003enext, node = even-\u003enext, even_head = even; bool flag = true; while (node) { if (flag) { odd-\u003enext = node; odd = odd-\u003enext; flag = false; } else { even-\u003enext = node; even = even-\u003enext; flag = true; } node = node-\u003enext; } odd-\u003enext = even_head; even-\u003enext = nullptr; return head; } }; 86 分隔链表 给一个链表和一个值 x，重新排列链表使得所有小于 x 的节点都在大于等于 x 的节点之前。\n用两个头节点 sth 和 geq 分别表示小于 x 和大于等于 x 的节点的起始位置，遍历整个链表，分别将各个节点链接到两个头节点之后，最后将 geq 链接到 sth 之后，再将 geq 的末端设为空指针。\nclass Solution { public: ListNode* partition(ListNode* head, int x) { auto sth = new ListNode(0), sth_head = sth, geq = new ListNode(0), geq_head = geq; while (head) { if (head-\u003eval \u003c x) { sth-\u003enext = head; sth = sth-\u003enext; } else { geq-\u003enext = head; geq = geq-\u003enext; } head = head-\u003enext; } sth-\u003enext = geq_head-\u003enext; geq-\u003enext = nullptr; return sth_head-\u003enext; } }; 725 分隔链表 给一个链表, 将其分隔为 k 个连续的部分。\n先计算出链表的长度和 k 个连续部分中每个部分的长度，依次将每个部分的头节点放入数组中。\nclass Solution { public: vector\u003cListNode *\u003e splitListToParts(ListNode *root, int k) { vector\u003cListNode *\u003e res(k, nullptr); int len = 0; ListNode *head = root, *temp = nullptr; while (root) root = root-\u003enext, ++len; int n = len / k, m = len % k, i = 0; while (head) { res[i] = head; for (int j = 0; j \u003c n + (m \u003e 0) - 1; ++j) head = head-\u003enext; temp = head; head = head-\u003enext; temp-\u003enext = nullptr; ++i; --m; } return res; } }; ","wordCount":"1376","inLanguage":"en","datePublished":"2019-07-04T19:12:25+10:00","dateModified":"2019-07-04T19:12:25+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/leetcode/linkedlist-1/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">LeetCode 链表（1）</h1><div class=post-meta><span title='2019-07-04 19:12:25 +1000 AEST'>July 4, 2019</span>&nbsp;·&nbsp;7 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#leetcode-%e9%93%be%e8%a1%a81httpsleetcode-cncomtaglinked-list aria-label="LeetCode 链表（1）">LeetCode 链表（1）</a><ul><li><a href=#%e9%a2%98%e7%9b%ae aria-label=题目>题目</a><ul><li><a href=#1-%e5%b8%b8%e8%a7%84%e9%a2%98 aria-label="1. 常规题">1. 常规题</a><ul><li><a href=#2-%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%8a%a0httpsleetcode-cncomproblemsadd-two-numbers aria-label="2 两数相加">2 两数相加</a></li><li><a href=#21-%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8httpsleetcode-cncomproblemsmerge-two-sorted-listssubmissions aria-label="21 合并两个有序链表">21 合并两个有序链表</a></li><li><a href=#83-%e5%88%a0%e9%99%a4%e6%8e%92%e5%ba%8f%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0httpsleetcode-cncomproblemsremove-duplicates-from-sorted-listsubmissions aria-label="83 删除排序链表中的重复元素">83 删除排序链表中的重复元素</a></li><li><a href=#82-%e5%88%a0%e9%99%a4%e6%8e%92%e5%ba%8f%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0-iihttpsleetcode-cncomproblemsremove-duplicates-from-sorted-list-iisubmissions aria-label="82 删除排序链表中的重复元素 II">82 删除排序链表中的重复元素 II</a></li><li><a href=#203-%e7%a7%bb%e9%99%a4%e9%93%be%e8%a1%a8%e5%85%83%e7%b4%a0httpsleetcode-cncomproblemsremove-linked-list-elementssubmissions aria-label="203 移除链表元素">203 移除链表元素</a></li><li><a href=#817-%e9%93%be%e8%a1%a8%e7%bb%84%e4%bb%b6httpsleetcode-cncomproblemslinked-list-componentssubmissions aria-label="817 链表组件">817 链表组件</a></li><li><a href=#24-%e4%b8%a4%e4%b8%a4%e4%ba%a4%e6%8d%a2%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9httpsleetcode-cncomproblemsswap-nodes-in-pairs aria-label="24 两两交换链表中的节点">24 两两交换链表中的节点</a></li><li><a href=#430-%e6%89%81%e5%b9%b3%e5%8c%96%e5%a4%9a%e7%ba%a7%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8httpsleetcode-cncomproblemsflatten-a-multilevel-doubly-linked-listsubmissions aria-label="430 扁平化多级双向链表">430 扁平化多级双向链表</a></li></ul></li><li><a href=#2-%e9%93%be%e8%a1%a8%e5%8f%8d%e8%bd%ac aria-label="2. 链表反转">2. 链表反转</a><ul><li><a href=#206-%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8httpsleetcode-cncomproblemsreverse-linked-listsubmissions aria-label="206 反转链表">206 反转链表</a></li><li><a href=#92-%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8-iihttpsleetcode-cncomproblemsreverse-linked-list-iisubmissions aria-label="92 反转链表 II">92 反转链表 II</a></li><li><a href=#369-%e7%bb%99%e5%8d%95%e9%93%be%e8%a1%a8%e5%8a%a0%e4%b8%80httpsleetcode-cncomproblemsplus-one-linked-listsubmissions aria-label="369 给单链表加一">369 给单链表加一</a></li><li><a href=#445-%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%8a%a0-iihttpsleetcode-cncomproblemsadd-two-numbers-iisubmissions aria-label="445 两数相加 II">445 两数相加 II</a></li><li><a href=#25-k-%e4%b8%aa%e4%b8%80%e7%bb%84%e7%bf%bb%e8%bd%ac%e9%93%be%e8%a1%a8httpsleetcode-cncomproblemsreverse-nodes-in-k-group aria-label="25 K 个一组翻转链表">25 K 个一组翻转链表</a></li></ul></li><li><a href=#3-%e5%8f%8c%e9%93%be%e8%a1%a8 aria-label="3. 双链表">3. 双链表</a><ul><li><a href=#328-%e5%a5%87%e5%81%b6%e9%93%be%e8%a1%a8httpsleetcode-cncomproblemsodd-even-linked-listsubmissions aria-label="328 奇偶链表">328 奇偶链表</a></li><li><a href=#86-%e5%88%86%e9%9a%94%e9%93%be%e8%a1%a8httpsleetcode-cncomproblemspartition-list aria-label="86 分隔链表">86 分隔链表</a></li><li><a href=#725-%e5%88%86%e9%9a%94%e9%93%be%e8%a1%a8httpsleetcode-cncomproblemssplit-linked-list-in-partssubmissions aria-label="725 分隔链表">725 分隔链表</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=leetcode-链表1httpsleetcode-cncomtaglinked-list><a href=https://leetcode-cn.com/tag/linked-list/>LeetCode 链表（1）</a><a hidden class=anchor aria-hidden=true href=#leetcode-链表1httpsleetcode-cncomtaglinked-list>#</a></h1><h2 id=题目>题目<a hidden class=anchor aria-hidden=true href=#题目>#</a></h2><h3 id=1-常规题>1. 常规题<a hidden class=anchor aria-hidden=true href=#1-常规题>#</a></h3><h4 id=2-两数相加httpsleetcode-cncomproblemsadd-two-numbers><a href=https://leetcode-cn.com/problems/add-two-numbers/>2 两数相加</a><a hidden class=anchor aria-hidden=true href=#2-两数相加httpsleetcode-cncomproblemsadd-two-numbers>#</a></h4><p>给两个链表分别代表两个正数的逆序表示，计算两个链表之和。</p><p>依次按位进行相加。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span>addTwoNumbers(ListNode <span style=color:#f92672>*</span>l1, ListNode <span style=color:#f92672>*</span>l2) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> acc <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> head <span style=color:#f92672>=</span> l1, tail <span style=color:#f92672>=</span> l1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l1 <span style=color:#f92672>&amp;&amp;</span> l2) {
</span></span><span style=display:flex><span>            val <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>+</span> l2<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>+</span> acc;
</span></span><span style=display:flex><span>            acc <span style=color:#f92672>=</span> val <span style=color:#f92672>/</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>            l1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> val <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>l1<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>                l1<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> l2<span style=color:#f92672>-&gt;</span>next, l2<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>            tail <span style=color:#f92672>=</span> l1;
</span></span><span style=display:flex><span>            l1 <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>next, l2 <span style=color:#f92672>=</span> l2<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l1) {
</span></span><span style=display:flex><span>            val <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>+</span> acc;
</span></span><span style=display:flex><span>            acc <span style=color:#f92672>=</span> val <span style=color:#f92672>/</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>            l1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> val <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>            tail <span style=color:#f92672>=</span> l1;
</span></span><span style=display:flex><span>            l1 <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (acc)
</span></span><span style=display:flex><span>            tail<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=21-合并两个有序链表httpsleetcode-cncomproblemsmerge-two-sorted-listssubmissions><a href=https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/>21 合并两个有序链表</a><a hidden class=anchor aria-hidden=true href=#21-合并两个有序链表httpsleetcode-cncomproblemsmerge-two-sorted-listssubmissions>#</a></h4><p>合并两个有序链表。</p><p>逐个比较大小并添加到当前节点后面，并移动对应的链表节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> mergeTwoLists(ListNode<span style=color:#f92672>*</span> l1, ListNode<span style=color:#f92672>*</span> l2) {
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>head <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>0</span>), <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l1 <span style=color:#f92672>&amp;&amp;</span> l2) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (l1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>&lt;</span> l2<span style=color:#f92672>-&gt;</span>val)
</span></span><span style=display:flex><span>                head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> l1, l1 <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> l2, l2 <span style=color:#f92672>=</span> l2<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l1)
</span></span><span style=display:flex><span>            head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> l1, l1 <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>next, head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l2)
</span></span><span style=display:flex><span>            head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> l2, l2 <span style=color:#f92672>=</span> l2<span style=color:#f92672>-&gt;</span>next, head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=83-删除排序链表中的重复元素httpsleetcode-cncomproblemsremove-duplicates-from-sorted-listsubmissions><a href=https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/submissions/>83 删除排序链表中的重复元素</a><a hidden class=anchor aria-hidden=true href=#83-删除排序链表中的重复元素httpsleetcode-cncomproblemsremove-duplicates-from-sorted-listsubmissions>#</a></h4><p>删除链表中所有重复的节点。</p><p>将每个节点与其后面的节点的值做对比，如果相同则删除后面的节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> deleteDuplicates(ListNode<span style=color:#f92672>*</span> head) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> ret <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>&amp;&amp;</span> head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> head<span style=color:#f92672>-&gt;</span>val) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>auto</span> next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>delete</span> next;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=82-删除排序链表中的重复元素-iihttpsleetcode-cncomproblemsremove-duplicates-from-sorted-list-iisubmissions><a href=https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/submissions/>82 删除排序链表中的重复元素 II</a><a hidden class=anchor aria-hidden=true href=#82-删除排序链表中的重复元素-iihttpsleetcode-cncomproblemsremove-duplicates-from-sorted-list-iisubmissions>#</a></h4><p>删除链表中所有重复的节点，只保留原始链表中没有重复出现的数字。</p><p>为了删除所有重复的节点并只保留所有没有出现过的数字，需要提前两个节点检查接下来的两个节点的值是否相同，如果相同的话需要将这两个节点及其后的所有重复节点都删除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> deleteDuplicates(ListNode<span style=color:#f92672>*</span> head) {
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>0</span>), <span style=color:#f92672>*</span>ret <span style=color:#f92672>=</span> node, <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>, <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (node <span style=color:#f92672>&amp;&amp;</span> node<span style=color:#f92672>-&gt;</span>next) {
</span></span><span style=display:flex><span>            next <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (next <span style=color:#f92672>&amp;&amp;</span> node<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> next<span style=color:#f92672>-&gt;</span>val) {
</span></span><span style=display:flex><span>                temp <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                next <span style=color:#f92672>=</span> next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>delete</span> temp;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (next <span style=color:#f92672>!=</span> node<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next) {
</span></span><span style=display:flex><span>                temp <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>delete</span> temp;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=203-移除链表元素httpsleetcode-cncomproblemsremove-linked-list-elementssubmissions><a href=https://leetcode-cn.com/problems/remove-linked-list-elements/submissions/>203 移除链表元素</a><a hidden class=anchor aria-hidden=true href=#203-移除链表元素httpsleetcode-cncomproblemsremove-linked-list-elementssubmissions>#</a></h4><p>删除链表中等于给定值的所有节点。</p><p>先判断头节点是否等于给定值，再判断其后面的节点是否等于给定值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> removeElements(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head <span style=color:#f92672>&amp;&amp;</span> head<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> val) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> prev <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> prev;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> ret <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>&amp;&amp;</span> head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> val) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>auto</span> next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>delete</span> next;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=817-链表组件httpsleetcode-cncomproblemslinked-list-componentssubmissions><a href=https://leetcode-cn.com/problems/linked-list-components/submissions/>817 链表组件</a><a hidden class=anchor aria-hidden=true href=#817-链表组件httpsleetcode-cncomproblemslinked-list-componentssubmissions>#</a></h4><p>给一个链表和一个数组，找到链表中一段子链表的值都在数组中的子链表的个数。</p><p>先将数组转换成哈希表方便查询，再依次遍历整个链表，判断一段子链表结束时或遍历结束时子链表是否是符合条件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> numComponents(ListNode<span style=color:#f92672>*</span> head, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> G) {
</span></span><span style=display:flex><span>        unordered_set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> exist(G.begin(), G.end());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> cont <span style=color:#f92672>=</span> false, curr <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>            curr <span style=color:#f92672>=</span> exist.count(head<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>            res <span style=color:#f92672>+=</span> cont <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>curr;
</span></span><span style=display:flex><span>            cont <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res <span style=color:#f92672>+</span> cont;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=24-两两交换链表中的节点httpsleetcode-cncomproblemsswap-nodes-in-pairs><a href=https://leetcode-cn.com/problems/swap-nodes-in-pairs/>24 两两交换链表中的节点</a><a hidden class=anchor aria-hidden=true href=#24-两两交换链表中的节点httpsleetcode-cncomproblemsswap-nodes-in-pairs>#</a></h4><p>给一个链表，返回两两交换其中相邻的节点后的结果。</p><p>用三个指针把要交换的两个节点和他们的前驱节点保存下来，交换后再更新三个指针，按顺序交换即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span>swapPairs(ListNode <span style=color:#f92672>*</span>head) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>head<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>0</span>), <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> root;
</span></span><span style=display:flex><span>        root<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> first <span style=color:#f92672>=</span> head, second <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (first <span style=color:#f92672>&amp;&amp;</span> second) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> temp <span style=color:#f92672>=</span> second<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> second;
</span></span><span style=display:flex><span>            second<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> first;
</span></span><span style=display:flex><span>            first<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> first;
</span></span><span style=display:flex><span>            first <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            second <span style=color:#f92672>=</span> temp <span style=color:#f92672>?</span> temp<span style=color:#f92672>-&gt;</span>next : <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=430-扁平化多级双向链表httpsleetcode-cncomproblemsflatten-a-multilevel-doubly-linked-listsubmissions><a href=https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/submissions/>430 扁平化多级双向链表</a><a hidden class=anchor aria-hidden=true href=#430-扁平化多级双向链表httpsleetcode-cncomproblemsflatten-a-multilevel-doubly-linked-listsubmissions>#</a></h4><p>给一个带子节点的双向链表，将其扁平化并使所有结点出现在单级双链表中。</p><p>对于某一个节点，如果它有 child 节点，那么需要将其 child 节点作为其新的 next 节点，将其 child 链表上的最后一个节点作为其原本 next 节点的 prev 节点，递归调用整个过程即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>flatten(Node <span style=color:#f92672>*</span>head) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        Node <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> head, <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (node) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>child) {
</span></span><span style=display:flex><span>                next <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>auto</span> child <span style=color:#f92672>=</span> flatten(node<span style=color:#f92672>-&gt;</span>child);
</span></span><span style=display:flex><span>                node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> child;
</span></span><span style=display:flex><span>                child<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>                node<span style=color:#f92672>-&gt;</span>child <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (node<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>                    node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (next)
</span></span><span style=display:flex><span>                    next<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=2-链表反转>2. 链表反转<a hidden class=anchor aria-hidden=true href=#2-链表反转>#</a></h3><h4 id=206-反转链表httpsleetcode-cncomproblemsreverse-linked-listsubmissions><a href=https://leetcode-cn.com/problems/reverse-linked-list/submissions/>206 反转链表</a><a hidden class=anchor aria-hidden=true href=#206-反转链表httpsleetcode-cncomproblemsreverse-linked-listsubmissions>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> reverseList(ListNode<span style=color:#f92672>*</span> head) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>, <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> head, <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (curr) {
</span></span><span style=display:flex><span>            next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> prev;
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>            curr <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=92-反转链表-iihttpsleetcode-cncomproblemsreverse-linked-list-iisubmissions><a href=https://leetcode-cn.com/problems/reverse-linked-list-ii/submissions/>92 反转链表 II</a><a hidden class=anchor aria-hidden=true href=#92-反转链表-iihttpsleetcode-cncomproblemsreverse-linked-list-iisubmissions>#</a></h4><p>将链表中从 m 到 n 位置的节点反转。</p><p>先找到位置在 m - 1 的节点，将其后的节点截断，再找到位置在 n 的节点，将其后的节点截断，将中间的一段链表反转后再链接到愿链表上。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span>reverseBetween(ListNode <span style=color:#f92672>*</span>head, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>0</span>), <span style=color:#f92672>*</span>r <span style=color:#f92672>=</span> root, <span style=color:#f92672>*</span>prev, <span style=color:#f92672>*</span>last;
</span></span><span style=display:flex><span>        root<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (cnt <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> r)
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> r<span style=color:#f92672>-&gt;</span>next, <span style=color:#f92672>++</span>cnt;
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (cnt <span style=color:#f92672>&lt;=</span> n <span style=color:#f92672>&amp;&amp;</span> r <span style=color:#f92672>&amp;&amp;</span> r<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> r<span style=color:#f92672>-&gt;</span>next, <span style=color:#f92672>++</span>cnt;
</span></span><span style=display:flex><span>        last <span style=color:#f92672>=</span> r<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        r<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> Reverse(prev<span style=color:#f92672>-&gt;</span>next);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (prev <span style=color:#f92672>&amp;&amp;</span> prev<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> prev<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> last;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span><span style=color:#a6e22e>Reverse</span>(ListNode <span style=color:#f92672>*</span>head) {
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>, <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> head, <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (curr) {
</span></span><span style=display:flex><span>            next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> prev;
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>            curr <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=369-给单链表加一httpsleetcode-cncomproblemsplus-one-linked-listsubmissions><a href=https://leetcode-cn.com/problems/plus-one-linked-list/submissions/>369 给单链表加一</a><a hidden class=anchor aria-hidden=true href=#369-给单链表加一httpsleetcode-cncomproblemsplus-one-linked-listsubmissions>#</a></h4><p>用一个单链表表示一个整数，计算将其加一的结果。</p><p>先将链表反转方便进位，然后进行加一和进位的操作，最后再反转一次链表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> plusOne(ListNode<span style=color:#f92672>*</span> head) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> Reverse(head);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> root <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (head<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span>) {
</span></span><span style=display:flex><span>                head<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head<span style=color:#f92672>-&gt;</span>next) {
</span></span><span style=display:flex><span>                    head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#f92672>++</span>head<span style=color:#f92672>-&gt;</span>val;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Reverse</span>(root);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span><span style=color:#a6e22e>Reverse</span>(ListNode<span style=color:#f92672>*</span> head) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>, <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> head, <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (curr) {
</span></span><span style=display:flex><span>            next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> prev;
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>            curr <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=445-两数相加-iihttpsleetcode-cncomproblemsadd-two-numbers-iisubmissions><a href=https://leetcode-cn.com/problems/add-two-numbers-ii/submissions/>445 两数相加 II</a><a hidden class=anchor aria-hidden=true href=#445-两数相加-iihttpsleetcode-cncomproblemsadd-two-numbers-iisubmissions>#</a></h4><p>给两个链表分别代表两个正数，计算两个链表之和。</p><p>先将两个链表反转，再依次按位进行相加，最后再将得到的结果反转并返回。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span>addTwoNumbers(ListNode <span style=color:#f92672>*</span>l1, ListNode <span style=color:#f92672>*</span>l2) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>l1 <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>l2)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>l1 <span style=color:#f92672>?</span> l2 : l1;
</span></span><span style=display:flex><span>        l1 <span style=color:#f92672>=</span> Reverse(l1);
</span></span><span style=display:flex><span>        l2 <span style=color:#f92672>=</span> Reverse(l2);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> carry <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>head <span style=color:#f92672>=</span> l1, <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> l1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l1 <span style=color:#f92672>&amp;&amp;</span> l2) {
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> l1;
</span></span><span style=display:flex><span>            sum <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>+</span> l2<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>+</span> carry;
</span></span><span style=display:flex><span>            carry <span style=color:#f92672>=</span> sum <span style=color:#f92672>/</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>            l1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> sum <span style=color:#f92672>-</span> carry <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (l2<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>l1<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>                l1<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> l2<span style=color:#f92672>-&gt;</span>next, l2<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>            l1 <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            l2 <span style=color:#f92672>=</span> l2<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l1) {
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> l1;
</span></span><span style=display:flex><span>            sum <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>+</span> carry;
</span></span><span style=display:flex><span>            carry <span style=color:#f92672>=</span> sum <span style=color:#f92672>/</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>            l1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> sum <span style=color:#f92672>-</span> carry <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>            l1 <span style=color:#f92672>=</span> l1<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (carry <span style=color:#f92672>&amp;&amp;</span> prev)
</span></span><span style=display:flex><span>            prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Reverse</span>(head);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span><span style=color:#a6e22e>Reverse</span>(ListNode <span style=color:#f92672>*</span>head) {
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>, <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> head, <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (curr) {
</span></span><span style=display:flex><span>            next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> prev;
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>            curr <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=25-k-个一组翻转链表httpsleetcode-cncomproblemsreverse-nodes-in-k-group><a href=https://leetcode-cn.com/problems/reverse-nodes-in-k-group/>25 K 个一组翻转链表</a><a hidden class=anchor aria-hidden=true href=#25-k-个一组翻转链表httpsleetcode-cncomproblemsreverse-nodes-in-k-group>#</a></h4><p>给一个链表，每 k 个节点一组进行翻转。</p><p>用几个指针记录下需要反转的部分的起始，终止位置，依次反转即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span><span style=color:#a6e22e>ReverseLinkedList</span>(ListNode <span style=color:#f92672>*</span>head) {
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>, <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> head, <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (curr) {
</span></span><span style=display:flex><span>            next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> prev;
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>            curr <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span>reverseKGroup(ListNode <span style=color:#f92672>*</span>head, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>0</span>), <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> root;
</span></span><span style=display:flex><span>        prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (prev) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            ListNode <span style=color:#f92672>*</span>start <span style=color:#f92672>=</span> prev<span style=color:#f92672>-&gt;</span>next, <span style=color:#f92672>*</span>end <span style=color:#f92672>=</span> prev<span style=color:#f92672>-&gt;</span>next, <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> end, <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (curr <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;</span> k)
</span></span><span style=display:flex><span>                curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next, <span style=color:#f92672>++</span>i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;</span> k <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>curr)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>            start <span style=color:#f92672>=</span> ReverseLinkedList(start);
</span></span><span style=display:flex><span>            prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> start;
</span></span><span style=display:flex><span>            end<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> end;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=3-双链表>3. 双链表<a hidden class=anchor aria-hidden=true href=#3-双链表>#</a></h3><h4 id=328-奇偶链表httpsleetcode-cncomproblemsodd-even-linked-listsubmissions><a href=https://leetcode-cn.com/problems/odd-even-linked-list/submissions/>328 奇偶链表</a><a hidden class=anchor aria-hidden=true href=#328-奇偶链表httpsleetcode-cncomproblemsodd-even-linked-listsubmissions>#</a></h4><p>把一个链表中的奇数位节点和偶数位节点分别排在一起。</p><p>用两个头节点分别表示奇数位和偶数位节点的起始位置，遍历整个链表，将奇数位节点链接在奇数位起始节点后，将偶数位节点链接在偶数位起始节点后，最后将偶数位起始节点链接在奇数位最后节点后即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> oddEvenList(ListNode<span style=color:#f92672>*</span> head) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>head<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> odd <span style=color:#f92672>=</span> head, even <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next, node <span style=color:#f92672>=</span> even<span style=color:#f92672>-&gt;</span>next, even_head <span style=color:#f92672>=</span> even;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> flag <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (node) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (flag) {
</span></span><span style=display:flex><span>                odd<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>                odd <span style=color:#f92672>=</span> odd<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                flag <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                even<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>                even <span style=color:#f92672>=</span> even<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                flag <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        odd<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> even_head;
</span></span><span style=display:flex><span>        even<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=86-分隔链表httpsleetcode-cncomproblemspartition-list><a href=https://leetcode-cn.com/problems/partition-list/>86 分隔链表</a><a hidden class=anchor aria-hidden=true href=#86-分隔链表httpsleetcode-cncomproblemspartition-list>#</a></h4><p>给一个链表和一个值 x，重新排列链表使得所有小于 x 的节点都在大于等于 x 的节点之前。</p><p>用两个头节点 sth 和 geq 分别表示小于 x 和大于等于 x 的节点的起始位置，遍历整个链表，分别将各个节点链接到两个头节点之后，最后将 geq 链接到 sth 之后，再将 geq 的末端设为空指针。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> partition(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> sth <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>0</span>), sth_head <span style=color:#f92672>=</span> sth, geq <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#ae81ff>0</span>), geq_head <span style=color:#f92672>=</span> geq;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (head<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>&lt;</span> x) {
</span></span><span style=display:flex><span>                sth<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>                sth <span style=color:#f92672>=</span> sth<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                geq<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>                geq <span style=color:#f92672>=</span> geq<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        sth<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> geq_head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        geq<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sth_head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=725-分隔链表httpsleetcode-cncomproblemssplit-linked-list-in-partssubmissions><a href=https://leetcode-cn.com/problems/split-linked-list-in-parts/submissions/>725 分隔链表</a><a hidden class=anchor aria-hidden=true href=#725-分隔链表httpsleetcode-cncomproblemssplit-linked-list-in-partssubmissions>#</a></h4><p>给一个链表, 将其分隔为 k 个连续的部分。</p><p>先计算出链表的长度和 k 个连续部分中每个部分的长度，依次将每个部分的头节点放入数组中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>ListNode <span style=color:#f92672>*&gt;</span> splitListToParts(ListNode <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>ListNode <span style=color:#f92672>*&gt;</span> res(k, <span style=color:#66d9ef>nullptr</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        ListNode <span style=color:#f92672>*</span>head <span style=color:#f92672>=</span> root, <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (root)
</span></span><span style=display:flex><span>            root <span style=color:#f92672>=</span> root<span style=color:#f92672>-&gt;</span>next, <span style=color:#f92672>++</span>len;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> len <span style=color:#f92672>/</span> k, m <span style=color:#f92672>=</span> len <span style=color:#f92672>%</span> k, i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>            res[i] <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>+</span> (m <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>                head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            temp <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            temp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>i;
</span></span><span style=display:flex><span>            <span style=color:#f92672>--</span>m;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/leetcode/linkedlist-2/><span class=title>« Prev</span><br><span>LeetCode 链表（2）</span>
</a><a class=next href=https://prov1dence.top/posts/leetcode/dynamicprogramming-3/><span class=title>Next »</span><br><span>LeetCode 动态规划（3）</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>