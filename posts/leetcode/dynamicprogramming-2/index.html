<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>LeetCode 动态规划（2） | 尾張</title>
<meta name=keywords content>
<meta name=description content="LeetCode 动态规划 题目 3. 数组相关 300 最长上升子序列 在无序数组中找到最长上升子序列的长度。
用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的每个数字 j，如果 nums[i] > nums[j]，那么 j 和 i 可以形成一个上升子序列，让 dp[i] = max(dp[i], dp[j] + 1) 就能得到最长的上升子序列了。
class Solution { public: int lengthOfLIS(vector<int>& nums) { int n = nums.size(), res = 2; if (n <= 1) return n; vector<int> dp(n, 1); for (int i = 1; i < n; ++i) for (int j = 0; j < i; ++j) if (nums[i] > nums[j]) { dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); } return res; } }; 53 最大子序和 找一个数组中具有最大和的连续子数组的和。">
<meta name=author content>
<link rel=canonical href=http://zintrulcre.github.io/posts/leetcode/dynamicprogramming-2/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="LeetCode 动态规划（2）">
<meta property="og:description" content="LeetCode 动态规划 题目 3. 数组相关 300 最长上升子序列 在无序数组中找到最长上升子序列的长度。
用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的每个数字 j，如果 nums[i] > nums[j]，那么 j 和 i 可以形成一个上升子序列，让 dp[i] = max(dp[i], dp[j] + 1) 就能得到最长的上升子序列了。
class Solution { public: int lengthOfLIS(vector<int>& nums) { int n = nums.size(), res = 2; if (n <= 1) return n; vector<int> dp(n, 1); for (int i = 1; i < n; ++i) for (int j = 0; j < i; ++j) if (nums[i] > nums[j]) { dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); } return res; } }; 53 最大子序和 找一个数组中具有最大和的连续子数组的和。">
<meta property="og:type" content="article">
<meta property="og:url" content="http://zintrulcre.github.io/posts/leetcode/dynamicprogramming-2/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-06-28T10:09:13+10:00">
<meta property="article:modified_time" content="2019-06-28T10:09:13+10:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="LeetCode 动态规划（2）">
<meta name=twitter:description content="LeetCode 动态规划 题目 3. 数组相关 300 最长上升子序列 在无序数组中找到最长上升子序列的长度。
用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的每个数字 j，如果 nums[i] > nums[j]，那么 j 和 i 可以形成一个上升子序列，让 dp[i] = max(dp[i], dp[j] + 1) 就能得到最长的上升子序列了。
class Solution { public: int lengthOfLIS(vector<int>& nums) { int n = nums.size(), res = 2; if (n <= 1) return n; vector<int> dp(n, 1); for (int i = 1; i < n; ++i) for (int j = 0; j < i; ++j) if (nums[i] > nums[j]) { dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); } return res; } }; 53 最大子序和 找一个数组中具有最大和的连续子数组的和。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://zintrulcre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode 动态规划（2）","item":"http://zintrulcre.github.io/posts/leetcode/dynamicprogramming-2/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode 动态规划（2）","name":"LeetCode 动态规划（2）","description":"LeetCode 动态规划 题目 3. 数组相关 300 最长上升子序列 在无序数组中找到最长上升子序列的长度。\n用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的每个数字 j，如果 nums[i] \u0026gt; nums[j]，那么 j 和 i 可以形成一个上升子序列，让 dp[i] = max(dp[i], dp[j] + 1) 就能得到最长的上升子序列了。\nclass Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(), res = 2; if (n \u0026lt;= 1) return n; vector\u0026lt;int\u0026gt; dp(n, 1); for (int i = 1; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; i; ++j) if (nums[i] \u0026gt; nums[j]) { dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); } return res; } }; 53 最大子序和 找一个数组中具有最大和的连续子数组的和。","keywords":[],"articleBody":"LeetCode 动态规划 题目 3. 数组相关 300 最长上升子序列 在无序数组中找到最长上升子序列的长度。\n用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的每个数字 j，如果 nums[i]  nums[j]，那么 j 和 i 可以形成一个上升子序列，让 dp[i] = max(dp[i], dp[j] + 1) 就能得到最长的上升子序列了。\nclass Solution { public: int lengthOfLIS(vectorint\u0026 nums) { int n = nums.size(), res = 2; if (n  1) return n; vectorint dp(n, 1); for (int i = 1; i  n; ++i) for (int j = 0; j  i; ++j) if (nums[i]  nums[j]) { dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); } return res; } }; 53 最大子序和 找一个数组中具有最大和的连续子数组的和。\n从头开始用一个变量 val 保存到当前数为止的连续子数组和，每一个数对于之前的连续子数组和只有加与不加两种选择，当之前的连续子数组和大于 0 时加上之前的连续子数组和，否则不加。\nclass Solution { public: int maxSubArray(vectorint \u0026nums) { int res = INT_MIN, val = 0; for (auto \u0026n:nums) { val = max(val, 0) + n; res = max(res, val); } return res; } }; 718 最长重复子数组 给两个数组，求两个数组中公共的长度最长的子数组的长度。\n对于某两个字符 A[i] 和 B[j]，如果 A[i] == B[j]，则代表 A[i]，B[j] 与他们之前的子数组有可能是公共子数组，其最长长度 dp[i][j] = dp[i - 1][j - 1] + 1，否则他们不能组成公共子数组，dp[i][j] = 0。用两层循环遍历两个数组即可，时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\nclass Solution { public: int findLength(vectorint \u0026A, vectorint \u0026B) { int m = A.size(), n = B.size(), res = 0; if (m == 0 || n == 0) return 0; vectorvectorint dp(m + 1, vectorint(n + 1, 0)); for (int i = 1; i  m; ++i) for (int j = 1; j  n; ++j) { dp[i][j] = A[i - 1] == B[j - 1] ? dp[i - 1][j - 1] + 1 : 0; res = max(res, dp[i][j]); } return res; } }; 983 最低票价 给出要旅行的所有日期，有三种通行证：一日票，七日票，三十日票。求最低消费。\n对于第 i 天的最低消费，只需要选出一天前的最低消费加上一日票的消费，七天前的最低消费加上七日票，三十天前的最低消费加上三十日票这三种消费中最低的即可，因此有状态转移方程 dp[i] = min({dp[i - 1] + costs[0], dp[i - 7] + costs[1], dp[i - 30] + costs[2]})。\nclass Solution { public: int mincostTickets(vectorint \u0026days, vectorint \u0026costs) { vectorint dp(366, INT_MAX); dp[0] = 0; int j = 0, n = days.size(); for (int i = 1; i  365 \u0026\u0026 j  n; ++i) { if (i == days[j]) { dp[i] = min({dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2]}); ++j; } else dp[i] = dp[i - 1]; } return dp[days[n - 1]]; } }; 813 最大平均值和的分组 将数组分为 K 个相邻的非空子数组，求所有子数组的平均值的和的最大值。\n用二维数组 dp[n][K] 来表示前 i 个数分成 k 组得到的最优值，每次将从第 j 个数到第 n 个数分为一组，将前面 j - 1 个数分为 k - 1 组，求得 dp[i][k] 的最大值。为了快速地算出第 j 个数到第 n 个数的和以及前 j - 1 个数的和，可以用一个前缀和数组将前 m 个数的和保存下来，再用状态转移方程 dp[i][k] = max(dp[i][k], dp[j][k - 1] + (pre[i] - pre[j]) / (i - j)) 求得最优值。\nclass Solution { public: double largestSumOfAverages(vectorint \u0026A, int K) { int n = A.size(); if (n == 0) return 0; vectordouble pre(n + 1, 0); for (int i = 1; i  n; ++i) pre[i] += pre[i - 1] + A[i - 1]; vectorvectordouble dp(n + 1, vectordouble(K + 1, 0)); for (int i = 1; i  n; ++i) { dp[i][1] = pre[i] / i; for (int k = 2; k  K \u0026\u0026 k  i; ++k) for (int j = 1; j  i; ++j) dp[i][k] = max(dp[i][k], dp[j][k - 1] + (pre[i] - pre[j]) / (i - j)); } return dp[n][K]; } }; 646 最长数对链 按照每个数对的第一个元素从小到大排序，从第二个数对开始，依次判断其与其前面的所有数对是否符合题意，是的话则 dp[j] = max(dp[j], dp[i] + 1）。时间复杂度是 O(n^2)。\nclass Solution { public: int findLongestChain(vectorvectorint\u0026 pairs) { sort(pairs.begin(), pairs.end()); int n = pairs.size(), res = 1; vectorint dp(n, 1); for (int j = 1; j  n; ++j) for (int i = 0; i  j; ++i) if (pairs[j][0]  pairs[i][1]) { dp[j] = max(dp[j], dp[i] + 1); res = max(res, dp[j]); } return res; } }; 4. 等差数列 413 等差数列划分 给一个数组，计算数组中等差子数组的个数。\n等差数列必须是相邻两个元素之差相等的长度大于 3 的子数组，因此只需要知道 nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 1] 即可。用一个变量 cul 表示到目前为止等差数列的长度，diff 表示之前的公差，如果目前的差等于 diff 则加上 cul。时间复杂度是 O(n)，空间复杂度是 O(1)。\nclass Solution { public: int numberOfArithmeticSlices(vectorint\u0026 nums) { int res = 0, n = nums.size(), cul = 1, curr = 0; if (n  3) return 0; int diff = nums[1] - nums[0]; for (int i = 2; i  n; ++i) { if ((curr = nums[i] - nums[i - 1]) == diff) { res += cul; ++cul; } else { diff = curr; cul = 1; } } return res; } }; 446 等差数列划分 II - 子序列 给一个数组，计算数组中等差子序列的个数。\n对于某一个数 nums[i]，已知其与其之前某一个数的差 diff = nums[i] - nums[j]，需要知道在 nums[j] 之前公差为 diff 的等差子序列的最大个数，可以用一个哈希表数组来表示数 nums[j] 之前公差为 diff 的等差子序列的最大个数，如果 nums[i] - nums[j] == diff 则到位置 i 为止公差为 diff 的等差子序列的个数 dp[i][diff] += dp[j][diff]，注意要用 += 而不是 =，因为如果在 nums[i] 之前有多个相同的数字那么需要把每一个都算作一个独立的等差子序列。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。很搞笑的是这道题的动态规划解法在 LeetCode 上提交的时候 runtime 是 1000ms +-，而在LeetCode-CN 上提交的时候执行用时是 1400ms ~ 1800ms，而且偶尔还会超时，超时的 case 的公差超过了 int32 的表示范围，如果加上判断 diff INT_MAX 直接 continue 就能正常通过了。\nclass Solution { public: int numberOfArithmeticSlices(vectorint\u0026 A) { int n = A.size(), res = 0; long long diff = 0; vectorunordered_maplong long, int dp(n); for (int i = 1; i  n; ++i) { for (int j = 0; j  i; ++j) { diff = static_castlong long(A[i]) - A[j]; if (diff  INT_MIN || diff  INT_MAX) continue; dp[i][diff] += dp[j][diff] + 1; res += dp[j][diff]; } } return res; } }; 1027 最长等差数列 给一个数组，计算数组中最长等差子序列的长度。\n对于某一个数 nums[i]，已知其与其之前某一个数的差 diff = nums[i] - nums[j]，需要知道在 nums[j] 之前公差为 diff 的等差子序列有多长，可以用一个哈希表数组来表示每一个数之前公差为 diff 的等差子序列的最长长度，在此基础上 +1 即可得到最长的等差子序列的长度。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。\nclass Solution { public: int longestArithSeqLength(vectorint \u0026A) { int n = A.size(), res = 2; vectorunordered_mapint, int dp(n); for (int i = 1; i  n; ++i) { for (int j = 0; j  i; ++j) { int diff = A[i] - A[j]; if (dp[j].find(diff) == dp[j].end()) dp[i][diff] = 2; else { dp[i][diff] = dp[j][diff] + 1; res = max(res, dp[i][diff]); } } } return res; } }; 5. 斐波那契数列 70 爬楼梯 每次能爬 1 或 2 阶楼梯，求爬 n 阶楼梯有多少种方法。\n爬到当前楼梯的方法等于爬到前两阶楼梯的方法之和，因此有状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]，又因为当前状态只取决于前两个状态，因此可以只使用两个变量 s1 和 s2 来保存前两个状态的结果。时间复杂度是 O(n)，空间复杂度是 O(1)。\nclass Solution { public: int climbStairs(int n) { if (n  1) return 1; int s1 = 1, s2 = 1, temp; for (int i = 1; i  n; ++i) { temp = s2; s2 += s1; s1 = temp; } return s2; } }; 746 使用最小花费爬楼梯 每次能爬 1 或 2 阶楼梯，每一阶楼梯有一个权值，求爬 n 阶楼梯的最小花费。\n和上一题类似，不过每次只需要取前两阶楼梯中权值较小的就可以了。\nclass Solution { public: int minCostClimbingStairs(vectorint\u0026 cost) { int n = cost.size(); if (n == 0) return 0; else if (n == 1) return cost[0]; else if (n == 2) return cost[0] + cost[1]; int s1 = cost[0], s2 = cost[1]; for (int i = 2; i  n; ++i) { int temp = s2; s2 = min(s1, s2) + cost[i]; s1 = temp; } return min(s1, s2); } }; 740 删除与获得点数 给一个数组，每次任选一个 nums[i]，获得 nums[i] 的个数乘以 nums[i] 的点数，计算能获得的最大点数。\n对于 nums[i]，能取到的最大点数只能是 nums[i - 1] 的最大点数或 nums[i - 2] 的最大点书加上 nums[i] 能获得的点数，因此有状态转移方程 dp[i] = max(dp[i - 1], dp[i - 2] + val[i])，时间复杂度是 O(n)。每个点只与其之前两个点有关，因此可以只使用两个变量 p1 和 p2 来保存前两个点的结果，空间复杂度是 O(1)。\nclass Solution { public: int deleteAndEarn(vectorint\u0026 nums) { vectorint val(10001, 0); for (auto \u0026m:nums) val[m] += m; int res = 0, prev = 0, curr = 0; for (int i = 1; i  10000; ++i) { res = max(curr, prev + val[i]); prev = curr; curr = res; } return res; } }; 198 打家劫舍 给一个带权值的数组，取不相邻的数，求能取到的最大值。\n对于某一点，如果到之前一点为止能取到的最大值大于取当前点与之前两点的最大值的和则不取，否则取当前点，当前点的值与之前两点的最大值之和就是当前点的最优值，因此有状态转移方程 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])，时间复杂度是 O(n)。当前点只与之前两个点有关，因此可以只使用两个变量 p1 和 p2 来保存前两个点的结果，空间复杂度是 O(1)。\nclass Solution { public: int rob(vectorint\u0026 nums) { int n = nums.size(); if (n  2) return n == 0 ? 0 : n == 1 ? nums[0] : max(nums[0], nums[1]); int p1 = nums[0], p2 = max(nums[0], nums[1]), temp; for (int i = 2; i  n; ++i) { temp = p2; p2 = max(p1 + nums[i], p2); p1 = temp; } return p2; } }; 213 打家劫舍 II 给一个带权值的数组，数组首尾相邻，取不相邻的数，求能取到的最大值。\n数组首尾相邻代表不能同时取第一个点和最后一个点，因此从第一个点到倒数第二个点进行动态规划得到的就是包含第一个点而不包含最后一个点能取到的最大值，从第二个点到最后一个点进行动态规划得到的就是包含最后一个点而不包含第一个点能取到的最大值，用于上一题同样的方法分别做两次就能得到结果。时间复杂度是 O(n)，空间复杂度是 O(1)。\nclass Solution { public: int rob(vector\u0026 nums) { int res = 0, n = nums.size(); if (n 337 打家劫舍 III 给一个带权值的二叉树，取不相邻的数，求能取到的最大值。\n对于一个节点，如果取节点本身则不能取两个子节点，如果取两个子节点则不能去其本身和四个子节点，因此对比其两个子节点的和与其本身和四个孙子节点的和，取最大值返回，也就是 max(dp[node-left-left] + dp [node-left-right] + dp[node-right-left] + dp [node-right-right] + dp[node], dp[node-left] + dp[node-right])。因为递归会造成大量的重复计算，因此用一个哈希表把已经计算过的节点的最优值保存下来，递归到该节点的时候直接取值防止造成TLE。时间复杂度是 O(n)，空间复杂度是 O(n)。\nclass Solution { unordered_mapTreeNode *, int val; public: int rob(TreeNode *node) { if (!node) return 0; if (val.find(node) != val.end()) return val[node]; int p1 = 0, p2 = 0; if (node-left) p1 += rob(node-left-left) + rob(node-left-right); if (node-right) p1 += rob(node-right-left) + rob(node-right-right); p1 += node-val; p2 += rob(node-left) + rob(node-right); val[node] = max(p1, p2); return val[node]; } } 96 不同的二叉搜索树 求有 n 个节点的二叉搜索树有多少种。\n对于某一个数 i 作为根结点时，无论 i 是多少，其左子树左子树总是由 i - 1 个节点构成的，而其右节点总是由 n - i 个节点构成的，例如 n = 3 时，如果让 3 作为根节点，那么其左子树一定是由 1 和 2 两个节点构成的，那么我们只需要知道由两个节点构成的二叉搜索树有多少种，再用这个左子树的种类数 dp[2] 乘以右子树的种类数 dp[0] 就能知道由 3 个节点构成的，以 3 作为根节点的种类数，其次需要依次让 1 和 2 作为根节点，那么他们的左子树分别有 dp[0] 和 dp[1] 种构成的方法，因此得到状态转移方程 dp[i] += dp[j - 1] * dp[i - j]，时间复杂度是 O(n ^ 2)，空间复杂度是 O(n)。\nclass Solution { public: int numTrees(int n) { vectorint dp(n + 1, 0); dp[0] = dp[1] = 1; for (int i = 2; i  n; ++i) for (int j = 1; j  i; ++j) dp[i] += dp[j - 1] * dp[i - j]; return dp[n]; } }; 873 最长的斐波那契子序列的长度 给一个严格递增的数组，找到其中最长的斐波那契子序列的长度。\n根据斐波那契数列的定义，要判断 A[i] 和 A[j] 能否在原数组中构成斐波那契数列，只需要知道 A[i - j] 是否在原数组中，并且 A[i] - A[j] 注意在判断下标是否存在于哈希表中时要用 pos.find(A[i] - A[j]) == pos.end()，而不能直接用 pos[A[i] - A[j]] 来获取，这样虽然如果 A[i] - A[j] 不存在于哈希表中仍然能够得到结果 0，但效率非常低，会导致TLE。\nclass Solution { public: int lenLongestFibSubseq(vectorint \u0026A) { int n = A.size(), res = 0; vectorvectorint dp(n, vectorint(n, 0)); unordered_mapint, int pos; for (int i = 0; i  n; ++i) { pos[A[i]] = i; for (int j = 0; j  i; ++j) { auto k = pos.find(A[i] - A[j]) == pos.end() ? -1 : pos[A[i] - A[j]]; dp[i][j] = A[i] - A[j]  A[j] \u0026\u0026 k != -1 ? dp[j][k] + 1 : 2; res = max(res, dp[i][j]); } } return res  3 ? 0 : res; } }; ","wordCount":"1700","inLanguage":"en","datePublished":"2019-06-28T10:09:13+10:00","dateModified":"2019-06-28T10:09:13+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://zintrulcre.github.io/posts/leetcode/dynamicprogramming-2/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://zintrulcre.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://zintrulcre.github.io/archives/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=http://zintrulcre.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://zintrulcre.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://zintrulcre.github.io/posts/>Posts</a></div>
<h1 class=post-title>
LeetCode 动态规划（2）
</h1>
<div class=post-meta><span title="2019-06-28 10:09:13 +1000 +1000">June 28, 2019</span>&nbsp;·&nbsp;8 min
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#leetcode-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92httpsleetcode-cncomproblemsetallsearche4b891e695b0 aria-label="LeetCode 动态规划"><a href="https://leetcode-cn.com/problemset/all/?search=%E4%B8%91%E6%95%B0">LeetCode 动态规划</a></a><ul>
<li>
<a href=#%e9%a2%98%e7%9b%ae aria-label=题目>题目</a><ul>
<li>
<a href=#3-%e6%95%b0%e7%bb%84%e7%9b%b8%e5%85%b3 aria-label="3. 数组相关">3. 数组相关</a><ul>
<li>
<a href=#300-%e6%9c%80%e9%95%bf%e4%b8%8a%e5%8d%87%e5%ad%90%e5%ba%8f%e5%88%97httpsleetcode-cncomproblemslongest-increasing-subsequencesubmissions aria-label="300 最长上升子序列"><a href=https://leetcode-cn.com/problems/longest-increasing-subsequence/submissions/>300 最长上升子序列</a></a></li>
<li>
<a href=#53-%e6%9c%80%e5%a4%a7%e5%ad%90%e5%ba%8f%e5%92%8chttpsleetcode-cncomproblemsmaximum-subarray aria-label="53 最大子序和"><a href=https://leetcode-cn.com/problems/maximum-subarray/>53 最大子序和</a></a></li>
<li>
<a href=#718-%e6%9c%80%e9%95%bf%e9%87%8d%e5%a4%8d%e5%ad%90%e6%95%b0%e7%bb%84httpsleetcode-cncomproblemsmaximum-length-of-repeated-subarray aria-label="718 最长重复子数组"><a href=https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/>718 最长重复子数组</a></a></li>
<li>
<a href=#983-%e6%9c%80%e4%bd%8e%e7%a5%a8%e4%bb%b7httpsleetcode-cncomproblemsminimum-cost-for-tickets aria-label="983 最低票价"><a href=https://leetcode-cn.com/problems/minimum-cost-for-tickets/>983 最低票价</a></a></li>
<li>
<a href=#813-%e6%9c%80%e5%a4%a7%e5%b9%b3%e5%9d%87%e5%80%bc%e5%92%8c%e7%9a%84%e5%88%86%e7%bb%84httpsleetcode-cncomproblemslargest-sum-of-averages aria-label="813 最大平均值和的分组"><a href=https://leetcode-cn.com/problems/largest-sum-of-averages/>813 最大平均值和的分组</a></a></li>
<li>
<a href=#646-%e6%9c%80%e9%95%bf%e6%95%b0%e5%af%b9%e9%93%behttpsleetcode-cncomproblemsmaximum-length-of-pair-chain aria-label="646 最长数对链"><a href=https://leetcode-cn.com/problems/maximum-length-of-pair-chain/>646 最长数对链</a></a></li></ul>
</li>
<li>
<a href=#4-%e7%ad%89%e5%b7%ae%e6%95%b0%e5%88%97 aria-label="4. 等差数列">4. 等差数列</a><ul>
<li>
<a href=#413-%e7%ad%89%e5%b7%ae%e6%95%b0%e5%88%97%e5%88%92%e5%88%86httpsleetcode-cncomproblemsarithmetic-slices aria-label="413 等差数列划分"><a href=https://leetcode-cn.com/problems/arithmetic-slices/>413 等差数列划分</a></a></li>
<li>
<a href=#446-%e7%ad%89%e5%b7%ae%e6%95%b0%e5%88%97%e5%88%92%e5%88%86-ii---%e5%ad%90%e5%ba%8f%e5%88%97httpsleetcode-cncomproblemsarithmetic-slices-ii-subsequence aria-label="446 等差数列划分 II - 子序列"><a href=https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/>446 等差数列划分 II - 子序列</a></a></li>
<li>
<a href=#1027-%e6%9c%80%e9%95%bf%e7%ad%89%e5%b7%ae%e6%95%b0%e5%88%97httpsleetcode-cncomproblemslongest-arithmetic-sequencesubmissions aria-label="1027 最长等差数列"><a href=https://leetcode-cn.com/problems/longest-arithmetic-sequence/submissions/>1027 最长等差数列</a></a></li></ul>
</li>
<li>
<a href=#5-%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97 aria-label="5. 斐波那契数列">5. 斐波那契数列</a><ul>
<li>
<a href=#70-%e7%88%ac%e6%a5%bc%e6%a2%afhttpsleetcode-cncomproblemsclimbing-stairs aria-label="70 爬楼梯"><a href=https://leetcode-cn.com/problems/climbing-stairs/>70 爬楼梯</a></a></li>
<li>
<a href=#746-%e4%bd%bf%e7%94%a8%e6%9c%80%e5%b0%8f%e8%8a%b1%e8%b4%b9%e7%88%ac%e6%a5%bc%e6%a2%afhttpsleetcode-cncomproblemsmin-cost-climbing-stairs aria-label="746 使用最小花费爬楼梯"><a href=https://leetcode-cn.com/problems/min-cost-climbing-stairs/>746 使用最小花费爬楼梯</a></a></li>
<li>
<a href=#740-%e5%88%a0%e9%99%a4%e4%b8%8e%e8%8e%b7%e5%be%97%e7%82%b9%e6%95%b0httpsleetcode-cncomproblemsdelete-and-earn aria-label="740 删除与获得点数"><a href=https://leetcode-cn.com/problems/delete-and-earn/>740 删除与获得点数</a></a></li>
<li>
<a href=#198-%e6%89%93%e5%ae%b6%e5%8a%ab%e8%88%8dhttpsleetcode-cncomproblemshouse-robber aria-label="198 打家劫舍"><a href=https://leetcode-cn.com/problems/house-robber/>198 打家劫舍</a></a></li>
<li>
<a href=#213-%e6%89%93%e5%ae%b6%e5%8a%ab%e8%88%8d-iihttpsleetcode-cncomproblemshouse-robber-ii aria-label="213 打家劫舍 II"><a href=https://leetcode-cn.com/problems/house-robber-ii/>213 打家劫舍 II</a></a></li>
<li>
<a href=#337-%e6%89%93%e5%ae%b6%e5%8a%ab%e8%88%8d-iiihttpsleetcode-cncomproblemshouse-robber-iii aria-label="337 打家劫舍 III"><a href=https://leetcode-cn.com/problems/house-robber-iii/>337 打家劫舍 III</a></a></li>
<li>
<a href=#96-%e4%b8%8d%e5%90%8c%e7%9a%84%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91httpsleetcode-cncomproblemsunique-binary-search-trees aria-label="96 不同的二叉搜索树"><a href=https://leetcode-cn.com/problems/unique-binary-search-trees/>96 不同的二叉搜索树</a></a></li>
<li>
<a href=#873-%e6%9c%80%e9%95%bf%e7%9a%84%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e5%ad%90%e5%ba%8f%e5%88%97%e7%9a%84%e9%95%bf%e5%ba%a6httpsleetcode-cncomproblemslength-of-longest-fibonacci-subsequence aria-label="873 最长的斐波那契子序列的长度"><a href=https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/>873 最长的斐波那契子序列的长度</a></a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=leetcode-动态规划httpsleetcode-cncomproblemsetallsearche4b891e695b0><a href="https://leetcode-cn.com/problemset/all/?search=%E4%B8%91%E6%95%B0">LeetCode 动态规划</a><a hidden class=anchor aria-hidden=true href=#leetcode-动态规划httpsleetcode-cncomproblemsetallsearche4b891e695b0>#</a></h1>
<h2 id=题目>题目<a hidden class=anchor aria-hidden=true href=#题目>#</a></h2>
<h3 id=3-数组相关>3. 数组相关<a hidden class=anchor aria-hidden=true href=#3-数组相关>#</a></h3>
<h4 id=300-最长上升子序列httpsleetcode-cncomproblemslongest-increasing-subsequencesubmissions><a href=https://leetcode-cn.com/problems/longest-increasing-subsequence/submissions/>300 最长上升子序列</a><a hidden class=anchor aria-hidden=true href=#300-最长上升子序列httpsleetcode-cncomproblemslongest-increasing-subsequencesubmissions>#</a></h4>
<p>在无序数组中找到最长上升子序列的长度。</p>
<p>用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的每个数字 j，如果 nums[i] > nums[j]，那么 j 和 i 可以形成一个上升子序列，让 dp[i] = max(dp[i], dp[j] + 1) 就能得到最长的上升子序列了。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> lengthOfLIS(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> nums.size(), res <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>)
            <span style=color:#66d9ef>return</span> n;
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(n, <span style=color:#ae81ff>1</span>);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> i; <span style=color:#f92672>++</span>j)
                <span style=color:#66d9ef>if</span> (nums[i] <span style=color:#f92672>&gt;</span> nums[j]) {
                    dp[i] <span style=color:#f92672>=</span> max(dp[i], dp[j] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
                    res <span style=color:#f92672>=</span> max(res, dp[i]);
                }
        <span style=color:#66d9ef>return</span> res;
    }
};
</code></pre></div><h4 id=53-最大子序和httpsleetcode-cncomproblemsmaximum-subarray><a href=https://leetcode-cn.com/problems/maximum-subarray/>53 最大子序和</a><a hidden class=anchor aria-hidden=true href=#53-最大子序和httpsleetcode-cncomproblemsmaximum-subarray>#</a></h4>
<p>找一个数组中具有最大和的连续子数组的和。</p>
<p>从头开始用一个变量 val 保存到当前数为止的连续子数组和，每一个数对于之前的连续子数组和只有加与不加两种选择，当之前的连续子数组和大于 0 时加上之前的连续子数组和，否则不加。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> maxSubArray(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums) {
        <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> INT_MIN, val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>n:nums) {
            val <span style=color:#f92672>=</span> max(val, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> n;
            res <span style=color:#f92672>=</span> max(res, val);
        }
        <span style=color:#66d9ef>return</span> res;
    }
};
</code></pre></div><h4 id=718-最长重复子数组httpsleetcode-cncomproblemsmaximum-length-of-repeated-subarray><a href=https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/>718 最长重复子数组</a><a hidden class=anchor aria-hidden=true href=#718-最长重复子数组httpsleetcode-cncomproblemsmaximum-length-of-repeated-subarray>#</a></h4>
<p>给两个数组，求两个数组中公共的长度最长的子数组的长度。</p>
<p>对于某两个字符 A[i] 和 B[j]，如果 A[i] == B[j]，则代表 A[i]，B[j] 与他们之前的子数组有可能是公共子数组，其最长长度 dp[i][j] = dp[i - 1][j - 1] + 1，否则他们不能组成公共子数组，dp[i][j] = 0。用两层循环遍历两个数组即可，时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> findLength(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>A, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>B) {
        <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> A.size(), n <span style=color:#f92672>=</span> B.size(), res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> m; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>j) {
                dp[i][j] <span style=color:#f92672>=</span> A[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> B[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>?</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
                res <span style=color:#f92672>=</span> max(res, dp[i][j]);
            }
        <span style=color:#66d9ef>return</span> res;
    }
};
</code></pre></div><h4 id=983-最低票价httpsleetcode-cncomproblemsminimum-cost-for-tickets><a href=https://leetcode-cn.com/problems/minimum-cost-for-tickets/>983 最低票价</a><a hidden class=anchor aria-hidden=true href=#983-最低票价httpsleetcode-cncomproblemsminimum-cost-for-tickets>#</a></h4>
<p>给出要旅行的所有日期，有三种通行证：一日票，七日票，三十日票。求最低消费。</p>
<p>对于第 i 天的最低消费，只需要选出一天前的最低消费加上一日票的消费，七天前的最低消费加上七日票，三十天前的最低消费加上三十日票这三种消费中最低的即可，因此有状态转移方程 dp[i] = min({dp[i - 1] + costs[0], dp[i - 7] + costs[1], dp[i - 30] + costs[2]})。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> mincostTickets(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>days, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>costs) {
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(<span style=color:#ae81ff>366</span>, INT_MAX);
        dp[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, n <span style=color:#f92672>=</span> days.size();
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>365</span> <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> days[j]) {
                dp[i] <span style=color:#f92672>=</span> min({dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> costs[<span style=color:#ae81ff>0</span>], dp[max(<span style=color:#ae81ff>0</span>, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>7</span>)] <span style=color:#f92672>+</span> costs[<span style=color:#ae81ff>1</span>], dp[max(<span style=color:#ae81ff>0</span>, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>30</span>)] <span style=color:#f92672>+</span> costs[<span style=color:#ae81ff>2</span>]});
                <span style=color:#f92672>++</span>j;
            } <span style=color:#66d9ef>else</span>
                dp[i] <span style=color:#f92672>=</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
        }
        <span style=color:#66d9ef>return</span> dp[days[n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]];
    }
};
</code></pre></div><h4 id=813-最大平均值和的分组httpsleetcode-cncomproblemslargest-sum-of-averages><a href=https://leetcode-cn.com/problems/largest-sum-of-averages/>813 最大平均值和的分组</a><a hidden class=anchor aria-hidden=true href=#813-最大平均值和的分组httpsleetcode-cncomproblemslargest-sum-of-averages>#</a></h4>
<p>将数组分为 K 个相邻的非空子数组，求所有子数组的平均值的和的最大值。</p>
<p>用二维数组 dp[n][K] 来表示前 i 个数分成 k 组得到的最优值，每次将从第 j 个数到第 n 个数分为一组，将前面 j - 1 个数分为 k - 1 组，求得 dp[i][k] 的最大值。为了快速地算出第 j 个数到第 n 个数的和以及前 j - 1 个数的和，可以用一个前缀和数组将前 m 个数的和保存下来，再用状态转移方程 dp[i][k] = max(dp[i][k], dp[j][k - 1] + (pre[i] - pre[j]) / (i - j)) 求得最优值。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>double</span> largestSumOfAverages(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>A, <span style=color:#66d9ef>int</span> K) {
        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> A.size();
        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> pre(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i)
            pre[i] <span style=color:#f92672>+=</span> pre[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> A[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;&gt;</span> dp(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span>(K <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) {
            dp[i][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> pre[i] <span style=color:#f92672>/</span> i;
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; k <span style=color:#f92672>&lt;=</span> K <span style=color:#f92672>&amp;&amp;</span> k <span style=color:#f92672>&lt;=</span> i; <span style=color:#f92672>++</span>k)
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> i; <span style=color:#f92672>++</span>j)
                    dp[i][k] <span style=color:#f92672>=</span> max(dp[i][k], dp[j][k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> (pre[i] <span style=color:#f92672>-</span> pre[j]) <span style=color:#f92672>/</span> (i <span style=color:#f92672>-</span> j));
        }
        <span style=color:#66d9ef>return</span> dp[n][K];
    }
};
</code></pre></div><h4 id=646-最长数对链httpsleetcode-cncomproblemsmaximum-length-of-pair-chain><a href=https://leetcode-cn.com/problems/maximum-length-of-pair-chain/>646 最长数对链</a><a hidden class=anchor aria-hidden=true href=#646-最长数对链httpsleetcode-cncomproblemsmaximum-length-of-pair-chain>#</a></h4>
<p>按照每个数对的第一个元素从小到大排序，从第二个数对开始，依次判断其与其前面的所有数对是否符合题意，是的话则 dp[j] = max(dp[j], dp[i] + 1）。时间复杂度是 O(n^2)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> findLongestChain(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> pairs) {
        sort(pairs.begin(), pairs.end());
        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> pairs.size(), res <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(n, <span style=color:#ae81ff>1</span>);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> j; <span style=color:#f92672>++</span>i)
                <span style=color:#66d9ef>if</span> (pairs[j][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> pairs[i][<span style=color:#ae81ff>1</span>]) {
                    dp[j] <span style=color:#f92672>=</span> max(dp[j], dp[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
                    res <span style=color:#f92672>=</span> max(res, dp[j]);
                }
        <span style=color:#66d9ef>return</span> res;
    }
};
</code></pre></div><h3 id=4-等差数列>4. 等差数列<a hidden class=anchor aria-hidden=true href=#4-等差数列>#</a></h3>
<h4 id=413-等差数列划分httpsleetcode-cncomproblemsarithmetic-slices><a href=https://leetcode-cn.com/problems/arithmetic-slices/>413 等差数列划分</a><a hidden class=anchor aria-hidden=true href=#413-等差数列划分httpsleetcode-cncomproblemsarithmetic-slices>#</a></h4>
<p>给一个数组，计算数组中等差子数组的个数。</p>
<p>等差数列必须是相邻两个元素之差相等的长度大于 3 的子数组，因此只需要知道 nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 1] 即可。用一个变量 cul 表示到目前为止等差数列的长度，diff 表示之前的公差，如果目前的差等于 diff 则加上 cul。时间复杂度是 O(n)，空间复杂度是 O(1)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> numberOfArithmeticSlices(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
        <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, n <span style=color:#f92672>=</span> nums.size(), cul <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, curr <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>int</span> diff <span style=color:#f92672>=</span> nums[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> nums[<span style=color:#ae81ff>0</span>];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            <span style=color:#66d9ef>if</span> ((curr <span style=color:#f92672>=</span> nums[i] <span style=color:#f92672>-</span> nums[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>==</span> diff) {
                res <span style=color:#f92672>+=</span> cul;
                <span style=color:#f92672>++</span>cul;
            }
            <span style=color:#66d9ef>else</span> {
                diff <span style=color:#f92672>=</span> curr;
                cul <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
            }
        }
        <span style=color:#66d9ef>return</span> res;
    }
};
</code></pre></div><h4 id=446-等差数列划分-ii---子序列httpsleetcode-cncomproblemsarithmetic-slices-ii-subsequence><a href=https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/>446 等差数列划分 II - 子序列</a><a hidden class=anchor aria-hidden=true href=#446-等差数列划分-ii---子序列httpsleetcode-cncomproblemsarithmetic-slices-ii-subsequence>#</a></h4>
<p>给一个数组，计算数组中等差子序列的个数。</p>
<p>对于某一个数 nums[i]，已知其与其之前某一个数的差 diff = nums[i] - nums[j]，需要知道在 nums[j] 之前公差为 diff 的等差子序列的最大个数，可以用一个哈希表数组来表示数 nums[j] 之前公差为 diff 的等差子序列的最大个数，如果 nums[i] - nums[j] == diff 则到位置 i 为止公差为 diff 的等差子序列的个数 dp[i][diff] += dp[j][diff]，注意要用 += 而不是 =，因为如果在 nums[i] 之前有多个相同的数字那么需要把每一个都算作一个独立的等差子序列。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。很搞笑的是这道题的动态规划解法在 LeetCode 上提交的时候 runtime 是 1000ms +-，而在LeetCode-CN 上提交的时候执行用时是 1400ms ~ 1800ms，而且偶尔还会超时，超时的 <a href=https://leetcode-cn.com/submissions/detail/21590899/testcase/>case</a> 的公差超过了 int32 的表示范围，如果加上判断 diff &lt; INT_MIN || diff > INT_MAX 直接 continue 就能正常通过了。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> numberOfArithmeticSlices(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> A) {
        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> A.size(), res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> diff <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        vector<span style=color:#f92672>&lt;</span>unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(n);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> i; <span style=color:#f92672>++</span>j) {
                diff <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span>(A[i]) <span style=color:#f92672>-</span> A[j];
                <span style=color:#66d9ef>if</span> (diff <span style=color:#f92672>&lt;</span> INT_MIN <span style=color:#f92672>||</span> diff <span style=color:#f92672>&gt;</span> INT_MAX)
                    <span style=color:#66d9ef>continue</span>;
                dp[i][diff] <span style=color:#f92672>+=</span> dp[j][diff] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
                res <span style=color:#f92672>+=</span> dp[j][diff];
            }
        }
        <span style=color:#66d9ef>return</span> res;
    }
};
</code></pre></div><h4 id=1027-最长等差数列httpsleetcode-cncomproblemslongest-arithmetic-sequencesubmissions><a href=https://leetcode-cn.com/problems/longest-arithmetic-sequence/submissions/>1027 最长等差数列</a><a hidden class=anchor aria-hidden=true href=#1027-最长等差数列httpsleetcode-cncomproblemslongest-arithmetic-sequencesubmissions>#</a></h4>
<p>给一个数组，计算数组中最长等差子序列的长度。</p>
<p>对于某一个数 nums[i]，已知其与其之前某一个数的差 diff = nums[i] - nums[j]，需要知道在 nums[j] 之前公差为 diff 的等差子序列有多长，可以用一个哈希表数组来表示每一个数之前公差为 diff 的等差子序列的最长长度，在此基础上 +1 即可得到最长的等差子序列的长度。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> longestArithSeqLength(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>A) {
        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> A.size(), res <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
        vector<span style=color:#f92672>&lt;</span>unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(n);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> i; <span style=color:#f92672>++</span>j) {
                <span style=color:#66d9ef>int</span> diff <span style=color:#f92672>=</span> A[i] <span style=color:#f92672>-</span> A[j];
                <span style=color:#66d9ef>if</span> (dp[j].find(diff) <span style=color:#f92672>==</span> dp[j].end())
                    dp[i][diff] <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
                <span style=color:#66d9ef>else</span> {
                    dp[i][diff] <span style=color:#f92672>=</span> dp[j][diff] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
                    res <span style=color:#f92672>=</span> max(res, dp[i][diff]);
                }
            }
        }
        <span style=color:#66d9ef>return</span> res;
    }
};
</code></pre></div><h3 id=5-斐波那契数列>5. 斐波那契数列<a hidden class=anchor aria-hidden=true href=#5-斐波那契数列>#</a></h3>
<h4 id=70-爬楼梯httpsleetcode-cncomproblemsclimbing-stairs><a href=https://leetcode-cn.com/problems/climbing-stairs/>70 爬楼梯</a><a hidden class=anchor aria-hidden=true href=#70-爬楼梯httpsleetcode-cncomproblemsclimbing-stairs>#</a></h4>
<p>每次能爬 1 或 2 阶楼梯，求爬 n 阶楼梯有多少种方法。</p>
<p>爬到当前楼梯的方法等于爬到前两阶楼梯的方法之和，因此有状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]，又因为当前状态只取决于前两个状态，因此可以只使用两个变量 s1 和 s2 来保存前两个状态的结果。时间复杂度是 O(n)，空间复杂度是 O(1)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> climbStairs(<span style=color:#66d9ef>int</span> n) {
        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>int</span> s1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, s2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, temp;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            temp <span style=color:#f92672>=</span> s2;
            s2 <span style=color:#f92672>+=</span> s1;
            s1 <span style=color:#f92672>=</span> temp;
        }
        <span style=color:#66d9ef>return</span> s2;
    }
};
</code></pre></div><h4 id=746-使用最小花费爬楼梯httpsleetcode-cncomproblemsmin-cost-climbing-stairs><a href=https://leetcode-cn.com/problems/min-cost-climbing-stairs/>746 使用最小花费爬楼梯</a><a hidden class=anchor aria-hidden=true href=#746-使用最小花费爬楼梯httpsleetcode-cncomproblemsmin-cost-climbing-stairs>#</a></h4>
<p>每次能爬 1 或 2 阶楼梯，每一阶楼梯有一个权值，求爬 n 阶楼梯的最小花费。</p>
<p>和上一题类似，不过每次只需要取前两阶楼梯中权值较小的就可以了。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> minCostClimbingStairs(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> cost) {
        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> cost.size();
        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
            <span style=color:#66d9ef>return</span> cost[<span style=color:#ae81ff>0</span>];
        <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>)
            <span style=color:#66d9ef>return</span> cost[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> cost[<span style=color:#ae81ff>1</span>];
        <span style=color:#66d9ef>int</span> s1 <span style=color:#f92672>=</span> cost[<span style=color:#ae81ff>0</span>], s2 <span style=color:#f92672>=</span> cost[<span style=color:#ae81ff>1</span>];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> s2;
            s2 <span style=color:#f92672>=</span> min(s1, s2) <span style=color:#f92672>+</span> cost[i];
            s1 <span style=color:#f92672>=</span> temp;
        }
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>min</span>(s1, s2);
    }
};
</code></pre></div><h4 id=740-删除与获得点数httpsleetcode-cncomproblemsdelete-and-earn><a href=https://leetcode-cn.com/problems/delete-and-earn/>740 删除与获得点数</a><a hidden class=anchor aria-hidden=true href=#740-删除与获得点数httpsleetcode-cncomproblemsdelete-and-earn>#</a></h4>
<p>给一个数组，每次任选一个 nums[i]，获得 nums[i] 的个数乘以 nums[i] 的点数，计算能获得的最大点数。</p>
<p>对于 nums[i]，能取到的最大点数只能是 nums[i - 1] 的最大点数或 nums[i - 2] 的最大点书加上 nums[i] 能获得的点数，因此有状态转移方程 dp[i] = max(dp[i - 1], dp[i - 2] + val[i])，时间复杂度是 O(n)。每个点只与其之前两个点有关，因此可以只使用两个变量 p1 和 p2 来保存前两个点的结果，空间复杂度是 O(1)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> deleteAndEarn(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> val(<span style=color:#ae81ff>10001</span>, <span style=color:#ae81ff>0</span>);
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>m:nums)
            val[m] <span style=color:#f92672>+=</span> m;
        <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, prev <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, curr <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>10000</span>; <span style=color:#f92672>++</span>i) {
            res <span style=color:#f92672>=</span> max(curr, prev <span style=color:#f92672>+</span> val[i]);
            prev <span style=color:#f92672>=</span> curr;
            curr <span style=color:#f92672>=</span> res;
        }
        <span style=color:#66d9ef>return</span> res;
    }
};
</code></pre></div><h4 id=198-打家劫舍httpsleetcode-cncomproblemshouse-robber><a href=https://leetcode-cn.com/problems/house-robber/>198 打家劫舍</a><a hidden class=anchor aria-hidden=true href=#198-打家劫舍httpsleetcode-cncomproblemshouse-robber>#</a></h4>
<p>给一个带权值的数组，取不相邻的数，求能取到的最大值。</p>
<p>对于某一点，如果到之前一点为止能取到的最大值大于取当前点与之前两点的最大值的和则不取，否则取当前点，当前点的值与之前两点的最大值之和就是当前点的最优值，因此有状态转移方程 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])，时间复杂度是 O(n)。当前点只与之前两个点有关，因此可以只使用两个变量 p1 和 p2 来保存前两个点的结果，空间复杂度是 O(1)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> rob(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> nums.size();
        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span>)
            <span style=color:#66d9ef>return</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>?</span> nums[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>:</span> max(nums[<span style=color:#ae81ff>0</span>], nums[<span style=color:#ae81ff>1</span>]);
        <span style=color:#66d9ef>int</span> p1 <span style=color:#f92672>=</span> nums[<span style=color:#ae81ff>0</span>], p2 <span style=color:#f92672>=</span> max(nums[<span style=color:#ae81ff>0</span>], nums[<span style=color:#ae81ff>1</span>]), temp;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            temp <span style=color:#f92672>=</span> p2;
            p2 <span style=color:#f92672>=</span> max(p1 <span style=color:#f92672>+</span> nums[i], p2);
            p1 <span style=color:#f92672>=</span> temp;
        }
        <span style=color:#66d9ef>return</span> p2;
    }
};
</code></pre></div><h4 id=213-打家劫舍-iihttpsleetcode-cncomproblemshouse-robber-ii><a href=https://leetcode-cn.com/problems/house-robber-ii/>213 打家劫舍 II</a><a hidden class=anchor aria-hidden=true href=#213-打家劫舍-iihttpsleetcode-cncomproblemshouse-robber-ii>#</a></h4>
<p>给一个带权值的数组，数组首尾相邻，取不相邻的数，求能取到的最大值。</p>
<p>数组首尾相邻代表不能同时取第一个点和最后一个点，因此从第一个点到倒数第二个点进行动态规划得到的就是包含第一个点而不包含最后一个点能取到的最大值，从第二个点到最后一个点进行动态规划得到的就是包含最后一个点而不包含第一个点能取到的最大值，用于上一题同样的方法分别做两次就能得到结果。时间复杂度是 O(n)，空间复杂度是 O(1)。</p>
<pre tabindex=0><code>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int res = 0, n = nums.size();
        if (n &lt;= 2)
            return n == 0 ? 0 : n == 1 ? nums[0] : max(nums[0], nums[1]);
        int p1 = nums[0], p2 = max(nums[0], nums[1]);
        for (int i = 2; i &lt; n - 1; ++i) {
            int temp = p2;
            p2 = max(p2, p1 + nums[i]);
            p1 = temp;
        }
        res = p2;
        p1 = nums[1], p2 = max(nums[1], nums[2]);
        for (int i = 3; i &lt; n; ++i) {
            int temp = p2;
            p2 = max(p2, p1 + nums[i]);
            p1 = temp;
        }
        return max(res, p2);
    }
};
</code></pre><h4 id=337-打家劫舍-iiihttpsleetcode-cncomproblemshouse-robber-iii><a href=https://leetcode-cn.com/problems/house-robber-iii/>337 打家劫舍 III</a><a hidden class=anchor aria-hidden=true href=#337-打家劫舍-iiihttpsleetcode-cncomproblemshouse-robber-iii>#</a></h4>
<p>给一个带权值的二叉树，取不相邻的数，求能取到的最大值。</p>
<p>对于一个节点，如果取节点本身则不能取两个子节点，如果取两个子节点则不能去其本身和四个子节点，因此对比其两个子节点的和与其本身和四个孙子节点的和，取最大值返回，也就是 max(dp[node->left->left] + dp [node->left->right] + dp[node->right->left] + dp [node->right->right] + dp[node], dp[node->left] + dp[node->right])。因为递归会造成大量的重复计算，因此用一个哈希表把已经计算过的节点的最优值保存下来，递归到该节点的时候直接取值防止造成TLE。时间复杂度是 O(n)，空间复杂度是 O(n)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
    unordered_map<span style=color:#f92672>&lt;</span>TreeNode <span style=color:#f92672>*</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> val;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> rob(TreeNode <span style=color:#f92672>*</span>node) {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>node)
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>if</span> (val.find(node) <span style=color:#f92672>!=</span> val.end())
            <span style=color:#66d9ef>return</span> val[node];
        <span style=color:#66d9ef>int</span> p1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, p2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>left)
            p1 <span style=color:#f92672>+=</span> rob(node<span style=color:#f92672>-&gt;</span>left<span style=color:#f92672>-&gt;</span>left) <span style=color:#f92672>+</span> rob(node<span style=color:#f92672>-&gt;</span>left<span style=color:#f92672>-&gt;</span>right);
        <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>right)
            p1 <span style=color:#f92672>+=</span> rob(node<span style=color:#f92672>-&gt;</span>right<span style=color:#f92672>-&gt;</span>left) <span style=color:#f92672>+</span> rob(node<span style=color:#f92672>-&gt;</span>right<span style=color:#f92672>-&gt;</span>right);
        p1 <span style=color:#f92672>+=</span> node<span style=color:#f92672>-&gt;</span>val;
        p2 <span style=color:#f92672>+=</span> rob(node<span style=color:#f92672>-&gt;</span>left) <span style=color:#f92672>+</span> rob(node<span style=color:#f92672>-&gt;</span>right);
        val[node] <span style=color:#f92672>=</span> max(p1, p2);
        <span style=color:#66d9ef>return</span> val[node];
    }
}
</code></pre></div><h4 id=96-不同的二叉搜索树httpsleetcode-cncomproblemsunique-binary-search-trees><a href=https://leetcode-cn.com/problems/unique-binary-search-trees/>96 不同的二叉搜索树</a><a hidden class=anchor aria-hidden=true href=#96-不同的二叉搜索树httpsleetcode-cncomproblemsunique-binary-search-trees>#</a></h4>
<p>求有 n 个节点的二叉搜索树有多少种。</p>
<p>对于某一个数 i 作为根结点时，无论 i 是多少，其左子树左子树总是由 i - 1 个节点构成的，而其右节点总是由 n - i 个节点构成的，例如 n = 3 时，如果让 3 作为根节点，那么其左子树一定是由 1 和 2 两个节点构成的，那么我们只需要知道由两个节点构成的二叉搜索树有多少种，再用这个左子树的种类数 dp[2] 乘以右子树的种类数 dp[0] 就能知道由 3 个节点构成的，以 3 作为根节点的种类数，其次需要依次让 1 和 2 作为根节点，那么他们的左子树分别有 dp[0] 和 dp[1] 种构成的方法，因此得到状态转移方程 dp[i] += dp[j - 1] * dp[i - j]，时间复杂度是 O(n ^ 2)，空间复杂度是 O(n)。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> numTrees(<span style=color:#66d9ef>int</span> n) {
        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
        dp[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> dp[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i)
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> i; <span style=color:#f92672>++</span>j)
                dp[i] <span style=color:#f92672>+=</span> dp[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> dp[i <span style=color:#f92672>-</span> j];
        <span style=color:#66d9ef>return</span> dp[n];
    }
};
</code></pre></div><h4 id=873-最长的斐波那契子序列的长度httpsleetcode-cncomproblemslength-of-longest-fibonacci-subsequence><a href=https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/>873 最长的斐波那契子序列的长度</a><a hidden class=anchor aria-hidden=true href=#873-最长的斐波那契子序列的长度httpsleetcode-cncomproblemslength-of-longest-fibonacci-subsequence>#</a></h4>
<p>给一个严格递增的数组，找到其中最长的斐波那契子序列的长度。</p>
<p>根据斐波那契数列的定义，要判断 A[i] 和 A[j] 能否在原数组中构成斐波那契数列，只需要知道 A[i - j] 是否在原数组中，并且 A[i] - A[j] &lt; A[j] &lt; A[i] 是否成立，于是我们可以用一个二维数组 dp[n][n] 来代表由 A[i] 和 A[j] 以及 A[i - j] 构成的斐波那契子序列的最长长度。为了查找 A[i - j] 是否在原数组中，我们可以用一个哈希表 pos 来保存 A[i - j] 在原数组中的下标，获取下标 k = pos[A[i] - A[j]] 后，用状态转移方程 dp[i][j] = dp[j][k] + 1 来更新最长长度。</p>
<p>注意在判断下标是否存在于哈希表中时要用 pos.find(A[i] - A[j]) == pos.end()，而不能直接用 pos[A[i] - A[j]] 来获取，这样虽然如果 A[i] - A[j] 不存在于哈希表中仍然能够得到结果 0，但效率非常低，会导致TLE。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> lenLongestFibSubseq(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>A) {
        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> A.size(), res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(n, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n, <span style=color:#ae81ff>0</span>));
        unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pos;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
            pos[A[i]] <span style=color:#f92672>=</span> i;
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> i; <span style=color:#f92672>++</span>j) {
                <span style=color:#66d9ef>auto</span> k <span style=color:#f92672>=</span> pos.find(A[i] <span style=color:#f92672>-</span> A[j]) <span style=color:#f92672>==</span> pos.end() <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> pos[A[i] <span style=color:#f92672>-</span> A[j]];
                dp[i][j] <span style=color:#f92672>=</span> A[i] <span style=color:#f92672>-</span> A[j] <span style=color:#f92672>&lt;</span> A[j] <span style=color:#f92672>&amp;&amp;</span> k <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>?</span> dp[j][k] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>;
                res <span style=color:#f92672>=</span> max(res, dp[i][j]);
            }
        }
        <span style=color:#66d9ef>return</span> res <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> res;
    }
};
</code></pre></div>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=http://zintrulcre.github.io/posts/leetcode/dynamicprogramming-3/>
<span class=title>« Prev Page</span>
<br>
<span>LeetCode 动态规划（3）</span>
</a>
<a class=next href=http://zintrulcre.github.io/posts/leetcode/dynamicprogramming-1/>
<span class=title>Next Page »</span>
<br>
<span>LeetCode 动态规划（1）</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>
Zhengyu &copy; 2022
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>