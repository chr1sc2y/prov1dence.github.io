<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LeetCode 树（1） | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content="LeetCode 树（1）
题目
1. 树的遍历
144 二叉树的前序遍历
前序遍历一个二叉树。
前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，先将节点加入结果数组，然后用一个栈保存右，左子节点，依次访问，重复此过程。
class Solution {
        vector<int> res;
public:
    vector<int> preorderTraversal(TreeNode *root) {
        res = vector<int>();
        Preorder(root);
        return res;
    }
    
    void Preorder(TreeNode *root) {
        if (!root)
            return;
        res.push_back(root->val);
        Preorder(root->left);
        Preorder(root->right);
    }
};
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        if (!root)
            return res;
        stack<TreeNode *> pre;
        pre.push(root);
        while (!pre.empty()) {
            TreeNode *node = pre.top();
            pre.pop();
            res.push_back(node->val);
            if (node->right)
                pre.push(node->right);
            if (node->left)
                pre.push(node->left);
        }
        return res;
    }
};
589 N叉树的前序遍历
前序遍历一个 N 叉树。"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/leetcode/tree-1/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/leetcode/tree-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/leetcode/tree-1/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="LeetCode 树（1）"><meta property="og:description" content="LeetCode 树（1） 题目 1. 树的遍历 144 二叉树的前序遍历 前序遍历一个二叉树。
前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，先将节点加入结果数组，然后用一个栈保存右，左子节点，依次访问，重复此过程。
class Solution { vector<int> res; public: vector<int> preorderTraversal(TreeNode *root) { res = vector<int>(); Preorder(root); return res; } void Preorder(TreeNode *root) { if (!root) return; res.push_back(root->val); Preorder(root->left); Preorder(root->right); } }; class Solution { public: vector<int> preorderTraversal(TreeNode *root) { vector<int> res; if (!root) return res; stack<TreeNode *> pre; pre.push(root); while (!pre.empty()) { TreeNode *node = pre.top(); pre.pop(); res.push_back(node->val); if (node->right) pre.push(node->right); if (node->left) pre.push(node->left); } return res; } }; 589 N叉树的前序遍历 前序遍历一个 N 叉树。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-13T19:12:25+10:00"><meta property="article:modified_time" content="2019-07-13T19:12:25+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode 树（1）"><meta name=twitter:description content="LeetCode 树（1）
题目
1. 树的遍历
144 二叉树的前序遍历
前序遍历一个二叉树。
前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，先将节点加入结果数组，然后用一个栈保存右，左子节点，依次访问，重复此过程。
class Solution {
        vector<int> res;
public:
    vector<int> preorderTraversal(TreeNode *root) {
        res = vector<int>();
        Preorder(root);
        return res;
    }
    
    void Preorder(TreeNode *root) {
        if (!root)
            return;
        res.push_back(root->val);
        Preorder(root->left);
        Preorder(root->right);
    }
};
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        if (!root)
            return res;
        stack<TreeNode *> pre;
        pre.push(root);
        while (!pre.empty()) {
            TreeNode *node = pre.top();
            pre.pop();
            res.push_back(node->val);
            if (node->right)
                pre.push(node->right);
            if (node->left)
                pre.push(node->left);
        }
        return res;
    }
};
589 N叉树的前序遍历
前序遍历一个 N 叉树。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode 树（1）","item":"https://prov1dence.top/posts/leetcode/tree-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode 树（1）","name":"LeetCode 树（1）","description":"LeetCode 树（1） 题目 1. 树的遍历 144 二叉树的前序遍历 前序遍历一个二叉树。\n前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，先将节点加入结果数组，然后用一个栈保存右，左子节点，依次访问，重复此过程。\nclass Solution { vector\u0026lt;int\u0026gt; res; public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) { res = vector\u0026lt;int\u0026gt;(); Preorder(root); return res; } void Preorder(TreeNode *root) { if (!root) return; res.push_back(root-\u0026gt;val); Preorder(root-\u0026gt;left); Preorder(root-\u0026gt;right); } }; class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; if (!root) return res; stack\u0026lt;TreeNode *\u0026gt; pre; pre.push(root); while (!pre.empty()) { TreeNode *node = pre.top(); pre.pop(); res.push_back(node-\u0026gt;val); if (node-\u0026gt;right) pre.push(node-\u0026gt;right); if (node-\u0026gt;left) pre.push(node-\u0026gt;left); } return res; } }; 589 N叉树的前序遍历 前序遍历一个 N 叉树。\n","keywords":[],"articleBody":"LeetCode 树（1） 题目 1. 树的遍历 144 二叉树的前序遍历 前序遍历一个二叉树。\n前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，先将节点加入结果数组，然后用一个栈保存右，左子节点，依次访问，重复此过程。\nclass Solution { vector\u003cint\u003e res; public: vector\u003cint\u003e preorderTraversal(TreeNode *root) { res = vector\u003cint\u003e(); Preorder(root); return res; } void Preorder(TreeNode *root) { if (!root) return; res.push_back(root-\u003eval); Preorder(root-\u003eleft); Preorder(root-\u003eright); } }; class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode *root) { vector\u003cint\u003e res; if (!root) return res; stack\u003cTreeNode *\u003e pre; pre.push(root); while (!pre.empty()) { TreeNode *node = pre.top(); pre.pop(); res.push_back(node-\u003eval); if (node-\u003eright) pre.push(node-\u003eright); if (node-\u003eleft) pre.push(node-\u003eleft); } return res; } }; 589 N叉树的前序遍历 前序遍历一个 N 叉树。\n跟二叉树的前序遍历类似，有递归和迭代两种做法。\nclass Solution { vector\u003cint\u003e res; public: vector\u003cint\u003e preorder(Node *root) { res = vector\u003cint\u003e(); Preorder(root); return res; } void Preorder(Node *root) { if (!root) return; res.push_back(root-\u003eval); for (auto \u0026c:root-\u003echildren) Preorder(c); } }; class Solution { public: vector\u003cint\u003e preorder(Node *root) { vector\u003cint\u003e res; if (!root) return res; stack\u003cNode *\u003e pre; pre.push(root); while (!pre.empty()) { Node *node = pre.top(); pre.pop(); res.push_back(node-\u003eval); for (auto iter = node-\u003echildren.rbegin(); iter \u003c node-\u003echildren.rend(); ++iter) pre.push(*iter); } return res; } }; 94 二叉树的中序遍历 中序遍历一个二叉树。\n中序遍历是按照左子节点，根节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，用一个栈保存父节点以便最后访问，先找到最左节点，将其加入结果数组，然后访问其右子节点，重复此过程。\nclass Solution { vector\u003cint\u003e res; public: vector\u003cint\u003e inorderTraversal(TreeNode* root) { res = vector\u003cint\u003e(); Inorder(root); return res; } void Inorder(TreeNode *root) { if (!root) return; Inorder(root-\u003eleft); res.push_back(root-\u003eval); Inorder(root-\u003eright); } }; class Solution { public: vector\u003cint\u003e inorderTraversal(TreeNode *root) { vector\u003cint\u003e res; if (!root) return res; stack\u003cTreeNode *\u003e in; TreeNode *node = root; while (node || !in.empty()) { while (node) { in.push(node); node = node-\u003eleft; } if (!in.empty()) { node = in.top(); in.pop(); res.push_back(node-\u003eval); node = node-\u003eright; } } return res; } }; 145 二叉树的后序遍历 后序遍历一个二叉树。\n后序遍历是按照左子节点，右子节点，根节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，用一个栈保存父节点以便最后访问，先找到最左节点，如果其已经是叶子节点则将其加入结果数组，否则访问其右子节点，用 last 保存上一次访问过的右子节点防止再次访问，重复此过程。\nclass Solution { vector\u003cint\u003e res; public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { res = vector\u003cint\u003e(); Postorder(root); return res; } void Postorder(TreeNode *root) { if (!root) return; Postorder(root-\u003eleft); Postorder(root-\u003eright); res.push_back(root-\u003eval); } }; class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode *root) { vector\u003cint\u003e res; if (!root) return res; stack\u003cTreeNode *\u003e post; TreeNode *node = root, *last = nullptr; while (node || !post.empty()) { while (node) { post.push(node); node = node-\u003eleft; } if (!post.empty()) { node = post.top(); if (node-\u003eright \u0026\u0026 node-\u003eright != last) node = node-\u003eright; else { res.push_back(node-\u003eval); post.pop(); last = node; node = nullptr; } } } return res; } }; 590 N叉树的后序遍历 跟二叉树的后序遍历类似，有递归和迭代两种做法。\nclass Solution { vector\u003cint\u003e res; public: vector\u003cint\u003e postorder(Node *root) { res = vector\u003cint\u003e(); Postorder(root); return res; } void Postorder(Node *root) { if (!root) return; for (auto \u0026c:root-\u003echildren) Postorder(c); res.push_back(root-\u003eval); } }; class Solution { public: vector\u003cint\u003e postorder(Node *root) { vector\u003cint\u003e res; if (!root) return res; stack\u003cNode *\u003e post; post.push(root); while (!post.empty()) { Node *node = post.top(); post.pop(); res.push_back(node-\u003eval); for (auto \u0026c:node-\u003echildren) post.push(c); } reverse(res.begin(), res.end()); return res; } }; 102 二叉树的层次遍历 给一个二叉树，返回其按层次遍历的节点值。\n用一个队列来保存该二叉树当前一层的所有节点，一边将这些节点 pop 并 push 进结果数组中，一边将这些节点的子节点 push 进队列。\nclass Solution { public: vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode *root) { vector\u003cvector\u003cint\u003e\u003e res; if (!root) return res; queue\u003cTreeNode *\u003e q; q.push(root); int n = 1; while (!q.empty()) { vector\u003cint\u003e lvl; for (int i = 0; i \u003c n; ++i) { TreeNode *node = q.front(); q.pop(); lvl.push_back(node-\u003eval); if (node-\u003eleft) q.push(node-\u003eleft); if (node-\u003eright) q.push(node-\u003eright); } res.push_back(lvl); n = q.size(); } return res; } }; 107 二叉树的层次遍历 II 给一个二叉树，返回其节点值自底向上的层次遍历。\n跟上一题相同，只需要将结果数组倒置，或用一个栈保存结果，再 pop 进结果数组即可。\nclass Solution { public: vector\u003cvector\u003cint\u003e\u003e levelOrderBottom(TreeNode *root) { vector\u003cvector\u003cint\u003e\u003e res; if (!root) return res; queue\u003cTreeNode *\u003e q; int n = 1; q.push(root); while (!q.empty()) { vector\u003cint\u003e lvl; for (int i = 0; i \u003c n; ++i) { TreeNode *node = q.front(); q.pop(); lvl.push_back(node-\u003eval); if (node-\u003eleft) q.push(node-\u003eleft); if (node-\u003eright) q.push(node-\u003eright); } res.push_back(lvl); n = q.size(); } reverse(res.begin(), res.end()); return res; } }; 429 N 叉树的层序遍历 层序遍历一个 N 叉树。\n用一个队列来保存该 N 叉树当前一层的所有节点，一边将这些节点 pop 并 push 进结果数组中，一边将这些节点的子节点 push 进队列。\nclass Solution { public: vector\u003cvector\u003cint\u003e\u003e levelOrder(Node *root) { vector\u003cvector\u003cint\u003e\u003e res; if (!root) return res; queue\u003cNode *\u003e q; q.push(root); int n = 1; while (!q.empty()) { vector\u003cint\u003e lvl; for (int i = 0; i \u003c n; ++i) { Node *node = q.front(); q.pop(); lvl.push_back(node-\u003eval); for (auto \u0026c:node-\u003echildren) q.push(c); } res.push_back(lvl); n = q.size(); } return res; } }; 987 二叉树的垂序遍历 垂序遍历一个二叉树。\n用红黑树把二叉树中每个节点的位置保存下来，如果根节点的位置是 (x, y)，那么其左子节点和右子节点的位置分别是 (x - 1, y + 1) 和 (x + 1, y + 1)，再按顺序保存到结果数组即可。\nclass Solution { map\u003cint, map\u003cint, vector\u003cint\u003e\u003e\u003e matrix; public: vector\u003cvector\u003cint\u003e\u003e verticalTraversal(TreeNode *root) { vector\u003cvector\u003cint\u003e\u003e res; matrix = map\u003cint, map\u003cint, vector\u003cint\u003e\u003e\u003e(); Traverse(root, 0, 0); for (auto \u0026m:matrix) { vector\u003cint\u003e temp; for (auto \u0026n:m.second) { sort(n.second.begin(), n.second.end()); temp.insert(temp.end(), n.second.begin(), n.second.end()); } res.push_back(temp); } return res; } void Traverse(TreeNode *root, int x, int y) { if (!root) return; if (matrix.find(x) == matrix.end()) matrix[x] = map\u003cint, vector\u003cint\u003e\u003e(); if (matrix[x].find(y) == matrix[x].end()) matrix[x][y] = vector\u003cint\u003e(); matrix[x][y].push_back(root-\u003eval); Traverse(root-\u003eleft, x - 1, y + 1); Traverse(root-\u003eright, x + 1, y + 1); } }; 103 二叉树的锯齿形层次遍历 锯齿形层次遍历一个二叉树。\n用两个栈轮流从左往右和从右往左保存节点，再依次加入结果数组即可。\nclass Solution { public: vector\u003cvector\u003cint\u003e\u003e zigzagLevelOrder(TreeNode *root) { stack\u003cTreeNode *\u003e s1, s2; vector\u003cvector\u003cint\u003e\u003e res; if (!root) return res; s1.push(root); while (!s1.empty() || !s2.empty()) { vector\u003cint\u003e lvl; if (s2.empty()) { while (!s1.empty()) { TreeNode *node = s1.top(); s1.pop(); lvl.push_back(node-\u003eval); if (node-\u003eleft) s2.push(node-\u003eleft); if (node-\u003eright) s2.push(node-\u003eright); } } else { while (!s2.empty()) { TreeNode *node = s2.top(); s2.pop(); lvl.push_back(node-\u003eval); if (node-\u003eright) s1.push(node-\u003eright); if (node-\u003eleft) s1.push(node-\u003eleft); } } res.push_back(lvl); } return res; } }; 124 二叉树中的最大路径和 用递归的方式，在每个节点值加上其左右子树的最大路径来更新结果，并以其左右子树中较大的一个加上其节点值返回即可。\nclass Solution { int res; public: int maxPathSum(TreeNode *root) { res = INT_MIN; Traverse(root); return res; } int Traverse(TreeNode *node) { if (!node) return 0; int left = max(0, Traverse(node-\u003eleft)); int right = max(0, Traverse(node-\u003eright)); res = max(res, left + right + node-\u003eval); return max(left, right) + node-\u003eval; } }; 968 监控二叉树 贪心法，分情况讨论，三种状态分别是：0 表示节点未被监控，1 表示节点自带监控，2 表示节点被子节点监控；一个节点的两个字子节点组合起来分别由 6 种情况，分别是：若两个子节点都为 2（22），那么当前节点未被监控，需要被父节点监控，返回 0；若两个子节点至少有一个为 0（00，01，02，未被监控），那么当前节点需要装上监控以监控子节点，返回 1；剩下的 2 种情况是至少有一个子节点自带监控（11，12），那么当前节点被子节点监控，且其子节点都已被监控或自带监控，返回 2；最后需要单独判断树的根节点是否是 0 的状态，因为已经没有父节点可以进行监控。\nclass Solution { int res; public: int minCameraCover(TreeNode *root) { res = 0; if (Traverse(root) == 0) ++res; return res; } int Traverse(TreeNode *node) { if (!node) return 2; int left = Traverse(node-\u003eleft); int right = Traverse(node-\u003eright); if (left == 2 \u0026\u0026 right == 2) return 0; else if (left == 0 || right == 0) { ++res; return 1; } return 2; } }; 2. 构造二叉树 105 从前序与中序遍历序列构造二叉树 根据前序遍历与中序遍历的结果构造二叉树。\n前序遍历结果中的第一个元素一定是二叉树的根节点的值，因此在中序遍历结果中找到这个值，那么中序遍历结果中这个值左边的所有元素一定都在这个根节点的左子树上，右边的所有元素一定都在这个根节点的右子树上，假设左边的长度为 m，那么在前序遍历结果的第一个元素后的 m 个元素也都对应左子树上的这些元素，分别把这两部分递归调用构造新的子树即可。\nclass Solution { public: TreeNode *buildTree(vector\u003cint\u003e \u0026preorder, vector\u003cint\u003e \u0026inorder) { return Build(preorder, 0, preorder.size(), inorder, 0, inorder.size()); } TreeNode *Build(vector\u003cint\u003e \u0026preorder, int x, int y, vector\u003cint\u003e \u0026inorder, int m, int n) { if (x \u003e= y || m \u003e= n) return nullptr; TreeNode *node = new TreeNode(preorder[x]); int pos = m; while (pos \u003c n \u0026\u0026 inorder[pos] != preorder[x]) ++pos; node-\u003eleft = Build(preorder, x + 1, x + 1 + pos - m, inorder, m, pos); node-\u003eright = Build(preorder, x + 1 + pos - m, y, inorder, pos + 1, n); return node; } }; 106 从中序与后序遍历序列构造二叉树 根据后序遍历与中序遍历的结果构造二叉树。\n后序遍历结果中的最后一个元素一定是二叉树的根节点的值，因此在中序遍历结果中找到这个值，那么中序遍历结果中这个值左边的所有元素一定都在这个根节点的左子树上，右边的所有元素一定都在这个根节点的右子树上，假设左边的长度为 m，那么在后序遍历结果中从第一个元素往后 m 个元素也都对应左子树上的这些元素，分别把这两部分递归调用构造新的子树即可。\nclass Solution { public: TreeNode *buildTree(vector\u003cint\u003e \u0026inorder, vector\u003cint\u003e \u0026postorder) { return Build(inorder, 0, inorder.size(), postorder, 0, postorder.size()); } TreeNode *Build(vector\u003cint\u003e \u0026inorder, int x, int y, vector\u003cint\u003e \u0026postorder, int m, int n) { if (x \u003e= y || m \u003e= n) return nullptr; TreeNode *node = new TreeNode(postorder[n - 1]); int pos = x; while (pos \u003c y \u0026\u0026 inorder[pos] != postorder[n - 1]) ++pos; node-\u003eleft = Build(inorder, x, pos, postorder, m, m + pos - x); node-\u003eright = Build(inorder, pos + 1, y, postorder, m + pos - x, n - 1); return node; } }; 889 根据前序和后序遍历构造二叉树 根据前序遍历与后序遍历的结果构造二叉树。\n前序遍历结果中的第一个元素对应后序遍历结果中的最后一个元素，都是二叉树的根节点的值，以此构建根节点；前序遍历结果中的第二个元素一定是根节点的左子节点，而后序遍历结果中的这个值一定是左子树上的最后一个值，那么只需要找到这个值在后序遍历结果中的位置，就可以确定左子树和右子树的长度，分别递归调用构造新的子树即可。\nclass Solution { public: TreeNode *constructFromPrePost(vector\u003cint\u003e \u0026pre, vector\u003cint\u003e \u0026post) { return Build(pre, 0, pre.size(), post, 0, post.size()); } TreeNode *Build(vector\u003cint\u003e \u0026pre, int x, int y, vector\u003cint\u003e \u0026post, int m, int n) { if (x \u003e= y || m \u003e= n) return nullptr; TreeNode *node = new TreeNode(pre[x]); if (x == y - 1) return node; int pos = m; while (pos \u003c n \u0026\u0026 post[pos] != pre[x + 1]) ++pos; node-\u003eleft = Build(pre, x + 1, x + pos - m + 2, post, m, pos + 1); node-\u003eright = Build(pre, x + pos - m + 2, y, post, pos + 1, n - 1); return node; } }; 1008 先序遍历构造二叉树 给一个先序遍历的结果，构造其对应的二叉搜索树。\n根据先序遍历和二叉搜索树的定义，数组的第一个元素即是根节点，其后所有小于它的元素都在它的左子树上，所有大于它的元素都在它的右子树上，递归求解即可。\nclass Solution { public: TreeNode *bstFromPreorder(vector\u003cint\u003e \u0026preorder) { return Build(preorder, 0, preorder.size()); } TreeNode *Build(vector\u003cint\u003e \u0026preorder, int x, int y) { if (x \u003e= y) return nullptr; TreeNode *root = new TreeNode(preorder[x]); int i = x + 1; while (i \u003c y \u0026\u0026 preorder[i] \u003c preorder[x]) ++i; root-\u003eleft = Build(preorder, x + 1, i); root-\u003eright = Build(preorder, i, y); return root; } }; 1028 从先序遍历还原二叉树 给一个先序遍历的结果和用不同长度的 ‘-’ 相连的字符串，构造其对应的二叉树。\n‘-’ 的长度代表当前的层次，如果当前节点之后的 ‘-’ 的长度等于当前的层次加一，那么其后的数构成当前节点的左节点；如果左节点之后的 ‘-’ 的长度等于当前的层次加一，那么其后的数构成当前节点的右节点；否则如果当前节点之后或左节点之后的 ‘-’ 的长度小于等于等钱层次则代表当前节点已经是叶子节点，其没有左右子节点，直接返回。用一个变量 pos 保存当前遍历到的字符串位置，递归调用该过程即可。\nclass Solution { public: TreeNode *recoverFromPreorder(string S) { int pos = 0; return Build(S, 0, pos, 0); } TreeNode *Build(const string \u0026S, int x, int \u0026pos, int lvl) { int num = 0, i = x; while (S[i] \u003e= '0' \u0026\u0026 S[i] \u003c= '9') ++i; TreeNode *node = new TreeNode(stoi(S.substr(x, i - x + 1))); pos = i; while (S[i] == '-') ++i; if (i - pos == lvl + 1) node-\u003eleft = Build(S, i, pos, lvl + 1); else return node; i = pos; while (S[i] == '-') ++i; if (i - pos == lvl + 1) node-\u003eright = Build(S, i, y, pos, lvl + 1); return node; } }; ","wordCount":"1454","inLanguage":"en","datePublished":"2019-07-13T19:12:25+10:00","dateModified":"2019-07-13T19:12:25+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/leetcode/tree-1/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">LeetCode 树（1）</h1><div class=post-meta><span title='2019-07-13 19:12:25 +1000 AEST'>July 13, 2019</span>&nbsp;·&nbsp;7 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#leetcode-%e6%a0%911httpsleetcode-cncomtagtree aria-label="LeetCode 树（1）">LeetCode 树（1）</a><ul><li><a href=#%e9%a2%98%e7%9b%ae aria-label=题目>题目</a><ul><li><a href=#1-%e6%a0%91%e7%9a%84%e9%81%8d%e5%8e%86 aria-label="1. 树的遍历">1. 树的遍历</a><ul><li><a href=#144-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcode-cncomproblemsbinary-tree-preorder-traversal aria-label="144 二叉树的前序遍历">144 二叉树的前序遍历</a></li><li><a href=#589-n%e5%8f%89%e6%a0%91%e7%9a%84%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcode-cncomproblemsn-ary-tree-preorder-traversal aria-label="589 N叉树的前序遍历">589 N叉树的前序遍历</a></li><li><a href=#94-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcode-cncomproblemsbinary-tree-inorder-traversal aria-label="94 二叉树的中序遍历">94 二叉树的中序遍历</a></li><li><a href=#145-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcode-cncomproblemsbinary-tree-postorder-traversal aria-label="145 二叉树的后序遍历">145 二叉树的后序遍历</a></li><li><a href=#590-n%e5%8f%89%e6%a0%91%e7%9a%84%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcode-cncomproblemsn-ary-tree-postorder-traversal aria-label="590 N叉树的后序遍历">590 N叉树的后序遍历</a></li><li><a href=#102-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86httpsleetcode-cncomproblemsbinary-tree-level-order-traversal aria-label="102 二叉树的层次遍历">102 二叉树的层次遍历</a></li><li><a href=#107-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86-iihttpsleetcode-cncomproblemsbinary-tree-level-order-traversal-ii aria-label="107 二叉树的层次遍历 II">107 二叉树的层次遍历 II</a></li><li><a href=#429-n-%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcode-cncomproblemsn-ary-tree-level-order-traversal aria-label="429 N 叉树的层序遍历">429 N 叉树的层序遍历</a></li><li><a href=#987-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%9e%82%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcode-cncomproblemsvertical-order-traversal-of-a-binary-tree aria-label="987 二叉树的垂序遍历">987 二叉树的垂序遍历</a></li><li><a href=#103-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%94%af%e9%bd%bf%e5%bd%a2%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86httpsleetcode-cncomproblemsbinary-tree-zigzag-level-order-traversal aria-label="103 二叉树的锯齿形层次遍历">103 二叉树的锯齿形层次遍历</a></li><li><a href=#124-%e4%ba%8c%e5%8f%89%e6%a0%91%e4%b8%ad%e7%9a%84%e6%9c%80%e5%a4%a7%e8%b7%af%e5%be%84%e5%92%8chttpsleetcode-cncomproblemsbinary-tree-maximum-path-sum aria-label="124 二叉树中的最大路径和">124 二叉树中的最大路径和</a></li><li><a href=#968-%e7%9b%91%e6%8e%a7%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcode-cncomproblemsbinary-tree-cameras aria-label="968 监控二叉树">968 监控二叉树</a></li></ul></li><li><a href=#2-%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="2. 构造二叉树">2. 构造二叉树</a><ul><li><a href=#105-%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcode-cncomproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal aria-label="105 从前序与中序遍历序列构造二叉树">105 从前序与中序遍历序列构造二叉树</a></li><li><a href=#106-%e4%bb%8e%e4%b8%ad%e5%ba%8f%e4%b8%8e%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcode-cncomproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal aria-label="106 从中序与后序遍历序列构造二叉树">106 从中序与后序遍历序列构造二叉树</a></li><li><a href=#889-%e6%a0%b9%e6%8d%ae%e5%89%8d%e5%ba%8f%e5%92%8c%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcode-cncomproblemsconstruct-binary-tree-from-preorder-and-postorder-traversal aria-label="889 根据前序和后序遍历构造二叉树">889 根据前序和后序遍历构造二叉树</a></li><li><a href=#1008-%e5%85%88%e5%ba%8f%e9%81%8d%e5%8e%86%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcode-cncomproblemsconstruct-binary-search-tree-from-preorder-traversal aria-label="1008 先序遍历构造二叉树">1008 先序遍历构造二叉树</a></li><li><a href=#1028-%e4%bb%8e%e5%85%88%e5%ba%8f%e9%81%8d%e5%8e%86%e8%bf%98%e5%8e%9f%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcode-cncomproblemsrecover-a-tree-from-preorder-traversal aria-label="1028 从先序遍历还原二叉树">1028 从先序遍历还原二叉树</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=leetcode-树1httpsleetcode-cncomtagtree><a href=https://leetcode-cn.com/tag/tree/>LeetCode 树（1）</a><a hidden class=anchor aria-hidden=true href=#leetcode-树1httpsleetcode-cncomtagtree>#</a></h1><h2 id=题目>题目<a hidden class=anchor aria-hidden=true href=#题目>#</a></h2><h3 id=1-树的遍历>1. 树的遍历<a hidden class=anchor aria-hidden=true href=#1-树的遍历>#</a></h3><h4 id=144-二叉树的前序遍历httpsleetcode-cncomproblemsbinary-tree-preorder-traversal><a href=https://leetcode-cn.com/problems/binary-tree-preorder-traversal/>144 二叉树的前序遍历</a><a hidden class=anchor aria-hidden=true href=#144-二叉树的前序遍历httpsleetcode-cncomproblemsbinary-tree-preorder-traversal>#</a></h4><p>前序遍历一个二叉树。</p><p>前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，先将节点加入结果数组，然后用一个栈保存右，左子节点，依次访问，重复此过程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> preorderTraversal(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        Preorder(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Preorder</span>(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        res.push_back(root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>        Preorder(root<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>        Preorder(root<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> preorderTraversal(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>&lt;</span>TreeNode <span style=color:#f92672>*&gt;</span> pre;
</span></span><span style=display:flex><span>        pre.push(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pre.empty()) {
</span></span><span style=display:flex><span>            TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> pre.top();
</span></span><span style=display:flex><span>            pre.pop();
</span></span><span style=display:flex><span>            res.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>right)
</span></span><span style=display:flex><span>                pre.push(node<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>left)
</span></span><span style=display:flex><span>                pre.push(node<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=589-n叉树的前序遍历httpsleetcode-cncomproblemsn-ary-tree-preorder-traversal><a href=https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/>589 N叉树的前序遍历</a><a hidden class=anchor aria-hidden=true href=#589-n叉树的前序遍历httpsleetcode-cncomproblemsn-ary-tree-preorder-traversal>#</a></h4><p>前序遍历一个 N 叉树。</p><p>跟二叉树的前序遍历类似，有递归和迭代两种做法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> preorder(Node <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        Preorder(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Preorder</span>(Node <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        res.push_back(root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>c:root<span style=color:#f92672>-&gt;</span>children)
</span></span><span style=display:flex><span>            Preorder(c);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> preorder(Node <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>&lt;</span>Node <span style=color:#f92672>*&gt;</span> pre;
</span></span><span style=display:flex><span>        pre.push(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pre.empty()) {
</span></span><span style=display:flex><span>            Node <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> pre.top();
</span></span><span style=display:flex><span>            pre.pop();
</span></span><span style=display:flex><span>            res.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>children.rbegin(); iter <span style=color:#f92672>&lt;</span> node<span style=color:#f92672>-&gt;</span>children.rend(); <span style=color:#f92672>++</span>iter)
</span></span><span style=display:flex><span>                pre.push(<span style=color:#f92672>*</span>iter);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=94-二叉树的中序遍历httpsleetcode-cncomproblemsbinary-tree-inorder-traversal><a href=https://leetcode-cn.com/problems/binary-tree-inorder-traversal/>94 二叉树的中序遍历</a><a hidden class=anchor aria-hidden=true href=#94-二叉树的中序遍历httpsleetcode-cncomproblemsbinary-tree-inorder-traversal>#</a></h4><p>中序遍历一个二叉树。</p><p>中序遍历是按照左子节点，根节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，用一个栈保存父节点以便最后访问，先找到最左节点，将其加入结果数组，然后访问其右子节点，重复此过程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> inorderTraversal(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        Inorder(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Inorder</span>(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        Inorder(root<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>        res.push_back(root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>        Inorder(root<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> inorderTraversal(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>&lt;</span>TreeNode <span style=color:#f92672>*&gt;</span> in;
</span></span><span style=display:flex><span>        TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> root;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (node <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>in.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (node) {
</span></span><span style=display:flex><span>                in.push(node);
</span></span><span style=display:flex><span>                node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>left;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>in.empty()) {
</span></span><span style=display:flex><span>                node <span style=color:#f92672>=</span> in.top();
</span></span><span style=display:flex><span>                in.pop();
</span></span><span style=display:flex><span>                res.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>                node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>right;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=145-二叉树的后序遍历httpsleetcode-cncomproblemsbinary-tree-postorder-traversal><a href=https://leetcode-cn.com/problems/binary-tree-postorder-traversal/>145 二叉树的后序遍历</a><a hidden class=anchor aria-hidden=true href=#145-二叉树的后序遍历httpsleetcode-cncomproblemsbinary-tree-postorder-traversal>#</a></h4><p>后序遍历一个二叉树。</p><p>后序遍历是按照左子节点，右子节点，根节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，用一个栈保存父节点以便最后访问，先找到最左节点，如果其已经是叶子节点则将其加入结果数组，否则访问其右子节点，用 last 保存上一次访问过的右子节点防止再次访问，重复此过程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> postorderTraversal(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        Postorder(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Postorder</span>(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        Postorder(root<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>        Postorder(root<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>        res.push_back(root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> postorderTraversal(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>&lt;</span>TreeNode <span style=color:#f92672>*&gt;</span> post;
</span></span><span style=display:flex><span>        TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> root, <span style=color:#f92672>*</span>last <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (node <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>post.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (node) {
</span></span><span style=display:flex><span>                post.push(node);
</span></span><span style=display:flex><span>                node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>left;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>post.empty()) {
</span></span><span style=display:flex><span>                node <span style=color:#f92672>=</span> post.top();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>&amp;&amp;</span> node<span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>!=</span> last)
</span></span><span style=display:flex><span>                    node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>right;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    res.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>                    post.pop();
</span></span><span style=display:flex><span>                    last <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>                    node <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=590-n叉树的后序遍历httpsleetcode-cncomproblemsn-ary-tree-postorder-traversal><a href=https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/>590 N叉树的后序遍历</a><a hidden class=anchor aria-hidden=true href=#590-n叉树的后序遍历httpsleetcode-cncomproblemsn-ary-tree-postorder-traversal>#</a></h4><p>跟二叉树的后序遍历类似，有递归和迭代两种做法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> postorder(Node <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        Postorder(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Postorder</span>(Node <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>c:root<span style=color:#f92672>-&gt;</span>children)
</span></span><span style=display:flex><span>            Postorder(c);
</span></span><span style=display:flex><span>        res.push_back(root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> postorder(Node <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>&lt;</span>Node <span style=color:#f92672>*&gt;</span> post;
</span></span><span style=display:flex><span>        post.push(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>post.empty()) {
</span></span><span style=display:flex><span>            Node <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> post.top();
</span></span><span style=display:flex><span>            post.pop();
</span></span><span style=display:flex><span>            res.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>c:node<span style=color:#f92672>-&gt;</span>children)
</span></span><span style=display:flex><span>                post.push(c);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        reverse(res.begin(), res.end());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=102-二叉树的层次遍历httpsleetcode-cncomproblemsbinary-tree-level-order-traversal><a href=https://leetcode-cn.com/problems/binary-tree-level-order-traversal/>102 二叉树的层次遍历</a><a hidden class=anchor aria-hidden=true href=#102-二叉树的层次遍历httpsleetcode-cncomproblemsbinary-tree-level-order-traversal>#</a></h4><p>给一个二叉树，返回其按层次遍历的节点值。</p><p>用一个队列来保存该二叉树当前一层的所有节点，一边将这些节点 pop 并 push 进结果数组中，一边将这些节点的子节点 push 进队列。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> levelOrder(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span>TreeNode <span style=color:#f92672>*&gt;</span> q;
</span></span><span style=display:flex><span>        q.push(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>            vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lvl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>                TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>                q.pop();
</span></span><span style=display:flex><span>                lvl.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>left)
</span></span><span style=display:flex><span>                    q.push(node<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>right)
</span></span><span style=display:flex><span>                    q.push(node<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            res.push_back(lvl);
</span></span><span style=display:flex><span>            n <span style=color:#f92672>=</span> q.size();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=107-二叉树的层次遍历-iihttpsleetcode-cncomproblemsbinary-tree-level-order-traversal-ii><a href=https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/>107 二叉树的层次遍历 II</a><a hidden class=anchor aria-hidden=true href=#107-二叉树的层次遍历-iihttpsleetcode-cncomproblemsbinary-tree-level-order-traversal-ii>#</a></h4><p>给一个二叉树，返回其节点值自底向上的层次遍历。</p><p>跟上一题相同，只需要将结果数组倒置，或用一个栈保存结果，再 pop 进结果数组即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> levelOrderBottom(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span>TreeNode <span style=color:#f92672>*&gt;</span> q;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        q.push(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>            vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lvl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>                TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>                q.pop();
</span></span><span style=display:flex><span>                lvl.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>left)
</span></span><span style=display:flex><span>                    q.push(node<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>right)
</span></span><span style=display:flex><span>                    q.push(node<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            res.push_back(lvl);
</span></span><span style=display:flex><span>            n <span style=color:#f92672>=</span> q.size();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        reverse(res.begin(), res.end());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=429-n-叉树的层序遍历httpsleetcode-cncomproblemsn-ary-tree-level-order-traversal><a href=https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/>429 N 叉树的层序遍历</a><a hidden class=anchor aria-hidden=true href=#429-n-叉树的层序遍历httpsleetcode-cncomproblemsn-ary-tree-level-order-traversal>#</a></h4><p>层序遍历一个 N 叉树。</p><p>用一个队列来保存该 N 叉树当前一层的所有节点，一边将这些节点 pop 并 push 进结果数组中，一边将这些节点的子节点 push 进队列。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> levelOrder(Node <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span>Node <span style=color:#f92672>*&gt;</span> q;
</span></span><span style=display:flex><span>        q.push(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>            vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lvl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>                Node <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>                q.pop();
</span></span><span style=display:flex><span>                lvl.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>c:node<span style=color:#f92672>-&gt;</span>children)
</span></span><span style=display:flex><span>                    q.push(c);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            res.push_back(lvl);
</span></span><span style=display:flex><span>            n <span style=color:#f92672>=</span> q.size();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=987-二叉树的垂序遍历httpsleetcode-cncomproblemsvertical-order-traversal-of-a-binary-tree><a href=https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/>987 二叉树的垂序遍历</a><a hidden class=anchor aria-hidden=true href=#987-二叉树的垂序遍历httpsleetcode-cncomproblemsvertical-order-traversal-of-a-binary-tree>#</a></h4><p>垂序遍历一个二叉树。</p><p>用红黑树把二叉树中每个节点的位置保存下来，如果根节点的位置是 (x, y)，那么其左子节点和右子节点的位置分别是 (x - 1, y + 1) 和 (x + 1, y + 1)，再按顺序保存到结果数组即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&gt;</span> matrix;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> verticalTraversal(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        matrix <span style=color:#f92672>=</span> map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&gt;</span>();
</span></span><span style=display:flex><span>        Traverse(root, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>m:matrix) {
</span></span><span style=display:flex><span>            vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> temp;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>n:m.second) {
</span></span><span style=display:flex><span>                sort(n.second.begin(), n.second.end());
</span></span><span style=display:flex><span>                temp.insert(temp.end(), n.second.begin(), n.second.end());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            res.push_back(temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Traverse</span>(TreeNode <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (matrix.find(x) <span style=color:#f92672>==</span> matrix.end())
</span></span><span style=display:flex><span>            matrix[x] <span style=color:#f92672>=</span> map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (matrix[x].find(y) <span style=color:#f92672>==</span> matrix[x].end())
</span></span><span style=display:flex><span>            matrix[x][y] <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        matrix[x][y].push_back(root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>        Traverse(root<span style=color:#f92672>-&gt;</span>left, x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        Traverse(root<span style=color:#f92672>-&gt;</span>right, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=103-二叉树的锯齿形层次遍历httpsleetcode-cncomproblemsbinary-tree-zigzag-level-order-traversal><a href=https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/>103 二叉树的锯齿形层次遍历</a><a hidden class=anchor aria-hidden=true href=#103-二叉树的锯齿形层次遍历httpsleetcode-cncomproblemsbinary-tree-zigzag-level-order-traversal>#</a></h4><p>锯齿形层次遍历一个二叉树。</p><p>用两个栈轮流从左往右和从右往左保存节点，再依次加入结果数组即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> zigzagLevelOrder(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>&lt;</span>TreeNode <span style=color:#f92672>*&gt;</span> s1, s2;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>        s1.push(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>s1.empty() <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>s2.empty()) {
</span></span><span style=display:flex><span>            vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lvl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (s2.empty()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>s1.empty()) {
</span></span><span style=display:flex><span>                    TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> s1.top();
</span></span><span style=display:flex><span>                    s1.pop();
</span></span><span style=display:flex><span>                    lvl.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>left)
</span></span><span style=display:flex><span>                        s2.push(node<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>right)
</span></span><span style=display:flex><span>                        s2.push(node<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>s2.empty()) {
</span></span><span style=display:flex><span>                    TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> s2.top();
</span></span><span style=display:flex><span>                    s2.pop();
</span></span><span style=display:flex><span>                    lvl.push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>right)
</span></span><span style=display:flex><span>                        s1.push(node<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>left)
</span></span><span style=display:flex><span>                        s1.push(node<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            res.push_back(lvl);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=124-二叉树中的最大路径和httpsleetcode-cncomproblemsbinary-tree-maximum-path-sum><a href=https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/>124 二叉树中的最大路径和</a><a hidden class=anchor aria-hidden=true href=#124-二叉树中的最大路径和httpsleetcode-cncomproblemsbinary-tree-maximum-path-sum>#</a></h4><p>用递归的方式，在每个节点值加上其左右子树的最大路径来更新结果，并以其左右子树中较大的一个加上其节点值返回即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> maxPathSum(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> INT_MIN;
</span></span><span style=display:flex><span>        Traverse(root);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Traverse</span>(TreeNode <span style=color:#f92672>*</span>node) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>node)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0</span>, Traverse(node<span style=color:#f92672>-&gt;</span>left));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0</span>, Traverse(node<span style=color:#f92672>-&gt;</span>right));
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> max(res, left <span style=color:#f92672>+</span> right <span style=color:#f92672>+</span> node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max(left, right) <span style=color:#f92672>+</span> node<span style=color:#f92672>-&gt;</span>val;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=968-监控二叉树httpsleetcode-cncomproblemsbinary-tree-cameras><a href=https://leetcode-cn.com/problems/binary-tree-cameras/>968 监控二叉树</a><a hidden class=anchor aria-hidden=true href=#968-监控二叉树httpsleetcode-cncomproblemsbinary-tree-cameras>#</a></h4><p>贪心法，分情况讨论，三种状态分别是：0 表示节点未被监控，1 表示节点自带监控，2 表示节点被子节点监控；一个节点的两个字子节点组合起来分别由 6 种情况，分别是：若两个子节点都为 2（22），那么当前节点未被监控，需要被父节点监控，返回 0；若两个子节点至少有一个为 0（00，01，02，未被监控），那么当前节点需要装上监控以监控子节点，返回 1；剩下的 2 种情况是至少有一个子节点自带监控（11，12），那么当前节点被子节点监控，且其子节点都已被监控或自带监控，返回 2；最后需要单独判断树的根节点是否是 0 的状态，因为已经没有父节点可以进行监控。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minCameraCover(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Traverse(root) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Traverse</span>(TreeNode <span style=color:#f92672>*</span>node) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>node)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> Traverse(node<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> Traverse(node<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> right <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> right <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>res;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=2-构造二叉树>2. 构造二叉树<a hidden class=anchor aria-hidden=true href=#2-构造二叉树>#</a></h3><h4 id=105-从前序与中序遍历序列构造二叉树httpsleetcode-cncomproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal><a href=https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>105 从前序与中序遍历序列构造二叉树</a><a hidden class=anchor aria-hidden=true href=#105-从前序与中序遍历序列构造二叉树httpsleetcode-cncomproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal>#</a></h4><p>根据前序遍历与中序遍历的结果构造二叉树。</p><p>前序遍历结果中的第一个元素一定是二叉树的根节点的值，因此在中序遍历结果中找到这个值，那么中序遍历结果中这个值左边的所有元素一定都在这个根节点的左子树上，右边的所有元素一定都在这个根节点的右子树上，假设左边的长度为 m，那么在前序遍历结果的第一个元素后的 m 个元素也都对应左子树上的这些元素，分别把这两部分递归调用构造新的子树即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span>buildTree(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>preorder, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>inorder) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Build</span>(preorder, <span style=color:#ae81ff>0</span>, preorder.size(), inorder, <span style=color:#ae81ff>0</span>, inorder.size());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span><span style=color:#a6e22e>Build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>preorder, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>inorder, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&gt;=</span> y <span style=color:#f92672>||</span> m <span style=color:#f92672>&gt;=</span> n)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeNode(preorder[x]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> pos <span style=color:#f92672>=</span> m;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (pos <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> inorder[pos] <span style=color:#f92672>!=</span> preorder[x])
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>pos;
</span></span><span style=display:flex><span>        node<span style=color:#f92672>-&gt;</span>left <span style=color:#f92672>=</span> Build(preorder, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> pos <span style=color:#f92672>-</span> m, inorder, m, pos);
</span></span><span style=display:flex><span>        node<span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>=</span> Build(preorder, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> pos <span style=color:#f92672>-</span> m, y, inorder, pos <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=106-从中序与后序遍历序列构造二叉树httpsleetcode-cncomproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal><a href=https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/>106 从中序与后序遍历序列构造二叉树</a><a hidden class=anchor aria-hidden=true href=#106-从中序与后序遍历序列构造二叉树httpsleetcode-cncomproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal>#</a></h4><p>根据后序遍历与中序遍历的结果构造二叉树。</p><p>后序遍历结果中的最后一个元素一定是二叉树的根节点的值，因此在中序遍历结果中找到这个值，那么中序遍历结果中这个值左边的所有元素一定都在这个根节点的左子树上，右边的所有元素一定都在这个根节点的右子树上，假设左边的长度为 m，那么在后序遍历结果中从第一个元素往后 m 个元素也都对应左子树上的这些元素，分别把这两部分递归调用构造新的子树即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span>buildTree(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>inorder, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>postorder) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Build</span>(inorder, <span style=color:#ae81ff>0</span>, inorder.size(), postorder, <span style=color:#ae81ff>0</span>, postorder.size());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span><span style=color:#a6e22e>Build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>inorder, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>postorder, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&gt;=</span> y <span style=color:#f92672>||</span> m <span style=color:#f92672>&gt;=</span> n)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeNode(postorder[n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> pos <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (pos <span style=color:#f92672>&lt;</span> y <span style=color:#f92672>&amp;&amp;</span> inorder[pos] <span style=color:#f92672>!=</span> postorder[n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>pos;
</span></span><span style=display:flex><span>        node<span style=color:#f92672>-&gt;</span>left <span style=color:#f92672>=</span> Build(inorder, x, pos, postorder, m, m <span style=color:#f92672>+</span> pos <span style=color:#f92672>-</span> x);
</span></span><span style=display:flex><span>        node<span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>=</span> Build(inorder, pos <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, y, postorder, m <span style=color:#f92672>+</span> pos <span style=color:#f92672>-</span> x, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=889-根据前序和后序遍历构造二叉树httpsleetcode-cncomproblemsconstruct-binary-tree-from-preorder-and-postorder-traversal><a href=https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/>889 根据前序和后序遍历构造二叉树</a><a hidden class=anchor aria-hidden=true href=#889-根据前序和后序遍历构造二叉树httpsleetcode-cncomproblemsconstruct-binary-tree-from-preorder-and-postorder-traversal>#</a></h4><p>根据前序遍历与后序遍历的结果构造二叉树。</p><p>前序遍历结果中的第一个元素对应后序遍历结果中的最后一个元素，都是二叉树的根节点的值，以此构建根节点；前序遍历结果中的第二个元素一定是根节点的左子节点，而后序遍历结果中的这个值一定是左子树上的最后一个值，那么只需要找到这个值在后序遍历结果中的位置，就可以确定左子树和右子树的长度，分别递归调用构造新的子树即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span>constructFromPrePost(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>pre, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>post) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Build</span>(pre, <span style=color:#ae81ff>0</span>, pre.size(), post, <span style=color:#ae81ff>0</span>, post.size());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span><span style=color:#a6e22e>Build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>pre, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>post, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&gt;=</span> y <span style=color:#f92672>||</span> m <span style=color:#f92672>&gt;=</span> n)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeNode(pre[x]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>==</span> y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> pos <span style=color:#f92672>=</span> m;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (pos <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> post[pos] <span style=color:#f92672>!=</span> pre[x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>pos;
</span></span><span style=display:flex><span>        node<span style=color:#f92672>-&gt;</span>left <span style=color:#f92672>=</span> Build(pre, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, x <span style=color:#f92672>+</span> pos <span style=color:#f92672>-</span> m <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>, post, m, pos <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        node<span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>=</span> Build(pre, x <span style=color:#f92672>+</span> pos <span style=color:#f92672>-</span> m <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>, y, post, pos <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=1008-先序遍历构造二叉树httpsleetcode-cncomproblemsconstruct-binary-search-tree-from-preorder-traversal><a href=https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/>1008 先序遍历构造二叉树</a><a hidden class=anchor aria-hidden=true href=#1008-先序遍历构造二叉树httpsleetcode-cncomproblemsconstruct-binary-search-tree-from-preorder-traversal>#</a></h4><p>给一个先序遍历的结果，构造其对应的二叉搜索树。</p><p>根据先序遍历和二叉搜索树的定义，数组的第一个元素即是根节点，其后所有小于它的元素都在它的左子树上，所有大于它的元素都在它的右子树上，递归求解即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span>bstFromPreorder(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>preorder) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Build</span>(preorder, <span style=color:#ae81ff>0</span>, preorder.size());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span><span style=color:#a6e22e>Build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>preorder, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&gt;=</span> y)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        TreeNode <span style=color:#f92672>*</span>root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeNode(preorder[x]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> y <span style=color:#f92672>&amp;&amp;</span> preorder[i] <span style=color:#f92672>&lt;</span> preorder[x])
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>i;
</span></span><span style=display:flex><span>        root<span style=color:#f92672>-&gt;</span>left <span style=color:#f92672>=</span> Build(preorder, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, i);
</span></span><span style=display:flex><span>        root<span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>=</span> Build(preorder, i, y);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=1028-从先序遍历还原二叉树httpsleetcode-cncomproblemsrecover-a-tree-from-preorder-traversal><a href=https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/>1028 从先序遍历还原二叉树</a><a hidden class=anchor aria-hidden=true href=#1028-从先序遍历还原二叉树httpsleetcode-cncomproblemsrecover-a-tree-from-preorder-traversal>#</a></h4><p>给一个先序遍历的结果和用不同长度的 &lsquo;-&rsquo; 相连的字符串，构造其对应的二叉树。</p><p>&lsquo;-&rsquo; 的长度代表当前的层次，如果当前节点之后的 &lsquo;-&rsquo; 的长度等于当前的层次加一，那么其后的数构成当前节点的左节点；如果左节点之后的 &lsquo;-&rsquo; 的长度等于当前的层次加一，那么其后的数构成当前节点的右节点；否则如果当前节点之后或左节点之后的 &lsquo;-&rsquo; 的长度小于等于等钱层次则代表当前节点已经是叶子节点，其没有左右子节点，直接返回。用一个变量 pos 保存当前遍历到的字符串位置，递归调用该过程即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span>recoverFromPreorder(string S) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Build</span>(S, <span style=color:#ae81ff>0</span>, pos, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode <span style=color:#f92672>*</span><span style=color:#a6e22e>Build</span>(<span style=color:#66d9ef>const</span> string <span style=color:#f92672>&amp;</span>S, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>pos, <span style=color:#66d9ef>int</span> lvl) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, i <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (S[i] <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>&amp;&amp;</span> S[i] <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;9&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>i;
</span></span><span style=display:flex><span>        TreeNode <span style=color:#f92672>*</span>node <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeNode(stoi(S.substr(x, i <span style=color:#f92672>-</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)));
</span></span><span style=display:flex><span>        pos <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (S[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;-&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>-</span> pos <span style=color:#f92672>==</span> lvl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            node<span style=color:#f92672>-&gt;</span>left <span style=color:#f92672>=</span> Build(S, i, pos, lvl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> pos;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (S[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;-&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>-</span> pos <span style=color:#f92672>==</span> lvl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            node<span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>=</span> Build(S, i, y, pos, lvl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/leetcode/tree-2/><span class=title>« Prev</span><br><span>LeetCode 树（2）</span>
</a><a class=next href=https://prov1dence.top/posts/leetcode/linkedlist-2/><span class=title>Next »</span><br><span>LeetCode 链表（2）</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>