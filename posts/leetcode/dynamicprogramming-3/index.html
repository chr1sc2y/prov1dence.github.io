<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LeetCode 动态规划（3） | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content="LeetCode 动态规划
题目
6. 字符串相关
712 两个字符串的最小ASCII删除和
给定两个字符串，计算使两个字符串相同所需要删除的字符的ASCII值的和的最小值。
对于两个字符串中的字符 s1[i] 和 s2[j]，如果s1[i] == s2[j]，那么这两个字符都不需要被删除，所以 dp[i][j] = dp[i - 1][j - 1]，否则至少有一个应该被删除，取两个中的最小值，状态转移方程是dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int n1 = s1.size(), n2 = s2.size();
        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));
        for (int i = 1; i <= n1; ++i)
            dp[i][0] = dp[i - 1][0] + s1[i - 1];
        for (int j = 1; j <= n2; ++j)
            dp[0][j] = dp[0][j - 1] + s2[j - 1];
        for (int i = 0; i < n1; ++i)
            for (int j = 0; j < n2; ++j)
                if (s1[i] == s2[j])
                    dp[i + 1][j + 1] = dp[i][j];
                else
                    dp[i + 1][j + 1] = min(dp[i][j] + s1[i] + s2[j], min(dp[i][j + 1] + s1[i], dp[i + 1][j] + s2[j]));
        return dp[n1][n2];
    }
};
5 最长回文子串
找到一个字符串中的最长回文子串。"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/leetcode/dynamicprogramming-3/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/leetcode/dynamicprogramming-3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/leetcode/dynamicprogramming-3/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="LeetCode 动态规划（3）"><meta property="og:description" content="LeetCode 动态规划 题目 6. 字符串相关 712 两个字符串的最小ASCII删除和 给定两个字符串，计算使两个字符串相同所需要删除的字符的ASCII值的和的最小值。
对于两个字符串中的字符 s1[i] 和 s2[j]，如果s1[i] == s2[j]，那么这两个字符都不需要被删除，所以 dp[i][j] = dp[i - 1][j - 1]，否则至少有一个应该被删除，取两个中的最小值，状态转移方程是dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。
class Solution { public: int minimumDeleteSum(string s1, string s2) { int n1 = s1.size(), n2 = s2.size(); vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0)); for (int i = 1; i <= n1; ++i) dp[i][0] = dp[i - 1][0] + s1[i - 1]; for (int j = 1; j <= n2; ++j) dp[0][j] = dp[0][j - 1] + s2[j - 1]; for (int i = 0; i < n1; ++i) for (int j = 0; j < n2; ++j) if (s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j]; else dp[i + 1][j + 1] = min(dp[i][j] + s1[i] + s2[j], min(dp[i][j + 1] + s1[i], dp[i + 1][j] + s2[j])); return dp[n1][n2]; } }; 5 最长回文子串 找到一个字符串中的最长回文子串。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-01T18:22:45+10:00"><meta property="article:modified_time" content="2019-07-01T18:22:45+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode 动态规划（3）"><meta name=twitter:description content="LeetCode 动态规划
题目
6. 字符串相关
712 两个字符串的最小ASCII删除和
给定两个字符串，计算使两个字符串相同所需要删除的字符的ASCII值的和的最小值。
对于两个字符串中的字符 s1[i] 和 s2[j]，如果s1[i] == s2[j]，那么这两个字符都不需要被删除，所以 dp[i][j] = dp[i - 1][j - 1]，否则至少有一个应该被删除，取两个中的最小值，状态转移方程是dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int n1 = s1.size(), n2 = s2.size();
        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));
        for (int i = 1; i <= n1; ++i)
            dp[i][0] = dp[i - 1][0] + s1[i - 1];
        for (int j = 1; j <= n2; ++j)
            dp[0][j] = dp[0][j - 1] + s2[j - 1];
        for (int i = 0; i < n1; ++i)
            for (int j = 0; j < n2; ++j)
                if (s1[i] == s2[j])
                    dp[i + 1][j + 1] = dp[i][j];
                else
                    dp[i + 1][j + 1] = min(dp[i][j] + s1[i] + s2[j], min(dp[i][j + 1] + s1[i], dp[i + 1][j] + s2[j]));
        return dp[n1][n2];
    }
};
5 最长回文子串
找到一个字符串中的最长回文子串。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode 动态规划（3）","item":"https://prov1dence.top/posts/leetcode/dynamicprogramming-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode 动态规划（3）","name":"LeetCode 动态规划（3）","description":"LeetCode 动态规划 题目 6. 字符串相关 712 两个字符串的最小ASCII删除和 给定两个字符串，计算使两个字符串相同所需要删除的字符的ASCII值的和的最小值。\n对于两个字符串中的字符 s1[i] 和 s2[j]，如果s1[i] == s2[j]，那么这两个字符都不需要被删除，所以 dp[i][j] = dp[i - 1][j - 1]，否则至少有一个应该被删除，取两个中的最小值，状态转移方程是dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\nclass Solution { public: int minimumDeleteSum(string s1, string s2) { int n1 = s1.size(), n2 = s2.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n1 + 1, vector\u0026lt;int\u0026gt;(n2 + 1, 0)); for (int i = 1; i \u0026lt;= n1; ++i) dp[i][0] = dp[i - 1][0] + s1[i - 1]; for (int j = 1; j \u0026lt;= n2; ++j) dp[0][j] = dp[0][j - 1] + s2[j - 1]; for (int i = 0; i \u0026lt; n1; ++i) for (int j = 0; j \u0026lt; n2; ++j) if (s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j]; else dp[i + 1][j + 1] = min(dp[i][j] + s1[i] + s2[j], min(dp[i][j + 1] + s1[i], dp[i + 1][j] + s2[j])); return dp[n1][n2]; } }; 5 最长回文子串 找到一个字符串中的最长回文子串。\n","keywords":[],"articleBody":"LeetCode 动态规划 题目 6. 字符串相关 712 两个字符串的最小ASCII删除和 给定两个字符串，计算使两个字符串相同所需要删除的字符的ASCII值的和的最小值。\n对于两个字符串中的字符 s1[i] 和 s2[j]，如果s1[i] == s2[j]，那么这两个字符都不需要被删除，所以 dp[i][j] = dp[i - 1][j - 1]，否则至少有一个应该被删除，取两个中的最小值，状态转移方程是dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\nclass Solution { public: int minimumDeleteSum(string s1, string s2) { int n1 = s1.size(), n2 = s2.size(); vector\u003cvector\u003cint\u003e\u003e dp(n1 + 1, vector\u003cint\u003e(n2 + 1, 0)); for (int i = 1; i \u003c= n1; ++i) dp[i][0] = dp[i - 1][0] + s1[i - 1]; for (int j = 1; j \u003c= n2; ++j) dp[0][j] = dp[0][j - 1] + s2[j - 1]; for (int i = 0; i \u003c n1; ++i) for (int j = 0; j \u003c n2; ++j) if (s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j]; else dp[i + 1][j + 1] = min(dp[i][j] + s1[i] + s2[j], min(dp[i][j + 1] + s1[i], dp[i + 1][j] + s2[j])); return dp[n1][n2]; } }; 5 最长回文子串 找到一个字符串中的最长回文子串。\n最简单的方法是从一个字符与其前一个/两个字符分别往两边遍历。也可以按照自下而上的动态规划思想，用一个二维数组 dp[i][j]，判断两个字符 s[i] 与 s[j] 是否相等，以及他们内侧的子字符串是否是一个回文串，状态转移方程是 dp[i][j] = s[i] == s[j] \u0026\u0026 (dp[i + 1][j - 1] || j - i \u003c 3)。\nclass Solution { public: string longestPalindrome(string s) { int n = s.size(); string res; vector\u003cvector\u003cbool\u003e\u003e dp(n, vector\u003cbool\u003e(n, false)); for (int i = 0; i \u003c n; ++i) for (int j = i; j \u003e= 0; --j) if (s[i] == s[j] \u0026\u0026 (i - j \u003c 3 || dp[j + 1][i - 1])) { dp[j][i] = true; if (i - j + 1 \u003e res.size()) res = s.substr(j, i - j + 1); } return res; } }; 647 回文子串 找到一个字符串中的回文子串的个数。\n与上一题类似，用一个二维数组 dp[i][j]，判断两个字符 s[i] 与 s[j] 是否相等，以及他们内侧的子字符串是否是一个回文串，如果是那么 s.substr(j, i - j + 1)，将结果 +1 即可。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。\nclass Solution { public: int countSubstrings(string s) { int res = 0, n = s.size(); vector\u003cvector\u003cbool\u003e\u003e dp(n, vector\u003cbool\u003e(n, false)); for (int i = 0; i \u003c n; ++i) for (int j = i; j \u003e= 0; --j) if (s[i] == s[j] \u0026\u0026 (i - j \u003c 3 || dp[j + 1][i - 1])) dp[j][i] = true, ++res; return res; } }; 516 最长回文子序列 给定一个字符串，找最长的回文子序列。\n只有当两个字符相等时，他们才有可能和他们之间的子序列形成回文子序列，因此只需要知道他们之间的最长回文子序列的长度即可，否则他们之间的最长回文子序列只能是其中一个字符的左边或右边到另一个字符之间的最大回文子序列长度，状态转移方程是 dp[j][i] = s[i] == s[j] ? dp[j + 1][i - 1] + 2 : max(dp[j + 1][i], dp[j][i - 1])。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。\nclass Solution { public: int longestPalindromeSubseq(string s) { int n = s.size(); if (n \u003c= 1) return n; vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(n, 0)); for (int i = 1; i \u003c n; ++i) { dp[i][i] = 1; for (int j = i - 1; j \u003e= 0; --j) { if (s[i] == s[j]) dp[j][i] = dp[j + 1][i - 1] + 2; else dp[j][i] = max(dp[j + 1][i], dp[j][i - 1]); } } return dp[0][n - 1]; } }; 7. 路径和 62 不同路径 给一个矩阵，求从左上角走到右下角有多少种方法。\n走到第一列和第一行的每一格都只有一种方法，其余的格子均可以从其上方和左方走一格到达，因此有状态转移方程 dp[i][j] = dp[i][j - 1] + dp[i - 1][j]。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\nclass Solution { public: int uniquePaths(int m, int n) { if (m == 0 || n == 0) return 0; vector\u003cvector\u003cint\u003e\u003e dp(m, vector\u003cint\u003e(n, 1)); for (int i = 1; i \u003c m; ++i) for (int j = 1; j \u003c n; ++j) dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; return dp[m - 1][n - 1]; } }; 对于每一个格子来说，它的值都等于到达上方和左方格子的方法数量之和，也就相当于在遍历完一行之后，把上一行的值全部赋值给下一行，在下一行遍历时使其加上左方格子的方法数量，由此可以将赋值的过程简化为一个一维数组，空间复杂度降低为 O(min(m, n))。\nclass Solution { public: int uniquePaths(int m, int n) { if (m == 0 || n == 0) return 0; vector\u003cint\u003e dp(n, 1); for (int i = 1; i \u003c m; ++i) for (int j = 1; j \u003c n; ++j) dp[j] += dp[j - 1]; return dp[n - 1]; } }; 63 不同路径 II 给一个矩阵，部分位置有障碍物，求从左上角走到右下角有多少种方法。\n和上一题相比在部分位置增加了障碍物，首先要处理第一列和第一行，如果有一个位置有障碍物那么接下来的位置都不能到达了，然后对于其他格子，如果本身是障碍物那么也无法到达，否则仍然等于其上方和左方之和。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。\nclass Solution { public: int uniquePathsWithObstacles(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int m = grid.size(), n = m != 0 ? grid[0].size() : 0; if (m == 0 || n == 0) return 0; vector\u003cvector\u003clong long\u003e\u003e dp(m, vector\u003clong long\u003e(n, 0)); dp[0][0] = grid[0][0] ^ 1; for (int i = 1; i \u003c m; ++i) dp[i][0] = (grid[i][0] ^ 1) \u0026 dp[i - 1][0]; for (int j = 1; j \u003c n; ++j) dp[0][j] = (grid[0][j] ^ 1) \u0026 dp[0][j - 1]; for (int i = 1; i \u003c m; ++i) for (int j = 1; j \u003c n; ++j) dp[i][j] = grid[i][j] ? 0 : dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; } }; 64 最小路径和 给一个带权值的矩阵，求从左上角走到右下角的最小权值之和。\n到达第一列和第一行的每一格都只有一种方法，因此先将其初始化。因为每一格只能从其上方和左方到达，因此有状态转移方程 grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])。时间复杂度是 O(m * n)。可以直接在给的矩阵中操作，因此空间复杂度是 O(1)。\nclass Solution { public: int minPathSum(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int m = grid.size(), n = m != 0 ? grid[0].size() : 0; if (m == 0) return 0; for (int i = 1; i \u003c m; ++i) grid[i][0] += grid[i - 1][0]; for (int j = 1; j \u003c n; ++j) grid[0][j] += grid[0][j - 1]; for (int i = 1; i \u003c m; ++i) for (int j = 1; j \u003c n; ++j) grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]); return grid[m - 1][n - 1]; } }; 120 三角形最小路径和 给一个带权值的三角形，求自顶向下的最小路径和。每一步可以移动到左下方或右下方。\n因为每一格只能从其左上方和右上方到达，因此有状态转移方程 tri[i][j] += min(tri[i - 1][j], tri[i - 1][j - 1])。时间复杂度是 O(m * n)。可以直接在给的矩阵中操作，因此空间复杂度是 O(1)。\nclass Solution { public: int minimumTotal(vector\u003cvector\u003cint\u003e\u003e \u0026tri) { int n = tri.size(), res = INT_MAX; if (n \u003c= 1) return n == 0 ? 0 : tri[0][0]; for (int i = 1; i \u003c n; ++i) { for (int j = 0; j \u003c tri[i].size(); ++j) { if (j == 0) tri[i][j] += tri[i - 1][j]; else if (j \u003e= tri[i - 1].size()) tri[i][j] += tri[i - 1][j - 1]; else tri[i][j] += min(tri[i - 1][j], tri[i - 1][j - 1]); if (i == n - 1) res = min(res, tri[i][j]); } } return res; } }; 931 下降路径最小和 给一个带权值的方形，求自顶向下的最小路径和。每一步可以移动到左下方，下方或右下方。\n每一格可以从其左上方，上方和右上方到达，因此有状态转移方程 A[i][j] += min({A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1]})。\nclass Solution { public: int minFallingPathSum(vector\u003cvector\u003cint\u003e\u003e\u0026 A) { int m = A.size(), n = m != 0 ? A[0].size() : 0, val = INT_MAX, res = INT_MAX; if (m == 0) return 0; for (int i = 1; i \u003c m; ++i) { for (int j = 0; j \u003c n; ++j) { val = A[i - 1][j]; if (j \u003c n - 1) val = min(val, A[i - 1][j + 1]); if (j \u003e 0) val = min(val, A[i - 1][j - 1]); A[i][j] += val; } } return *min_element(A[m - 1].begin(), A[m - 1].end()); } }; 8. 其他 650 只有两个键的键盘 有一个字符 ‘A’，只能进行复制和粘贴操作，求得到 n 个 ‘A’ 的最小操作次数。\nm 个 ‘A’ 只能通过粘贴的操作得到，求出所有能整除 m 的数里通过复制粘贴操作得到 m 的最小次数即可。\nclass Solution { public: int minSteps(int n) { vector\u003cint\u003e dp(n + 1, n); dp[1] = 0; for (int i = 1; i \u003c= n; ++i) { int res = dp[i] + 1; for (int j = i; j \u003c= n; j += i) { dp[j] = min(dp[j], res); ++res; } } return dp[n]; } }; 651 4键键盘 一个键盘上有四个键：输入 ‘A’，选中全部，复制，和粘贴。可以按 N 次键盘，求最多能显示多少个 ‘A’。\n因为 N 是最后一次操作，所以只能进行输入 ‘A’ 和粘贴两种操作，只需要求出每一步在之前一步基础上输入 ‘A’，以及在往前三步的每一步基础上选中，复制，粘贴能得到的最2优解。\nclass Solution { public: int maxA(int N) { vector\u003cint\u003e dp(N + 1, 0); for (int i = 1; i \u003c= N; ++i) { dp[i] = dp[i - 1] + 1; for (int j = i - 1; j \u003e= 2; --j) dp[i] = max(dp[i], dp[j - 2] * (i - j + 1)); } return dp[N]; } }; ","wordCount":"1192","inLanguage":"en","datePublished":"2019-07-01T18:22:45+10:00","dateModified":"2019-07-01T18:22:45+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/leetcode/dynamicprogramming-3/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">LeetCode 动态规划（3）</h1><div class=post-meta><span title='2019-07-01 18:22:45 +1000 AEST'>July 1, 2019</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#leetcode-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92httpsleetcode-cncomproblemsetallsearche4b891e695b0 aria-label="LeetCode 动态规划">LeetCode 动态规划</a><ul><li><a href=#%e9%a2%98%e7%9b%ae aria-label=题目>题目</a><ul><li><a href=#6-%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9b%b8%e5%85%b3 aria-label="6. 字符串相关">6. 字符串相关</a><ul><li><a href=#712-%e4%b8%a4%e4%b8%aa%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%9c%80%e5%b0%8fascii%e5%88%a0%e9%99%a4%e5%92%8chttpsleetcode-cncomproblemsminimum-ascii-delete-sum-for-two-strings aria-label="712 两个字符串的最小ASCII删除和">712 两个字符串的最小ASCII删除和</a></li><li><a href=#5-%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%90%e4%b8%b2httpsleetcode-cncomproblemslongest-palindromic-substring aria-label="5 最长回文子串">5 最长回文子串</a></li><li><a href=#647-%e5%9b%9e%e6%96%87%e5%ad%90%e4%b8%b2httpsleetcode-cncomproblemspalindromic-substrings aria-label="647 回文子串">647 回文子串</a></li><li><a href=#516-%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%90%e5%ba%8f%e5%88%97httpsleetcode-cncomproblemslongest-palindromic-subsequence aria-label="516 最长回文子序列">516 最长回文子序列</a></li></ul></li><li><a href=#7-%e8%b7%af%e5%be%84%e5%92%8c aria-label="7. 路径和">7. 路径和</a><ul><li><a href=#62-%e4%b8%8d%e5%90%8c%e8%b7%af%e5%be%84httpsleetcode-cncomproblemsunique-paths aria-label="62 不同路径">62 不同路径</a></li><li><a href=#63-%e4%b8%8d%e5%90%8c%e8%b7%af%e5%be%84-iihttpsleetcode-cncomproblemsunique-paths-ii aria-label="63 不同路径 II">63 不同路径 II</a></li><li><a href=#64-%e6%9c%80%e5%b0%8f%e8%b7%af%e5%be%84%e5%92%8chttpsleetcode-cncomproblemsminimum-path-sum aria-label="64 最小路径和">64 最小路径和</a></li><li><a href=#120-%e4%b8%89%e8%a7%92%e5%bd%a2%e6%9c%80%e5%b0%8f%e8%b7%af%e5%be%84%e5%92%8chttpsleetcode-cncomproblemstriangle aria-label="120 三角形最小路径和">120 三角形最小路径和</a></li><li><a href=#931-%e4%b8%8b%e9%99%8d%e8%b7%af%e5%be%84%e6%9c%80%e5%b0%8f%e5%92%8chttpsleetcode-cncomproblemsminimum-falling-path-sum aria-label="931 下降路径最小和">931 下降路径最小和</a></li></ul></li><li><a href=#8-%e5%85%b6%e4%bb%96 aria-label="8. 其他">8. 其他</a><ul><li><a href=#650-%e5%8f%aa%e6%9c%89%e4%b8%a4%e4%b8%aa%e9%94%ae%e7%9a%84%e9%94%ae%e7%9b%98httpsleetcode-cncomproblems2-keys-keyboard aria-label="650 只有两个键的键盘">650 只有两个键的键盘</a></li><li><a href=#651-4%e9%94%ae%e9%94%ae%e7%9b%98httpsleetcode-cncomproblems4-keys-keyboardsubmissions aria-label="651 4键键盘">651 4键键盘</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=leetcode-动态规划httpsleetcode-cncomproblemsetallsearche4b891e695b0><a href="https://leetcode-cn.com/problemset/all/?search=%E4%B8%91%E6%95%B0">LeetCode 动态规划</a><a hidden class=anchor aria-hidden=true href=#leetcode-动态规划httpsleetcode-cncomproblemsetallsearche4b891e695b0>#</a></h1><h2 id=题目>题目<a hidden class=anchor aria-hidden=true href=#题目>#</a></h2><h3 id=6-字符串相关>6. 字符串相关<a hidden class=anchor aria-hidden=true href=#6-字符串相关>#</a></h3><h4 id=712-两个字符串的最小ascii删除和httpsleetcode-cncomproblemsminimum-ascii-delete-sum-for-two-strings><a href=https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/>712 两个字符串的最小ASCII删除和</a><a hidden class=anchor aria-hidden=true href=#712-两个字符串的最小ascii删除和httpsleetcode-cncomproblemsminimum-ascii-delete-sum-for-two-strings>#</a></h4><p>给定两个字符串，计算使两个字符串相同所需要删除的字符的ASCII值的和的最小值。</p><p>对于两个字符串中的字符 s1[i] 和 s2[j]，如果s1[i] == s2[j]，那么这两个字符都不需要被删除，所以 dp[i][j] = dp[i - 1][j - 1]，否则至少有一个应该被删除，取两个中的最小值，状态转移方程是dp[i][j] = min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minimumDeleteSum(string s1, string s2) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n1 <span style=color:#f92672>=</span> s1.size(), n2 <span style=color:#f92672>=</span> s2.size();
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(n1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n1; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            dp[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> s1[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n2; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>            dp[<span style=color:#ae81ff>0</span>][j] <span style=color:#f92672>=</span> dp[<span style=color:#ae81ff>0</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> s2[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n1; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n2; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (s1[i] <span style=color:#f92672>==</span> s2[j])
</span></span><span style=display:flex><span>                    dp[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> dp[i][j];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    dp[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> min(dp[i][j] <span style=color:#f92672>+</span> s1[i] <span style=color:#f92672>+</span> s2[j], min(dp[i][j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> s1[i], dp[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>+</span> s2[j]));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[n1][n2];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=5-最长回文子串httpsleetcode-cncomproblemslongest-palindromic-substring><a href=https://leetcode-cn.com/problems/longest-palindromic-substring/>5 最长回文子串</a><a hidden class=anchor aria-hidden=true href=#5-最长回文子串httpsleetcode-cncomproblemslongest-palindromic-substring>#</a></h4><p>找到一个字符串中的最长回文子串。</p><p>最简单的方法是从一个字符与其前一个/两个字符分别往两边遍历。也可以按照自下而上的动态规划思想，用一个二维数组 dp[i][j]，判断两个字符 s[i] 与 s[j] 是否相等，以及他们内侧的子字符串是否是一个回文串，状态转移方程是 dp[i][j] = s[i] == s[j] && (dp[i + 1][j - 1] || j - i &lt; 3)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    string longestPalindrome(string s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> s.size();
</span></span><span style=display:flex><span>        string res;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> dp(n, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(n, false));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>j)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (s[i] <span style=color:#f92672>==</span> s[j] <span style=color:#f92672>&amp;&amp;</span> (i <span style=color:#f92672>-</span> j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>||</span> dp[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])) {
</span></span><span style=display:flex><span>                    dp[j][i] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>-</span> j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;</span> res.size())
</span></span><span style=display:flex><span>                        res <span style=color:#f92672>=</span> s.substr(j, i <span style=color:#f92672>-</span> j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=647-回文子串httpsleetcode-cncomproblemspalindromic-substrings><a href=https://leetcode-cn.com/problems/palindromic-substrings/>647 回文子串</a><a hidden class=anchor aria-hidden=true href=#647-回文子串httpsleetcode-cncomproblemspalindromic-substrings>#</a></h4><p>找到一个字符串中的回文子串的个数。</p><p>与上一题类似，用一个二维数组 dp[i][j]，判断两个字符 s[i] 与 s[j] 是否相等，以及他们内侧的子字符串是否是一个回文串，如果是那么 s.substr(j, i - j + 1)，将结果 +1 即可。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> countSubstrings(string s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, n <span style=color:#f92672>=</span> s.size();
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> dp(n, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(n, false));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>j)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (s[i] <span style=color:#f92672>==</span> s[j] <span style=color:#f92672>&amp;&amp;</span> (i <span style=color:#f92672>-</span> j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>||</span> dp[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>                    dp[j][i] <span style=color:#f92672>=</span> true, <span style=color:#f92672>++</span>res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=516-最长回文子序列httpsleetcode-cncomproblemslongest-palindromic-subsequence><a href=https://leetcode-cn.com/problems/longest-palindromic-subsequence/>516 最长回文子序列</a><a hidden class=anchor aria-hidden=true href=#516-最长回文子序列httpsleetcode-cncomproblemslongest-palindromic-subsequence>#</a></h4><p>给定一个字符串，找最长的回文子序列。</p><p>只有当两个字符相等时，他们才有可能和他们之间的子序列形成回文子序列，因此只需要知道他们之间的最长回文子序列的长度即可，否则他们之间的最长回文子序列只能是其中一个字符的左边或右边到另一个字符之间的最大回文子序列长度，状态转移方程是 dp[j][i] = s[i] == s[j] ? dp[j + 1][i - 1] + 2 : max(dp[j + 1][i], dp[j][i - 1])。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> longestPalindromeSubseq(string s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> s.size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> n;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(n, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            dp[i][i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>j) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (s[i] <span style=color:#f92672>==</span> s[j])
</span></span><span style=display:flex><span>                    dp[j][i] <span style=color:#f92672>=</span> dp[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    dp[j][i] <span style=color:#f92672>=</span> max(dp[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][i], dp[j][i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[<span style=color:#ae81ff>0</span>][n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=7-路径和>7. 路径和<a hidden class=anchor aria-hidden=true href=#7-路径和>#</a></h3><h4 id=62-不同路径httpsleetcode-cncomproblemsunique-paths><a href=https://leetcode-cn.com/problems/unique-paths/>62 不同路径</a><a hidden class=anchor aria-hidden=true href=#62-不同路径httpsleetcode-cncomproblemsunique-paths>#</a></h4><p>给一个矩阵，求从左上角走到右下角有多少种方法。</p><p>走到第一列和第一行的每一格都只有一种方法，其余的格子均可以从其上方和左方走一格到达，因此有状态转移方程 dp[i][j] = dp[i][j - 1] + dp[i - 1][j]。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> uniquePaths(<span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> dp[i][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>对于每一个格子来说，它的值都等于到达上方和左方格子的方法数量之和，也就相当于在遍历完一行之后，把上一行的值全部赋值给下一行，在下一行遍历时使其加上左方格子的方法数量，由此可以将赋值的过程简化为一个一维数组，空间复杂度降低为 O(min(m, n))。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> uniquePaths(<span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(n, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>                dp[j] <span style=color:#f92672>+=</span> dp[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=63-不同路径-iihttpsleetcode-cncomproblemsunique-paths-ii><a href=https://leetcode-cn.com/problems/unique-paths-ii/>63 不同路径 II</a><a hidden class=anchor aria-hidden=true href=#63-不同路径-iihttpsleetcode-cncomproblemsunique-paths-ii>#</a></h4><p>给一个矩阵，部分位置有障碍物，求从左上角走到右下角有多少种方法。</p><p>和上一题相比在部分位置增加了障碍物，首先要处理第一列和第一行，如果有一个位置有障碍物那么接下来的位置都不能到达了，然后对于其他格子，如果本身是障碍物那么也无法到达，否则仍然等于其上方和左方之和。时间复杂度是 O(m * n)，空间复杂度是 O(m * n)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> uniquePathsWithObstacles(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> grid.size(), n <span style=color:#f92672>=</span> m <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> grid[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;&gt;</span> dp(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span>(n, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        dp[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> grid[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            dp[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> (grid[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>            dp[<span style=color:#ae81ff>0</span>][j] <span style=color:#f92672>=</span> (grid[<span style=color:#ae81ff>0</span>][j] <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;</span> dp[<span style=color:#ae81ff>0</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>                dp[i][j] <span style=color:#f92672>=</span> grid[i][j] <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>+</span> dp[i][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=64-最小路径和httpsleetcode-cncomproblemsminimum-path-sum><a href=https://leetcode-cn.com/problems/minimum-path-sum/>64 最小路径和</a><a hidden class=anchor aria-hidden=true href=#64-最小路径和httpsleetcode-cncomproblemsminimum-path-sum>#</a></h4><p>给一个带权值的矩阵，求从左上角走到右下角的最小权值之和。</p><p>到达第一列和第一行的每一格都只有一种方法，因此先将其初始化。因为每一格只能从其上方和左方到达，因此有状态转移方程 grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])。时间复杂度是 O(m * n)。可以直接在给的矩阵中操作，因此空间复杂度是 O(1)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minPathSum(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> grid.size(), n <span style=color:#f92672>=</span> m <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> grid[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            grid[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+=</span> grid[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>            grid[<span style=color:#ae81ff>0</span>][j] <span style=color:#f92672>+=</span> grid[<span style=color:#ae81ff>0</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>                grid[i][j] <span style=color:#f92672>+=</span> min(grid[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j], grid[i][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> grid[m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=120-三角形最小路径和httpsleetcode-cncomproblemstriangle><a href=https://leetcode-cn.com/problems/triangle/>120 三角形最小路径和</a><a hidden class=anchor aria-hidden=true href=#120-三角形最小路径和httpsleetcode-cncomproblemstriangle>#</a></h4><p>给一个带权值的三角形，求自顶向下的最小路径和。每一步可以移动到左下方或右下方。</p><p>因为每一格只能从其左上方和右上方到达，因此有状态转移方程 tri[i][j] += min(tri[i - 1][j], tri[i - 1][j - 1])。时间复杂度是 O(m * n)。可以直接在给的矩阵中操作，因此空间复杂度是 O(1)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minimumTotal(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>tri) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> tri.size(), res <span style=color:#f92672>=</span> INT_MAX;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> tri[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> tri[i].size(); <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    tri[i][j] <span style=color:#f92672>+=</span> tri[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (j <span style=color:#f92672>&gt;=</span> tri[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].size())
</span></span><span style=display:flex><span>                    tri[i][j] <span style=color:#f92672>+=</span> tri[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    tri[i][j] <span style=color:#f92672>+=</span> min(tri[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j], tri[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    res <span style=color:#f92672>=</span> min(res, tri[i][j]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=931-下降路径最小和httpsleetcode-cncomproblemsminimum-falling-path-sum><a href=https://leetcode-cn.com/problems/minimum-falling-path-sum/>931 下降路径最小和</a><a hidden class=anchor aria-hidden=true href=#931-下降路径最小和httpsleetcode-cncomproblemsminimum-falling-path-sum>#</a></h4><p>给一个带权值的方形，求自顶向下的最小路径和。每一步可以移动到左下方，下方或右下方。</p><p>每一格可以从其左上方，上方和右上方到达，因此有状态转移方程 A[i][j] += min({A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1]})。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minFallingPathSum(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> A) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> A.size(), n <span style=color:#f92672>=</span> m <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> A[<span style=color:#ae81ff>0</span>].size() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>, val <span style=color:#f92672>=</span> INT_MAX, res <span style=color:#f92672>=</span> INT_MAX;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> m; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>                val <span style=color:#f92672>=</span> A[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    val <span style=color:#f92672>=</span> min(val, A[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    val <span style=color:#f92672>=</span> min(val, A[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>                A[i][j] <span style=color:#f92672>+=</span> val;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>min_element</span>(A[m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].begin(), A[m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].end());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=8-其他>8. 其他<a hidden class=anchor aria-hidden=true href=#8-其他>#</a></h3><h4 id=650-只有两个键的键盘httpsleetcode-cncomproblems2-keys-keyboard><a href=https://leetcode-cn.com/problems/2-keys-keyboard/>650 只有两个键的键盘</a><a hidden class=anchor aria-hidden=true href=#650-只有两个键的键盘httpsleetcode-cncomproblems2-keys-keyboard>#</a></h4><p>有一个字符 &lsquo;A&rsquo;，只能进行复制和粘贴操作，求得到 n 个 &lsquo;A&rsquo; 的最小操作次数。</p><p>m 个 &lsquo;A&rsquo; 只能通过粘贴的操作得到，求出所有能整除 m 的数里通过复制粘贴操作得到 m 的最小次数即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minSteps(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, n);
</span></span><span style=display:flex><span>        dp[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> dp[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&lt;=</span> n; j <span style=color:#f92672>+=</span> i) {
</span></span><span style=display:flex><span>                dp[j] <span style=color:#f92672>=</span> min(dp[j], res);
</span></span><span style=display:flex><span>                <span style=color:#f92672>++</span>res;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[n];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=651-4键键盘httpsleetcode-cncomproblems4-keys-keyboardsubmissions><a href=https://leetcode-cn.com/problems/4-keys-keyboard/submissions/>651 4键键盘</a><a hidden class=anchor aria-hidden=true href=#651-4键键盘httpsleetcode-cncomproblems4-keys-keyboardsubmissions>#</a></h4><p>一个键盘上有四个键：输入 &lsquo;A&rsquo;，选中全部，复制，和粘贴。可以按 N 次键盘，求最多能显示多少个 &lsquo;A&rsquo;。</p><p>因为 N 是最后一次操作，所以只能进行输入 &lsquo;A&rsquo; 和粘贴两种操作，只需要求出每一步在之前一步基础上输入 &lsquo;A&rsquo;，以及在往前三步的每一步基础上选中，复制，粘贴能得到的最2优解。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> maxA(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(N <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> N; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            dp[i] <span style=color:#f92672>=</span> dp[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>--</span>j)
</span></span><span style=display:flex><span>                dp[i] <span style=color:#f92672>=</span> max(dp[i], dp[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>*</span> (i <span style=color:#f92672>-</span> j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[N];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/leetcode/linkedlist-1/><span class=title>« Prev</span><br><span>LeetCode 链表（1）</span>
</a><a class=next href=https://prov1dence.top/posts/leetcode/dynamicprogramming-2/><span class=title>Next »</span><br><span>LeetCode 动态规划（2）</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>