<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Prometheus 入门 | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content="Prometheus 入门
Prometheus 是一个开源的监控解决方案，也是云原生基金会 CNCF 的毕业项目，它能够提供指标数据的采集、存储、查询、告警等功能。本文主要介绍 Prometheus 的基础概念和应用中需要注意的一些问题。
1 监控系统
1.1 监控模式
监控系统执行监控检查的模式有两种，分别是 pull 和 push。Prometheus 采用了 pull 模式进行数据收集，同时也支持使用 Pushgateway 的 push 模式进行数据中转。
pull 方式的特点是有拉取间隔，不能及时获取数值的变化，因此需要进一步的数据处理；它的优点是在告警时可以按照策略分片，仅拉取需要的数据，并且支持聚合场景；缺点是监控的数据量庞大，对存储有较高的要求，切需要考虑数据的冷热分离。
push 方式的特点是由服务主动将数据推向监控系统，实时性更高；它的缺点是推送数据的不可预知性，因为当大量数据被推送到监控系统时，数据的缓存和解析会消耗大量资源，此时如果因为网络原因数据的收发没有得到确认，很容易产生数据的重发和重复，因此需要进行去重等操作。
pull 模式在云原生环境中更有优势，因为我们可以通过服务发现对所有需要进行监控的节点进行统一的数据拉取，如果使用 push 模式则需要在每个被监控的服务中部署上报数据的客户端，并配置监控服务器的信息，这会加大部署的难度。
1.2 Prometheus
Prometheus 是一套开源的数据采集与监控框架，可以做后台服务器的监控告警，此处用来采集被测服务的性能指标数据，包括CPU占用比率、内存消耗、网络IO等。
特点
Prometheus 最主要的特点有 4 个：

通过 PromQL 实现多维度数据模型的灵活查询；这使得监控指标可以关联到多个标签，并对时间序列进行切片和切块，以支持各种查询和告警场景
定义了开放指标数据的标准，可以方便地自定义探针（exporter）
利用 Pushgateway 组件可以以 push 的方式接收监控数据
提供了容器化版本

架构

Prometheus 的架构主要由以下部分组成：


Prometheus Server
Prometheus 服务器主要包含了使用 pull 模式抓取监控数据，通过本地存储（本地磁盘）和远程存储（OpenTSDB, InfluxDB, ElasticSearch 等）保存数据，使用 PromQL 查询数据三大功能。
PromQL (Prometheus Query Language) 是 Prometheus 内置的数据查询语言，提供了对时间序列数据的查询，聚合和逻辑运算等操作的支持，被广泛地应用在数据的查询，可视化和告警中。关于 PromQL 的相关操作可以参考 探索PromQL。"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/cloud/intro-to-prometheus/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/cloud/intro-to-prometheus/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/cloud/intro-to-prometheus/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="Prometheus 入门"><meta property="og:description" content="Prometheus 入门 Prometheus 是一个开源的监控解决方案，也是云原生基金会 CNCF 的毕业项目，它能够提供指标数据的采集、存储、查询、告警等功能。本文主要介绍 Prometheus 的基础概念和应用中需要注意的一些问题。
1 监控系统 1.1 监控模式 监控系统执行监控检查的模式有两种，分别是 pull 和 push。Prometheus 采用了 pull 模式进行数据收集，同时也支持使用 Pushgateway 的 push 模式进行数据中转。
pull 方式的特点是有拉取间隔，不能及时获取数值的变化，因此需要进一步的数据处理；它的优点是在告警时可以按照策略分片，仅拉取需要的数据，并且支持聚合场景；缺点是监控的数据量庞大，对存储有较高的要求，切需要考虑数据的冷热分离。
push 方式的特点是由服务主动将数据推向监控系统，实时性更高；它的缺点是推送数据的不可预知性，因为当大量数据被推送到监控系统时，数据的缓存和解析会消耗大量资源，此时如果因为网络原因数据的收发没有得到确认，很容易产生数据的重发和重复，因此需要进行去重等操作。
pull 模式在云原生环境中更有优势，因为我们可以通过服务发现对所有需要进行监控的节点进行统一的数据拉取，如果使用 push 模式则需要在每个被监控的服务中部署上报数据的客户端，并配置监控服务器的信息，这会加大部署的难度。
1.2 Prometheus Prometheus 是一套开源的数据采集与监控框架，可以做后台服务器的监控告警，此处用来采集被测服务的性能指标数据，包括CPU占用比率、内存消耗、网络IO等。
特点 Prometheus 最主要的特点有 4 个：
通过 PromQL 实现多维度数据模型的灵活查询；这使得监控指标可以关联到多个标签，并对时间序列进行切片和切块，以支持各种查询和告警场景 定义了开放指标数据的标准，可以方便地自定义探针（exporter） 利用 Pushgateway 组件可以以 push 的方式接收监控数据 提供了容器化版本 架构 Prometheus 的架构主要由以下部分组成：
Prometheus Server
Prometheus 服务器主要包含了使用 pull 模式抓取监控数据，通过本地存储（本地磁盘）和远程存储（OpenTSDB, InfluxDB, ElasticSearch 等）保存数据，使用 PromQL 查询数据三大功能。
PromQL (Prometheus Query Language) 是 Prometheus 内置的数据查询语言，提供了对时间序列数据的查询，聚合和逻辑运算等操作的支持，被广泛地应用在数据的查询，可视化和告警中。关于 PromQL 的相关操作可以参考 探索PromQL。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-21T18:01:12+08:00"><meta property="article:modified_time" content="2021-10-21T18:01:12+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Prometheus 入门"><meta name=twitter:description content="Prometheus 入门
Prometheus 是一个开源的监控解决方案，也是云原生基金会 CNCF 的毕业项目，它能够提供指标数据的采集、存储、查询、告警等功能。本文主要介绍 Prometheus 的基础概念和应用中需要注意的一些问题。
1 监控系统
1.1 监控模式
监控系统执行监控检查的模式有两种，分别是 pull 和 push。Prometheus 采用了 pull 模式进行数据收集，同时也支持使用 Pushgateway 的 push 模式进行数据中转。
pull 方式的特点是有拉取间隔，不能及时获取数值的变化，因此需要进一步的数据处理；它的优点是在告警时可以按照策略分片，仅拉取需要的数据，并且支持聚合场景；缺点是监控的数据量庞大，对存储有较高的要求，切需要考虑数据的冷热分离。
push 方式的特点是由服务主动将数据推向监控系统，实时性更高；它的缺点是推送数据的不可预知性，因为当大量数据被推送到监控系统时，数据的缓存和解析会消耗大量资源，此时如果因为网络原因数据的收发没有得到确认，很容易产生数据的重发和重复，因此需要进行去重等操作。
pull 模式在云原生环境中更有优势，因为我们可以通过服务发现对所有需要进行监控的节点进行统一的数据拉取，如果使用 push 模式则需要在每个被监控的服务中部署上报数据的客户端，并配置监控服务器的信息，这会加大部署的难度。
1.2 Prometheus
Prometheus 是一套开源的数据采集与监控框架，可以做后台服务器的监控告警，此处用来采集被测服务的性能指标数据，包括CPU占用比率、内存消耗、网络IO等。
特点
Prometheus 最主要的特点有 4 个：

通过 PromQL 实现多维度数据模型的灵活查询；这使得监控指标可以关联到多个标签，并对时间序列进行切片和切块，以支持各种查询和告警场景
定义了开放指标数据的标准，可以方便地自定义探针（exporter）
利用 Pushgateway 组件可以以 push 的方式接收监控数据
提供了容器化版本

架构

Prometheus 的架构主要由以下部分组成：


Prometheus Server
Prometheus 服务器主要包含了使用 pull 模式抓取监控数据，通过本地存储（本地磁盘）和远程存储（OpenTSDB, InfluxDB, ElasticSearch 等）保存数据，使用 PromQL 查询数据三大功能。
PromQL (Prometheus Query Language) 是 Prometheus 内置的数据查询语言，提供了对时间序列数据的查询，聚合和逻辑运算等操作的支持，被广泛地应用在数据的查询，可视化和告警中。关于 PromQL 的相关操作可以参考 探索PromQL。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"Prometheus 入门","item":"https://prov1dence.top/posts/cloud/intro-to-prometheus/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Prometheus 入门","name":"Prometheus 入门","description":"Prometheus 入门 Prometheus 是一个开源的监控解决方案，也是云原生基金会 CNCF 的毕业项目，它能够提供指标数据的采集、存储、查询、告警等功能。本文主要介绍 Prometheus 的基础概念和应用中需要注意的一些问题。\n1 监控系统 1.1 监控模式 监控系统执行监控检查的模式有两种，分别是 pull 和 push。Prometheus 采用了 pull 模式进行数据收集，同时也支持使用 Pushgateway 的 push 模式进行数据中转。\npull 方式的特点是有拉取间隔，不能及时获取数值的变化，因此需要进一步的数据处理；它的优点是在告警时可以按照策略分片，仅拉取需要的数据，并且支持聚合场景；缺点是监控的数据量庞大，对存储有较高的要求，切需要考虑数据的冷热分离。\npush 方式的特点是由服务主动将数据推向监控系统，实时性更高；它的缺点是推送数据的不可预知性，因为当大量数据被推送到监控系统时，数据的缓存和解析会消耗大量资源，此时如果因为网络原因数据的收发没有得到确认，很容易产生数据的重发和重复，因此需要进行去重等操作。\npull 模式在云原生环境中更有优势，因为我们可以通过服务发现对所有需要进行监控的节点进行统一的数据拉取，如果使用 push 模式则需要在每个被监控的服务中部署上报数据的客户端，并配置监控服务器的信息，这会加大部署的难度。\n1.2 Prometheus Prometheus 是一套开源的数据采集与监控框架，可以做后台服务器的监控告警，此处用来采集被测服务的性能指标数据，包括CPU占用比率、内存消耗、网络IO等。\n特点 Prometheus 最主要的特点有 4 个：\n通过 PromQL 实现多维度数据模型的灵活查询；这使得监控指标可以关联到多个标签，并对时间序列进行切片和切块，以支持各种查询和告警场景 定义了开放指标数据的标准，可以方便地自定义探针（exporter） 利用 Pushgateway 组件可以以 push 的方式接收监控数据 提供了容器化版本 架构 Prometheus 的架构主要由以下部分组成：\nPrometheus Server\nPrometheus 服务器主要包含了使用 pull 模式抓取监控数据，通过本地存储（本地磁盘）和远程存储（OpenTSDB, InfluxDB, ElasticSearch 等）保存数据，使用 PromQL 查询数据三大功能。\nPromQL (Prometheus Query Language) 是 Prometheus 内置的数据查询语言，提供了对时间序列数据的查询，聚合和逻辑运算等操作的支持，被广泛地应用在数据的查询，可视化和告警中。关于 PromQL 的相关操作可以参考 探索PromQL。\n","keywords":[],"articleBody":"Prometheus 入门 Prometheus 是一个开源的监控解决方案，也是云原生基金会 CNCF 的毕业项目，它能够提供指标数据的采集、存储、查询、告警等功能。本文主要介绍 Prometheus 的基础概念和应用中需要注意的一些问题。\n1 监控系统 1.1 监控模式 监控系统执行监控检查的模式有两种，分别是 pull 和 push。Prometheus 采用了 pull 模式进行数据收集，同时也支持使用 Pushgateway 的 push 模式进行数据中转。\npull 方式的特点是有拉取间隔，不能及时获取数值的变化，因此需要进一步的数据处理；它的优点是在告警时可以按照策略分片，仅拉取需要的数据，并且支持聚合场景；缺点是监控的数据量庞大，对存储有较高的要求，切需要考虑数据的冷热分离。\npush 方式的特点是由服务主动将数据推向监控系统，实时性更高；它的缺点是推送数据的不可预知性，因为当大量数据被推送到监控系统时，数据的缓存和解析会消耗大量资源，此时如果因为网络原因数据的收发没有得到确认，很容易产生数据的重发和重复，因此需要进行去重等操作。\npull 模式在云原生环境中更有优势，因为我们可以通过服务发现对所有需要进行监控的节点进行统一的数据拉取，如果使用 push 模式则需要在每个被监控的服务中部署上报数据的客户端，并配置监控服务器的信息，这会加大部署的难度。\n1.2 Prometheus Prometheus 是一套开源的数据采集与监控框架，可以做后台服务器的监控告警，此处用来采集被测服务的性能指标数据，包括CPU占用比率、内存消耗、网络IO等。\n特点 Prometheus 最主要的特点有 4 个：\n通过 PromQL 实现多维度数据模型的灵活查询；这使得监控指标可以关联到多个标签，并对时间序列进行切片和切块，以支持各种查询和告警场景 定义了开放指标数据的标准，可以方便地自定义探针（exporter） 利用 Pushgateway 组件可以以 push 的方式接收监控数据 提供了容器化版本 架构 Prometheus 的架构主要由以下部分组成：\nPrometheus Server\nPrometheus 服务器主要包含了使用 pull 模式抓取监控数据，通过本地存储（本地磁盘）和远程存储（OpenTSDB, InfluxDB, ElasticSearch 等）保存数据，使用 PromQL 查询数据三大功能。\nPromQL (Prometheus Query Language) 是 Prometheus 内置的数据查询语言，提供了对时间序列数据的查询，聚合和逻辑运算等操作的支持，被广泛地应用在数据的查询，可视化和告警中。关于 PromQL 的相关操作可以参考 探索PromQL。\nPushgateway\nPushgateway 是用来实现 push 模式监控的组件，一般应用于短作业，批处理作业，或当服务与 Prometheus 服务器之间有网络隔离时；它的主要问题是存在单点故障，一个 Pushgateway 的宕机会导致所有被推送到这个 Pushgateway 上的数据的丢失，如果使用多个 Pushgateway 实例组成的集群，那么每一次数据推送只会被分发到单个实例上，但 Prometheus Server 每次会在所有的 Pushgateway 实例上进行数据采集，这会导致数据错乱，目前官方对此并没有解决方案，一个比较好的开源方案是使用动态一致性哈希 + 基于 consul 的 service check；除此之外，Pushgateway 不会自动删除任何指标数据，即使在进行过 push 操作的 pod 被销毁之后，其上报的所有数据仍然残留在 Pushgateway 中，需要手动。\nJob/Exporter\nJob 和 Exporter 都是 Prometheus 的 target 监控对象；exporter 的机制是将监控数据暴露出来，Prometheus 对这些指标进行采集；每个 exporter 需要单独维护，如果数量过多可以考虑使用 Telegraf 进行统一管理。\nService Discovery\n相比于读取文件配置，在云原生和容器环境下被监控实例都是会动态变化的，而通过服务发现，我们可以在很方便地获取需要被检控的 target 的实例信息；服务发现中的 relabeling 机制可以从 target 实例中获取元标签数据，从而对不同开发环境进行区分。\nAlertmanager\nPrometheus 将数据采集和告警分离成了两个模块，告警模块叫做 Alertmanager，它是独立于 Prometheus 的一个组件，需要单独部署，多个 Alertmanager 可以配置为一个集群来避免单点问题。报警规则被配置在 Prometheus Servers 上，产生告警信息时会通知 AlertManger，AlertManager 会通过 silencing, inhibition 等方式聚合，并通过 email、PagerDuty、HipChat、Slack 等方式发送告警提示。\nDashboard\nWeb UI, Grafana, API Client 等统称为 Dashboard。\n局限性 Prometheus 是基于 metrics 的系统，不适合存储日志 Prometheus 认为只有近期的数据才需要被查询，因此本地存储只会保存短期数据；TB 级以上的历史数据需要搭配 OpenTSDB 等远端存储使用 Prometheus 的集群方案有 federation 和开源的 Thanos，但都存在各种细节上的技术问题（如耗尽 CPU 和机器资源），其成熟度都比不上在时序数据库中排名第一的 InfluxDB 2 数据模型 2.1 时序数据 Prometheus 存储的是时序数据，即由名称 name，标签 label 与值 value 定义的指标 metric；Prometheus 中所有的指标都是时序数据，并以名称和标签进行区分；具有相同名称和标签的数据属于相同时序，这些时序数据拥有不同的时间戳。\n指标命名 指标的名字由 ASCII 字符，数字，下划线，以及冒号组成，且满足正则表达式 [a-zA-Z0-9_:]*, 其命名应该具有语义化，用于表示一个可以度量的指标，例如 http_requests_total；时序的标签可以用于区分具体不同的方法和参数变量，例如 http_requests_total{method=\"POST\"}。\n一个 metric 的命名应该具有以下几个特点：\n以命名空间或应用名称作为前缀，避免不通作用域的相同名称产生冲突，例如 prometheus_notifications_total, http_request_duration_seconds\n以基本单位（秒，米，字节，个数等）作为后缀，例如 http_requests_total, node_memory_usage_bytes\n将所有标签的共同逻辑部分抽离作为名称，将可变量作为标签的一部分\n指标类型 指标是整个监控系统的核心，Prometheus 中的指标类型 Metrics Type 有以下四种：\nCounter Counter 是只增不减的计数器，一般用于记录服务请求，返回或错误的总量，它会在程序重启时被重置为 0。例如 Prometheus Server 中 http_requests_total 表示当前处理的 http 请求总数。\n为了能够直观地展示指标数据计数的变化情况，一般需要计算 Counter 数据的增长速率，建议 PromQL 中的 rate, topk, increase, irate 等函数使用。\nGauge Gauge 表示可以任意变化的快照数据，一般用于记录内存使用率，CPU 温度，程序中的 goroutine 数量等。例如 Prometheus Server 中 go_goroutines 表示当前 goroutines 的数量。\nGauge 经常结合 PromQL 中的最大值 max，最小值min，总和 sum 函数，或基于线性回归的时间序列预测函数 predict_linear ，获取指标在一段时间内的变化情况的 delta 等函数使用。\nHistogram Histogram 用于对一定时间范围内的数据进行采样，记录各个桶中的数据个数。例如 Prometheus Server 中 prometheus_local_storage_series_chunks_persisted 表示每个时间序列需要存储的 chunks 数量，我们可以使用 histogram_quantile 计算待持久化的数据的分位数 quantile 数据。\nSummary Summary 和 Histogram 类似，也用于表示一段时间范围内的数据采样结果，它直接存储了分位数 quantile 数据（通过客户端计算），而非根据统计区间计算。对于分位数的计算，Summary 在通过 PromQL 进行查询时有更好的性能表现，而 Histogram 则会消耗更多的资源。反之，对于客户端而言，Histogram 消耗的资源更少。\n2.2 数据采集 Prometheus server 的数据采集基于 Pull 模型，其工作流程大致为 Prometheus server 会定期地从 exporter 上通过 HTTP 接口获取 metrics 结构的数据，并进行存储，如果 Prometheus Server 与 Exporter 不能够直接进行通信，那么我们可以将 exporter 上的数据推送到 Pushgateway 上，并让 Prometheus Server 从 PushGateway 上获取数据。\n术语 Exporter：所有向 Prometheus server 提供数据的程序都可以被称为 exporter，Prometheus server 会周期性地从 exporter 提供的HTTP 服务 URL 拉取数据，我们只需要在 Prometheus server 的配置文件 /etc/prometheus/prometheus.yml 中添加一个target，并重启服务即可定位到 exporter 并拉取数据。\nInstance：任意一个独立的数据源 target 都可以被称为 Instance 实例，它是用来提供数据的最小单位。\nJob：包含相同类型的实例的集合叫做 Job，例如在 k8s 集群上被复制出的可弹性伸缩的一组 pod 中的相同进程。\n2.3 Pushgateway 由于 Prometheus server 采用 pull 模式获取数据，如果 Prometheus server 和 exporter 由于不在一个子网环境或由于防火墙原因导致两者无法直接通信，或在我们需要将多个 exporter 的数据汇总到一起时，我们可以主动将数据推送到 Pushgateway 上，间接地进行数据采集；但它的弊端也很明显，那就是单点故障，如果唯一的 Pushgateway 出现不可用的情况，那么所有的数据都无法被 Prometheus server 获取。\nPushgateway 不需要任何配置，直接启动 docker image 后即可使用。\ndocker pull prom/pushgateway docker run -d -p 9091:9091 prom/pushgateway 启动好 Pushgateway 之后，需要在 Prometheus server 的静态配置中添加 Pushgateway：\ndocker exec -it --user root f257794e5e3d sh vi /etc/prometheus/prometheus.yml scrape_configs: - job_name: \"pushgateway\" static_configs: - targets: [\"ip:port\"] 修改配置后，发送信号给 Prometheus Server 使其加载最新的配置：\nkill -HUP $pid 默认情况下，Pushgateway 将所有数据存储在内存中，因此一旦 Pushagateway 服务因为故障而停止运行，那么所有尚未被 Prometheus server 获取的数据都将会丢失，为此可以在启动 Pushgateway 服务时通过指定 persistence.file 参数将数据持久化：\npushgateway --persistence.file=\"/tmp/pushgateway_persist\" 默认情况下，文件每五分钟持久化写入一次，我们可以通过修改 persistence.interval 参数来进行调整。\n推送数据 向 Pushgateway 推送数据时可以使用 PUT 和 POST 两种方法，其中 PUT 会将实例中的所有 metrics 替换为新推送的 metrics，而 POST 则只会将 name 相同 metrics 替换（前提是这部分数据在相同的 job/instance 下）；\n假设将要进行推送的数据如下：\n$ cat req1.txt # TYPE foo GAUGE foo{id=\"1\"} 1 foo{id=\"2\"} 2 foo{id=\"3\"} 3 # TYPE bar GAUGE bar{id=\"11\"} 11 将其推送到 Pushgateway 上并检查：\n$ curl -X POST --data-binary @req1.txt localhost:9091/metrics/job/test $ curl localhost:9091/metrics | grep test bar{id=\"11\",instance=\"\",job=\"test\"} 11 foo{id=\"1\",instance=\"\",job=\"test\"} 1 foo{id=\"2\",instance=\"\",job=\"test\"} 2 foo{id=\"3\",instance=\"\",job=\"test\"} 3 使用 POST 方法推送另一组数据：\n$ cat req2.txt # TYPE foo GAUGE foo{id=\"4\"} 4 foo{id=\"5\"} 5 $ curl -X POST --data-binary @req2.txt localhost:9091/metrics/job/test $ curl localhost:9091/metrics | grep test bar{id=\"11\",instance=\"\",job=\"test\"} 11 foo{id=\"4\",instance=\"\",job=\"test\"} 4 foo{id=\"5\",instance=\"\",job=\"test\"} 5 可以看到原有的 name 为 foo 的数据都被覆盖了；\n使用 PUT 方法推送第二组数据：\n$ curl -X PUT --data-binary @req2.txt localhost:9091/metrics/job/test $ curl localhost:9091/metrics | grep test foo{id=\"4\",instance=\"\",job=\"test\"} 4 foo{id=\"5\",instance=\"\",job=\"test\"} 5 可以看到原有的所有数据（包括 name 不同的 bar 数据）都被覆盖了。\n推送不能包含时间戳\nPrometheus pull 数据时不会采集与当前时间差在 5 分钟以上的数据，官方认为 pushgateway 一般用在临时任务和批处理作业上，为了防止这些任务因为存在的时间不够长导致 Prometheus 还没来得及 pull 数据就结束了，所以不允许在向 pushgateway 推送数据时带上时间戳。\n删除数据 如果想要删除 Pushgateway 上特定的数据，可以使用官方提供的 http API：\n删除特定 job 和 instance 的所有数据： curl -X DELETE http://pushgateway.example.org:9091/metrics/job/some_job/instance/some_instance 删除特定 job ，且 instance=\"\" 下的所有数据，注意这不会删除其他 instance 的数据： curl -X DELETE http://pushgateway.example.org:9091/metrics/job/some_job 删除一个实例上的所有数据（需要在启动时加上参数 --web.enable-admin-api 才能用）： curl -X PUT http://pushgateway.example.org:9091/api/v1/admin/wipe ","wordCount":"601","inLanguage":"en","datePublished":"2021-10-21T18:01:12+08:00","dateModified":"2021-10-21T18:01:12+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/cloud/intro-to-prometheus/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Prometheus 入门</h1><div class=post-meta><span title='2021-10-21 18:01:12 +0800 +0800'>October 21, 2021</span>&nbsp;·&nbsp;3 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#prometheus-%e5%85%a5%e9%97%a8 aria-label="Prometheus 入门">Prometheus 入门</a><ul><li><a href=#1-%e7%9b%91%e6%8e%a7%e7%b3%bb%e7%bb%9f aria-label="1 监控系统">1 监控系统</a><ul><li><a href=#11-%e7%9b%91%e6%8e%a7%e6%a8%a1%e5%bc%8f aria-label="1.1 监控模式">1.1 监控模式</a></li><li><a href=#12-prometheus aria-label="1.2 Prometheus">1.2 Prometheus</a><ul><li><a href=#%e7%89%b9%e7%82%b9 aria-label=特点>特点</a></li><li><a href=#%e6%9e%b6%e6%9e%84 aria-label=架构>架构</a></li><li><a href=#%e5%b1%80%e9%99%90%e6%80%a7 aria-label=局限性>局限性</a></li></ul></li></ul></li><li><a href=#2-%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b aria-label="2 数据模型">2 数据模型</a><ul><li><a href=#21-%e6%97%b6%e5%ba%8f%e6%95%b0%e6%8d%ae aria-label="2.1 时序数据">2.1 时序数据</a><ul><li><a href=#%e6%8c%87%e6%a0%87%e5%91%bd%e5%90%8d aria-label=指标命名>指标命名</a></li><li><a href=#%e6%8c%87%e6%a0%87%e7%b1%bb%e5%9e%8b aria-label=指标类型>指标类型</a></li></ul></li><li><a href=#22-%e6%95%b0%e6%8d%ae%e9%87%87%e9%9b%86 aria-label="2.2 数据采集">2.2 数据采集</a><ul><li><a href=#%e6%9c%af%e8%af%ad aria-label=术语>术语</a></li></ul></li><li><a href=#23-pushgateway aria-label="2.3 Pushgateway">2.3 Pushgateway</a><ul><li><a href=#%e6%8e%a8%e9%80%81%e6%95%b0%e6%8d%ae aria-label=推送数据>推送数据</a></li><li><a href=#%e5%88%a0%e9%99%a4%e6%95%b0%e6%8d%ae aria-label=删除数据>删除数据</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=prometheus-入门>Prometheus 入门<a hidden class=anchor aria-hidden=true href=#prometheus-入门>#</a></h1><p>Prometheus 是一个开源的监控解决方案，也是云原生基金会 CNCF 的毕业项目，它能够提供指标数据的采集、存储、查询、告警等功能。本文主要介绍 Prometheus 的基础概念和应用中需要注意的一些问题。</p><h2 id=1-监控系统>1 监控系统<a hidden class=anchor aria-hidden=true href=#1-监控系统>#</a></h2><h3 id=11-监控模式>1.1 监控模式<a hidden class=anchor aria-hidden=true href=#11-监控模式>#</a></h3><p>监控系统执行监控检查的模式有两种，分别是 <strong>pull</strong> 和 <strong>push</strong>。Prometheus 采用了 pull 模式进行数据收集，同时也支持使用 Pushgateway 的 push 模式进行数据中转。</p><p>pull 方式的特点是有拉取间隔，不能及时获取数值的变化，因此需要进一步的数据处理；它的优点是在告警时可以按照策略分片，仅拉取需要的数据，并且支持聚合场景；缺点是监控的数据量庞大，对存储有较高的要求，切需要考虑数据的冷热分离。</p><p>push 方式的特点是由服务主动将数据推向监控系统，实时性更高；它的缺点是推送数据的不可预知性，因为当大量数据被推送到监控系统时，数据的缓存和解析会消耗大量资源，此时如果因为网络原因数据的收发没有得到确认，很容易产生数据的重发和重复，因此需要进行去重等操作。</p><p>pull 模式在云原生环境中更有优势，因为我们可以通过服务发现对所有需要进行监控的节点进行统一的数据拉取，如果使用 push 模式则需要在每个被监控的服务中部署上报数据的客户端，并配置监控服务器的信息，这会加大部署的难度。</p><h3 id=12-prometheus>1.2 Prometheus<a hidden class=anchor aria-hidden=true href=#12-prometheus>#</a></h3><p>Prometheus 是一套开源的数据采集与监控框架，可以做后台服务器的监控告警，此处用来采集被测服务的性能指标数据，包括CPU占用比率、内存消耗、网络IO等。</p><h4 id=特点>特点<a hidden class=anchor aria-hidden=true href=#特点>#</a></h4><p>Prometheus 最主要的特点有 4 个：</p><ol><li>通过 PromQL 实现多维度数据模型的灵活查询；这使得监控指标可以关联到多个标签，并对时间序列进行切片和切块，以支持各种查询和告警场景</li><li>定义了开放指标数据的标准，可以方便地自定义探针（exporter）</li><li>利用 Pushgateway 组件可以以 push 的方式接收监控数据</li><li>提供了容器化版本</li></ol><h4 id=架构>架构<a hidden class=anchor aria-hidden=true href=#架构>#</a></h4><p><img alt=prometheus-architecture loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/data/prometheus-architecture.png></p><p>Prometheus 的架构主要由以下部分组成：</p><ol><li><p>Prometheus Server</p><p>Prometheus 服务器主要包含了使用 pull 模式抓取监控数据，通过本地存储（本地磁盘）和远程存储（OpenTSDB, InfluxDB, ElasticSearch 等）保存数据，使用 PromQL 查询数据三大功能。</p><p>PromQL (Prometheus Query Language) 是 Prometheus 内置的数据查询语言，提供了对时间序列数据的查询，聚合和逻辑运算等操作的支持，被广泛地应用在数据的查询，可视化和告警中。关于 PromQL 的相关操作可以参考 <a href=https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language>探索PromQL</a>。</p></li><li><p>Pushgateway</p><p>Pushgateway 是用来实现 push 模式监控的组件，一般应用于短作业，批处理作业，或当服务与 Prometheus 服务器之间有网络隔离时；它的主要问题是存在<strong>单点故障</strong>，一个 Pushgateway 的<strong>宕机</strong>会导致所有被推送到这个 Pushgateway 上的数据的丢失，如果使用多个 Pushgateway 实例组成的<strong>集群</strong>，那么每一次数据推送只会被分发到单个实例上，但 Prometheus Server 每次会在所有的 Pushgateway 实例上进行数据采集，这会导致数据错乱，目前官方对此并没有解决方案，一个比较好的开源方案是使用<a href=https://github.com/ning1875/dynamic-sharding>动态一致性哈希 + 基于 consul 的 service check</a>；除此之外，Pushgateway 不会自动删除任何指标数据，即使在进行过 push 操作的 pod 被销毁之后，其上报的所有数据仍然残留在 Pushgateway 中，需要手动。</p></li><li><p>Job/Exporter</p><p>Job 和 Exporter 都是 Prometheus 的 target 监控对象；exporter 的机制是将监控数据暴露出来，Prometheus 对这些指标进行采集；每个 exporter 需要单独维护，如果数量过多可以考虑使用 Telegraf 进行统一管理。</p></li><li><p>Service Discovery</p><p>相比于读取文件配置，在云原生和容器环境下被监控实例都是会动态变化的，而通过服务发现，我们可以在很方便地获取需要被检控的 target 的实例信息；服务发现中的 relabeling 机制可以从 target 实例中获取元标签数据，从而对不同开发环境进行区分。</p></li><li><p>Alertmanager</p><p>Prometheus 将数据采集和告警分离成了两个模块，告警模块叫做 Alertmanager，它是独立于 Prometheus 的一个组件，需要单独部署，多个 Alertmanager 可以配置为一个集群来避免单点问题。报警规则被配置在 Prometheus Servers 上，产生告警信息时会通知 AlertManger，AlertManager 会通过 silencing, inhibition 等方式聚合，并通过 email、PagerDuty、HipChat、Slack 等方式发送告警提示。</p></li><li><p>Dashboard</p><p>Web UI, Grafana, API Client 等统称为 Dashboard。</p></li></ol><h4 id=局限性>局限性<a hidden class=anchor aria-hidden=true href=#局限性>#</a></h4><ol><li>Prometheus 是基于 metrics 的系统，不适合存储日志</li><li>Prometheus 认为只有近期的数据才需要被查询，因此本地存储只会保存短期数据；TB 级以上的历史数据需要搭配 OpenTSDB 等远端存储使用</li><li>Prometheus 的集群方案有 federation 和开源的 Thanos，但都存在各种细节上的技术问题（如耗尽 CPU 和机器资源），其成熟度都比不上在时序数据库中排名第一的 InfluxDB</li></ol><h2 id=2-数据模型>2 数据模型<a hidden class=anchor aria-hidden=true href=#2-数据模型>#</a></h2><h3 id=21-时序数据>2.1 时序数据<a hidden class=anchor aria-hidden=true href=#21-时序数据>#</a></h3><p>Prometheus 存储的是<a href=https://en.wikipedia.org/wiki/Time_series>时序数据</a>，即由名称 name，标签 label 与值 value 定义的指标 metric；Prometheus 中所有的指标都是时序数据，并以名称和标签进行区分；具有相同名称和标签的数据属于相同时序，这些时序数据拥有不同的时间戳。</p><h4 id=指标命名>指标命名<a hidden class=anchor aria-hidden=true href=#指标命名>#</a></h4><p>指标的名字由 ASCII 字符，数字，下划线，以及冒号组成，且满足正则表达式 <code>[a-zA-Z0-9_:]*</code>, 其命名应该具有语义化，用于表示一个可以度量的指标，例如 <code>http_requests_total</code>；时序的标签可以用于区分具体不同的方法和参数变量，例如 <code>http_requests_total{method="POST"}</code>。</p><p>一个 metric 的命名应该具有以下几个特点：</p><ol><li><p>以命名空间或应用名称作为前缀，避免不通作用域的相同名称产生冲突，例如 <strong>prometheus</strong>_notifications_total, <strong>http</strong>_request_duration_seconds</p></li><li><p>以基本单位（秒，米，字节，个数等）作为后缀，例如 http_requests_<strong>total</strong>, node_memory_usage_<strong>bytes</strong></p></li><li><p>将所有标签的共同逻辑部分抽离作为名称，将可变量作为标签的一部分</p></li></ol><h4 id=指标类型>指标类型<a hidden class=anchor aria-hidden=true href=#指标类型>#</a></h4><p>指标是整个监控系统的核心，Prometheus 中的指标类型 Metrics Type 有以下四种：</p><ol><li>Counter</li></ol><p>Counter 是只增不减的计数器，一般用于记录服务请求，返回或错误的总量，它会在程序重启时被重置为 0。例如 Prometheus Server 中 <code>http_requests_total</code> 表示当前处理的 http 请求总数。</p><p>为了能够直观地展示指标数据计数的变化情况，一般需要计算 Counter 数据的增长速率，建议 PromQL 中的 rate, topk, increase, irate 等函数使用。</p><ol start=2><li>Gauge</li></ol><p>Gauge 表示可以任意变化的快照数据，一般用于记录内存使用率，CPU 温度，程序中的 goroutine 数量等。例如 Prometheus Server 中 <code>go_goroutines</code> 表示当前 goroutines 的数量。</p><p>Gauge 经常结合 PromQL 中的最大值 max，最小值min，总和 sum 函数，或基于线性回归的时间序列预测函数 predict_linear ，获取指标在一段时间内的变化情况的 delta 等函数使用。</p><ol start=3><li>Histogram</li></ol><p>Histogram 用于对一定时间范围内的数据进行采样，记录各个桶中的数据个数。例如 Prometheus Server 中 <code>prometheus_local_storage_series_chunks_persisted</code> 表示每个时间序列需要存储的 chunks 数量，我们可以使用 histogram_quantile 计算待持久化的数据的分位数 quantile 数据。</p><ol start=4><li>Summary</li></ol><p>Summary 和 Histogram 类似，也用于表示一段时间范围内的数据采样结果，它直接存储了分位数 quantile 数据（通过客户端计算），而非根据统计区间计算。对于分位数的计算，Summary 在通过 PromQL 进行查询时有更好的性能表现，而 Histogram 则会消耗更多的资源。反之，对于客户端而言，Histogram 消耗的资源更少。</p><h3 id=22-数据采集>2.2 数据采集<a hidden class=anchor aria-hidden=true href=#22-数据采集>#</a></h3><p>Prometheus server 的数据采集基于 Pull 模型，其工作流程大致为 Prometheus server 会定期地从 exporter 上通过 HTTP 接口获取 metrics 结构的数据，并进行存储，如果 Prometheus Server 与 Exporter 不能够直接进行通信，那么我们可以将 exporter 上的数据推送到 Pushgateway 上，并让 Prometheus Server 从 PushGateway 上获取数据。</p><h4 id=术语>术语<a hidden class=anchor aria-hidden=true href=#术语>#</a></h4><p><strong>Exporter</strong>：所有向 Prometheus server 提供数据的程序都可以被称为 exporter，Prometheus server 会周期性地从 exporter 提供的HTTP 服务 URL 拉取数据，我们只需要在 Prometheus server 的配置文件 /etc/prometheus/prometheus.yml 中添加一个target，并重启服务即可定位到 exporter 并拉取数据。</p><p><strong>Instance</strong>：任意一个独立的数据源 target 都可以被称为 Instance 实例，它是用来提供数据的最小单位。</p><p><strong>Job</strong>：包含相同类型的实例的集合叫做 Job，例如在 k8s 集群上被复制出的可弹性伸缩的一组 pod 中的相同进程。</p><h3 id=23-pushgateway>2.3 Pushgateway<a hidden class=anchor aria-hidden=true href=#23-pushgateway>#</a></h3><p>由于 Prometheus server 采用 pull 模式获取数据，如果 Prometheus server 和 exporter 由于不在一个子网环境或由于防火墙原因导致两者无法直接通信，或在我们需要将多个 exporter 的数据汇总到一起时，我们可以主动将数据推送到 Pushgateway 上，间接地进行数据采集；但它的弊端也很明显，那就是单点故障，如果唯一的 Pushgateway 出现不可用的情况，那么所有的数据都无法被 Prometheus server 获取。</p><p>Pushgateway 不需要任何配置，直接启动 docker image 后即可使用。</p><pre tabindex=0><code>docker pull prom/pushgateway

docker run -d -p 9091:9091 prom/pushgateway
</code></pre><p>启动好 Pushgateway 之后，需要在 Prometheus server 的静态配置中添加 Pushgateway：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker exec -it --user root f257794e5e3d sh
</span></span><span style=display:flex><span>vi /etc/prometheus/prometheus.yml
</span></span></code></pre></div><pre tabindex=0><code>scrape_configs:
  - job_name: &#34;pushgateway&#34;
    static_configs:
      - targets: [&#34;ip:port&#34;]
</code></pre><p>修改配置后，发送信号给 Prometheus Server 使其加载最新的配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kill -HUP $pid
</span></span></code></pre></div><p>默认情况下，Pushgateway 将所有数据存储在内存中，因此一旦 Pushagateway 服务因为故障而停止运行，那么所有尚未被 Prometheus server 获取的数据都将会丢失，为此可以在启动 Pushgateway 服务时通过指定 <code>persistence.file</code> 参数将数据持久化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>pushgateway</span> <span style=color:#f92672>--</span><span style=color:#a6e22e>persistence</span>.<span style=color:#a6e22e>file</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/tmp/pushgateway_persist&#34;</span>
</span></span></code></pre></div><p>默认情况下，文件每五分钟持久化写入一次，我们可以通过修改 <code>persistence.interval</code> 参数来进行调整。</p><h4 id=推送数据>推送数据<a hidden class=anchor aria-hidden=true href=#推送数据>#</a></h4><p>向 Pushgateway 推送数据时可以使用 PUT 和 POST 两种方法，其中 PUT 会将实例中的所有 metrics 替换为新推送的 metrics，而 POST 则只会将 name 相同 metrics 替换（前提是这部分数据在相同的 job/instance 下）；</p><p><img alt=pushgateway-put-post loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/data/pushgateway-put-post.png></p><p>假设将要进行推送的数据如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cat req1.txt 
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE foo GAUGE</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE bar GAUGE</span>
</span></span><span style=display:flex><span>bar<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;11&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>11</span>
</span></span></code></pre></div><p>将其推送到 Pushgateway 上并检查：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ curl -X POST --data-binary @req1.txt localhost:9091/metrics/job/test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ curl localhost:9091/metrics | grep test
</span></span><span style=display:flex><span>bar<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;11&#34;</span>,instance<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,job<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1&#34;</span>,instance<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,job<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2&#34;</span>,instance<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,job<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;3&#34;</span>,instance<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,job<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>使用 POST 方法推送另一组数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cat req2.txt 
</span></span><span style=display:flex><span><span style=color:#75715e># TYPE foo GAUGE</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;4&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;5&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ curl -X POST --data-binary @req2.txt localhost:9091/metrics/job/test
</span></span><span style=display:flex><span>$ curl localhost:9091/metrics | grep test
</span></span><span style=display:flex><span>bar<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;11&#34;</span>,instance<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,job<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;4&#34;</span>,instance<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,job<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;5&#34;</span>,instance<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,job<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>5</span>
</span></span></code></pre></div><p>可以看到原有的 name 为 foo 的数据都被覆盖了；</p><p>使用 PUT 方法推送第二组数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ curl -X PUT --data-binary @req2.txt localhost:9091/metrics/job/test
</span></span><span style=display:flex><span>$ curl localhost:9091/metrics | grep test
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;4&#34;</span>,instance<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,job<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>{</span>id<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;5&#34;</span>,instance<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>,job<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>}</span> <span style=color:#ae81ff>5</span>
</span></span></code></pre></div><p>可以看到原有的所有数据（包括 name 不同的 bar 数据）都被覆盖了。</p><p><strong>推送不能包含时间戳</strong></p><p>Prometheus pull 数据时不会采集与当前时间差在 5 分钟以上的数据，官方认为 pushgateway 一般用在临时任务和批处理作业上，为了防止这些任务因为存在的时间不够长导致 Prometheus 还没来得及 pull 数据就结束了，所以不允许在向 pushgateway 推送数据时带上时间戳。</p><p><img alt=about-timestamps loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/data/about-timestamps.png></p><h4 id=删除数据>删除数据<a hidden class=anchor aria-hidden=true href=#删除数据>#</a></h4><p>如果想要删除 Pushgateway 上特定的数据，可以使用官方提供的 http API：</p><ul><li>删除特定 job 和 instance 的所有数据：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE http://pushgateway.example.org:9091/metrics/job/some_job/instance/some_instance
</span></span></code></pre></div><ul><li>删除特定 job ，且 instance="" 下的所有数据，注意这不会删除其他 instance 的数据：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X DELETE http://pushgateway.example.org:9091/metrics/job/some_job
</span></span></code></pre></div><ul><li>删除一个实例上的所有数据（需要在启动时加上参数 <code>--web.enable-admin-api</code> 才能用）：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  curl -X PUT http://pushgateway.example.org:9091/api/v1/admin/wipe
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/message-broker/kafka/><span class=title>« Prev</span><br><span>Kafka 入门</span>
</a><a class=next href=https://prov1dence.top/posts/python/python-source-code-coroutine/><span class=title>Next »</span><br><span>Python 源码学习（5）：协程</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>