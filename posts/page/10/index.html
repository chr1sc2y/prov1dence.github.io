<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 尾張</title><meta name=keywords content><meta name=description content="Posts - 尾張"><meta name=author content><link rel=canonical href=http://zintrulcre.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.110.0"><link rel=alternate type=application/rss+xml href=http://zintrulcre.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-132809676-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Posts"><meta property="og:description" content="Zhengyu's Blog"><meta property="og:type" content="website"><meta property="og:url" content="http://zintrulcre.github.io/posts/"><meta property="og:site_name" content="尾張"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Zhengyu's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://zintrulcre.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://zintrulcre.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://zintrulcre.github.io/archives/ title=Posts><span>Posts</span></a></li><li><a href=http://zintrulcre.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://zintrulcre.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>Object Detection</h2></header><section class=entry-content><p>Object Detection Object detection deals with detecting instances of objects of a certain class, such as humans, animals, etc, in digital images and videos. Object detection has applications in many areas of computer vision, including image retrieval, face detection, video surveillance, and self-driving, etc. Current detection systems repurpose classifiers to perform detection. To detect an object, these systems take a classifier for that object and evaluate it at various locations and scales in a test image....</p></section><footer class=entry-footer><span title='2019-05-19 19:40:23 +1000 +1000'>May 19, 2019</span>&nbsp;·&nbsp;5 min</footer><a class=entry-link aria-label="post link to Object Detection" href=http://zintrulcre.github.io/posts/deep-learning/object-detection-yolo/></a></article><article class=post-entry><header class=entry-header><h2>Code Jam 2019 Round 1C</h2></header><section class=entry-content><p>Code Jam 2019 Round 1C Robot Programming Strategy (10pts, 18pts) 已知所有人石头剪刀布的出招顺序，每一轮同时和所有人比赛，找到必胜的策略。
Solution: Eliminiating 每一轮遍历当前轮次所有人的出招，如果同时有三种情况（R, P, S）则没有必胜策略，直接输出IMPOSSIBLE；否则返回胜利或打平的策略。
对于已经打败过的对手没有必要再考虑其之后的出招，所以用一个defeated数组保存已经打败过的对手以便直接跳过。因为当前轮次有可能超过对手的出招顺序长度，所以要用i % size获取对手当前的出招。
时间复杂度：O(A ^ 2) 空间复杂度：O(A) #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; char Decide(const char &R, const char &P, const char &S) { if (R && P && S) return 'X'; if (R && P) return 'P'; if (R && S) return 'R'; if (P && S) return 'S'; if (R) return 'P'; if (P) return 'S'; return 'R'; } bool Defeate(const char &current, const char &opponent) { return (current == 'R' && opponent == 'S') || (current == 'S' && opponent == 'P') || (current == 'P' && opponent == 'R'); } void solve(const int &t) { int A; scanf("%d", &A); int i = 0; vector&lt;string> opponent(A); vector&lt;bool> defeated(A, false); bool R, P, S; string res; for (int a = 0; a &lt; A; ++a) cin >> opponent[a]; while (true) { int current_opponent = 0; R = false, P = false, S = false; for (int a = 0; a &lt; A; ++a) { if (!...</p></section><footer class=entry-footer><span title='2019-05-07 22:02:15 +1000 +1000'>May 7, 2019</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Code Jam 2019 Round 1C" href=http://zintrulcre.github.io/posts/code-jam/2019-round-1c/></a></article><article class=post-entry><header class=entry-header><h2>Kick Start 2019 Round B</h2></header><section class=entry-content><p>Kick Start 2019 Round B Building Palindromes (5pts, 12pts) 判断给定区间内的子字符串是否是回文串。
Solution: Prefix Sum 判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。
时间复杂度：O(N) 空间复杂度：O(N) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int main() { int total_test_case_number; cin >> total_test_case_number; for (int case_number = 1; case_number &lt;= total_test_case_number; ++case_number) { int N, Q, m, n, total = 0; cin >> N >> Q; string words; cin >> words; vector&lt;vector&lt;int>> odds(N + 1, vector&lt;int>(26)); for (int i = 1; i &lt;= N; ++i) { for (int j = 0; j &lt; 26; ++j) odds[i][j] = odds[i - 1][j]; ++odds[i][words[i - 1] - 'A']; } for (int q = 0; q &lt; Q; ++q) { cin >> m >> n; int odd = 0; for (int j = 0; j &lt; 26; ++j) odd += ((odds[n][j] - odds[m - 1][j]) % 2 !...</p></section><footer class=entry-footer><span title='2019-04-21 14:41:22 +1000 +1000'>April 21, 2019</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Kick Start 2019 Round B" href=http://zintrulcre.github.io/posts/kick-start/2019-round-b/></a></article><article class=post-entry><header class=entry-header><h2>Code Jam 2019 Round 1A</h2></header><section class=entry-content><p>Code Jam 2019 Round 1A Pylons (8pts, 23pts) 在m*n的网格里移动，每次移动后的位置不能与之前的位置在同一行/列/对角线上。
Solution: BackTracking 类似于八皇后问题，不过每次的限制条件只和上一个位置有关，可以用回溯解决。
时间复杂度：O(m^2 * n^2) 空间复杂度：O(m * n) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int m, n; bool BackTracking(int t, int i, int j, vector&lt;vector&lt;bool>> &visited, vector&lt;vector&lt;int>> &res) { visited[i][j] = true; res[t] = {i, j}; if (t + 1 == m * n) return true; for (int x = 0; x &lt; m; ++x) { for (int y = 0; y &lt; n; ++y) { int r = (x + i) % m, c = (y + j) % n; if (!...</p></section><footer class=entry-footer><span title='2019-04-13 15:28:11 +1000 +1000'>April 13, 2019</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Code Jam 2019 Round 1A" href=http://zintrulcre.github.io/posts/code-jam/2019-round-1a/></a></article><article class=post-entry><header class=entry-header><h2>Code Jam 2019 Qualification Round</h2></header><section class=entry-content><p>Code Jam 2019 Qualification Round Foregone Solution (6pts, 10pts, 1pts) 将一个带有数字4的数拆分为两个不带数字4的数。
Solution: Construction 输入的数一定带有数字4，对于每一位上的数字4，我们可以将其拆分为2+2（或1+3）的两个数。输入数据最大是10的100次方，所以我们可以将其作为字符串处理。
时间复杂度：O(n) 空间复杂度：O(1) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int main() { int T; cin >> T; for (int t = 1; t &lt;= T; ++t) { string N; cin >> N; string a, b; for (auto c:N) { a += c == '4' ?...</p></section><footer class=entry-footer><span title='2019-04-06 13:40:27 +1000 +1000'>April 6, 2019</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Code Jam 2019 Qualification Round" href=http://zintrulcre.github.io/posts/code-jam/2019-qualification-round/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=http://zintrulcre.github.io/posts/page/9/>« Prev Page</a>
<a class=next href=http://zintrulcre.github.io/posts/page/11/>Next Page »</a></nav></footer></main><footer class=footer><span>Zhengyu &copy; 2023</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>