<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content="Posts - ChrisChen - 尾張"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://prov1dence.top/posts/index.xml><link rel=alternate hreflang=en href=https://prov1dence.top/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="Posts"><meta property="og:description" content="Prov1dence Portfolio"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Prov1dence Portfolio"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Object Detection</h2></header><div class=entry-content><p>Object Detection Object detection deals with detecting instances of objects of a certain class, such as humans, animals, etc, in digital images and videos. Object detection has applications in many areas of computer vision, including image retrieval, face detection, video surveillance, and self-driving, etc. Current detection systems repurpose classifiers to perform detection. To detect an object, these systems take a classifier for that object and evaluate it at various locations and scales in a test image.
...</p></div><footer class=entry-footer><span title='2019-05-19 19:40:23 +1000 AEST'>May 19, 2019</span>&nbsp;·&nbsp;5 min</footer><a class=entry-link aria-label="post link to Object Detection" href=https://prov1dence.top/posts/deep-learning/object-detection-yolo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Code Jam 2019 Round 1C</h2></header><div class=entry-content><p>Code Jam 2019 Round 1C Robot Programming Strategy (10pts, 18pts) 已知所有人石头剪刀布的出招顺序，每一轮同时和所有人比赛，找到必胜的策略。
Solution: Eliminiating 每一轮遍历当前轮次所有人的出招，如果同时有三种情况（R, P, S）则没有必胜策略，直接输出IMPOSSIBLE；否则返回胜利或打平的策略。
对于已经打败过的对手没有必要再考虑其之后的出招，所以用一个defeated数组保存已经打败过的对手以便直接跳过。因为当前轮次有可能超过对手的出招顺序长度，所以要用i % size获取对手当前的出招。
时间复杂度：O(A ^ 2) 空间复杂度：O(A) #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; char Decide(const char &amp;R, const char &amp;P, const char &amp;S) { if (R && P && S) return 'X'; if (R && P) return 'P'; if (R && S) return 'R'; if (P && S) return 'S'; if (R) return 'P'; if (P) return 'S'; return 'R'; } bool Defeate(const char &amp;current, const char &amp;opponent) { return (current == 'R' && opponent == 'S') || (current == 'S' && opponent == 'P') || (current == 'P' && opponent == 'R'); } void solve(const int &amp;t) { int A; scanf("%d", &amp;A); int i = 0; vector&lt;string> opponent(A); vector&lt;bool> defeated(A, false); bool R, P, S; string res; for (int a = 0; a &lt; A; ++a) cin >> opponent[a]; while (true) { int current_opponent = 0; R = false, P = false, S = false; for (int a = 0; a &lt; A; ++a) { if (!defeated[a]) { ++current_opponent; if (opponent[a][i % opponent[a].size()] == 'R') R = true; else if (opponent[a][i % opponent[a].size()] == 'P') P = true; else S = true; } } if (current_opponent == 0) break; char result = Decide(R, P, S); if (result == 'X') { res = "IMPOSSIBLE"; break; } res += result; for (int a = 0; a &lt; A; ++a) { if (!defeated[a] && Defeate(result, opponent[a][i % opponent[a].size()])) defeated[a] = true; } ++i; } printf("Case #%d: %s\n", t, res.c_str()); } int main() { int T; scanf("%d", &amp;T); for (int t = 1; t &lt;= T; ++t) solve(t); return 0; } Power Arrangers (11pts, 21pts) // TODO
...</p></div><footer class=entry-footer><span title='2019-05-07 22:02:15 +1000 AEST'>May 7, 2019</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Code Jam 2019 Round 1C" href=https://prov1dence.top/posts/code-jam/2019-round-1c/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kick Start 2019 Round B</h2></header><div class=entry-content><p>Kick Start 2019 Round B Building Palindromes (5pts, 12pts) 判断给定区间内的子字符串是否是回文串。
Solution: Prefix Sum 判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。
时间复杂度：O(N) 空间复杂度：O(N) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int main() { int total_test_case_number; cin >> total_test_case_number; for (int case_number = 1; case_number &lt;= total_test_case_number; ++case_number) { int N, Q, m, n, total = 0; cin >> N >> Q; string words; cin >> words; vector&lt;vector&lt;int>> odds(N + 1, vector&lt;int>(26)); for (int i = 1; i &lt;= N; ++i) { for (int j = 0; j &lt; 26; ++j) odds[i][j] = odds[i - 1][j]; ++odds[i][words[i - 1] - 'A']; } for (int q = 0; q &lt; Q; ++q) { cin >> m >> n; int odd = 0; for (int j = 0; j &lt; 26; ++j) odd += ((odds[n][j] - odds[m - 1][j]) % 2 != 0); total += odd &lt;= 1; } printf("Case #%d: %d\n", case_number, total); } return 0; } Energy Stones (17pts, 24pts) 在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于背包问题。
...</p></div><footer class=entry-footer><span title='2019-04-21 14:41:22 +1000 AEST'>April 21, 2019</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Kick Start 2019 Round B" href=https://prov1dence.top/posts/kick-start/2019-round-b/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Code Jam 2019 Round 1A</h2></header><div class=entry-content><p>Code Jam 2019 Round 1A Pylons (8pts, 23pts) 在m*n的网格里移动，每次移动后的位置不能与之前的位置在同一行/列/对角线上。
Solution: BackTracking 类似于八皇后问题，不过每次的限制条件只和上一个位置有关，可以用回溯解决。
时间复杂度：O(m^2 * n^2) 空间复杂度：O(m * n) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int m, n; bool BackTracking(int t, int i, int j, vector&lt;vector&lt;bool>> &amp;visited, vector&lt;vector&lt;int>> &amp;res) { visited[i][j] = true; res[t] = {i, j}; if (t + 1 == m * n) return true; for (int x = 0; x &lt; m; ++x) { for (int y = 0; y &lt; n; ++y) { int r = (x + i) % m, c = (y + j) % n; if (!visited[r][c] && r != i && c != j && r + c != i + j && r - c != i - j && BackTracking(t + 1, r, c, visited, res)) return true; } } visited[i][j] = false; return false; } int main() { int total_test_case_number; cin >> total_test_case_number; for (int case_number = 1; case_number &lt;= total_test_case_number; ++case_number) { bool rev = false; cin >> m >> n; if (m > n) { rev = true; swap(n, m); } vector&lt;vector&lt;bool>> visited(m, vector&lt;bool>(n, false)); vector&lt;vector&lt;int>> res(m * n, vector&lt;int>()); printf("Case #%d: ", case_number); if (BackTracking(0, 0, 0, visited, res)) { printf("POSSIBLE\n"); for (int i = 0; i &lt; m * n; ++i) if (!rev) printf("%d %d\n", res[i][0] + 1, res[i][1] + 1); else printf("%d %d\n", res[i][1] + 1, res[i][0] + 1); } else printf("IMPOSSIBLE\n"); } return 0; } Alien Rhyme (10pts, 27pts) 找到后缀相同的一对单词，后缀的长度可以自己定义，其他单词的后缀不能与这一对相同，使得这样的单词对最多。
...</p></div><footer class=entry-footer><span title='2019-04-13 15:28:11 +1000 AEST'>April 13, 2019</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Code Jam 2019 Round 1A" href=https://prov1dence.top/posts/code-jam/2019-round-1a/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Code Jam 2019 Qualification Round</h2></header><div class=entry-content><p>Code Jam 2019 Qualification Round Foregone Solution (6pts, 10pts, 1pts) 将一个带有数字4的数拆分为两个不带数字4的数。
Solution: Construction 输入的数一定带有数字4，对于每一位上的数字4，我们可以将其拆分为2+2（或1+3）的两个数。输入数据最大是10的100次方，所以我们可以将其作为字符串处理。
时间复杂度：O(n) 空间复杂度：O(1) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int main() { int T; cin >> T; for (int t = 1; t &lt;= T; ++t) { string N; cin >> N; string a, b; for (auto c:N) { a += c == '4' ? '2' : c; b += c == '4' ? '2' : '0'; } while (a[0] == '0') a.erase(a.begin()); while (b[0] == '0') b.erase(b.begin()); cout &lt;&lt; "Case #" &lt;&lt; t &lt;&lt; ": " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; } } You Can Go Your Own Way (5pts, 9pts, 10pts) 在n*n的矩阵里从(0,0)走到(n-1,n-1)，只能向右或向下走。矩阵里有一条已有的路径，不能与该路径有重合。最常规的做法是DFS/BFS，时间复杂度为O(n^2)。
...</p></div><footer class=entry-footer><span title='2019-04-06 13:40:27 +1000 +1000'>April 6, 2019</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Code Jam 2019 Qualification Round" href=https://prov1dence.top/posts/code-jam/2019-qualification-round/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://prov1dence.top/posts/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://prov1dence.top/posts/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>