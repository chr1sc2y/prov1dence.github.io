<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ 闭包和匿名函数 | ChrisChen - 尾張</title>
<meta name=keywords content="C++,Pointer,C++11"><meta name=description content='C++ 闭包和匿名函数
本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。
1 闭包和仿函数
闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 &ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions."，其中有两层含义：

词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈；
函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；

显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：
class Adder
{
public:
    int operator()(int num)
    {
        sum += num;
        return sum;
    }

    Adder() : sum(0) {}
    Adder(int num) : sum(num) {}
private:
    int sum;
};
   
int main()
{
    Adder adder(0);
    cout << adder(1) << endl;
    cout << adder(2) << endl;
    cout << adder(3) << endl;
}
$ g++ -std=c++98 -o adder adder.cpp 
$ ./adder 
1
3
6
相比之下 golang 中真正的闭包显得简洁很多：'><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/cpp/closure-and-anonymous-function/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/cpp/closure-and-anonymous-function/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/cpp/closure-and-anonymous-function/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="C++ 闭包和匿名函数"><meta property="og:description" content='C++ 闭包和匿名函数 本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。
1 闭包和仿函数 闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 “In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions."，其中有两层含义：
词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈； 函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数； 显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：
class Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout << adder(1) << endl; cout << adder(2) << endl; cout << adder(3) << endl; } $ g++ -std=c++98 -o adder adder.cpp $ ./adder 1 3 6 相比之下 golang 中真正的闭包显得简洁很多：'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-14T21:20:18+08:00"><meta property="article:modified_time" content="2020-11-14T21:20:18+08:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Pointer"><meta property="article:tag" content="C++11"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 闭包和匿名函数"><meta name=twitter:description content='C++ 闭包和匿名函数
本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。
1 闭包和仿函数
闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 &ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions."，其中有两层含义：

词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈；
函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；

显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：
class Adder
{
public:
    int operator()(int num)
    {
        sum += num;
        return sum;
    }

    Adder() : sum(0) {}
    Adder(int num) : sum(num) {}
private:
    int sum;
};
   
int main()
{
    Adder adder(0);
    cout << adder(1) << endl;
    cout << adder(2) << endl;
    cout << adder(3) << endl;
}
$ g++ -std=c++98 -o adder adder.cpp 
$ ./adder 
1
3
6
相比之下 golang 中真正的闭包显得简洁很多：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"C++ 闭包和匿名函数","item":"https://prov1dence.top/posts/cpp/closure-and-anonymous-function/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 闭包和匿名函数","name":"C\u002b\u002b 闭包和匿名函数","description":"C++ 闭包和匿名函数 本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。\n1 闭包和仿函数 闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 \u0026ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.\u0026quot;，其中有两层含义：\n词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈； 函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数； 显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：\nclass Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout \u0026lt;\u0026lt; adder(1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(3) \u0026lt;\u0026lt; endl; } $ g++ -std=c++98 -o adder adder.cpp $ ./adder 1 3 6 相比之下 golang 中真正的闭包显得简洁很多：\n","keywords":["C++","Pointer","C++11"],"articleBody":"C++ 闭包和匿名函数 本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。\n1 闭包和仿函数 闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 “In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.\"，其中有两层含义：\n词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈； 函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数； 显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：\nclass Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout \u003c\u003c adder(1) \u003c\u003c endl; cout \u003c\u003c adder(2) \u003c\u003c endl; cout \u003c\u003c adder(3) \u003c\u003c endl; } $ g++ -std=c++98 -o adder adder.cpp $ ./adder 1 3 6 相比之下 golang 中真正的闭包显得简洁很多：\nfunc adder() func(int) int { sum := 0 return func(num int) int { sum += num return sum } } func main() { numAdder := adder() fmt.Println(numAdder(1)) fmt.Println(numAdder(2)) fmt.Println(numAdder(3)) } $ go run main.go 1 3 6 C++ 98 的标准库中提供了很多实用的函数，例如 std::sort，当我们需要定制其排序规则的时候，也可以定义一个简单的仿函数（或者普通的函数）作为参数传入 ，注意定义排序规则的时候要满足 Strict Weak Ordering：\nstruct Foo { int a_, b_; Foo(int a, int b) : a_(a), b_(b) {} }; struct FooComparatorGreater { bool operator()(const Foo f1, const Foo f2) { if (f1.a_ != f2.a_) return f1.a_ \u003e f2.a_; return f1.b_ \u003e f2.b_; } }; int main() { vector\u003cFoo\u003e foo{ Foo(3, 6), Foo(9, 2), Foo(9, 8) }; sort(foo.begin(), foo.end(), FooComparatorGreater()); for (const auto\u0026 f : foo) cout \u003c\u003c f.a_ \u003c\u003c ' ' \u003c\u003c f.b_ \u003c\u003c endl; return 0; } $ g++ -std=c++11 -o sort-functor sort-functor.cpp $ ./sort-functor 9 8 9 2 3 6 2 匿名函数 匿名函数（Anonymous Function）起源于第一个函数式编程语言 Lisp，C++ 11 标准中正式引入了匿名函数，也叫做 lambda 表达式（Lambda Expression）；匿名函数是一种没有被绑定标识符的函数，可以用于很方便地定义一个临时的函数对象，或作为一个函数对象传递给更上层的函数（例如 std::for_each），其在 C++ 11 的语法上表现得非常轻量级，不需要像普通的具名函数一样单独在头文件中作出声明，且符合闭包的定义。\n匿名函数可以替代掉复杂且冗余的仿函数，使得代码更易于理解和维护：\nsort(foo.begin(), foo.end(), [](const Foo\u0026 f1, const Foo\u0026 f2) { return f1.a_ != f2.a_ ? f1.a_ \u003e f2.a_ : f1.b_ \u003e f2.b_; }); 匿名函数由以下几个部分组成，其中只有 1, 2, 6 三个部分是必须的，其余部分可以省略：\n捕获子句 capture clause / lambda introducer 参数列表 parameter list / lambda declarator 可变规格 mutable specification 被 mutable 修饰的匿名函数可以修改按值捕获的变量 异常规格 exception specification 尾随返回类型 trailing-return-type 匿名函数体 lambda body 2.1 捕获子句 捕获子句用于捕获外部变量，使得匿名函数体可以使用这些变量，捕获的方法分为引用捕获和值（拷贝）捕获两种，使用方法如下：\n[] 不捕获任何变量；\n[\u0026] 按引用捕获所有外部变量；\n[=] 按值捕获所有外部变量\n[\u0026, var] 默认按引用捕获，仅按值捕获 var；\n[=, \u0026var] 默认按值捕获，仅按引用捕获 var；\n[y, y] 重复按值捕获同一个变量，没有意义，会报 warning；\n[\u0026, \u0026var] 默认按引用捕获，并按引用捕获 var，没有意义，会报 warning；\n[=, this] 默认按值捕获，并按值捕获 this 指针，没有意义，同样会报 warning；\nstd::function\u003cvoid()\u003e AnonyFunc = [=, this]() -\u003e void {};// warning: explicit by-copy capture of ‘this’ redundant with by-copy capture default [this] 按值捕获 this 指针，this 指针虽然不能被修改，但其指向的对象可以被操作并修改，相当于按引用捕获了 this 指向的对象，即 [\u0026(*this)]；\nclass Foo { public: void Func() { int y{ 0 }; std::function\u003cvoid()\u003e AnonyFunc = [this]() -\u003e void { x_ = 2; // ok，x_ 是类的成员变量，可以被修改 y = 2; // error: ‘y’ is not captured，函数的局部变量并没有被捕获 this = nullptr; // error: lvalue required as left operand of assignment，这里捕获的 this 指针是一个临时变量即右值，不能被修改 }; AnonyFunc(); } private: int x_ = 0; }; [*this] 在 C++ 11 中不能按值捕获 this 指针指向的对象；\nstd::function\u003cvoid()\u003e AnonyFunc = [*this]() -\u003e void {}; // error: expected identifier before ‘*’ token 在使用捕获子句的时候，需要注意一些问题：\n不建议使用 2，3 这两种方式进行捕获（对性能影响较大），应该明确地指出需要按引用捕获的变量；\n按值捕获的变量是 read-only (const) 的，只有当匿名函数的可变规格被显式声明为 mutable 的时候才可以修改按值捕获的变量；\nint x{ 0 }; auto AnonyFunc = [=]() -\u003e void { x = 1; // error: assignment of read-only variable ‘x’ } auto AnonyFunc = [=]() mutable -\u003e void { x = 1; // ok } 按值捕获的变量的值在匿名函数生成的时候就已经确定了，如果在匿名函数生成后修改外部变量的值，则不会影响到匿名函数内被捕获的变量值，因为它们是两个作用域不同的变量：\nint i{ 0 }; auto AnonyFunc = [i]() -\u003e void { cout \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \u0026i \u003c\u003c endl; }; i = 1; cout \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \u0026i \u003c\u003c endl; AnonyFunc(); $ g++ -std=c++11 -o lambda-capture lambda-capture.cpp $ ./lambda-capture 1 0x7ffe31fced8c 0 0x7ffe31fced80 对于按引用捕获的变量（或按值捕获的指针），如果该引用变量（或指针指向的对象）在外部被析构，那么匿名函数中的引用变量（或指针）则会成为悬空引用/指针（Dangling Pointer）：\nint* x = new int[1000000]; x[0] = 0; auto AnonyFunc = [\u0026x]() { x[0] = 1; // Segmentation fault }; delete[] x; AnonyFunc(); struct Foo { int x_[1000000]; }; int main() { Foo* f = new Foo(); f-\u003ex_[0] = 0; auto AnonyFunc = [f]() -\u003e void { f-\u003ex_[0] = 1; // Segmentation fault }; delete f; AnonyFunc(); } 2.2 匿名函数和闭包 Scott Meyers 对 lambda 表达式（匿名函数）与闭包之间的关系的解释是 “The distinction between a lambda and the corresponding closure is precisely equivalent to the distinction between a class and an instance of the class. A class exists only in source code; it doesn’t exist at runtime. What exists at runtime are objects of the class type. Closures are to lambdas as objects are to classes. This should not be a surprise, because each lambda expression causes a unique class to be generated (during compilation) and also causes an object of that class type–a closure–to be created (at runtime).\"；\n这段解释可以拆分为两段：\n匿名函数和闭包的关系就如同类和类对象的关系，匿名函数和类的定义都只存在于源码（代码段）中，而闭包和类对象则是在运行时占用内存空间的实体； 对匿名函数的定义会生成一个独一无二的类，并在运行时生成其类对象； 再结合 C++ 11 的标准说明：\n\"[C++11: 5.1.2/3]: The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type — called the closure type…\"，C++ 11 中的匿名函数实际上也是用类（closure type）来实现的； “[C++11: 5.1.2/5]: The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters and return type are described by the lambda-expression’s parameter-declaration-clause and trailing-return-type respectively. [..]”，匿名函数生成的类中也重载了 operator()，其参数与匿名函数的参数列表相同，返回值与匿名函数的尾随返回类型相同； \"[C++11: 5.1.2/6]: The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type’s function call operator.\"，如果匿名函数没有任何参数，那么将会生成一个普通的函数，而不是闭包类型； 可以知道实际上匿名函数也是用仿函数实现的，它实际上是 C++ 11 加入的语法糖，不过其语法特性是符合闭包定义的。\n3 匿名函数在 C++ 14 及之后的变化 C++ 14 广义捕获 C++ 14 中引入了新的广义 lambda 捕获（Generalized Lambda Captures），即可以在捕获列表中以任意方式初始化匿名函数中的变量，使得某些被禁用了拷贝构造函数的类型可以通过 std::move 的方式被捕获到匿名函数中：\nauto ptr_0 = make_unique\u003cint\u003e( 0 ); auto AnonyFunc = [ptr_0 = move(ptr_0)]() { *ptr_0 = 1; cout \u003c\u003c *ptr_0 \u003c\u003c endl; }; AnonyFunc(); 这里捕获列表中左边和右边的 ptr_0 不是同一个变量，它们的作用域分别是匿名函数内和匿名函数外；\n除此之外广义 lambda 捕获还可以用来间接地捕获 *this，即在 C++ 11 中无法实现的按值捕获 this 指向的对象：\nauto AnonyFunc = [this_copy = *this]() mutable { this_copy.x_ = 1; cout \u003c\u003c this_copy.x_ \u003c\u003c endl; }; AnonyFunc(); C++ 17 捕获 *this 在 C++ 17 中，终于可以直接捕获 *this 了，提案 P0018R3 指出捕获 *this 可以用于需要进行异步操作的并发应用，因为 this 可能失效：\nauto AnonyFunc = [*this]() mutable { x_ = 1; cout \u003c\u003c x_ \u003c\u003c endl; }; AnonyFunc(); cout \u003c\u003c x_ \u003c\u003c endl; $ g++ -std=c++17 -o lambda lambda.cpp $ ./lambda 1 0 ","wordCount":"954","inLanguage":"en","datePublished":"2020-11-14T21:20:18+08:00","dateModified":"2020-11-14T21:20:18+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/cpp/closure-and-anonymous-function/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++ 闭包和匿名函数</h1><div class=post-meta><span title='2020-11-14 21:20:18 +0800 +0800'>November 14, 2020</span>&nbsp;·&nbsp;5 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#c-%e9%97%ad%e5%8c%85%e5%92%8c%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0 aria-label="C++ 闭包和匿名函数">C++ 闭包和匿名函数</a><ul><li><a href=#1-%e9%97%ad%e5%8c%85%e5%92%8c%e4%bb%bf%e5%87%bd%e6%95%b0 aria-label="1 闭包和仿函数">1 闭包和仿函数</a></li><li><a href=#2-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0 aria-label="2 匿名函数">2 匿名函数</a><ul><li><a href=#21-%e6%8d%95%e8%8e%b7%e5%ad%90%e5%8f%a5 aria-label="2.1 捕获子句">2.1 捕获子句</a></li><li><a href=#22-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0%e5%92%8c%e9%97%ad%e5%8c%85 aria-label="2.2 匿名函数和闭包">2.2 匿名函数和闭包</a></li></ul></li><li><a href=#3-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0%e5%9c%a8-c-14-%e5%8f%8a%e4%b9%8b%e5%90%8e%e7%9a%84%e5%8f%98%e5%8c%96 aria-label="3 匿名函数在 C++ 14 及之后的变化">3 匿名函数在 C++ 14 及之后的变化</a><ul><li><a href=#c-14-%e5%b9%bf%e4%b9%89%e6%8d%95%e8%8e%b7 aria-label="C++ 14 广义捕获">C++ 14 广义捕获</a></li><li><a href=#c-17-%e6%8d%95%e8%8e%b7-this aria-label="C++ 17 捕获 *this">C++ 17 捕获 *this</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=c-闭包和匿名函数>C++ 闭包和匿名函数<a hidden class=anchor aria-hidden=true href=#c-闭包和匿名函数>#</a></h1><p>本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。</p><h2 id=1-闭包和仿函数>1 闭包和仿函数<a hidden class=anchor aria-hidden=true href=#1-闭包和仿函数>#</a></h2><p><strong>闭包</strong>（<a href=https://en.wikipedia.org/wiki/Closure_(computer_programming)>Closure</a>）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 <em>&ldquo;In programming languages, a <strong>closure</strong>, also <strong>lexical closure</strong> or <strong>function closure</strong>, is a technique for implementing <strong>lexically scoped name binding</strong> in a language with <strong>first-class functions</strong>."</em>，其中有两层含义：</p><ol><li>词法作用域（<a href=https://en.wikipedia.org/wiki/Lexically_scoped>lexically scoped</a>）的名字绑定（<a href=https://en.wikipedia.org/wiki/Name_binding>name binding</a>）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈；</li><li>函数被当作头等公民（<a href=https://en.wikipedia.org/wiki/First-class_citizen>first-class citizen</a>）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；</li></ol><p>显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（<a href=https://www.geeksforgeeks.org/functors-in-cpp/>Functor</a>）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Adder</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>operator</span>()(<span style=color:#66d9ef>int</span> num)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> num;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Adder() <span style=color:#f92672>:</span> sum(<span style=color:#ae81ff>0</span>) {}
</span></span><span style=display:flex><span>    Adder(<span style=color:#66d9ef>int</span> num) <span style=color:#f92672>:</span> sum(num) {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sum;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Adder adder(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> adder(<span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> adder(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> adder(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ g++ -std<span style=color:#f92672>=</span>c++98 -o adder adder.cpp 
</span></span><span style=display:flex><span>$ ./adder 
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>
</span></span></code></pre></div><p>相比之下 golang 中真正的闭包显得简洁很多：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>adder</span>() <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>num</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>num</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>numAdder</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>adder</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>numAdder</span>(<span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>numAdder</span>(<span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>numAdder</span>(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ go run main.go 
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>
</span></span></code></pre></div><p>C++ 98 的标准库中提供了很多实用的函数，例如 <code>std::sort</code>，当我们需要定制其排序规则的时候，也可以定义一个简单的仿函数（或者普通的函数）作为参数传入 ，注意定义排序规则的时候要满足 <a href=https://www.boost.org/sgi/stl/StrictWeakOrdering.html>Strict Weak Ordering</a>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a_, b_;
</span></span><span style=display:flex><span>    Foo(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) <span style=color:#f92672>:</span> a_(a), b_(b) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>FooComparatorGreater</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> Foo f1, <span style=color:#66d9ef>const</span> Foo f2)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (f1.a_ <span style=color:#f92672>!=</span> f2.a_)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> f1.a_ <span style=color:#f92672>&gt;</span> f2.a_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f1.b_ <span style=color:#f92672>&gt;</span> f2.b_;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span> foo{ Foo(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>6</span>), Foo(<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>2</span>), Foo(<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>8</span>) };
</span></span><span style=display:flex><span>    sort(foo.begin(), foo.end(), FooComparatorGreater());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> f : foo)
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> f.a_ <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> f.b_ <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ g++ -std<span style=color:#f92672>=</span>c++11 -o sort-functor sort-functor.cpp 
</span></span><span style=display:flex><span>$ ./sort-functor 
</span></span><span style=display:flex><span><span style=color:#ae81ff>9</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>9</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> <span style=color:#ae81ff>6</span>
</span></span></code></pre></div><h2 id=2-匿名函数>2 匿名函数<a hidden class=anchor aria-hidden=true href=#2-匿名函数>#</a></h2><p><strong>匿名函数</strong>（<a href=https://en.wikipedia.org/wiki/Anonymous_function>Anonymous Function</a>）起源于第一个<a href=https://en.wikipedia.org/wiki/Functional_programming>函数式编程</a>语言 <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)#:~:text=Lisp%20(historically%20LISP)%20is%20a,is%20older%2C%20by%20one%20year.">Lisp</a>，C++ 11 标准中正式引入了匿名函数，也叫做 lambda 表达式（<a href=https://en.cppreference.com/w/cpp/language/lambda>Lambda Expression</a>）；匿名函数是一种没有被绑定标识符的函数，可以用于很方便地定义一个临时的函数对象，或作为一个函数对象传递给更上层的函数（例如 <a href=https://en.cppreference.com/w/cpp/algorithm/sort><code>std::for_each</code></a>），其在 C++ 11 的语法上表现得非常轻量级，不需要像普通的<strong>具名函数</strong>一样单独在头文件中作出声明，且<strong>符合闭包的定义</strong>。</p><p>匿名函数可以替代掉复杂且冗余的仿函数，使得代码更易于理解和维护：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>sort(foo.begin(), foo.end(), [](<span style=color:#66d9ef>const</span> Foo<span style=color:#f92672>&amp;</span> f1, <span style=color:#66d9ef>const</span> Foo<span style=color:#f92672>&amp;</span> f2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> f1.a_ <span style=color:#f92672>!=</span> f2.a_ <span style=color:#f92672>?</span> f1.a_ <span style=color:#f92672>&gt;</span> f2.a_ : f1.b_ <span style=color:#f92672>&gt;</span> f2.b_;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>匿名函数由以下几个部分组成，其中只有 1, 2, 6 三个部分是必须的，其余部分可以省略：</p><p><img alt=lambda-expression-syntax loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/cpp/lambda-expression-syntax.png></p><ol><li>捕获子句 capture clause / lambda introducer</li><li>参数列表 parameter list / lambda declarator</li><li>可变规格 mutable specification<ul><li>被 mutable 修饰的匿名函数可以修改按值捕获的变量</li></ul></li><li>异常规格 exception specification</li><li>尾随返回类型 trailing-return-type</li><li>匿名函数体 lambda body</li></ol><h3 id=21-捕获子句>2.1 捕获子句<a hidden class=anchor aria-hidden=true href=#21-捕获子句>#</a></h3><p>捕获子句用于捕获外部变量，使得匿名函数体可以使用这些变量，捕获的方法分为引用捕获和值（拷贝）捕获两种，使用方法如下：</p><ol><li><p><code>[]</code> 不捕获任何变量；</p></li><li><p><code>[&]</code> 按引用捕获所有外部变量；</p></li><li><p><code>[=]</code> 按值捕获所有外部变量</p></li><li><p><code>[&, var]</code> 默认按引用捕获，仅按值捕获 var；</p></li><li><p><code>[=, &amp;var]</code> 默认按值捕获，仅按引用捕获 var；</p></li><li><p><code>[y, y]</code> 重复按值捕获同一个变量，没有意义，会报 warning；</p></li><li><p><code>[&, &amp;var]</code> 默认按引用捕获，并按引用捕获 var，没有意义，会报 warning；</p></li><li><p><code>[=, this]</code> 默认按值捕获，并按值捕获 this 指针，没有意义，同样会报 warning；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>function<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span>()<span style=color:#f92672>&gt;</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>=</span>, <span style=color:#66d9ef>this</span>]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span> {};<span style=color:#75715e>//  warning: explicit by-copy capture of ‘this’ redundant with by-copy capture default
</span></span></span></code></pre></div></li><li><p><code>[this]</code> 按值捕获 this 指针，this 指针虽然不能被修改，但其指向的对象可以被操作并修改，相当于按引用捕获了 this 指向的对象，即 <code>[&(*this)]</code>；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Func()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> y{ <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>function<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span>()<span style=color:#f92672>&gt;</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#66d9ef>this</span>]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            x_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>// ok，x_ 是类的成员变量，可以被修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            y <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>// error: ‘y’ is not captured，函数的局部变量并没有被捕获
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>this</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>; <span style=color:#75715e>// error: lvalue required as left operand of assignment，这里捕获的 this 指针是一个临时变量即右值，不能被修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        };
</span></span><span style=display:flex><span>        AnonyFunc();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></li><li><p><code>[*this]</code> 在 C++ 11 中不能按值捕获 this 指针指向的对象；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>function<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span>()<span style=color:#f92672>&gt;</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span> {}; <span style=color:#75715e>// error: expected identifier before ‘*’ token
</span></span></span></code></pre></div></li></ol><p>在使用捕获子句的时候，需要注意一些问题：</p><ol><li><p>不建议使用 2，3 这两种方式进行捕获（对性能影响较大），应该明确地指出需要按引用捕获的变量；</p></li><li><p>按值捕获的变量是 read-only (const) 的，只有当匿名函数的可变规格被显式声明为 <code>mutable</code> 的时候才可以修改按值捕获的变量；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> x{ <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>=</span>]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// error: assignment of read-only variable ‘x’
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>=</span>]() <span style=color:#66d9ef>mutable</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// ok
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li><li><p>按值捕获的变量的值在匿名函数生成的时候就已经确定了，如果在匿名函数生成后修改外部变量的值，则不会影响到匿名函数内被捕获的变量值，因为它们是两个作用域不同的变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> i{ <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [i]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>&amp;</span>i <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>&amp;</span>i <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>AnonyFunc();
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ g++ -std<span style=color:#f92672>=</span>c++11 -o lambda-capture lambda-capture.cpp 
</span></span><span style=display:flex><span>$ ./lambda-capture 
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>0x7ffe31fced8c
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>0x7ffe31fced80
</span></span></code></pre></div></li><li><p>对于按引用捕获的变量（或按值捕获的指针），如果该引用变量（或指针指向的对象）在外部被析构，那么匿名函数中的引用变量（或指针）则会成为<strong>悬空引用/指针</strong>（<a href=https://en.wikipedia.org/wiki/Dangling_pointer>Dangling Pointer</a>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> x <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>1000000</span>];
</span></span><span style=display:flex><span>x[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>x]()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    x[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Segmentation fault
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>delete</span>[] x;
</span></span><span style=display:flex><span>AnonyFunc();
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x_[<span style=color:#ae81ff>1000000</span>];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Foo<span style=color:#f92672>*</span> f <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Foo();
</span></span><span style=display:flex><span>    f<span style=color:#f92672>-&gt;</span>x_[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [f]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        f<span style=color:#f92672>-&gt;</span>x_[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Segmentation fault
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> f;
</span></span><span style=display:flex><span>    AnonyFunc();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h3 id=22-匿名函数和闭包>2.2 匿名函数和闭包<a hidden class=anchor aria-hidden=true href=#22-匿名函数和闭包>#</a></h3><p><em>Scott Meyers</em> 对 lambda 表达式（匿名函数）与闭包之间的关系的解释是 <em>&ldquo;The distinction between a lambda and the corresponding closure is precisely equivalent to the distinction between a class and an instance of the class. A class exists only in source code; it doesn’t exist at runtime. What exists at runtime are objects of the class type. Closures are to lambdas as objects are to classes. This should not be a surprise, because each lambda expression causes a unique class to be generated (during compilation) and also causes an object of that class type–a closure–to be created (at runtime)."</em>；</p><p>这段解释可以拆分为两段：</p><ol><li>匿名函数和闭包的关系就如同类和类对象的关系，匿名函数和类的定义都只存在于源码（代码段）中，而闭包和类对象则是在运行时占用内存空间的实体；</li><li>对匿名函数的定义会生成一个独一无二的类，并在运行时生成其类对象；</li></ol><p>再结合 C++ 11 的标准说明：</p><ul><li><em>"[C++11: 5.1.2/3]: The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type — called the closure type&mldr;"</em>，C++ 11 中的匿名函数实际上也是用类（closure type）来实现的；</li><li><em>“[C++11: 5.1.2/5]: The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters and return type are described by the lambda-expression’s parameter-declaration-clause and trailing-return-type respectively. [..]”</em>，匿名函数生成的类中也重载了 <code>operator()</code>，其参数与匿名函数的参数列表相同，返回值与匿名函数的尾随返回类型相同；</li><li><em>"[C++11: 5.1.2/6]: The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type’s function call operator."</em>，如果匿名函数没有任何参数，那么将会生成一个普通的函数，而不是闭包类型；</li></ul><p>可以知道实际上匿名函数也是用仿函数实现的，它实际上是 C++ 11 加入的语法糖，不过其语法特性是符合闭包定义的。</p><h2 id=3-匿名函数在-c-14-及之后的变化>3 匿名函数在 C++ 14 及之后的变化<a hidden class=anchor aria-hidden=true href=#3-匿名函数在-c-14-及之后的变化>#</a></h2><h3 id=c-14-广义捕获>C++ 14 广义捕获<a hidden class=anchor aria-hidden=true href=#c-14-广义捕获>#</a></h3><p>C++ 14 中引入了新的<strong>广义 lambda 捕获</strong>（<a href=https://en.wikipedia.org/wiki/C%2B%2B14#Generic_lambdas>Generalized Lambda Captures</a>），即可以在捕获列表中以任意方式初始化匿名函数中的变量，使得某些被禁用了拷贝构造函数的类型可以通过 <code>std::move</code> 的方式被捕获到匿名函数中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> ptr_0 <span style=color:#f92672>=</span> make_unique<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>( <span style=color:#ae81ff>0</span> );
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [ptr_0 <span style=color:#f92672>=</span> move(ptr_0)]()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>ptr_0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>ptr_0 <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>AnonyFunc();
</span></span></code></pre></div><p>这里捕获列表中左边和右边的 <code>ptr_0</code> 不是同一个变量，它们的作用域分别是匿名函数内和匿名函数外；</p><p>除此之外广义 lambda 捕获还可以用来间接地捕获 <code>*this</code>，即在 C++ 11 中无法实现的按值捕获 this 指向的对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [this_copy <span style=color:#f92672>=</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>]() <span style=color:#66d9ef>mutable</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    this_copy.x_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> this_copy.x_ <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>AnonyFunc();
</span></span></code></pre></div><h3 id=c-17-捕获-this>C++ 17 捕获 <code>*this</code><a hidden class=anchor aria-hidden=true href=#c-17-捕获-this>#</a></h3><p>在 C++ 17 中，终于可以直接捕获 <code>*this</code> 了，<a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0018r3.html>提案 P0018R3</a> 指出捕获 <code>*this</code> 可以用于需要进行异步操作的并发应用，因为 <code>this</code> 可能失效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>]() <span style=color:#66d9ef>mutable</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    x_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> x_ <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>AnonyFunc();
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> x_ <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ g++ -std<span style=color:#f92672>=</span>c++17 -o lambda lambda.cpp 
</span></span><span style=display:flex><span>$ ./lambda 
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://prov1dence.top/tags/c++/>C++</a></li><li><a href=https://prov1dence.top/tags/pointer/>Pointer</a></li><li><a href=https://prov1dence.top/tags/c++11/>C++11</a></li></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/reinforcement-learning/heuristic-search-and-reinforcement-learning/><span class=title>« Prev</span><br><span>启发式搜索和强化学习</span>
</a><a class=next href=https://prov1dence.top/posts/service-governance/load-balancing/><span class=title>Next »</span><br><span>负载均衡和一致性哈希</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>