<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ 智能指针（1）：auto_ptr | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content='C++智能指针（1）：auto_ptr
分析
C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类
class Object {
public:
    Object() { std::cout << "Construct" << std::endl; }

    Object(const Object &amp;other) { std::cout << "Copy" << std::endl; }

    Object(Object &&amp;other) noexcept { std::cout << "Move" << std::endl; }

    ~Object() { std::cout << "Destruct" << std::endl; }

    void Print() { std::cout << "Print" << std::endl; }
};
创建一个指向 Object 类型的指针
int main() {
    Object *o = new Object();
    o->Print();
    return 0;
}
/*
output:
Construct
Print
*/
我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象
int main() {
    Object *o1 = new Object();
    o1->Print();
    Object o2 = Object();
    o2.Print();
    return 0;
}
/*
output:
Construct
Print
Construct
Print
Destruct
*/
产生这样的结果是因为对象创建在栈（stack）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。'><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="C++ 智能指针（1）：auto_ptr"><meta property="og:description" content='C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类
class Object { public: Object() { std::cout << "Construct" << std::endl; } Object(const Object &amp;other) { std::cout << "Copy" << std::endl; } Object(Object &&amp;other) noexcept { std::cout << "Move" << std::endl; } ~Object() { std::cout << "Destruct" << std::endl; } void Print() { std::cout << "Print" << std::endl; } }; 创建一个指向 Object 类型的指针
int main() { Object *o = new Object(); o->Print(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象
int main() { Object *o1 = new Object(); o1->Print(); Object o2 = Object(); o2.Print(); return 0; } /* output: Construct Print Construct Print Destruct */ 产生这样的结果是因为对象创建在栈（stack）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-27T15:21:35+11:00"><meta property="article:modified_time" content="2018-12-27T15:21:35+11:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 智能指针（1）：auto_ptr"><meta name=twitter:description content='C++智能指针（1）：auto_ptr
分析
C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类
class Object {
public:
    Object() { std::cout << "Construct" << std::endl; }

    Object(const Object &amp;other) { std::cout << "Copy" << std::endl; }

    Object(Object &&amp;other) noexcept { std::cout << "Move" << std::endl; }

    ~Object() { std::cout << "Destruct" << std::endl; }

    void Print() { std::cout << "Print" << std::endl; }
};
创建一个指向 Object 类型的指针
int main() {
    Object *o = new Object();
    o->Print();
    return 0;
}
/*
output:
Construct
Print
*/
我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象
int main() {
    Object *o1 = new Object();
    o1->Print();
    Object o2 = Object();
    o2.Print();
    return 0;
}
/*
output:
Construct
Print
Construct
Print
Destruct
*/
产生这样的结果是因为对象创建在栈（stack）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"C++ 智能指针（1）：auto_ptr","item":"https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 智能指针（1）：auto_ptr","name":"C\u002b\u002b 智能指针（1）：auto_ptr","description":"C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类\nclass Object { public: Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Construct\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(const Object \u0026amp;other) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy\u0026#34; \u0026lt;\u0026lt; std::endl; } Object(Object \u0026amp;\u0026amp;other) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Object() { std::cout \u0026lt;\u0026lt; \u0026#34;Destruct\u0026#34; \u0026lt;\u0026lt; std::endl; } void Print() { std::cout \u0026lt;\u0026lt; \u0026#34;Print\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 创建一个指向 Object 类型的指针\nint main() { Object *o = new Object(); o-\u0026gt;Print(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象\nint main() { Object *o1 = new Object(); o1-\u0026gt;Print(); Object o2 = Object(); o2.Print(); return 0; } /* output: Construct Print Construct Print Destruct */ 产生这样的结果是因为对象创建在栈（stack）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。\n","keywords":[],"articleBody":"C++智能指针（1）：auto_ptr 分析 C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类\nclass Object { public: Object() { std::cout \u003c\u003c \"Construct\" \u003c\u003c std::endl; } Object(const Object \u0026other) { std::cout \u003c\u003c \"Copy\" \u003c\u003c std::endl; } Object(Object \u0026\u0026other) noexcept { std::cout \u003c\u003c \"Move\" \u003c\u003c std::endl; } ~Object() { std::cout \u003c\u003c \"Destruct\" \u003c\u003c std::endl; } void Print() { std::cout \u003c\u003c \"Print\" \u003c\u003c std::endl; } }; 创建一个指向 Object 类型的指针\nint main() { Object *o = new Object(); o-\u003ePrint(); return 0; } /* output: Construct Print */ 我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象\nint main() { Object *o1 = new Object(); o1-\u003ePrint(); Object o2 = Object(); o2.Print(); return 0; } /* output: Construct Print Construct Print Destruct */ 产生这样的结果是因为对象创建在栈（stack）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。\n实现 根据auto_ptr的源码，能够大致实现 AutoPointer 类\ntemplate\u003ctypename T\u003e class AutoPointer { public: explicit AutoPointer(T *t); ~AutoPointer(); T \u0026operator*(); T *operator-\u003e(); T *release(); void reset(T *p); AutoPointer(AutoPointer\u003cT\u003e \u0026other); AutoPointer\u003cT\u003e \u0026operator=(AutoPointer\u003cT\u003e const \u0026other); private: T *pointer; }; template\u003ctypename T\u003e AutoPointer\u003cT\u003e::AutoPointer(T *t) { std::cout \u003c\u003c \"AutoPointer \" \u003c\u003c this \u003c\u003c \" constructor called.\" \u003c\u003c std::endl; this-\u003epointer = t; } template\u003ctypename T\u003e AutoPointer\u003cT\u003e::~AutoPointer() { std::cout \u003c\u003c \"AutoPointer \" \u003c\u003c this \u003c\u003c \" destructor called.\" \u003c\u003c std::endl; delete this-\u003epointer; } template\u003ctypename T\u003e T \u0026AutoPointer\u003cT\u003e::operator*() { return *this-\u003epointer; } template\u003ctypename T\u003e T *AutoPointer\u003cT\u003e::operator-\u003e() { return this-\u003epointer; } template\u003ctypename T\u003e T *AutoPointer\u003cT\u003e::release() { T *new_pointer = this-\u003epointer; this-\u003epointer = nullptr; return new_pointer; } template\u003ctypename T\u003e void AutoPointer\u003cT\u003e::reset(T *p) { if (this-\u003epointer != p) { delete this-\u003epointer; this-\u003epointer = p; } } template\u003ctypename T\u003e AutoPointer\u003cT\u003e::AutoPointer(AutoPointer\u003cT\u003e \u0026other) { std::cout \u003c\u003c \"AutoPointer \" \u003c\u003c this \u003c\u003c \" copy constructor called.\" \u003c\u003c std::endl; this-\u003epointer = other.release(); } template\u003ctypename T\u003e AutoPointer\u003cT\u003e \u0026AutoPointer\u003cT\u003e::operator=(AutoPointer\u003cT\u003e const \u0026other) { std::cout \u003c\u003c \"AutoPointer \" \u003c\u003c this \u003c\u003c \" assignment operator called.\" \u003c\u003c std::endl; if (this-\u003epointer != other.pointer) this-\u003ereset(other.release()); return *this; } 构造函数直接将 AutoPointer 类的 pointer 指针指向传入的参数指针所指向的地址 拷贝构造函数先对参数对象的指针进行 release 操作，也就是将参数对象的私有成员 pointer 指针置为 nullptr 并返回其原本指向的地址，然后将自身的 pointer 指向这个地址 赋值操作符先判断传入的参数是否是当前的 AutoPointer 类对象本身，如果是的话直接返回 this 指针，否则先对参数对象的指针进行 release 操作，并 delete 掉当前对象的 pointer，再将 pointer 指向参数对象的 pointer 原本指向的地址，这样的实现有效地规避了迷途指针（也称悬空指针或野指针）。 测试 创建单个 AutoPointer 类对象时能够正常使用。\nint main() { Object *o = new Object(); AutoPointer\u003cObject\u003e a1(o); (*a1).Print(); a1-\u003ePrint(); return 0; } /* output: Construct AutoPointer 0x7fe680c02ab0 constructor called. Print Print AutoPointer 0x7fe680c02ab0 destructor called. Destruct */ 创建两个 AutoPointer 类对象时如果使用同一个 Object 指针进行初始化，那么在程序退出时 Object 对象会被两个 AutoPointer 类对象各析构一次，也就是说同一块地址会被 delete 两次，造成运行时报错。\nint main() { Object *o = new Object(); AutoPointer\u003cObject\u003e a1(o); AutoPointer\u003cObject\u003e a2(o); return 0; } /* output: Construct AutoPointer 0x7ffee3fa0178 constructor called. AutoPointer 0x7ffee3fa0170 constructor called. AutoPointer 0x7ffee3fa0170 destructor called. Destruct AutoPointer 0x7ffee3fa0178 destructor called. Destruct cpp(9015,0x1197a25c0) malloc: *** error for object 0x7fe9dec02b40: pointer being freed was not allocated cpp(9015,0x1197a25c0) malloc: *** set a breakpoint in malloc_error_break to debug */ 使用拷贝构造函数将一个 AutoPointer 类对象 a1 拷贝给另一个 AutoPointer 类对象 a2 时，Object 指针 o 原本是属于 a1 的，在 a2 调用拷贝构造函数之后，a1 的 pointer 变成了空指针，而 s2 拥有了指针 o，造成了所有权转移。\nint main() { Object *o = new Object(); AutoPointer\u003cObject\u003e a1(o); AutoPointer\u003cObject\u003e a2(a1); return 0; } /* output: Construct AutoPointer 0x7fd15bc02ab0 constructor called. AutoPointer 0x7fd15bc02ab0 copy constructor called. AutoPointer 0x7fd15bc02ab0 destructor called. Destruct AutoPointer 0x0 destructor called. */ 使用赋值操作符也会有所有权转移的问题。\nint main() { Object *o = new Object(); AutoPointer\u003cObject\u003e a1(o); AutoPointer\u003cObject\u003e a2 = a1; return 0; } /* output: Construct AutoPointer 0x7ff5d5402ab0 constructor called. AutoPointer 0x7ff5d5402ab0 copy constructor called. AutoPointer 0x7ff5d5402ab0 destructor called. Destruct AutoPointer 0x0 destructor called. */ 总结 AutoPointer 有效地解决了野指针问题，但又会引入一些其他的问题，例如\n所有权转移\n将 AutoPointer 作为参数进行拷贝构造或赋值操作时造成所有权转移 内存泄漏\n在析构函数中使用了delete进行指针的销毁，但如果以数组指针进行初始化 AutoPointer s1(new int[10]) 会因为没有销毁数组\b的其它元素而造成内存泄漏\b auto_ptr源码 template\u003cclass _Tp\u003e class _LIBCPP_TEMPLATE_VIS auto_ptr { private: _Tp* __ptr_; public: typedef _Tp element_type; _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {} _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr\u0026 __p) throw() : __ptr_(__p.release()) {} template\u003cclass _Up\u003e _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr\u003c_Up\u003e\u0026 __p) throw() : __ptr_(__p.release()) {} _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026 operator=(auto_ptr\u0026 __p) throw() {reset(__p.release()); return *this;} template\u003cclass _Up\u003e _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026 operator=(auto_ptr\u003c_Up\u003e\u0026 __p) throw() {reset(__p.release()); return *this;} _LIBCPP_INLINE_VISIBILITY auto_ptr\u0026 operator=(auto_ptr_ref\u003c_Tp\u003e __p) throw() {reset(__p.__ptr_); return *this;} _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp\u0026 operator*() const throw() {return *__ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* operator-\u003e() const throw() {return __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;} _LIBCPP_INLINE_VISIBILITY _Tp* release() throw() { _Tp* __t = __ptr_; __ptr_ = 0; return __t; } _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw() { if (__ptr_ != __p) delete __ptr_; __ptr_ = __p; } _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref\u003c_Tp\u003e __p) throw() : __ptr_(__p.__ptr_) {} template\u003cclass _Up\u003e _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref\u003c_Up\u003e() throw() {auto_ptr_ref\u003c_Up\u003e __t; __t.__ptr_ = release(); return __t;} template\u003cclass _Up\u003e _LIBCPP_INLINE_VISIBILITY operator auto_ptr\u003c_Up\u003e() throw() {return auto_ptr\u003c_Up\u003e(release());} }; ","wordCount":"677","inLanguage":"en","datePublished":"2018-12-27T15:21:35+11:00","dateModified":"2018-12-27T15:21:35+11:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++ 智能指针（1）：auto_ptr</h1><div class=post-meta><span title='2018-12-27 15:21:35 +1100 AEDT'>December 27, 2018</span>&nbsp;·&nbsp;4 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#c%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%881auto_ptr aria-label=C++智能指针（1）：auto_ptr>C++智能指针（1）：auto_ptr</a><ul><li><a href=#%e5%88%86%e6%9e%90 aria-label=分析>分析</a></li><li><a href=#%e5%ae%9e%e7%8e%b0 aria-label=实现>实现</a></li><li><a href=#%e6%b5%8b%e8%af%95 aria-label=测试>测试</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#auto_ptr%e6%ba%90%e7%a0%81 aria-label=auto_ptr源码>auto_ptr源码</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=c智能指针1auto_ptr>C++智能指针（1）：auto_ptr<a hidden class=anchor aria-hidden=true href=#c智能指针1auto_ptr>#</a></h1><h2 id=分析>分析<a hidden class=anchor aria-hidden=true href=#分析>#</a></h2><p>C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Object</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Object() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Construct&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Object(<span style=color:#66d9ef>const</span> Object <span style=color:#f92672>&amp;</span>other) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Copy&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Object(Object <span style=color:#f92672>&amp;&amp;</span>other) <span style=color:#66d9ef>noexcept</span> { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Move&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>Object() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Destruct&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Print</span>() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Print&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>创建一个指向 Object 类型的指针</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>    o<span style=color:#f92672>-&gt;</span>Print();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>output:
</span></span></span><span style=display:flex><span><span style=color:#75715e>Construct
</span></span></span><span style=display:flex><span><span style=color:#75715e>Print
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Object <span style=color:#f92672>*</span>o1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>    o1<span style=color:#f92672>-&gt;</span>Print();
</span></span><span style=display:flex><span>    Object o2 <span style=color:#f92672>=</span> Object();
</span></span><span style=display:flex><span>    o2.Print();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>output:
</span></span></span><span style=display:flex><span><span style=color:#75715e>Construct
</span></span></span><span style=display:flex><span><span style=color:#75715e>Print
</span></span></span><span style=display:flex><span><span style=color:#75715e>Construct
</span></span></span><span style=display:flex><span><span style=color:#75715e>Print
</span></span></span><span style=display:flex><span><span style=color:#75715e>Destruct
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>产生这样的结果是因为对象创建在栈（<a href=https://isocpp.org/blog/2015/09/stack-heap-pool-tony-bulldozer00-bd00-dasilva>stack</a>）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。</p><h2 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h2><p>根据auto_ptr的源码，能够大致实现 AutoPointer 类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AutoPointer</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> AutoPointer(T <span style=color:#f92672>*</span>t);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>AutoPointer();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T <span style=color:#f92672>*</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T <span style=color:#f92672>*</span><span style=color:#a6e22e>release</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reset</span>(T <span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    AutoPointer(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>other);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>&amp;</span>other);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    T <span style=color:#f92672>*</span>pointer;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>AutoPointer(T <span style=color:#f92672>*</span>t) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; constructor called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>=</span> t;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::~</span>AutoPointer() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; destructor called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T <span style=color:#f92672>&amp;</span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T <span style=color:#f92672>*</span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T <span style=color:#f92672>*</span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>release() {
</span></span><span style=display:flex><span>    T <span style=color:#f92672>*</span>new_pointer <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> new_pointer;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>reset(T <span style=color:#f92672>*</span>p) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>!=</span> p) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>AutoPointer(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>other) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; copy constructor called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>=</span> other.release();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>&amp;</span>other) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; assignment operator called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>pointer <span style=color:#f92672>!=</span> other.pointer)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>reset(other.release());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>构造函数直接将 AutoPointer 类的 pointer 指针指向传入的参数指针所指向的地址</li><li>拷贝构造函数先对参数对象的指针进行 release 操作，也就是将参数对象的私有成员 pointer 指针置为 nullptr 并返回其原本指向的地址，然后将自身的 pointer 指向这个地址</li><li>赋值操作符先判断传入的参数是否是当前的 AutoPointer 类对象本身，如果是的话直接返回 this 指针，否则先对参数对象的指针进行 release 操作，并 delete 掉当前对象的 pointer，再将 pointer 指向参数对象的 pointer 原本指向的地址，这样的实现有效地规避了<a href=https://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88>迷途指针</a>（也称悬空指针或野指针）。</li></ul><h2 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h2><p>创建单个 AutoPointer 类对象时能够正常使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a1(o);
</span></span><span style=display:flex><span>    (<span style=color:#f92672>*</span>a1).Print();
</span></span><span style=display:flex><span>    a1<span style=color:#f92672>-&gt;</span>Print();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>output:
</span></span></span><span style=display:flex><span><span style=color:#75715e>Construct
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7fe680c02ab0 constructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>Print
</span></span></span><span style=display:flex><span><span style=color:#75715e>Print
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7fe680c02ab0 destructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>Destruct
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>创建两个 AutoPointer 类对象时如果使用同一个 Object 指针进行初始化，那么在程序退出时 Object 对象会被两个 AutoPointer 类对象各析构一次，也就是说同一块地址会被 delete 两次，造成运行时报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a1(o);
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a2(o);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>output:
</span></span></span><span style=display:flex><span><span style=color:#75715e>Construct
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7ffee3fa0178 constructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7ffee3fa0170 constructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7ffee3fa0170 destructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>Destruct
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7ffee3fa0178 destructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>Destruct
</span></span></span><span style=display:flex><span><span style=color:#75715e>cpp(9015,0x1197a25c0) malloc: *** error for object 0x7fe9dec02b40: pointer being freed was not allocated
</span></span></span><span style=display:flex><span><span style=color:#75715e>cpp(9015,0x1197a25c0) malloc: *** set a breakpoint in malloc_error_break to debug
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>使用拷贝构造函数将一个 AutoPointer 类对象 a1 拷贝给另一个 AutoPointer 类对象 a2 时，Object 指针 o 原本是属于 a1 的，在 a2 调用拷贝构造函数之后，a1 的 pointer 变成了空指针，而 s2 拥有了指针 o，造成了所有权转移。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a1(o);
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a2(a1);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>output:
</span></span></span><span style=display:flex><span><span style=color:#75715e>Construct
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7fd15bc02ab0 constructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7fd15bc02ab0 copy constructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7fd15bc02ab0 destructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>Destruct
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x0 destructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>使用赋值操作符也会有所有权转移的问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Object <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a1(o);
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> a2 <span style=color:#f92672>=</span> a1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>output:
</span></span></span><span style=display:flex><span><span style=color:#75715e>Construct
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7ff5d5402ab0 constructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7ff5d5402ab0 copy constructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x7ff5d5402ab0 destructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>Destruct
</span></span></span><span style=display:flex><span><span style=color:#75715e>AutoPointer 0x0 destructor called.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>AutoPointer 有效地解决了野指针问题，但又会引入一些其他的问题，例如</p><ol><li><p>所有权转移</p><ul><li>将 AutoPointer 作为参数进行拷贝构造或赋值操作时造成所有权转移</li></ul></li><li><p>内存泄漏</p><ul><li>在析构函数中使用了delete进行指针的销毁，但如果以数组指针进行初始化 <code>AutoPointer&lt;int> s1(new int[10])</code> 会因为没有销毁数组的其它元素而造成内存泄漏</li></ul></li></ol><h2 id=auto_ptr源码>auto_ptr源码<a hidden class=anchor aria-hidden=true href=#auto_ptr源码>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Tp</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_LIBCPP_TEMPLATE_VIS</span> auto_ptr
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    _Tp<span style=color:#f92672>*</span> __ptr_;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typedef</span> _Tp element_type;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>auto_ptr</span>(_Tp<span style=color:#f92672>*</span> __p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>throw</span>() <span style=color:#f92672>:</span> __ptr_(__p) {}
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY <span style=color:#a6e22e>auto_ptr</span>(auto_ptr<span style=color:#f92672>&amp;</span> __p) <span style=color:#66d9ef>throw</span>() <span style=color:#f92672>:</span> __ptr_(__p.release()) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Up</span><span style=color:#f92672>&gt;</span> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;&amp;</span> __p) <span style=color:#66d9ef>throw</span>()
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> __ptr_(__p.release()) {}
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY auto_ptr<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(auto_ptr<span style=color:#f92672>&amp;</span> __p) <span style=color:#66d9ef>throw</span>()
</span></span><span style=display:flex><span>        {reset(__p.release()); <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Up</span><span style=color:#f92672>&gt;</span> _LIBCPP_INLINE_VISIBILITY auto_ptr<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(auto_ptr<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;&amp;</span> __p) <span style=color:#66d9ef>throw</span>()
</span></span><span style=display:flex><span>        {reset(__p.release()); <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;}
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY auto_ptr<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(auto_ptr_ref<span style=color:#f92672>&lt;</span>_Tp<span style=color:#f92672>&gt;</span> __p) <span style=color:#66d9ef>throw</span>()
</span></span><span style=display:flex><span>        {reset(__p.__ptr_); <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;}
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY <span style=color:#f92672>~</span>auto_ptr() <span style=color:#66d9ef>throw</span>() {<span style=color:#66d9ef>delete</span> __ptr_;}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY _Tp<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>throw</span>()
</span></span><span style=display:flex><span>        {<span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>__ptr_;}
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY _Tp<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>throw</span>() {<span style=color:#66d9ef>return</span> __ptr_;}
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY _Tp<span style=color:#f92672>*</span> <span style=color:#a6e22e>get</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>throw</span>() {<span style=color:#66d9ef>return</span> __ptr_;}
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY _Tp<span style=color:#f92672>*</span> <span style=color:#a6e22e>release</span>() <span style=color:#66d9ef>throw</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _Tp<span style=color:#f92672>*</span> __t <span style=color:#f92672>=</span> __ptr_;
</span></span><span style=display:flex><span>        __ptr_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> __t;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reset</span>(_Tp<span style=color:#f92672>*</span> __p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>throw</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (__ptr_ <span style=color:#f92672>!=</span> __p)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> __ptr_;
</span></span><span style=display:flex><span>        __ptr_ <span style=color:#f92672>=</span> __p;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _LIBCPP_INLINE_VISIBILITY <span style=color:#a6e22e>auto_ptr</span>(auto_ptr_ref<span style=color:#f92672>&lt;</span>_Tp<span style=color:#f92672>&gt;</span> __p) <span style=color:#66d9ef>throw</span>() <span style=color:#f92672>:</span> __ptr_(__p.__ptr_) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Up</span><span style=color:#f92672>&gt;</span> _LIBCPP_INLINE_VISIBILITY <span style=color:#66d9ef>operator</span> auto_ptr_ref<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;</span>() <span style=color:#66d9ef>throw</span>()
</span></span><span style=display:flex><span>        {auto_ptr_ref<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;</span> __t; __t.__ptr_ <span style=color:#f92672>=</span> release(); <span style=color:#66d9ef>return</span> __t;}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Up</span><span style=color:#f92672>&gt;</span> _LIBCPP_INLINE_VISIBILITY <span style=color:#66d9ef>operator</span> auto_ptr<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;</span>() <span style=color:#66d9ef>throw</span>()
</span></span><span style=display:flex><span>        {<span style=color:#66d9ef>return</span> auto_ptr<span style=color:#f92672>&lt;</span>_Up<span style=color:#f92672>&gt;</span>(release());}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-1.5/><span class=title>« Prev</span><br><span>C++ 智能指针（1.5）：move 语义</span>
</a><a class=next href=https://prov1dence.top/posts/leetcode-archiver/leetcode-archiver2/><span class=title>Next »</span><br><span>LeetCode Archiver(2)：获取题目信息</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>