<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ 智能指针的简单实现 | ChrisChen - 尾張</title>
<meta name=keywords content="C++,Pointer,C++11"><meta name=description content='C++ 智能指针的简单实现
1 std::auto_ptr
C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 模板类：
template<typename T>
class Object
{
public:
    // constructor
    Object() : t_() { cout << "Object::Constructor " << this << endl; }
    Object(T t) : t_(t) { cout << "Object::Constructor " << this << endl; }

    // copy-ctor
    Object(const Object &amp;other) { cout << "Object::Copy-ctor " << this << endl; }

    // destructor
    ~Object() { cout << "Object::Destructor " << this << endl; }

    void Set(T t) { t_ = t; }

    void Print() { cout << t_ << endl; }

private:
    T t_;
};
如果在堆上为类对象分配了内存，在离开其作用域的时候又没将其释放，则会造成内存泄漏：'><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/cpp/smart-pointer/smart-pointer/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/cpp/smart-pointer/smart-pointer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/cpp/smart-pointer/smart-pointer/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="C++ 智能指针的简单实现"><meta property="og:description" content='C++ 智能指针的简单实现 1 std::auto_ptr C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 模板类：
template<typename T> class Object { public: // constructor Object() : t_() { cout << "Object::Constructor " << this << endl; } Object(T t) : t_(t) { cout << "Object::Constructor " << this << endl; } // copy-ctor Object(const Object &amp;other) { cout << "Object::Copy-ctor " << this << endl; } // destructor ~Object() { cout << "Object::Destructor " << this << endl; } void Set(T t) { t_ = t; } void Print() { cout << t_ << endl; } private: T t_; }; 如果在堆上为类对象分配了内存，在离开其作用域的时候又没将其释放，则会造成内存泄漏：'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-21T21:20:18+08:00"><meta property="article:modified_time" content="2021-02-21T21:20:18+08:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Pointer"><meta property="article:tag" content="C++11"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 智能指针的简单实现"><meta name=twitter:description content='C++ 智能指针的简单实现
1 std::auto_ptr
C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 模板类：
template<typename T>
class Object
{
public:
    // constructor
    Object() : t_() { cout << "Object::Constructor " << this << endl; }
    Object(T t) : t_(t) { cout << "Object::Constructor " << this << endl; }

    // copy-ctor
    Object(const Object &amp;other) { cout << "Object::Copy-ctor " << this << endl; }

    // destructor
    ~Object() { cout << "Object::Destructor " << this << endl; }

    void Set(T t) { t_ = t; }

    void Print() { cout << t_ << endl; }

private:
    T t_;
};
如果在堆上为类对象分配了内存，在离开其作用域的时候又没将其释放，则会造成内存泄漏：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"C++ 智能指针的简单实现","item":"https://prov1dence.top/posts/cpp/smart-pointer/smart-pointer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 智能指针的简单实现","name":"C\u002b\u002b 智能指针的简单实现","description":"C++ 智能指针的简单实现 1 std::auto_ptr C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 模板类：\ntemplate\u0026lt;typename T\u0026gt; class Object { public: // constructor Object() : t_() { cout \u0026lt;\u0026lt; \u0026#34;Object::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } Object(T t) : t_(t) { cout \u0026lt;\u0026lt; \u0026#34;Object::Constructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } // copy-ctor Object(const Object \u0026amp;other) { cout \u0026lt;\u0026lt; \u0026#34;Object::Copy-ctor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } // destructor ~Object() { cout \u0026lt;\u0026lt; \u0026#34;Object::Destructor \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } void Set(T t) { t_ = t; } void Print() { cout \u0026lt;\u0026lt; t_ \u0026lt;\u0026lt; endl; } private: T t_; }; 如果在堆上为类对象分配了内存，在离开其作用域的时候又没将其释放，则会造成内存泄漏：\n","keywords":["C++","Pointer","C++11"],"articleBody":"C++ 智能指针的简单实现 1 std::auto_ptr C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 模板类：\ntemplate\u003ctypename T\u003e class Object { public: // constructor Object() : t_() { cout \u003c\u003c \"Object::Constructor \" \u003c\u003c this \u003c\u003c endl; } Object(T t) : t_(t) { cout \u003c\u003c \"Object::Constructor \" \u003c\u003c this \u003c\u003c endl; } // copy-ctor Object(const Object \u0026other) { cout \u003c\u003c \"Object::Copy-ctor \" \u003c\u003c this \u003c\u003c endl; } // destructor ~Object() { cout \u003c\u003c \"Object::Destructor \" \u003c\u003c this \u003c\u003c endl; } void Set(T t) { t_ = t; } void Print() { cout \u003c\u003c t_ \u003c\u003c endl; } private: T t_; }; 如果在堆上为类对象分配了内存，在离开其作用域的时候又没将其释放，则会造成内存泄漏：\nvoid AutoPointerFoo() { Object\u003cint\u003e* o = new Object\u003cint\u003e(1); o-\u003ePrint(); } $ ./bin/smart-pointer Object::Constructor 0x7b7058 # o 1 为了解决这个问题，C++ 98 在标准中增加了最原始的智能指针 std::auto_ptr，它利用 RAII 的机制提供了自动内存管理的功能，即利用栈上对象来管理堆上内存，当智能指针对象离开其作用域时，默认在其析构函数中释放其管理的堆上变量；它能够在一定程度上减少内存泄露的发生，以下是参考 GCC 中的 std::auto_ptr 实现的 AutoPointer 类，做了一定程度的简化，增加了一些输出方便追踪资源分配过程：\ntemplate\u003ctypename T\u003e class AutoPointer { public: // constructor explicit AutoPointer(T* t = nullptr) noexcept : ptr_(t) { std::cout \u003c\u003c \"AutoPointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } // copy-ctor AutoPointer(AutoPointer\u003cT\u003e\u0026 other) noexcept : ptr_(other.Release()) { std::cout \u003c\u003c \"AutoPointer::Copyctor \" \u003c\u003c this \u003c\u003c std::endl; } // assignment operator AutoPointer\u003cT\u003e\u0026 operator=(AutoPointer\u003cT\u003e\u0026 other) { std::cout \u003c\u003c \"AutoPointer::Assignment \" \u003c\u003c this \u003c\u003c std::endl; Reset(other.Release()); return *this; } // destructor ~AutoPointer() noexcept { std::cout \u003c\u003c \"AutoPointer::Destructor \" \u003c\u003c this \u003c\u003c std::endl; delete ptr_; } T\u0026 operator*() noexcept { return *ptr_; } T* operator-\u003e() const noexcept { return ptr_; } T* Get() const noexcept { return ptr_; } T* Release() noexcept { T* ptr_ret = ptr_; ptr_ = nullptr; return ptr_ret; } void Reset(T* ptr_para) noexcept { if (ptr_ != ptr_para) { delete ptr_; ptr_ = ptr_para; } } private: T *ptr_; }; 在初始化时，我们需要手动在堆上分配一个对象，并将其作为参数传入；接下来就可以将智能指针对象当作普通的指针使用了，同时也并不需要关心其生命周期，并能够用使用普通指针的方法来使用智能指针：\nvoid AutoPointerFoo() { Object\u003cint\u003e* o = new Object\u003cint\u003e(1); AutoPointer\u003cObject\u003cint\u003e\u003e a(o); (*o).Set(2); (*o).Print(); o-\u003eSet(3); o-\u003ePrint(); } $ ./bin/smart-pointer Object::Constructor 0x48f058 # o AutoPointer::Constructor 0xbee47668 # a 2 3 AutoPointer::Destructor 0xbee47668 # a Object::Destructor 0x48f058 # o 类中最重要的两个函数是 Release 和 Reset，前者用来解除对象当前所管理的指针对象并返回，后者会释放对象当前所管理的指针对象，并将传入的指针对象置为新的管理对象，两者搭配起来实现了拷贝构造函数和赋值操作符；而这两个函数的存在则带来了第一个问题，即在进行拷贝构造或者赋值操作的时候，被操作的 AutoPointer 对象可能在无意识的情况下失去对其自身所管理对象的所有权，从而可能造成 segmentation fault：\nvoid Foo() { AutoPointer\u003cObject\u003cint\u003e\u003e p1(new Object\u003cint\u003e(6)); AutoPointer\u003cObject\u003cint\u003e\u003e p2(p1); cout \u003c\u003c \"p2: \"; p2-\u003ePrint(); cout \u003c\u003c \"p1: \"; p1-\u003ePrint(); } $ ./bin/smart-pointer Object::Constructor 0x1cbd058 # o AutoPointer::Constructor 0xbed23668 # a1 AutoPointer::Copyctor 0xbed23664 # a2 a2: 1 Segmentation fault 第二个问题是 AutoPointer 默认只会使用 delete 来进行删除操作，如果一个 AutoPointer 对象管理了一个数组，则会在离开其作用域时发生内存泄漏，开启 AddressSanitizer 可以检查到：\nvoid AutoPointerFoo() { int *a = new int[1000000]; AutoPointer\u003cint\u003e p(a); } $ ./bin/smart-pointer AutoPointer::Constructor 0xbe9955e0 # new[] AutoPointer::Destructor 0xbe9955e0 # delete ================================================================= ==2543==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new [] vs operator delete) on 0xb412e800 # ... 除此之外，如果使用同一个 Object 指针对多个 AutoPointer 对象进行初始化，那么这个 Object 对象会被多次 delete，在运行时造成 double free 的报错：\nvoid AutoPointerFoo() { Object\u003cint\u003e* o = new Object\u003cint\u003e(1); AutoPointer\u003cObject\u003cint\u003e\u003e a1(o); AutoPointer\u003cObject\u003cint\u003e\u003e a2(o); } $ ./bin/smart-pointer Object::Constructor 0x9c3058 # o AutoPointer::Constructor 0xbee80668 # a1 AutoPointer::Constructor 0xbee80664 # a2 AutoPointer::Destructor 0xbee80664 # a2 Object::Destructor 0x9c3058 # o AutoPointer::Destructor 0xbee80668 # a1 Object::Destructor 0x9c3058 # o free(): double free detected in tcache 2 Aborted 2 unique_ptr 为了解决 std::auto_ptr 中出现的问题，C++ 11 参考了 boost::unique_ptr 的设计，向标准库中引入了 std::unique_ptr，下面是参考其实现的 UniquePointer 模板类，做了相当程度的简化：\ntemplate\u003ctypename ElementType, typename DeleterType = DefaultDeleter\u003e class UniquePointer { public: // constructors UniquePointer() noexcept : ptr_(nullptr) { std::cout \u003c\u003c \"UniquePointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } explicit UniquePointer(ElementType* p) noexcept : ptr_(p) { std::cout \u003c\u003c \"UniquePointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } UniquePointer(ElementType* p, DeleterType d) noexcept : ptr_(p), deleter_(d) { std::cout \u003c\u003c \"UniquePointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } // move-ctor UniquePointer(UniquePointer\u003cElementType, DeleterType\u003e\u0026\u0026 other) noexcept : ptr_(other.Release()), deleter_(std::move(other.deleter_)) { std::cout \u003c\u003c \"UniquePointer::Move-ctor \" \u003c\u003c this \u003c\u003c std::endl; } // move assignment operator UniquePointer\u003cElementType, DeleterType\u003e\u0026 operator=(UniquePointer\u003cElementType, DeleterType\u003e\u0026\u0026 other) noexcept { std::cout \u003c\u003c \"UniquePointer::MoveAssignment \" \u003c\u003c this \u003c\u003c std::endl; ptr_ = other.Release(); deleter_ = std::move(other.deleter_); return *this; } // copy-ctor UniquePointer(UniquePointer\u003cElementType, DeleterType\u003e\u0026 other) noexcept = delete; // assignment operator UniquePointer\u003cElementType, DeleterType\u003e\u0026 operator=(UniquePointer\u003cElementType, DeleterType\u003e\u0026 other) = delete; // destructor ~UniquePointer() noexcept { std::cout \u003c\u003c \"UniquePointer::Destructor \" \u003c\u003c this \u003c\u003c std::endl; if (ptr_) { GetDeleter()(ptr_); ptr_ = nullptr; } } ElementType\u0026 operator*() noexcept { return *ptr_; } ElementType* operator-\u003e() const noexcept { return ptr_; } ElementType* Get() const noexcept { return ptr_; } const DeleterType\u0026 GetDeleter() const noexcept { return deleter_; } ElementType* Release() noexcept { ElementType* ret = nullptr; std::swap(ptr_, ret); return ret; } void Reset(ElementType* p) noexcept { if (ptr_ != p) { delete ptr_; ptr_ = p; } } private: ElementType* ptr_; DeleterType deleter_; }; 相较于 AutoPointer，UniquePointer 做出的改变主要有两点：第一点是 UniquePointer 对其管理的指针拥有独占所有权，通过禁用拷贝构造和赋值操作的方式防止了所有权转移的发生：\nvoid UniquePointerFoo() { Object\u003cint\u003e* o = new Object\u003cint\u003e(1); UniquePointer\u003cObject\u003cint\u003e\u003e u1(o); UniquePointer\u003cObject\u003cint\u003e\u003e u2{ u1 }; // error: use of deleted function ‘UniquePointer::UniquePointer(UniquePointer\u0026) [with ElementType = Object; DeleterType = DefaultDeleter]’ } 同时又增加了移动构造和移动赋值操作，通过 move 语义来让我们可以在特定情况下显式地转移指针：\nvoid UniquePointerFoo() { Object\u003cint\u003e* o = new Object\u003cint\u003e(1); UniquePointer\u003cObject\u003cint\u003e\u003e u1(o); UniquePointer\u003cObject\u003cint\u003e\u003e u2(std::move(u1)); UniquePointer\u003cObject\u003cint\u003e\u003e u3; u3 = std::move(u2); } $ ./bin/smart-pointer Object::Constructor 0x3af058\t# o UniquePointer::Constructor 0xbec29664\t# u1 UniquePointer::Move-ctor 0xbec2965c\t# u2 UniquePointer::Constructor 0xbec29654\t# u3 UniquePointer::MoveAssignment 0xbec29654\t# u3 UniquePointer::Destructor 0xbec29654\t# u3 Object::Destructor 0x3af058\t# o UniquePointer::Destructor 0xbec2965c\t# u2 UniquePointer::Destructor 0xbec29664\t# u1 第二点是在模板参数中增加了自定义删除器，删除器是一个 functor，我们可以在其 operator() 操作符中自定义 UniquePointer 在析构时对其管理的指针进行的操作，例如使用 delete[] 来释放内存，或是关闭相关的 Socket 等：\nstruct ArrayDeleter { template\u003ctypename T\u003e void operator()(T* p) const { static_assert(sizeof(p) \u003e 0, \"can't delete pointer to incomplete type\"); delete[] p; } }; void UniquePointerFoo() { int* int_arr = new int[1000000]; ArrayDeleter array_deleter; UniquePointer\u003cint, ArrayDeleter\u003e u(int_arr, array_deleter); } $ ./bin/smart-pointer UniquePointer::Constructor 0xbe9ad660 UniquePointer::Destructor 0xbe9ad660 正因为 UniquePointer 对资源具有独占所有权，不能同时有多个 UniquePointer 拥有相同的资源，因此 AutoPointer 中的第三个问题并不能通过使用 UniquePointer 来解决。\n3 shared_ptr std::shared_ptr 的应用场景在于当我们需要让多个智能指针对象同时拥有同一个指针，而又希望在这些对象都退出其作用域的时候去销毁指针。它使用了一个引用计数器来记录指针在同一时间被几个智能指针对象所共享，当这个引用计数减少为 0 时，说明已经不再有对象拥有这个指针，此时则需要进行资源的销毁。\n// A smart pointer with reference-counted copy semantics. The // object pointed to is deleted when the last shared_ptr pointing to // it is destroyed or reset. template\u003ctypename _Tp, _Lock_policy _Lp\u003e class __shared_ptr // ... 由 std::shared_ptr 管理的指针对象（以及引用计数器）存放在堆上，如果在同一时间有两个持有相同资源但位于不同线程中的智能指针同时访问他们所持有的资源，则可能会导致线程安全问题，因此我们还需要使用一定的机制来防止线程安全问题的发生；一般来说对引用计数器的加减修改是原子的，但对于共享资源的访问则需要使用互斥锁等机制保证线程安全。\n以下是参考 std::shared_ptr 实现的 SharedPointer 类：\ntemplate\u003ctypename ElementType, typename DeleterType = DefaultDeleter\u003e class SharedPointer { public: // constructors SharedPointer() noexcept : ptr_(nullptr), ref_count_(nullptr), deleter_(nullptr), mutex_(nullptr) { std::cout \u003c\u003c \"SharedPointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } explicit SharedPointer(ElementType* p) noexcept : ptr_(p), ref_count_(new int(1)), deleter_(new DeleterType()), mutex_(new mutex()) { std::cout \u003c\u003c \"SharedPointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } SharedPointer(ElementType* p, DeleterType *d) noexcept : ptr_(p), ref_count_(new int(1)), deleter_(d), mutex_(new mutex()) { std::cout \u003c\u003c \"SharedPointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } explicit SharedPointer(const WeakPointer\u003cElementType, DeleterType\u003e\u0026 wp) noexcept : ptr_(wp.ptr_), ref_count_(wp.ref_count_), deleter_(wp.deleter_), mutex_(wp.mutex_) { std::cout \u003c\u003c \"SharedPointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; IncreaseReferenceCount(); } // copy-ctor SharedPointer(const SharedPointer\u003cElementType\u003e\u0026 other) noexcept : ptr_(other.ptr_), ref_count_(other.ref_count_), deleter_(other.deleter_), mutex_(other.mutex_) { std::cout \u003c\u003c \"SharedPointer::Copy-ctor \" \u003c\u003c this \u003c\u003c std::endl; IncreaseReferenceCount(); } // assignment operator SharedPointer\u0026 operator=(SharedPointer\u003cElementType\u003e\u0026 other) { if (ptr_ != other.ptr_) { Release(); ptr_ = other.ptr_; ref_count_ = other.ref_count_; mutex_ = other.mutex_; deleter_ = other.deleter_; IncreaseReferenceCount(); } return *this; } // destructor ~SharedPointer() noexcept { std::cout \u003c\u003c \"SharedPointer::Destructor \" \u003c\u003c this \u003c\u003c std::endl; Release(); } void Swap(SharedPointer\u003cElementType, DeleterType\u003e\u0026 other) { std::swap(ptr_, other.ptr_); std::swap(ref_count_, other.ref_count_); std::swap(deleter_, other.deleter_); std::swap(mutex_, other.mutex_); } void Reset() { SharedPointer().Swap(*this); } void Reset(ElementType* p, DeleterType* d = nullptr) { SharedPointer(p, d).Swap(*this); } int UseCount() { return ref_count_ ? *ref_count_ : 0; } ElementType\u0026 operator*() noexcept { return *ptr_; } ElementType* operator-\u003e() const noexcept { return ptr_; } ElementType* Get() const noexcept { return ptr_; } const DeleterType\u0026 GetDeleter() const noexcept { return *deleter_; } void Release() { if (!ptr_) return; bool delete_flag = false; mutex_-\u003elock(); if (--(*ref_count_) == 0) { GetDeleter()(ptr_); delete ref_count_; delete deleter_; delete_flag = true; } mutex_-\u003eunlock(); if (delete_flag) { delete mutex_; } } void IncreaseReferenceCount() { if (!ptr_) return; mutex_-\u003elock(); ++(*ref_count_); mutex_-\u003eunlock(); } ElementType* ptr_; int *ref_count_; DeleterType* deleter_; mutex* mutex_; }; 现在可以正确地让一个指针被多个智能指针对象所持有了：\nvoid SharedPointerFoo() { Object\u003cint\u003e* o = new Object\u003cint\u003e(1); SharedPointer\u003cObject\u003cint\u003e\u003e s1(o); SharedPointer\u003cObject\u003cint\u003e\u003e s2(s1); s1.Reset(nullptr); s2.Reset(nullptr); } $ ./bin/smart-pointer Object::Constructor 0x1ac7058 # o1 SharedPointer::Constructor 0xbe89c65c # p1 SharedPointer::Copy-ctor 0xbe89c64c # p2 SharedPointer::Constructor 0xbe89c630 # p1.Reset SharedPointer::Destructor 0xbe89c630 # p1.Reset SharedPointer::Constructor 0xbe89c630 # p2.Reset SharedPointer::Destructor 0xbe89c630 # p2.Reset Object::Destructor 0x1ac7058 # o1 SharedPointer::Destructor 0xbe89c64c # p2 SharedPointer::Destructor 0xbe89c65c # p1 但又出现了循环引用的问题，例如：\nvoid SharedPointerFoo() { struct Node { int i_; SharedPointer\u003cNode\u003e prev_; SharedPointer\u003cNode\u003e next_; Node(int i) : i_(i) { std::cout \u003c\u003c \"Node::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } ~Node() { std::cout \u003c\u003c \"Node::Destructor \" \u003c\u003c this \u003c\u003c std::endl; } }; Node *n1 = new Node(1), *n2 = new Node(2); SharedPointer\u003cNode\u003e s1(n1), s2(n2); cout \u003c\u003c s1.UseCount() \u003c\u003c ' ' \u003c\u003c s2.UseCount() \u003c\u003c endl; s1-\u003enext_ = s2; s2-\u003eprev_ = s1; cout \u003c\u003c s1.UseCount() \u003c\u003c ' ' \u003c\u003c s2.UseCount() \u003c\u003c endl; } $ ./bin/smart-pointer SharedPointer::Constructor 0x3f905c # n1-\u003eprev_ SharedPointer::Constructor 0x3f906c # n1-\u003enext_ Node::Constructor 0x3f9058 # n1 SharedPointer::Constructor 0x3f948c # n2-\u003eprev_ SharedPointer::Constructor 0x3f949c # n2-\u003enext_ Node::Constructor 0x3f9488 # n2 SharedPointer::Constructor 0xbeca0658 # s1 SharedPointer::Constructor 0xbeca0648 # s2 1 1 2 2 SharedPointer::Destructor 0xbeca0648 # s2 SharedPointer::Destructor 0xbeca0658 # s1 这里虽然 s1 和 s2 两个 SharedPointer 在函数退出时被成功地销毁了，但它们所持有的 n1 和 n2 两个对象却没有，因为 s1 和 s2 的引用计数都没有减少为 0，只有当 s1-\u003enext_ 不再指向 s2，且 s2-\u003eprev_ 不再指向 s1 时，两者的引用计数才能够正确的减少为 0。\n4 weak_ptr std::weak_ptr 是一种弱引用智能指针，它和 std::shared_ptr 的唯一区别是它必须由 std::shared_ptr 或 std::weak_ptr 显式转换而来，而不能由使用 new 创建的对象进行构造，因此其管理的资源实际上是被另一个 std::shared_ptr 所持有的，而其本身则只是提供了对被管理资源的访问能力，同时也不对被管理资源的生命周期造成影响，即不会修改 std::shared_ptr 的引用计数。\n下面是参考 std::weak_ptr 实现的 WeakPointer 类：\ntemplate\u003ctypename ElementType, typename DeleterType\u003e class SharedPointer; template\u003ctypename ElementType, typename DeleterType = DefaultDeleter\u003e class WeakPointer { public: // constructors WeakPointer() noexcept : ptr_(nullptr), ref_count_(nullptr), deleter_(nullptr), mutex_(nullptr) { std::cout \u003c\u003c \"WeakPointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } explicit WeakPointer(SharedPointer\u003cElementType, DeleterType\u003e\u0026 sp) noexcept : ptr_(sp.ptr_), ref_count_(sp.ref_count_), deleter_(sp.deleter_), mutex_(sp.mutex_) { std::cout \u003c\u003c \"WeakPointer::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } // copy-ctor WeakPointer(WeakPointer\u003cElementType\u003e\u0026 other) noexcept : ptr_(other.ptr_), ref_count_(other.ref_count_), deleter_(other.deleter_), mutex_(other.mutex_) { std::cout \u003c\u003c \"WeakPointer::Copy-ctor \" \u003c\u003c this \u003c\u003c std::endl; } // assignment operator WeakPointer\u0026 operator=(SharedPointer\u003cElementType, DeleterType\u003e\u0026 sp) { ptr_ = sp.ptr_; ref_count_ = sp.ref_count_; mutex_ = sp.mutex_; deleter_ = sp.deleter_; return *this; } // destructor ~WeakPointer() noexcept { std::cout \u003c\u003c \"WeakPointer::Destructor \" \u003c\u003c this \u003c\u003c std::endl; } void Swap(WeakPointer\u0026 other) { std::swap(ptr_, other.ptr_); std::swap(ref_count_, other.ref_count_); std::swap(deleter_, other.deleter_); std::swap(mutex_, other.mutex_); } void Reset() { WeakPointer().Swap(*this); } SharedPointer\u003cElementType, DeleterType\u003e Lock() const { return Expired() ? SharedPointer\u003cElementType, DeleterType\u003e() : SharedPointer\u003cElementType, DeleterType\u003e(*this); } int UseCount() { return *ref_count_; } const DeleterType\u0026 GetDeleter() const noexcept { return *deleter_; } bool Expired() const { return *ref_count_ == 0; } ElementType* ptr_; int *ref_count_; DeleterType* deleter_; mutex* mutex_; }; std::weak_ptr 不能控制被管理资源的生命周期，因此我们在使用的时候需要先判断被管理资源是否存在，我们可以借助 std::weak_ptr::lock 获取一个新的 std::shared_ptr 对象以达到安全访问资源的目的：\nvoid WeakPointerFoo() { Object\u003cstring\u003e *o = new Object\u003cstring\u003e(\"test\"); SharedPointer\u003cObject\u003cstring\u003e\u003e s(o); WeakPointer\u003cObject\u003cstring\u003e\u003e w(s); s.Reset(); auto p = w.Lock().Get(); cout \u003c\u003c w.Expired() \u003c\u003c endl; cout \u003c\u003c static_cast\u003cvoid*\u003e(p) \u003c\u003c endl; } $ ./bin/smart-pointer Object::Constructor 0xf8c058 # o SharedPointer::Constructor 0xbe97a630 # s WeakPointer::Constructor 0xbe97a620 # w SharedPointer::Constructor 0xbe97a608 # temporary variable in s.Reset() SharedPointer::Destructor 0xbe97a608 # temporary variable in s.Reset() Object::Destructor 0xf8c058 # o SharedPointer::Constructor 0xbe97a65c # temporary variable in w.Lock() SharedPointer::Destructor 0xbe97a65c # temporary variable in w.Lock() 1 # w.Expired() 0 # p WeakPointer::Destructor 0xbe97a620 # w SharedPointer::Destructor 0xbe97a630 # s 如果把上面的 s.Reset() 去掉，那么 w.Lock() 则会返回一个包含有 Object 对象的 SharedPointer，上面的 *o 也不会在 s.Reset() 之后析构掉：\nvoid WeakPointerFoo() { Object\u003cstring\u003e *o = new Object\u003cstring\u003e(\"test\"); SharedPointer\u003cObject\u003cstring\u003e\u003e s(o); WeakPointer\u003cObject\u003cstring\u003e\u003e w(s); // s.Reset(); auto p = w.Lock().Get(); cout \u003c\u003c w.Expired() \u003c\u003c endl; cout \u003c\u003c static_cast\u003cvoid*\u003e(p) \u003c\u003c endl; } $ ./bin/smart-pointer Object::Constructor 0xb5c058 # o SharedPointer::Constructor 0xbef4562c # s WeakPointer::Constructor 0xbef4561c # w SharedPointer::Constructor 0xbef45658 # temporary variable in s.Reset() SharedPointer::Destructor 0xbef45658 # temporary variable in s.Reset() 0 # w.Expired() 0xb5c058 # p WeakPointer::Destructor 0xbef4561c # temporary variable in w.Lock() SharedPointer::Destructor 0xbef4562c # # temporary variable in w.Lock() Object::Destructor 0xb5c058 # o 对于循环引用的问题，将需要互相指向的智能指针改为 WeakPointer 则可以成功避免指针对象不能正常析构的问题：\nvoid WeakPointerFoo() { struct Node { int i_; WeakPointer\u003cNode\u003e prev_; WeakPointer\u003cNode\u003e next_; Node(int i) : i_(i) { std::cout \u003c\u003c \"Node::Constructor \" \u003c\u003c this \u003c\u003c std::endl; } ~Node() { std::cout \u003c\u003c \"Node::Destructor \" \u003c\u003c this \u003c\u003c std::endl; } }; Node *n1 = new Node(1), *n2 = new Node(2); SharedPointer\u003cNode\u003e p1(n1), p2(n2); cout \u003c\u003c p1.UseCount() \u003c\u003c ' ' \u003c\u003c p2.UseCount() \u003c\u003c endl; p1-\u003enext_ = p2; p2-\u003eprev_ = p1; cout \u003c\u003c p1.UseCount() \u003c\u003c ' ' \u003c\u003c p2.UseCount() \u003c\u003c endl; } $ ./bin/smart-pointer WeakPointer::Constructor 0xb505c # n1-\u003eprev_ WeakPointer::Constructor 0xb506c # n1-\u003enext_ Node::Constructor 0xb5058 # n1 WeakPointer::Constructor 0xb548c # n2-\u003eprev_ WeakPointer::Constructor 0xb549c # n2-\u003enext_ Node::Constructor 0xb5488 # n2 SharedPointer::Constructor 0xbe904658 # s1 SharedPointer::Constructor 0xbe904648 # s2 1 1 1 1 SharedPointer::Destructor 0xbe904648 # s2 Node::Destructor 0xb5488 # n2 WeakPointer::Destructor 0xb549c # n2-\u003enext_ WeakPointer::Destructor 0xb548c # n2-\u003eprev_ SharedPointer::Destructor 0xbe904658 # s1 Node::Destructor 0xb5058 # n1 WeakPointer::Destructor 0xb506c # n1-\u003enext_ WeakPointer::Destructor 0xb505c # n1-\u003eprev_ ","wordCount":"1909","inLanguage":"en","datePublished":"2021-02-21T21:20:18+08:00","dateModified":"2021-02-21T21:20:18+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/cpp/smart-pointer/smart-pointer/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++ 智能指针的简单实现</h1><div class=post-meta><span title='2021-02-21 21:20:18 +0800 +0800'>February 21, 2021</span>&nbsp;·&nbsp;9 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#c-%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%e7%9a%84%e7%ae%80%e5%8d%95%e5%ae%9e%e7%8e%b0 aria-label="C++ 智能指针的简单实现">C++ 智能指针的简单实现</a><ul><li><a href=#1-stdauto_ptr aria-label="1 std::auto_ptr">1 std::auto_ptr</a></li><li><a href=#2-unique_ptr aria-label="2 unique_ptr">2 unique_ptr</a></li><li><a href=#3-shared_ptr aria-label="3 shared_ptr">3 shared_ptr</a></li><li><a href=#4-weak_ptr aria-label="4 weak_ptr">4 weak_ptr</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=c-智能指针的简单实现>C++ 智能指针的简单实现<a hidden class=anchor aria-hidden=true href=#c-智能指针的简单实现>#</a></h1><h2 id=1-stdauto_ptr>1 std::auto_ptr<a hidden class=anchor aria-hidden=true href=#1-stdauto_ptr>#</a></h2><p>C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 模板类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Object</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// constructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Object() <span style=color:#f92672>:</span> t_() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Object::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>    Object(T t) <span style=color:#f92672>:</span> t_(t) { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Object::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// copy-ctor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Object(<span style=color:#66d9ef>const</span> Object <span style=color:#f92672>&amp;</span>other) { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Object::Copy-ctor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// destructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>Object() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Object::Destructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Set</span>(T t) { t_ <span style=color:#f92672>=</span> t; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Print</span>() { cout <span style=color:#f92672>&lt;&lt;</span> t_ <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    T t_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>如果在堆上为类对象分配了内存，在离开其作用域的时候又没将其释放，则会造成内存泄漏：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AutoPointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    o<span style=color:#f92672>-&gt;</span>Print();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>Object::Constructor 0x7b7058 <span style=color:#75715e># o</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>为了解决这个问题，C++ 98 在标准中增加了最原始的<a href=https://en.wikipedia.org/wiki/Smart_pointer>智能指针</a> <code>std::auto_ptr</code>，它利用 <a href=https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization>RAII</a> 的机制提供了自动内存管理的功能，即利用栈上对象来管理堆上内存，当智能指针对象离开其作用域时，默认在其析构函数中释放其管理的堆上变量；它能够在一定程度上减少内存泄露的发生，以下是参考 GCC 中的 <code>std::auto_ptr</code> 实现的 <code>AutoPointer</code> 类，做了一定程度的简化，增加了一些输出方便追踪资源分配过程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AutoPointer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// constructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>explicit</span> AutoPointer(T<span style=color:#f92672>*</span> t <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(t) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// copy-ctor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    AutoPointer(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> other) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(other.Release()) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer::Copyctor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assignment operator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(AutoPointer<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> other)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer::Assignment &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        Reset(other.Release());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// destructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>AutoPointer() <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;AutoPointer::Destructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span> ptr_;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>ptr_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> ptr_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#a6e22e>Get</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> ptr_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#a6e22e>Release</span>() <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        T<span style=color:#f92672>*</span> ptr_ret <span style=color:#f92672>=</span> ptr_;
</span></span><span style=display:flex><span>        ptr_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ptr_ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Reset</span>(T<span style=color:#f92672>*</span> ptr_para) <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ptr_ <span style=color:#f92672>!=</span> ptr_para)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> ptr_;
</span></span><span style=display:flex><span>            ptr_ <span style=color:#f92672>=</span> ptr_para;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    T <span style=color:#f92672>*</span>ptr_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>在初始化时，我们需要手动在堆上分配一个对象，并将其作为参数传入；接下来就可以将智能指针对象当作普通的指针使用了，同时也并不需要关心其生命周期，并能够用使用普通指针的方法来使用智能指针：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AutoPointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> a(o);
</span></span><span style=display:flex><span>    (<span style=color:#f92672>*</span>o).Set(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    (<span style=color:#f92672>*</span>o).Print();
</span></span><span style=display:flex><span>    o<span style=color:#f92672>-&gt;</span>Set(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    o<span style=color:#f92672>-&gt;</span>Print();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>Object::Constructor 0x48f058 <span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>AutoPointer::Constructor 0xbee47668 <span style=color:#75715e># a</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>AutoPointer::Destructor 0xbee47668 <span style=color:#75715e># a</span>
</span></span><span style=display:flex><span>Object::Destructor 0x48f058 <span style=color:#75715e># o</span>
</span></span></code></pre></div><p>类中最重要的两个函数是 <code>Release</code> 和 <code>Reset</code>，前者用来解除对象当前所管理的指针对象并返回，后者会释放对象当前所管理的指针对象，并将传入的指针对象置为新的管理对象，两者搭配起来实现了拷贝构造函数和赋值操作符；而这两个函数的存在则带来了第一个问题，即在进行拷贝构造或者赋值操作的时候，被操作的 <code>AutoPointer</code> 对象可能在无意识的情况下失去对其自身所管理对象的所有权，从而可能造成 <code>segmentation fault</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> p1(<span style=color:#66d9ef>new</span> Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>6</span>));
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> p2(p1);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;p2: &#34;</span>; p2<span style=color:#f92672>-&gt;</span>Print();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;p1: &#34;</span>; p1<span style=color:#f92672>-&gt;</span>Print();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>Object::Constructor 0x1cbd058 <span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>AutoPointer::Constructor 0xbed23668 <span style=color:#75715e># a1</span>
</span></span><span style=display:flex><span>AutoPointer::Copyctor 0xbed23664 <span style=color:#75715e># a2</span>
</span></span><span style=display:flex><span>a2: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Segmentation fault
</span></span></code></pre></div><p>第二个问题是 <code>AutoPointer</code> 默认只会使用 <code>delete</code> 来进行删除操作，如果一个 <code>AutoPointer</code> 对象管理了一个数组，则会在离开其作用域时发生内存泄漏，开启 AddressSanitizer 可以检查到：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AutoPointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>1000000</span>];
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p(a);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>AutoPointer::Constructor 0xbe9955e0 <span style=color:#75715e># new[]</span>
</span></span><span style=display:flex><span>AutoPointer::Destructor 0xbe9955e0 <span style=color:#75715e># delete</span>
</span></span><span style=display:flex><span><span style=color:#f92672>=================================================================</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>2543<span style=color:#f92672>==</span>ERROR: AddressSanitizer: alloc-dealloc-mismatch <span style=color:#f92672>(</span>operator new <span style=color:#f92672>[]</span> vs operator delete<span style=color:#f92672>)</span> on 0xb412e800
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span></code></pre></div><p>除此之外，如果使用同一个 <code>Object</code> 指针对多个 <code>AutoPointer</code> 对象进行初始化，那么这个 <code>Object</code> 对象会被多次 <code>delete</code>，在运行时造成 <code>double free</code> 的报错：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AutoPointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> a1(o);
</span></span><span style=display:flex><span>    AutoPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> a2(o);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>Object::Constructor 0x9c3058 <span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>AutoPointer::Constructor 0xbee80668 <span style=color:#75715e># a1</span>
</span></span><span style=display:flex><span>AutoPointer::Constructor 0xbee80664 <span style=color:#75715e># a2</span>
</span></span><span style=display:flex><span>AutoPointer::Destructor 0xbee80664 <span style=color:#75715e># a2</span>
</span></span><span style=display:flex><span>Object::Destructor 0x9c3058 <span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>AutoPointer::Destructor 0xbee80668 <span style=color:#75715e># a1</span>
</span></span><span style=display:flex><span>Object::Destructor 0x9c3058 <span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>free<span style=color:#f92672>()</span>: double free detected in tcache <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>Aborted
</span></span></code></pre></div><h2 id=2-unique_ptr>2 unique_ptr<a hidden class=anchor aria-hidden=true href=#2-unique_ptr>#</a></h2><p>为了解决 <code>std::auto_ptr</code> 中出现的问题，C++ 11 参考了 <code>boost::unique_ptr</code> 的设计，向标准库中引入了 <code>std::unique_ptr</code>，下面是参考其实现的 <code>UniquePointer</code> 模板类，做了相当程度的简化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> ElementType, <span style=color:#66d9ef>typename</span> DeleterType <span style=color:#f92672>=</span> DefaultDeleter<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UniquePointer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// constructors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UniquePointer() <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(<span style=color:#66d9ef>nullptr</span>) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;UniquePointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>UniquePointer</span>(ElementType<span style=color:#f92672>*</span> p) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(p) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;UniquePointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>    UniquePointer(ElementType<span style=color:#f92672>*</span> p, DeleterType d) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(p), deleter_(d) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;UniquePointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// move-ctor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UniquePointer(UniquePointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;&amp;</span> other) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(other.Release()), deleter_(std<span style=color:#f92672>::</span>move(other.deleter_)) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;UniquePointer::Move-ctor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// move assignment operator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UniquePointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(UniquePointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;&amp;</span> other) <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;UniquePointer::MoveAssignment &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        ptr_ <span style=color:#f92672>=</span> other.Release();
</span></span><span style=display:flex><span>        deleter_ <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(other.deleter_);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// copy-ctor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UniquePointer(UniquePointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;</span> other) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assignment operator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UniquePointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(UniquePointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;</span> other) <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// destructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>UniquePointer() <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;UniquePointer::Destructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ptr_)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GetDeleter()(ptr_);
</span></span><span style=display:flex><span>            ptr_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>ptr_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> ptr_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>*</span> <span style=color:#a6e22e>Get</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> ptr_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> DeleterType<span style=color:#f92672>&amp;</span> GetDeleter() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> deleter_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>*</span> <span style=color:#a6e22e>Release</span>() <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ElementType<span style=color:#f92672>*</span> ret <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>swap(ptr_, ret);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Reset</span>(ElementType<span style=color:#f92672>*</span> p) <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ptr_ <span style=color:#f92672>!=</span> p)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> ptr_;
</span></span><span style=display:flex><span>            ptr_ <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>*</span> ptr_;
</span></span><span style=display:flex><span>    DeleterType deleter_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>相较于 <code>AutoPointer</code>，<code>UniquePointer</code> 做出的改变主要有两点：第一点是 <code>UniquePointer</code> 对其管理的指针拥有独占所有权，通过禁用拷贝构造和赋值操作的方式防止了所有权转移的发生：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>UniquePointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    UniquePointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> u1(o);
</span></span><span style=display:flex><span>    UniquePointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> u2{ u1 }; <span style=color:#75715e>// error: use of deleted function ‘UniquePointer&lt;ElementType, DeleterType&gt;::UniquePointer(UniquePointer&lt;ElementType, DeleterType&gt;&amp;) [with ElementType = Object&lt;int&gt;; DeleterType = DefaultDeleter]’
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>同时又增加了移动构造和移动赋值操作，通过 move 语义来让我们可以在特定情况下显式地转移指针：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>UniquePointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    UniquePointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> u1(o);
</span></span><span style=display:flex><span>    UniquePointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> u2(std<span style=color:#f92672>::</span>move(u1));
</span></span><span style=display:flex><span>    UniquePointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> u3;
</span></span><span style=display:flex><span>    u3 <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(u2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>Object::Constructor 0x3af058				<span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>UniquePointer::Constructor 0xbec29664		<span style=color:#75715e># u1</span>
</span></span><span style=display:flex><span>UniquePointer::Move-ctor 0xbec2965c			<span style=color:#75715e># u2</span>
</span></span><span style=display:flex><span>UniquePointer::Constructor 0xbec29654		<span style=color:#75715e># u3</span>
</span></span><span style=display:flex><span>UniquePointer::MoveAssignment 0xbec29654	<span style=color:#75715e># u3</span>
</span></span><span style=display:flex><span>UniquePointer::Destructor 0xbec29654		<span style=color:#75715e># u3</span>
</span></span><span style=display:flex><span>Object::Destructor 0x3af058					<span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>UniquePointer::Destructor 0xbec2965c		<span style=color:#75715e># u2</span>
</span></span><span style=display:flex><span>UniquePointer::Destructor 0xbec29664		<span style=color:#75715e># u1</span>
</span></span></code></pre></div><p>第二点是在模板参数中增加了自定义删除器，删除器是一个 functor，我们可以在其 <code>operator()</code> 操作符中自定义 <code>UniquePointer</code> 在析构时对其管理的指针进行的操作，例如使用 <code>delete[]</code> 来释放内存，或是关闭相关的 Socket 等：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ArrayDeleter</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#66d9ef>operator</span>()(T<span style=color:#f92672>*</span> p) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static_assert</span>(<span style=color:#66d9ef>sizeof</span>(p) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;can&#39;t delete pointer to incomplete type&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span>[] p;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>UniquePointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> int_arr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>1000000</span>];
</span></span><span style=display:flex><span>    ArrayDeleter array_deleter;
</span></span><span style=display:flex><span>    UniquePointer<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, ArrayDeleter<span style=color:#f92672>&gt;</span> u(int_arr, array_deleter);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>UniquePointer::Constructor 0xbe9ad660
</span></span><span style=display:flex><span>UniquePointer::Destructor 0xbe9ad660
</span></span></code></pre></div><p>正因为 <code>UniquePointer</code> 对资源具有独占所有权，不能同时有多个 <code>UniquePointer</code> 拥有相同的资源，因此 <code>AutoPointer</code> 中的第三个问题并不能通过使用 <code>UniquePointer</code> 来解决。</p><h2 id=3-shared_ptr>3 shared_ptr<a hidden class=anchor aria-hidden=true href=#3-shared_ptr>#</a></h2><p><code>std::shared_ptr</code> 的应用场景在于当我们需要让多个智能指针对象同时拥有同一个指针，而又希望在这些对象都退出其作用域的时候去销毁指针。它使用了一个引用计数器来记录指针在同一时间被几个智能指针对象所共享，当这个引用计数减少为 0 时，说明已经不再有对象拥有这个指针，此时则需要进行资源的销毁。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// A smart pointer with reference-counted copy semantics.  The
</span></span></span><span style=display:flex><span><span style=color:#75715e>// object pointed to is deleted when the last shared_ptr pointing to
</span></span></span><span style=display:flex><span><span style=color:#75715e>// it is destroyed or reset.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> _Tp, _Lock_policy _Lp<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>__shared_ptr</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>由 <code>std::shared_ptr</code> 管理的指针对象（以及引用计数器）存放在堆上，如果在同一时间有两个持有相同资源但位于不同线程中的智能指针同时访问他们所持有的资源，则可能会导致线程安全问题，因此我们还需要使用一定的机制来防止线程安全问题的发生；一般来说对引用计数器的加减修改是原子的，但对于共享资源的访问则需要使用互斥锁等机制保证线程安全。</p><p>以下是参考 <code>std::shared_ptr</code> 实现的 <code>SharedPointer</code> 类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> ElementType, <span style=color:#66d9ef>typename</span> DeleterType <span style=color:#f92672>=</span> DefaultDeleter<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SharedPointer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// constructors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    SharedPointer() <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(<span style=color:#66d9ef>nullptr</span>), ref_count_(<span style=color:#66d9ef>nullptr</span>), deleter_(<span style=color:#66d9ef>nullptr</span>), mutex_(<span style=color:#66d9ef>nullptr</span>) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;SharedPointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>SharedPointer</span>(ElementType<span style=color:#f92672>*</span> p) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(p), ref_count_(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>(<span style=color:#ae81ff>1</span>)), deleter_(<span style=color:#66d9ef>new</span> DeleterType()), mutex_(<span style=color:#66d9ef>new</span> mutex()) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;SharedPointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>    SharedPointer(ElementType<span style=color:#f92672>*</span> p, DeleterType <span style=color:#f92672>*</span>d) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(p), ref_count_(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>(<span style=color:#ae81ff>1</span>)), deleter_(d), mutex_(<span style=color:#66d9ef>new</span> mutex()) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;SharedPointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>SharedPointer</span>(<span style=color:#66d9ef>const</span> WeakPointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;</span> wp) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(wp.ptr_), ref_count_(wp.ref_count_), deleter_(wp.deleter_), mutex_(wp.mutex_)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;SharedPointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        IncreaseReferenceCount();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// copy-ctor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    SharedPointer(<span style=color:#66d9ef>const</span> SharedPointer<span style=color:#f92672>&lt;</span>ElementType<span style=color:#f92672>&gt;&amp;</span> other) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(other.ptr_), ref_count_(other.ref_count_), deleter_(other.deleter_), mutex_(other.mutex_)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;SharedPointer::Copy-ctor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        IncreaseReferenceCount();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assignment operator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    SharedPointer<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(SharedPointer<span style=color:#f92672>&lt;</span>ElementType<span style=color:#f92672>&gt;&amp;</span> other)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ptr_ <span style=color:#f92672>!=</span> other.ptr_)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Release();
</span></span><span style=display:flex><span>            ptr_ <span style=color:#f92672>=</span> other.ptr_;
</span></span><span style=display:flex><span>            ref_count_ <span style=color:#f92672>=</span> other.ref_count_;
</span></span><span style=display:flex><span>            mutex_ <span style=color:#f92672>=</span> other.mutex_;
</span></span><span style=display:flex><span>            deleter_ <span style=color:#f92672>=</span> other.deleter_;
</span></span><span style=display:flex><span>            IncreaseReferenceCount();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// destructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>SharedPointer() <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;SharedPointer::Destructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        Release();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Swap</span>(SharedPointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;</span> other)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>swap(ptr_, other.ptr_);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>swap(ref_count_, other.ref_count_);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>swap(deleter_, other.deleter_);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>swap(mutex_, other.mutex_);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Reset</span>() { SharedPointer().Swap(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>); }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Reset</span>(ElementType<span style=color:#f92672>*</span> p, DeleterType<span style=color:#f92672>*</span> d <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) { SharedPointer(p, d).Swap(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>UseCount</span>() { <span style=color:#66d9ef>return</span> ref_count_ <span style=color:#f92672>?</span> <span style=color:#f92672>*</span>ref_count_ : <span style=color:#ae81ff>0</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>ptr_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> ptr_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>*</span> <span style=color:#a6e22e>Get</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> ptr_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> DeleterType<span style=color:#f92672>&amp;</span> GetDeleter() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>deleter_; }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Release</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ptr_)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> delete_flag <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        mutex_<span style=color:#f92672>-&gt;</span>lock();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>--</span>(<span style=color:#f92672>*</span>ref_count_) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GetDeleter()(ptr_);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> ref_count_;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> deleter_;
</span></span><span style=display:flex><span>            delete_flag <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        mutex_<span style=color:#f92672>-&gt;</span>unlock();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (delete_flag)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> mutex_;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>IncreaseReferenceCount</span>()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ptr_)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>		mutex_<span style=color:#f92672>-&gt;</span>lock();
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>(<span style=color:#f92672>*</span>ref_count_);
</span></span><span style=display:flex><span>		mutex_<span style=color:#f92672>-&gt;</span>unlock();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>*</span> ptr_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>ref_count_;
</span></span><span style=display:flex><span>    DeleterType<span style=color:#f92672>*</span> deleter_;
</span></span><span style=display:flex><span>	mutex<span style=color:#f92672>*</span> mutex_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>现在可以正确地让一个指针被多个智能指针对象所持有了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SharedPointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    SharedPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> s1(o);
</span></span><span style=display:flex><span>    SharedPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> s2(s1);
</span></span><span style=display:flex><span>    s1.Reset(<span style=color:#66d9ef>nullptr</span>);
</span></span><span style=display:flex><span>    s2.Reset(<span style=color:#66d9ef>nullptr</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>Object::Constructor 0x1ac7058 <span style=color:#75715e># o1</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbe89c65c <span style=color:#75715e># p1</span>
</span></span><span style=display:flex><span>SharedPointer::Copy-ctor 0xbe89c64c <span style=color:#75715e># p2</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbe89c630 <span style=color:#75715e># p1.Reset</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbe89c630 <span style=color:#75715e># p1.Reset</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbe89c630 <span style=color:#75715e># p2.Reset</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbe89c630 <span style=color:#75715e># p2.Reset</span>
</span></span><span style=display:flex><span>Object::Destructor 0x1ac7058 <span style=color:#75715e># o1</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbe89c64c <span style=color:#75715e># p2</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbe89c65c <span style=color:#75715e># p1</span>
</span></span></code></pre></div><p>但又出现了<a href=https://www.learncpp.com/cpp-tutorial/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/>循环引用</a>的问题，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SharedPointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i_;
</span></span><span style=display:flex><span>        SharedPointer<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> prev_;
</span></span><span style=display:flex><span>        SharedPointer<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> next_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Node(<span style=color:#66d9ef>int</span> i) <span style=color:#f92672>:</span> i_(i) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Node::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>Node() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Node::Destructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>n1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(<span style=color:#ae81ff>1</span>), <span style=color:#f92672>*</span>n2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    SharedPointer<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> s1(n1), s2(n2);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> s1.UseCount() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> s2.UseCount() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    s1<span style=color:#f92672>-&gt;</span>next_ <span style=color:#f92672>=</span> s2;
</span></span><span style=display:flex><span>    s2<span style=color:#f92672>-&gt;</span>prev_ <span style=color:#f92672>=</span> s1;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> s1.UseCount() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> s2.UseCount() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>SharedPointer::Constructor 0x3f905c <span style=color:#75715e># n1-&gt;prev_</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0x3f906c <span style=color:#75715e># n1-&gt;next_</span>
</span></span><span style=display:flex><span>Node::Constructor 0x3f9058 <span style=color:#75715e># n1</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0x3f948c <span style=color:#75715e># n2-&gt;prev_</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0x3f949c <span style=color:#75715e># n2-&gt;next_</span>
</span></span><span style=display:flex><span>Node::Constructor 0x3f9488 <span style=color:#75715e># n2</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbeca0658 <span style=color:#75715e># s1</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbeca0648 <span style=color:#75715e># s2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbeca0648 <span style=color:#75715e># s2</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbeca0658 <span style=color:#75715e># s1</span>
</span></span></code></pre></div><p>这里虽然 <code>s1</code> 和 <code>s2</code> 两个 <code>SharedPointer&lt;Node></code> 在函数退出时被成功地销毁了，但它们所持有的 <code>n1</code> 和 <code>n2</code> 两个对象却没有，因为 <code>s1</code> 和 <code>s2</code> 的引用计数都没有减少为 0，只有当 <code>s1->next_</code> 不再指向 <code>s2</code>，且 <code>s2->prev_</code> 不再指向 <code>s1</code> 时，两者的引用计数才能够正确的减少为 0。</p><h2 id=4-weak_ptr>4 weak_ptr<a hidden class=anchor aria-hidden=true href=#4-weak_ptr>#</a></h2><p><code>std::weak_ptr</code> 是一种弱引用智能指针，它和 <code>std::shared_ptr</code> 的唯一区别是它必须由 <code>std::shared_ptr</code> 或 <code>std::weak_ptr</code> 显式转换而来，而不能由使用 <code>new</code> 创建的对象进行构造，因此其管理的资源实际上是被另一个 <code>std::shared_ptr</code> 所持有的，而其本身则只是提供了对被管理资源的访问能力，同时也不对被管理资源的生命周期造成影响，即不会修改 <code>std::shared_ptr</code> 的引用计数。</p><p>下面是参考 <code>std::weak_ptr</code> 实现的 <code>WeakPointer</code> 类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> ElementType, <span style=color:#66d9ef>typename</span> DeleterType<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SharedPointer</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> ElementType, <span style=color:#66d9ef>typename</span> DeleterType <span style=color:#f92672>=</span> DefaultDeleter<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WeakPointer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// constructors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WeakPointer() <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(<span style=color:#66d9ef>nullptr</span>), ref_count_(<span style=color:#66d9ef>nullptr</span>), deleter_(<span style=color:#66d9ef>nullptr</span>), mutex_(<span style=color:#66d9ef>nullptr</span>) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;WeakPointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>WeakPointer</span>(SharedPointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;</span> sp) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(sp.ptr_), ref_count_(sp.ref_count_), deleter_(sp.deleter_), mutex_(sp.mutex_) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;WeakPointer::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// copy-ctor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WeakPointer(WeakPointer<span style=color:#f92672>&lt;</span>ElementType<span style=color:#f92672>&gt;&amp;</span> other) <span style=color:#66d9ef>noexcept</span> <span style=color:#f92672>:</span> ptr_(other.ptr_), ref_count_(other.ref_count_), deleter_(other.deleter_), mutex_(other.mutex_)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;WeakPointer::Copy-ctor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assignment operator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WeakPointer<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(SharedPointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;&amp;</span> sp)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ptr_ <span style=color:#f92672>=</span> sp.ptr_;
</span></span><span style=display:flex><span>        ref_count_ <span style=color:#f92672>=</span> sp.ref_count_;
</span></span><span style=display:flex><span>        mutex_ <span style=color:#f92672>=</span> sp.mutex_;
</span></span><span style=display:flex><span>        deleter_ <span style=color:#f92672>=</span> sp.deleter_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// destructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>WeakPointer() <span style=color:#66d9ef>noexcept</span> { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;WeakPointer::Destructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Swap</span>(WeakPointer<span style=color:#f92672>&amp;</span> other)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>swap(ptr_, other.ptr_);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>swap(ref_count_, other.ref_count_);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>swap(deleter_, other.deleter_);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>swap(mutex_, other.mutex_);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Reset</span>() { WeakPointer().Swap(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SharedPointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;</span> Lock() <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Expired</span>() <span style=color:#f92672>?</span> SharedPointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>                         <span style=color:#f92672>:</span> SharedPointer<span style=color:#f92672>&lt;</span>ElementType, DeleterType<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>UseCount</span>() { <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>ref_count_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> DeleterType<span style=color:#f92672>&amp;</span> GetDeleter() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>deleter_; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>Expired</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>ref_count_ <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ElementType<span style=color:#f92672>*</span> ptr_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>ref_count_;
</span></span><span style=display:flex><span>    DeleterType<span style=color:#f92672>*</span> deleter_;
</span></span><span style=display:flex><span>	mutex<span style=color:#f92672>*</span> mutex_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>std::weak_ptr</code> 不能控制被管理资源的生命周期，因此我们在使用的时候需要先判断被管理资源是否存在，我们可以借助 <code>std::weak_ptr::lock</code> 获取一个新的 <code>std::shared_ptr</code> 对象以达到安全访问资源的目的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>WeakPointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Object<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;test&#34;</span>);
</span></span><span style=display:flex><span>    SharedPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> s(o);
</span></span><span style=display:flex><span>    WeakPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> w(s);
</span></span><span style=display:flex><span>    s.Reset();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> p <span style=color:#f92672>=</span> w.Lock().Get();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> w.Expired() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*&gt;</span>(p) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer
</span></span><span style=display:flex><span>Object::Constructor 0xf8c058 <span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbe97a630 <span style=color:#75715e># s</span>
</span></span><span style=display:flex><span>WeakPointer::Constructor 0xbe97a620 <span style=color:#75715e># w</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbe97a608 <span style=color:#75715e># temporary variable in s.Reset()</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbe97a608 <span style=color:#75715e># temporary variable in s.Reset()</span>
</span></span><span style=display:flex><span>Object::Destructor 0xf8c058 <span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbe97a65c <span style=color:#75715e># temporary variable in w.Lock()</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbe97a65c <span style=color:#75715e># temporary variable in w.Lock()</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#75715e># w.Expired()</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span> <span style=color:#75715e># p</span>
</span></span><span style=display:flex><span>WeakPointer::Destructor 0xbe97a620 <span style=color:#75715e># w</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbe97a630 <span style=color:#75715e># s</span>
</span></span></code></pre></div><p>如果把上面的 <code>s.Reset()</code> 去掉，那么 <code>w.Lock()</code> 则会返回一个包含有 <code>Object&lt;string></code> 对象的 <code>SharedPointer</code>，上面的 <code>*o</code> 也不会在 <code>s.Reset()</code> 之后析构掉：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>WeakPointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Object<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> <span style=color:#f92672>*</span>o <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;test&#34;</span>);
</span></span><span style=display:flex><span>    SharedPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> s(o);
</span></span><span style=display:flex><span>    WeakPointer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> w(s);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// s.Reset();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> p <span style=color:#f92672>=</span> w.Lock().Get();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> w.Expired() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*&gt;</span>(p) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer
</span></span><span style=display:flex><span>Object::Constructor 0xb5c058 <span style=color:#75715e># o</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbef4562c <span style=color:#75715e># s</span>
</span></span><span style=display:flex><span>WeakPointer::Constructor 0xbef4561c <span style=color:#75715e># w</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbef45658 <span style=color:#75715e># temporary variable in s.Reset()</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbef45658 <span style=color:#75715e># temporary variable in s.Reset()</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span> <span style=color:#75715e># w.Expired()</span>
</span></span><span style=display:flex><span>0xb5c058 <span style=color:#75715e># p</span>
</span></span><span style=display:flex><span>WeakPointer::Destructor 0xbef4561c <span style=color:#75715e># temporary variable in w.Lock()</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbef4562c <span style=color:#75715e># # temporary variable in w.Lock()</span>
</span></span><span style=display:flex><span>Object::Destructor 0xb5c058 <span style=color:#75715e># o</span>
</span></span></code></pre></div><p>对于循环引用的问题，将需要互相指向的智能指针改为 <code>WeakPointer</code> 则可以成功避免指针对象不能正常析构的问题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>WeakPointerFoo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i_;
</span></span><span style=display:flex><span>        WeakPointer<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> prev_;
</span></span><span style=display:flex><span>        WeakPointer<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> next_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Node(<span style=color:#66d9ef>int</span> i) <span style=color:#f92672>:</span> i_(i) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Node::Constructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>Node() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Node::Destructor &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>n1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(<span style=color:#ae81ff>1</span>), <span style=color:#f92672>*</span>n2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    SharedPointer<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> p1(n1), p2(n2);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> p1.UseCount() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> p2.UseCount() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    p1<span style=color:#f92672>-&gt;</span>next_ <span style=color:#f92672>=</span> p2;
</span></span><span style=display:flex><span>    p2<span style=color:#f92672>-&gt;</span>prev_ <span style=color:#f92672>=</span> p1;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> p1.UseCount() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> p2.UseCount() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./bin/smart-pointer 
</span></span><span style=display:flex><span>WeakPointer::Constructor 0xb505c <span style=color:#75715e># n1-&gt;prev_</span>
</span></span><span style=display:flex><span>WeakPointer::Constructor 0xb506c <span style=color:#75715e># n1-&gt;next_</span>
</span></span><span style=display:flex><span>Node::Constructor 0xb5058 <span style=color:#75715e># n1</span>
</span></span><span style=display:flex><span>WeakPointer::Constructor 0xb548c <span style=color:#75715e># n2-&gt;prev_</span>
</span></span><span style=display:flex><span>WeakPointer::Constructor 0xb549c <span style=color:#75715e># n2-&gt;next_</span>
</span></span><span style=display:flex><span>Node::Constructor 0xb5488 <span style=color:#75715e># n2</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbe904658 <span style=color:#75715e># s1</span>
</span></span><span style=display:flex><span>SharedPointer::Constructor 0xbe904648 <span style=color:#75715e># s2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbe904648 <span style=color:#75715e># s2</span>
</span></span><span style=display:flex><span>Node::Destructor 0xb5488 <span style=color:#75715e># n2</span>
</span></span><span style=display:flex><span>WeakPointer::Destructor 0xb549c <span style=color:#75715e># n2-&gt;next_</span>
</span></span><span style=display:flex><span>WeakPointer::Destructor 0xb548c <span style=color:#75715e># n2-&gt;prev_</span>
</span></span><span style=display:flex><span>SharedPointer::Destructor 0xbe904658 <span style=color:#75715e># s1</span>
</span></span><span style=display:flex><span>Node::Destructor 0xb5058 <span style=color:#75715e># n1</span>
</span></span><span style=display:flex><span>WeakPointer::Destructor 0xb506c <span style=color:#75715e># n1-&gt;next_</span>
</span></span><span style=display:flex><span>WeakPointer::Destructor 0xb505c <span style=color:#75715e># n1-&gt;prev_</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://prov1dence.top/tags/c++/>C++</a></li><li><a href=https://prov1dence.top/tags/pointer/>Pointer</a></li><li><a href=https://prov1dence.top/tags/c++11/>C++11</a></li></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/python/source-code-1/><span class=title>« Prev</span><br><span>Python 源码学习（1）：类型和对象</span>
</a><a class=next href=https://prov1dence.top/posts/reinforcement-learning/heuristic-search-and-reinforcement-learning/><span class=title>Next »</span><br><span>启发式搜索和强化学习</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>