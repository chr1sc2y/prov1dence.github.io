<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python 源码学习（3）：list 类型 | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content="Python 源码学习（3）：list 类型
Python 中的 list 类型在源码中是一个名为 PyListObject 的结构体，定义在 listobject.h 文件中：
// Include/cpython/listobject.h
typedef struct {
    PyObject_VAR_HEAD
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 <= ob_size <= allocated
     *     len(list) == ob_size
     *     ob_item == NULL implies ob_size == allocated == 0
     * list.sort() temporarily sets allocated to -1 to detect mutations.
     *
     * Items must normally not be NULL, except during construction when
     * the list is not yet visible outside the function that builds it.
     */
    Py_ssize_t allocated;
} PyListObject;
它的实现和 C++ 中的 std::vector 类似，都是通过维护一个动态数组，在增加数据的时候动态扩大数组的容量来实现的；PyListObject 结构中包含了一个变长对象头部 PyObject_VAR_HEAD，ob_size 表示当前动态数组的长度，**ob_item 是指向动态数组的指针，allocated 是动态数组的容量；我们可以从它的类型指针 PyTypeObject PyList_Type 中找到用来操作 list 对象的相关方法："><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/python/source-code-3-list-and-dict/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/python/source-code-3-list-and-dict/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/python/source-code-3-list-and-dict/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="Python 源码学习（3）：list 类型"><meta property="og:description" content="Python 源码学习（3）：list 类型 Python 中的 list 类型在源码中是一个名为 PyListObject 的结构体，定义在 listobject.h 文件中：
// Include/cpython/listobject.h typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for 'allocated' elements. The number * currently in use is ob_size. * Invariants: * 0 <= ob_size <= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated; } PyListObject; 它的实现和 C++ 中的 std::vector 类似，都是通过维护一个动态数组，在增加数据的时候动态扩大数组的容量来实现的；PyListObject 结构中包含了一个变长对象头部 PyObject_VAR_HEAD，ob_size 表示当前动态数组的长度，**ob_item 是指向动态数组的指针，allocated 是动态数组的容量；我们可以从它的类型指针 PyTypeObject PyList_Type 中找到用来操作 list 对象的相关方法："><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-06T20:07:52+08:00"><meta property="article:modified_time" content="2021-05-06T20:07:52+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python 源码学习（3）：list 类型"><meta name=twitter:description content="Python 源码学习（3）：list 类型
Python 中的 list 类型在源码中是一个名为 PyListObject 的结构体，定义在 listobject.h 文件中：
// Include/cpython/listobject.h
typedef struct {
    PyObject_VAR_HEAD
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 <= ob_size <= allocated
     *     len(list) == ob_size
     *     ob_item == NULL implies ob_size == allocated == 0
     * list.sort() temporarily sets allocated to -1 to detect mutations.
     *
     * Items must normally not be NULL, except during construction when
     * the list is not yet visible outside the function that builds it.
     */
    Py_ssize_t allocated;
} PyListObject;
它的实现和 C++ 中的 std::vector 类似，都是通过维护一个动态数组，在增加数据的时候动态扩大数组的容量来实现的；PyListObject 结构中包含了一个变长对象头部 PyObject_VAR_HEAD，ob_size 表示当前动态数组的长度，**ob_item 是指向动态数组的指针，allocated 是动态数组的容量；我们可以从它的类型指针 PyTypeObject PyList_Type 中找到用来操作 list 对象的相关方法："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"Python 源码学习（3）：list 类型","item":"https://prov1dence.top/posts/python/source-code-3-list-and-dict/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 源码学习（3）：list 类型","name":"Python 源码学习（3）：list 类型","description":"Python 源码学习（3）：list 类型 Python 中的 list 类型在源码中是一个名为 PyListObject 的结构体，定义在 listobject.h 文件中：\n// Include/cpython/listobject.h typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for \u0026#39;allocated\u0026#39; elements. The number * currently in use is ob_size. * Invariants: * 0 \u0026lt;= ob_size \u0026lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated; } PyListObject; 它的实现和 C++ 中的 std::vector 类似，都是通过维护一个动态数组，在增加数据的时候动态扩大数组的容量来实现的；PyListObject 结构中包含了一个变长对象头部 PyObject_VAR_HEAD，ob_size 表示当前动态数组的长度，**ob_item 是指向动态数组的指针，allocated 是动态数组的容量；我们可以从它的类型指针 PyTypeObject PyList_Type 中找到用来操作 list 对象的相关方法：\n","keywords":[],"articleBody":"Python 源码学习（3）：list 类型 Python 中的 list 类型在源码中是一个名为 PyListObject 的结构体，定义在 listobject.h 文件中：\n// Include/cpython/listobject.h typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for 'allocated' elements. The number * currently in use is ob_size. * Invariants: * 0 \u003c= ob_size \u003c= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated; } PyListObject; 它的实现和 C++ 中的 std::vector 类似，都是通过维护一个动态数组，在增加数据的时候动态扩大数组的容量来实现的；PyListObject 结构中包含了一个变长对象头部 PyObject_VAR_HEAD，ob_size 表示当前动态数组的长度，**ob_item 是指向动态数组的指针，allocated 是动态数组的容量；我们可以从它的类型指针 PyTypeObject PyList_Type 中找到用来操作 list 对象的相关方法：\n// Objects/listobject.c PyTypeObject PyList_Type = { PyVarObject_HEAD_INIT(\u0026PyType_Type, 0) \"list\", sizeof(PyListObject), list_methods, /* tp_methods */ // ... }; static PyMethodDef list_methods[] = { {\"__getitem__\", (PyCFunction)list_subscript, METH_O|METH_COEXIST, \"x.__getitem__(y) \u003c==\u003e x[y]\"}, LIST___REVERSED___METHODDEF LIST___SIZEOF___METHODDEF LIST_CLEAR_METHODDEF LIST_COPY_METHODDEF LIST_APPEND_METHODDEF LIST_INSERT_METHODDEF LIST_EXTEND_METHODDEF LIST_POP_METHODDEF LIST_REMOVE_METHODDEF LIST_INDEX_METHODDEF LIST_COUNT_METHODDEF LIST_REVERSE_METHODDEF LIST_SORT_METHODDEF {\"__class_getitem__\", (PyCFunction)Py_GenericAlias, METH_O|METH_CLASS, PyDoc_STR(\"See PEP 585\")}, {NULL, NULL} /* sentinel */ }; #define LIST_APPEND_METHODDEF \\ {\"append\", (PyCFunction)list_append, METH_O, list_append__doc__}, PyDoc_STRVAR(list_append__doc__, \"append($self, object, /)\\n\" \"--\\n\" \"\\n\" \"Append object to the end of the list.\"); #define LIST_COPY_METHODDEF \\ {\"copy\", (PyCFunction)list_copy, METH_NOARGS, list_copy__doc__}, PyDoc_STRVAR(list_copy__doc__, \"copy($self, /)\\n\" \"--\\n\" \"\\n\" \"Return a shallow copy of the list.\"); Python 中也把所谓的函数封装成了一个叫做 PyMethodDef 的类型，其中包括了函数的名称 *ml_name、对应的 C 函数实现 ml_meth、C 函数所需要的标志 ml_flags，以及函数说明 *ml_doc：\n// Include/methodobject.h struct PyMethodDef { const char *ml_name; /* The name of the built-in function/method */ PyCFunction ml_meth; /* The C function that implements it */ int ml_flags; /* Combination of METH_xxx flags, which mostly describe the args expected by the C func */ const char *ml_doc; /* The __doc__ attribute, or NULL */ }; typedef struct PyMethodDef PyMethodDef; 1 append 如 list_append__doc__ 中所描述的，list_append 函数的目的是向 list 的末尾添加新的元素：\n// Objects/listobject.c static PyObject * list_append(PyListObject *self, PyObject *object) /*[clinic end generated code: output=7c096003a29c0eae input=43a3fe48a7066e91]*/ { if (app1(self, object) == 0) Py_RETURN_NONE; return NULL; } static int app1(PyListObject *self, PyObject *v) { Py_ssize_t n = PyList_GET_SIZE(self); assert (v != NULL); assert((size_t)n + 1 \u003c PY_SSIZE_T_MAX); if (list_resize(self, n+1) \u003c 0) return -1; Py_INCREF(v); PyList_SET_ITEM(self, n, v); return 0; } static int list_resize(PyListObject *self, Py_ssize_t newsize) { PyObject **items; size_t new_allocated, num_allocated_bytes; Py_ssize_t allocated = self-\u003eallocated; /* Bypass realloc() when a previous overallocation is large enough to accommodate the newsize. If the newsize falls lower than half the allocated size, then proceed with the realloc() to shrink the list. */ if (allocated \u003e= newsize \u0026\u0026 newsize \u003e= (allocated \u003e\u003e 1)) { assert(self-\u003eob_item != NULL || newsize == 0); Py_SET_SIZE(self, newsize); return 0; } /* This over-allocates proportional to the list size, making room * for additional growth. The over-allocation is mild, but is * enough to give linear-time amortized behavior over a long * sequence of appends() in the presence of a poorly-performing * system realloc(). * Add padding to make the allocated size multiple of 4. * The growth pattern is: 0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ... * Note: new_allocated won't overflow because the largest possible value * is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t. */ new_allocated = ((size_t)newsize + (newsize \u003e\u003e 3) + 6) \u0026 ~(size_t)3; /* Do not overallocate if the new size is closer to overallocated size * than to the old size. */ if (newsize - Py_SIZE(self) \u003e (Py_ssize_t)(new_allocated - newsize)) new_allocated = ((size_t)newsize + 3) \u0026 ~(size_t)3; if (newsize == 0) new_allocated = 0; num_allocated_bytes = new_allocated * sizeof(PyObject *); items = (PyObject **)PyMem_Realloc(self-\u003eob_item, num_allocated_bytes); if (items == NULL) { PyErr_NoMemory(); return -1; } self-\u003eob_item = items; Py_SET_SIZE(self, newsize); self-\u003eallocated = new_allocated; return 0; } 可以看到在 list_append 中先调用了 list_resize，这个函数可能会进行两个操作：\n在添加元素后，如果新的动态数组长度 newsize 在区间 [allocated / 2, allocated] 内（小于当前容量 allocated 且大于等于当前容量的一半 allocated \u003e\u003e 1），则将数组容量缩小为 newsize； 否则通过公式 new_allocated = ((size_t)newsize + (newsize \u003e\u003e 3) + 6) \u0026 ~(size_t)3 计算出 append 之后动态数组应该被分配的新容量 new_allocated，并重新分配内存。 其中第二步的公式不太直观，可以列表观察具体值的变化：\n动态数组长度 ob_size 当前容量 allocated append 后新的长度 newsize append 后新的容量 new_allocated 0 0 1 (1 + 0 + 6) \u0026 252 = 111 \u0026 11111100 = 4 3 4 4 4 ∈ [2, 4]（不变） 4 8 5 (5 + 0 + 6) \u0026 252 = 1011 \u0026 11111100 = 8 7 8 8 8 ∈ [4, 8]（不变） 8 16 9 (9 + 1 + 6) \u0026 252 = 10000 \u0026 11111100 = 16 15 16 16 16 ∈ [8, 16]（不变） 16 16 17 (16 + 2 + 6) \u0026 252 = 10011 \u0026 11111100 = 24 可以观察到，只有当 append 后新的长度 newsize 大于当前容量 allocated 时，才会将容量调整为一个更大的值，这个值以 4 的倍数来补足和填充；使用 python 测试代码来验证上表的计算结果：\nimport sys l = [] s = sys.getsizeof(l) print((sys.getsizeof(l) - s) // 8) for _ in range(17): l.append(0) print(\"newsize\", len(l), \"new_allocated\", (sys.getsizeof(l) - s) // 8) $ python3 main.py newsize 1 new_allocated 4 newsize 2 new_allocated 4 newsize 3 new_allocated 4 newsize 4 new_allocated 4 newsize 5 new_allocated 8 newsize 6 new_allocated 8 newsize 7 new_allocated 8 newsize 8 new_allocated 8 newsize 9 new_allocated 16 newsize 10 new_allocated 16 newsize 11 new_allocated 16 newsize 12 new_allocated 16 newsize 13 new_allocated 16 newsize 14 new_allocated 16 newsize 15 new_allocated 16 newsize 16 new_allocated 16 newsize 17 new_allocated 24 使用 Python3.9 前后的版本测试较大数据时可能会有出入，因为计算 new_allocated 的过程进行过修改：\n和 std::vector 类似，由摊还分析的方法可知 list_append 的平均时间复杂度为 O(1)。\n2 copy 如 list_copy__doc__ 中所描述的，list_copy 函数的目的是返回一个浅拷贝（shallow copy）的 list：\nstatic PyObject * list_copy(PyListObject *self, PyObject *Py_UNUSED(ignored)) { return list_copy_impl(self); } static PyObject * list_copy_impl(PyListObject *self) { return list_slice(self, 0, Py_SIZE(self)); } static PyObject * list_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh) { PyListObject *np; PyObject **src, **dest; Py_ssize_t i, len; len = ihigh - ilow; np = (PyListObject *) list_new_prealloc(len); if (np == NULL) return NULL; src = a-\u003eob_item + ilow; dest = np-\u003eob_item; for (i = 0; i \u003c len; i++) { PyObject *v = src[i]; Py_INCREF(v); dest[i] = v; } Py_SET_SIZE(np, len); return (PyObject *)np; } 从 PyListObject 的定义中可以得知动态数组指针 PyObject **ob_item 所指向的动态数组中存储的是对象的指针，因此在 list_slice 函数中，也只是简单地将 PyListObject *a 中每一个 PyObject 的指针依次赋予 PyListObject *np，并将其引用计数加 1；对于被拷贝的 list 中的任意一个值得修改都会反映到拷贝到的 list 上：\na = [1, True, [1, 2]] b = a print(a, b) a[0], a[1], a[2] = 0, False, [3, 4] print(a, b) 这里的 b = a 中在 C++ 中一般表示拷贝构造或拷贝赋值操作，但在 Python 中实际上则会调用 list_copy：\n$ python3 main.py [1, True, [1, 2]] [1, True, [1, 2]] [0, False, [3, 4]] [0, False, [3, 4]] 如果想要对一个 list 进行深拷贝，可以调用 copy 模块的 deepcopy 函数，这是一个用 Python 实现的模块：\ndef deepcopy(x, memo=None, _nil=[]): \"\"\"Deep copy operation on arbitrary Python objects. See the module's __doc__ string for more info. \"\"\" if memo is None: memo = {} d = id(x) y = memo.get(d, _nil) if y is not _nil: return y cls = type(x) copier = _deepcopy_dispatch.get(cls) if copier is not None: y = copier(x, memo) else: if issubclass(cls, type): y = _deepcopy_atomic(x, memo) else: copier = getattr(x, \"__deepcopy__\", None) if copier is not None: y = copier(memo) else: # ... # If is its own copy, don't memoize. if y is not x: memo[d] = y _keep_alive(x, memo) # Make sure x lives at least as long as d return y deepcopy 会通过 _deepcopy_dispatch.get 来获取内置容器的拷贝器，将内置容器中的数据依次递归地进行拷贝；为了防止某些容器存储的值当中包含指向自己的指针，或是无限重复的数据，函数中会使用一个 dict 变量 memo 来记录已经被拷贝过的数据，防止 deepcopy 无限地递归下去。\n如果容器中存储的是自定义类型的对象，deepcopy 会通过 copier = getattr(x, \"__deepcopy__\", None) 获取到这个类型中的函数 __deepcopy__，并将其作为一个拷贝器用来生成新的对象，这也就意味着我们需要实现 __deepcopy__ 函数来保证它可以被正确地深拷贝，以一个自定义的有向图结构为例：\nimport copy class DirectedGraphNode: def __init__(self, idx, node_list): self.idx = idx self.node_list = node_list def point_to(self, node): self.node_list.append(node) def __repr__(self): return 'id {}, idx {}, node_list {}'.format(id(self), self.idx, [node.idx for node in self.node_list]) def __deepcopy__(self, memo): print(f\"DirectedGraphNode: __deepcopy__ from {repr(self)}\") if self in memo: exist_obj = memo.get(self) return exist_obj cp_obj = DirectedGraphNode(self.idx, []) memo[self] = cp_obj for node in self.node_list: cp_obj.point_to(copy.deepcopy(node, memo)) print(f\" copy done, self: {repr(self)}\") return cp_obj a = DirectedGraphNode(1, []) b = DirectedGraphNode(2, []) a.point_to(b) b.point_to(a) print(repr(a)) print(repr(b)) c = copy.deepcopy(a) print(repr(c)) for node in c.node_list: print(repr(node)) 在它的 __deepcopy__ 函数中，我们以其中一个节点出发，先构造出新的节点对象 cp_obj，再将它指向的所有节点以递归的方式依次进行深拷贝，如果在拷贝的过程中发现节点是已经被拷贝过的，则直接返回 exist_obj：\n$ python3 main.py id 139867268624336, idx 1, node_list [2] id 139867268624240, idx 2, node_list [1] DirectedGraphNode: __deepcopy__ from id 139867268624336, idx 1, node_list [2] DirectedGraphNode: __deepcopy__ from id 139867268624240, idx 2, node_list [1] DirectedGraphNode: __deepcopy__ from id 139867268624336, idx 1, node_list [2] copy done, self: id 139867268624240, idx 2, node_list [1] copy done, self: id 139867268624336, idx 1, node_list [2] id 139867268624048, idx 1, node_list [2] id 139867268623040, idx 2, node_list [1] ","wordCount":"1330","inLanguage":"en","datePublished":"2021-05-06T20:07:52+08:00","dateModified":"2021-05-06T20:07:52+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/python/source-code-3-list-and-dict/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Python 源码学习（3）：list 类型</h1><div class=post-meta><span title='2021-05-06 20:07:52 +0800 +0800'>May 6, 2021</span>&nbsp;·&nbsp;7 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#python-%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a03list-%e7%b1%bb%e5%9e%8b aria-label="Python 源码学习（3）：list 类型">Python 源码学习（3）：list 类型</a><ul><li><a href=#1-append aria-label="1 append">1 append</a></li><li><a href=#2-copy aria-label="2 copy">2 copy</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=python-源码学习3list-类型>Python 源码学习（3）：list 类型<a hidden class=anchor aria-hidden=true href=#python-源码学习3list-类型>#</a></h1><p>Python 中的 list 类型在源码中是一个名为 <code>PyListObject</code> 的结构体，定义在 <code>listobject.h</code> 文件中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Include/cpython/listobject.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    PyObject_VAR_HEAD
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>**</span>ob_item;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ob_item contains space for &#39;allocated&#39; elements.  The number
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * currently in use is ob_size.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Invariants:
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *     0 &lt;= ob_size &lt;= allocated
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *     len(list) == ob_size
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *     ob_item == NULL implies ob_size == allocated == 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * list.sort() temporarily sets allocated to -1 to detect mutations.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Items must normally not be NULL, except during construction when
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * the list is not yet visible outside the function that builds it.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    Py_ssize_t allocated;
</span></span><span style=display:flex><span>} PyListObject;
</span></span></code></pre></div><p>它的实现和 C++ 中的 <code>std::vector</code> 类似，都是通过维护一个动态数组，在增加数据的时候动态扩大数组的容量来实现的；<code>PyListObject</code> 结构中包含了一个变长对象头部 <code>PyObject_VAR_HEAD</code>，<code>ob_size</code> 表示当前动态数组的长度，<code>**ob_item</code> 是指向动态数组的指针，<code>allocated</code> 是动态数组的容量；我们可以从它的类型指针 <code>PyTypeObject PyList_Type</code> 中找到用来操作 list 对象的相关方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/listobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PyTypeObject PyList_Type <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;list&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sizeof</span>(PyListObject),
</span></span><span style=display:flex><span>    list_methods,                               <span style=color:#75715e>/* tp_methods */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> PyMethodDef list_methods[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>&#34;__getitem__&#34;</span>, (PyCFunction)list_subscript, METH_O<span style=color:#f92672>|</span>METH_COEXIST, <span style=color:#e6db74>&#34;x.__getitem__(y) &lt;==&gt; x[y]&#34;</span>},
</span></span><span style=display:flex><span>    LIST___REVERSED___METHODDEF
</span></span><span style=display:flex><span>    LIST___SIZEOF___METHODDEF
</span></span><span style=display:flex><span>    LIST_CLEAR_METHODDEF
</span></span><span style=display:flex><span>    LIST_COPY_METHODDEF
</span></span><span style=display:flex><span>    LIST_APPEND_METHODDEF
</span></span><span style=display:flex><span>    LIST_INSERT_METHODDEF
</span></span><span style=display:flex><span>    LIST_EXTEND_METHODDEF
</span></span><span style=display:flex><span>    LIST_POP_METHODDEF
</span></span><span style=display:flex><span>    LIST_REMOVE_METHODDEF
</span></span><span style=display:flex><span>    LIST_INDEX_METHODDEF
</span></span><span style=display:flex><span>    LIST_COUNT_METHODDEF
</span></span><span style=display:flex><span>    LIST_REVERSE_METHODDEF
</span></span><span style=display:flex><span>    LIST_SORT_METHODDEF
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>&#34;__class_getitem__&#34;</span>, (PyCFunction)Py_GenericAlias, METH_O<span style=color:#f92672>|</span>METH_CLASS, PyDoc_STR(<span style=color:#e6db74>&#34;See PEP 585&#34;</span>)},
</span></span><span style=display:flex><span>    {NULL,              NULL}           <span style=color:#75715e>/* sentinel */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define LIST_APPEND_METHODDEF    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    {&#34;append&#34;, (PyCFunction)list_append, METH_O, list_append__doc__},
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>PyDoc_STRVAR(list_append__doc__,
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;append($self, object, /)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;--</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Append object to the end of the list.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define LIST_COPY_METHODDEF    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    {&#34;copy&#34;, (PyCFunction)list_copy, METH_NOARGS, list_copy__doc__},
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>PyDoc_STRVAR(list_copy__doc__,
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;copy($self, /)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;--</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Return a shallow copy of the list.&#34;</span>);
</span></span></code></pre></div><p>Python 中也把所谓的函数封装成了一个叫做 <code>PyMethodDef</code> 的类型，其中包括了函数的名称 <code>*ml_name</code>、对应的 C 函数实现 <code>ml_meth</code>、C 函数所需要的标志 <code>ml_flags</code>，以及函数说明 <code>*ml_doc</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Include/methodobject.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PyMethodDef</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span>  <span style=color:#f92672>*</span>ml_name;   <span style=color:#75715e>/* The name of the built-in function/method */</span>
</span></span><span style=display:flex><span>    PyCFunction ml_meth;    <span style=color:#75715e>/* The C function that implements it */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>         ml_flags;   <span style=color:#75715e>/* Combination of METH_xxx flags, which mostly
</span></span></span><span style=display:flex><span><span style=color:#75715e>                               describe the args expected by the C func */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span>  <span style=color:#f92672>*</span>ml_doc;    <span style=color:#75715e>/* The __doc__ attribute, or NULL */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PyMethodDef</span> PyMethodDef;
</span></span></code></pre></div><h2 id=1-append>1 append<a hidden class=anchor aria-hidden=true href=#1-append>#</a></h2><p>如 <code>list_append__doc__</code> 中所描述的，<code>list_append</code> 函数的目的是向 list 的末尾添加新的元素：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/listobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>list_append</span>(PyListObject <span style=color:#f92672>*</span>self, PyObject <span style=color:#f92672>*</span>object)
</span></span><span style=display:flex><span><span style=color:#75715e>/*[clinic end generated code: output=7c096003a29c0eae input=43a3fe48a7066e91]*/</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (app1(self, object) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        Py_RETURN_NONE;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app1</span>(PyListObject <span style=color:#f92672>*</span>self, PyObject <span style=color:#f92672>*</span>v)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Py_ssize_t n <span style=color:#f92672>=</span> PyList_GET_SIZE(self);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assert (v <span style=color:#f92672>!=</span> NULL);
</span></span><span style=display:flex><span>    assert((size_t)n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> PY_SSIZE_T_MAX);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (list_resize(self, n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Py_INCREF(v);
</span></span><span style=display:flex><span>    PyList_SET_ITEM(self, n, v);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>list_resize</span>(PyListObject <span style=color:#f92672>*</span>self, Py_ssize_t newsize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>**</span>items;
</span></span><span style=display:flex><span>    size_t new_allocated, num_allocated_bytes;
</span></span><span style=display:flex><span>    Py_ssize_t allocated <span style=color:#f92672>=</span> self<span style=color:#f92672>-&gt;</span>allocated;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Bypass realloc() when a previous overallocation is large enough
</span></span></span><span style=display:flex><span><span style=color:#75715e>       to accommodate the newsize.  If the newsize falls lower than half
</span></span></span><span style=display:flex><span><span style=color:#75715e>       the allocated size, then proceed with the realloc() to shrink the list.
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (allocated <span style=color:#f92672>&gt;=</span> newsize <span style=color:#f92672>&amp;&amp;</span> newsize <span style=color:#f92672>&gt;=</span> (allocated <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>        assert(self<span style=color:#f92672>-&gt;</span>ob_item <span style=color:#f92672>!=</span> NULL <span style=color:#f92672>||</span> newsize <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        Py_SET_SIZE(self, newsize);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* This over-allocates proportional to the list size, making room
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * for additional growth.  The over-allocation is mild, but is
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * enough to give linear-time amortized behavior over a long
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * sequence of appends() in the presence of a poorly-performing
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * system realloc().
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Add padding to make the allocated size multiple of 4.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * The growth pattern is:  0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ...
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Note: new_allocated won&#39;t overflow because the largest possible value
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *       is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    new_allocated <span style=color:#f92672>=</span> ((size_t)newsize <span style=color:#f92672>+</span> (newsize <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(size_t)<span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Do not overallocate if the new size is closer to overallocated size
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * than to the old size.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newsize <span style=color:#f92672>-</span> Py_SIZE(self) <span style=color:#f92672>&gt;</span> (Py_ssize_t)(new_allocated <span style=color:#f92672>-</span> newsize))
</span></span><span style=display:flex><span>        new_allocated <span style=color:#f92672>=</span> ((size_t)newsize <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(size_t)<span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newsize <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        new_allocated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    num_allocated_bytes <span style=color:#f92672>=</span> new_allocated <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(PyObject <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>    items <span style=color:#f92672>=</span> (PyObject <span style=color:#f92672>**</span>)PyMem_Realloc(self<span style=color:#f92672>-&gt;</span>ob_item, num_allocated_bytes);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (items <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        PyErr_NoMemory();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    self<span style=color:#f92672>-&gt;</span>ob_item <span style=color:#f92672>=</span> items;
</span></span><span style=display:flex><span>    Py_SET_SIZE(self, newsize);
</span></span><span style=display:flex><span>    self<span style=color:#f92672>-&gt;</span>allocated <span style=color:#f92672>=</span> new_allocated;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到在 <code>list_append</code> 中先调用了 <code>list_resize</code>，这个函数可能会进行两个操作：</p><ol><li>在添加元素后，如果新的动态数组长度 <code>newsize</code> 在区间 <code>[allocated / 2, allocated]</code> 内（小于当前容量 <code>allocated</code> 且大于等于当前容量的一半 <code>allocated >> 1</code>），则将数组容量缩小为 <code>newsize</code>；</li><li>否则通过公式 <code>new_allocated = ((size_t)newsize + (newsize >> 3) + 6) & ~(size_t)3</code> 计算出 <code>append</code> 之后动态数组应该被分配的新容量 <code>new_allocated</code>，并重新分配内存。</li></ol><p>其中第二步的公式不太直观，可以列表观察具体值的变化：</p><table><thead><tr><th>动态数组长度 ob_size</th><th>当前容量 allocated</th><th>append 后新的长度 newsize</th><th>append 后新的容量 new_allocated</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>(1 + 0 + 6) & 252 = 111 & 11111100 = 4</td></tr><tr><td>3</td><td>4</td><td>4</td><td>4 ∈ [2, 4]（不变）</td></tr><tr><td>4</td><td>8</td><td>5</td><td>(5 + 0 + 6) & 252 = 1011 & 11111100 = 8</td></tr><tr><td>7</td><td>8</td><td>8</td><td>8 ∈ [4, 8]（不变）</td></tr><tr><td>8</td><td>16</td><td>9</td><td>(9 + 1 + 6) & 252 = 10000 & 11111100 = 16</td></tr><tr><td>15</td><td>16</td><td>16</td><td>16 ∈ [8, 16]（不变）</td></tr><tr><td>16</td><td>16</td><td>17</td><td>(16 + 2 + 6) & 252 = 10011 & 11111100 = 24</td></tr></tbody></table><p>可以观察到，只有当 append 后新的长度 <code>newsize</code> 大于当前容量 <code>allocated</code> 时，才会将容量调整为一个更大的值，这个值以 4 的倍数来补足和填充；使用 <code>python</code> 测试代码来验证上表的计算结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>l <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>getsizeof(l)
</span></span><span style=display:flex><span>print((sys<span style=color:#f92672>.</span>getsizeof(l) <span style=color:#f92672>-</span> s) <span style=color:#f92672>//</span> <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>17</span>):
</span></span><span style=display:flex><span>	l<span style=color:#f92672>.</span>append(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	print(<span style=color:#e6db74>&#34;newsize&#34;</span>, len(l), <span style=color:#e6db74>&#34;new_allocated&#34;</span>, (sys<span style=color:#f92672>.</span>getsizeof(l) <span style=color:#f92672>-</span> s) <span style=color:#f92672>//</span> <span style=color:#ae81ff>8</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ python3 main.py 
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>1</span> new_allocated <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>2</span> new_allocated <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>3</span> new_allocated <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>4</span> new_allocated <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>5</span> new_allocated <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>6</span> new_allocated <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>7</span> new_allocated <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>8</span> new_allocated <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>9</span> new_allocated <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>10</span> new_allocated <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>11</span> new_allocated <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>12</span> new_allocated <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>13</span> new_allocated <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>14</span> new_allocated <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>15</span> new_allocated <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>16</span> new_allocated <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>newsize <span style=color:#ae81ff>17</span> new_allocated <span style=color:#ae81ff>24</span>
</span></span></code></pre></div><p>使用 Python3.9 前后的版本测试较大数据时可能会有出入，因为计算 <code>new_allocated</code> 的过程进行过修改：</p><p><img alt=list_resize loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/list_resize.png></p><p>和 <code>std::vector</code> 类似，由摊还分析的方法可知 <code>list_append</code> 的平均时间复杂度为 <em>O</em>(<em>1</em>)。</p><h2 id=2-copy>2 copy<a hidden class=anchor aria-hidden=true href=#2-copy>#</a></h2><p>如 <code>list_copy__doc__</code> 中所描述的，<code>list_copy</code> 函数的目的是返回一个<strong>浅拷贝</strong>（<a href=https://en.wikipedia.org/wiki/Object_copying>shallow copy</a>）的 list：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>static</span> PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>list_copy</span>(PyListObject <span style=color:#f92672>*</span>self, PyObject <span style=color:#f92672>*</span>Py_UNUSED(ignored))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list_copy_impl(self);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>list_copy_impl</span>(PyListObject <span style=color:#f92672>*</span>self)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list_slice(self, <span style=color:#ae81ff>0</span>, Py_SIZE(self));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>list_slice</span>(PyListObject <span style=color:#f92672>*</span>a, Py_ssize_t ilow, Py_ssize_t ihigh)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyListObject <span style=color:#f92672>*</span>np;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>**</span>src, <span style=color:#f92672>**</span>dest;
</span></span><span style=display:flex><span>    Py_ssize_t i, len;
</span></span><span style=display:flex><span>    len <span style=color:#f92672>=</span> ihigh <span style=color:#f92672>-</span> ilow;
</span></span><span style=display:flex><span>    np <span style=color:#f92672>=</span> (PyListObject <span style=color:#f92672>*</span>) list_new_prealloc(len);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (np <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    src <span style=color:#f92672>=</span> a<span style=color:#f92672>-&gt;</span>ob_item <span style=color:#f92672>+</span> ilow;
</span></span><span style=display:flex><span>    dest <span style=color:#f92672>=</span> np<span style=color:#f92672>-&gt;</span>ob_item;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> len; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        PyObject <span style=color:#f92672>*</span>v <span style=color:#f92672>=</span> src[i];
</span></span><span style=display:flex><span>        Py_INCREF(v);
</span></span><span style=display:flex><span>        dest[i] <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Py_SET_SIZE(np, len);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (PyObject <span style=color:#f92672>*</span>)np;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从 <code>PyListObject</code> 的定义中可以得知动态数组指针 <code>PyObject **ob_item</code> 所指向的动态数组中存储的是对象的指针，因此在 <code>list_slice</code> 函数中，也只是简单地将 <code>PyListObject *a</code> 中每一个 <code>PyObject</code> 的指针依次赋予 <code>PyListObject *np</code>，并将其引用计数加 1；对于被拷贝的 list 中的任意一个值得修改都会反映到拷贝到的 list 上：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>True</span>, [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>]]
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> a
</span></span><span style=display:flex><span>print(a, b)
</span></span><span style=display:flex><span>a[<span style=color:#ae81ff>0</span>], a[<span style=color:#ae81ff>1</span>], a[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>False</span>, [<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>print(a, b)
</span></span></code></pre></div><p>这里的 <code>b = a</code> 中在 C++ 中一般表示拷贝构造或拷贝赋值操作，但在 Python 中实际上则会调用 <code>list_copy</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ python3 main.py 
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1, True, <span style=color:#f92672>[</span>1, 2<span style=color:#f92672>]]</span> <span style=color:#f92672>[</span>1, True, <span style=color:#f92672>[</span>1, 2<span style=color:#f92672>]]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>0, False, <span style=color:#f92672>[</span>3, 4<span style=color:#f92672>]]</span> <span style=color:#f92672>[</span>0, False, <span style=color:#f92672>[</span>3, 4<span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>如果想要对一个 list 进行深拷贝，可以调用 <code>copy</code> 模块的 <code>deepcopy</code> 函数，这是一个用 Python 实现的模块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>deepcopy</span>(x, memo<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, _nil<span style=color:#f92672>=</span>[]):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Deep copy operation on arbitrary Python objects.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    See the module&#39;s __doc__ string for more info.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> memo <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        memo <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    d <span style=color:#f92672>=</span> id(x)
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> memo<span style=color:#f92672>.</span>get(d, _nil)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> y <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> _nil:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cls <span style=color:#f92672>=</span> type(x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    copier <span style=color:#f92672>=</span> _deepcopy_dispatch<span style=color:#f92672>.</span>get(cls)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> copier <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        y <span style=color:#f92672>=</span> copier(x, memo)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> issubclass(cls, type):
</span></span><span style=display:flex><span>            y <span style=color:#f92672>=</span> _deepcopy_atomic(x, memo)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            copier <span style=color:#f92672>=</span> getattr(x, <span style=color:#e6db74>&#34;__deepcopy__&#34;</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> copier <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                y <span style=color:#f92672>=</span> copier(memo)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>    	<span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># If is its own copy, don&#39;t memoize.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> y <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> x:
</span></span><span style=display:flex><span>        memo[d] <span style=color:#f92672>=</span> y
</span></span><span style=display:flex><span>        _keep_alive(x, memo) <span style=color:#75715e># Make sure x lives at least as long as d</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> y
</span></span></code></pre></div><p><code>deepcopy</code> 会通过 <code>_deepcopy_dispatch.get</code> 来获取内置容器的拷贝器，将内置容器中的数据依次递归地进行拷贝；为了防止某些容器存储的值当中包含指向自己的指针，或是无限重复的数据，函数中会使用一个 dict 变量 <code>memo</code> 来记录已经被拷贝过的数据，防止 <code>deepcopy</code> 无限地递归下去。</p><p>如果容器中存储的是自定义类型的对象，<code>deepcopy</code> 会通过 <code>copier = getattr(x, "__deepcopy__", None)</code> 获取到这个类型中的函数 <code>__deepcopy__</code>，并将其作为一个拷贝器用来生成新的对象，这也就意味着我们需要实现 <code>__deepcopy__</code> 函数来保证它可以被正确地深拷贝，以一个自定义的有向图结构为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> copy
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DirectedGraphNode</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, idx, node_list):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>idx <span style=color:#f92672>=</span> idx
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>node_list <span style=color:#f92672>=</span> node_list
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>point_to</span>(self, node):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>node_list<span style=color:#f92672>.</span>append(node)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __repr__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;id </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, idx </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, node_list </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(id(self), self<span style=color:#f92672>.</span>idx, [node<span style=color:#f92672>.</span>idx <span style=color:#66d9ef>for</span> node <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>node_list])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__deepcopy__</span>(self, memo):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;DirectedGraphNode: __deepcopy__ from </span><span style=color:#e6db74>{</span>repr(self)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self <span style=color:#f92672>in</span> memo:
</span></span><span style=display:flex><span>            exist_obj <span style=color:#f92672>=</span> memo<span style=color:#f92672>.</span>get(self)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> exist_obj
</span></span><span style=display:flex><span>        cp_obj <span style=color:#f92672>=</span> DirectedGraphNode(self<span style=color:#f92672>.</span>idx, [])
</span></span><span style=display:flex><span>        memo[self] <span style=color:#f92672>=</span> cp_obj
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> node <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>node_list:
</span></span><span style=display:flex><span>            cp_obj<span style=color:#f92672>.</span>point_to(copy<span style=color:#f92672>.</span>deepcopy(node, memo))
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;    copy done, self: </span><span style=color:#e6db74>{</span>repr(self)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cp_obj
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> DirectedGraphNode(<span style=color:#ae81ff>1</span>, [])
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> DirectedGraphNode(<span style=color:#ae81ff>2</span>, [])
</span></span><span style=display:flex><span>a<span style=color:#f92672>.</span>point_to(b)
</span></span><span style=display:flex><span>b<span style=color:#f92672>.</span>point_to(a)
</span></span><span style=display:flex><span>print(repr(a))
</span></span><span style=display:flex><span>print(repr(b))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> copy<span style=color:#f92672>.</span>deepcopy(a)
</span></span><span style=display:flex><span>print(repr(c))
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> node <span style=color:#f92672>in</span> c<span style=color:#f92672>.</span>node_list:
</span></span><span style=display:flex><span>    print(repr(node))
</span></span></code></pre></div><p>在它的 <code>__deepcopy__</code> 函数中，我们以其中一个节点出发，先构造出新的节点对象 <code>cp_obj</code>，再将它指向的所有节点以递归的方式依次进行深拷贝，如果在拷贝的过程中发现节点是已经被拷贝过的，则直接返回 <code>exist_obj</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ python3 main.py 
</span></span><span style=display:flex><span>id 139867268624336, idx 1, node_list <span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>id 139867268624240, idx 2, node_list <span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>DirectedGraphNode: __deepcopy__ from id 139867268624336, idx 1, node_list <span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>DirectedGraphNode: __deepcopy__ from id 139867268624240, idx 2, node_list <span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>DirectedGraphNode: __deepcopy__ from id 139867268624336, idx 1, node_list <span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    copy <span style=color:#66d9ef>done</span>, self: id 139867268624240, idx 2, node_list <span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    copy <span style=color:#66d9ef>done</span>, self: id 139867268624336, idx 1, node_list <span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>id 139867268624048, idx 1, node_list <span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>id 139867268623040, idx 2, node_list <span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/python/python-source-code-interpreter/><span class=title>« Prev</span><br><span>Python 源码学习（4）：编译器和虚拟机</span>
</a><a class=next href=https://prov1dence.top/posts/serialization/protocol-buffer/><span class=title>Next »</span><br><span>ProtoBuf 语法和编码原理入门</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>