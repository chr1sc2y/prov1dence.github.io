<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python 源码学习（1）：类型和对象 | ChrisChen - 尾張</title>
<meta name=keywords content><meta name=description content="Python 源码学习（1）：类型和对象
Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：
$ git clone https://github.com/python/cpython
$ tree -d -L 2 .
.
`-- cpython
    |-- Doc			# 文档
    |-- Grammar
    |-- Include 	# C 头文件
    |-- Lib			# 用 Python 写的库文件
    |-- Mac			# 用于在 macOS 上构建的文件
    |-- Misc		# 杂项
    |-- Modules		# 用 C 写的库文件
    |-- Objects 	# 核心类型，以及对象模型的定义
    |-- PC			# 用于在 Windows 上构建的文件
    |-- PCbuild 	# 用于在老版本的 Windows 上构建的文件
    |-- Parser		# Python 解析器源码
    |-- Programs	# Python 可执行文件和其他
    |-- Python		# CPython 编译器源码
    |-- Tools		# 构建时的工具
    `-- m4

16 directories
本系列主要以阅读和分析 CPython 源码的方式学习 Python。"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/python/source-code-1/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/python/source-code-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://prov1dence.top/posts/python/source-code-1/"><meta property="og:site_name" content="ChrisChen - 尾張"><meta property="og:title" content="Python 源码学习（1）：类型和对象"><meta property="og:description" content="Python 源码学习（1）：类型和对象 Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：
$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc	# 文档 |-- Grammar |-- Include # C 头文件 |-- Lib	# 用 Python 写的库文件 |-- Mac	# 用于在 macOS 上构建的文件 |-- Misc	# 杂项 |-- Modules	# 用 C 写的库文件 |-- Objects # 核心类型，以及对象模型的定义 |-- PC	# 用于在 Windows 上构建的文件 |-- PCbuild # 用于在老版本的 Windows 上构建的文件 |-- Parser	# Python 解析器源码 |-- Programs	# Python 可执行文件和其他 |-- Python	# CPython 编译器源码 |-- Tools	# 构建时的工具 `-- m4 16 directories 本系列主要以阅读和分析 CPython 源码的方式学习 Python。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-14T16:05:52+08:00"><meta property="article:modified_time" content="2021-03-14T16:05:52+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python 源码学习（1）：类型和对象"><meta name=twitter:description content="Python 源码学习（1）：类型和对象
Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：
$ git clone https://github.com/python/cpython
$ tree -d -L 2 .
.
`-- cpython
    |-- Doc			# 文档
    |-- Grammar
    |-- Include 	# C 头文件
    |-- Lib			# 用 Python 写的库文件
    |-- Mac			# 用于在 macOS 上构建的文件
    |-- Misc		# 杂项
    |-- Modules		# 用 C 写的库文件
    |-- Objects 	# 核心类型，以及对象模型的定义
    |-- PC			# 用于在 Windows 上构建的文件
    |-- PCbuild 	# 用于在老版本的 Windows 上构建的文件
    |-- Parser		# Python 解析器源码
    |-- Programs	# Python 可执行文件和其他
    |-- Python		# CPython 编译器源码
    |-- Tools		# 构建时的工具
    `-- m4

16 directories
本系列主要以阅读和分析 CPython 源码的方式学习 Python。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"Python 源码学习（1）：类型和对象","item":"https://prov1dence.top/posts/python/source-code-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 源码学习（1）：类型和对象","name":"Python 源码学习（1）：类型和对象","description":"Python 源码学习（1）：类型和对象 Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：\n$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc\t# 文档 |-- Grammar |-- Include # C 头文件 |-- Lib\t# 用 Python 写的库文件 |-- Mac\t# 用于在 macOS 上构建的文件 |-- Misc\t# 杂项 |-- Modules\t# 用 C 写的库文件 |-- Objects # 核心类型，以及对象模型的定义 |-- PC\t# 用于在 Windows 上构建的文件 |-- PCbuild # 用于在老版本的 Windows 上构建的文件 |-- Parser\t# Python 解析器源码 |-- Programs\t# Python 可执行文件和其他 |-- Python\t# CPython 编译器源码 |-- Tools\t# 构建时的工具 `-- m4 16 directories 本系列主要以阅读和分析 CPython 源码的方式学习 Python。\n","keywords":[],"articleBody":"Python 源码学习（1）：类型和对象 Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：\n$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc\t# 文档 |-- Grammar |-- Include # C 头文件 |-- Lib\t# 用 Python 写的库文件 |-- Mac\t# 用于在 macOS 上构建的文件 |-- Misc\t# 杂项 |-- Modules\t# 用 C 写的库文件 |-- Objects # 核心类型，以及对象模型的定义 |-- PC\t# 用于在 Windows 上构建的文件 |-- PCbuild # 用于在老版本的 Windows 上构建的文件 |-- Parser\t# Python 解析器源码 |-- Programs\t# Python 可执行文件和其他 |-- Python\t# CPython 编译器源码 |-- Tools\t# 构建时的工具 `-- m4 16 directories 本系列主要以阅读和分析 CPython 源码的方式学习 Python。\n1 对象模型 Python 是一门面向对象的语言，我们可以使用 Python 中的 type() 函数查看一个对象所属的类：\n\u003e\u003e\u003e type(1) ","wordCount":"1106","inLanguage":"en","datePublished":"2021-03-14T16:05:52+08:00","dateModified":"2021-03-14T16:05:52+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/python/source-code-1/"},"publisher":{"@type":"Organization","name":"ChrisChen - 尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="尾張 (Alt + H)">尾張</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Python 源码学习（1）：类型和对象</h1><div class=post-meta><span title='2021-03-14 16:05:52 +0800 +0800'>March 14, 2021</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#python-%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a01%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%af%b9%e8%b1%a1 aria-label="Python 源码学习（1）：类型和对象">Python 源码学习（1）：类型和对象</a><ul><li><a href=#1-%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b aria-label="1 对象模型">1 对象模型</a></li><li><a href=#2-%e6%a0%b8%e5%bf%83%e7%b1%bb%e5%9e%8b%e4%b8%8e%e5%af%b9%e8%b1%a1 aria-label="2 核心类型与对象">2 核心类型与对象</a><ul><li><a href=#21-%e5%af%b9%e8%b1%a1 aria-label="2.1 对象">2.1 对象</a><ul><li><a href=#pyobject aria-label=PyObject>PyObject</a></li><li><a href=#pyvarobject aria-label=PyVarObject>PyVarObject</a></li></ul></li><li><a href=#22-%e7%b1%bb%e5%9e%8b aria-label="2.2 类型">2.2 类型</a><ul><li><a href=#pytypeobject aria-label=PyTypeObject>PyTypeObject</a></li><li><a href=#pytype_type aria-label=PyType_Type>PyType_Type</a></li><li><a href=#pybaseobject_type aria-label=PyBaseObject_Type>PyBaseObject_Type</a></li></ul></li></ul></li><li><a href=#%e9%99%84%e5%bd%95 aria-label=附录>附录</a><ul><li><a href=#1-pytype_type-%e6%9e%84%e9%80%a0 aria-label="1 PyType_Type 构造">1 PyType_Type 构造</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=python-源码学习1类型和对象>Python 源码学习（1）：类型和对象<a hidden class=anchor aria-hidden=true href=#python-源码学习1类型和对象>#</a></h1><p>Python 是一门解释型，动态类型，多范式的编程语言，当我们从 <a href=https://www.python.org/>python.org</a> 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 <a href=https://github.com/python/cpython>CPython</a>，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ git clone https://github.com/python/cpython
</span></span><span style=display:flex><span>$ tree -d -L <span style=color:#ae81ff>2</span> .
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>-- cpython
</span></span><span style=display:flex><span>    |-- Doc			<span style=color:#75715e># 文档</span>
</span></span><span style=display:flex><span>    |-- Grammar
</span></span><span style=display:flex><span>    |-- Include 	<span style=color:#75715e># C 头文件</span>
</span></span><span style=display:flex><span>    |-- Lib			<span style=color:#75715e># 用 Python 写的库文件</span>
</span></span><span style=display:flex><span>    |-- Mac			<span style=color:#75715e># 用于在 macOS 上构建的文件</span>
</span></span><span style=display:flex><span>    |-- Misc		<span style=color:#75715e># 杂项</span>
</span></span><span style=display:flex><span>    |-- Modules		<span style=color:#75715e># 用 C 写的库文件</span>
</span></span><span style=display:flex><span>    |-- Objects 	<span style=color:#75715e># 核心类型，以及对象模型的定义</span>
</span></span><span style=display:flex><span>    |-- PC			<span style=color:#75715e># 用于在 Windows 上构建的文件</span>
</span></span><span style=display:flex><span>    |-- PCbuild 	<span style=color:#75715e># 用于在老版本的 Windows 上构建的文件</span>
</span></span><span style=display:flex><span>    |-- Parser		<span style=color:#75715e># Python 解析器源码</span>
</span></span><span style=display:flex><span>    |-- Programs	<span style=color:#75715e># Python 可执行文件和其他</span>
</span></span><span style=display:flex><span>    |-- Python		<span style=color:#75715e># CPython 编译器源码</span>
</span></span><span style=display:flex><span>    |-- Tools		<span style=color:#75715e># 构建时的工具</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>`</span>-- m4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>16</span> directories
</span></span></code></pre></div><p>本系列主要以阅读和分析 CPython 源码的方式学习 Python。</p><h2 id=1-对象模型>1 对象模型<a hidden class=anchor aria-hidden=true href=#1-对象模型>#</a></h2><p>Python 是一门面向对象的语言，我们可以使用 Python 中的 <code>type()</code> 函数查看一个对象所属的类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt;&gt;&gt; type<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>&lt;class <span style=color:#e6db74>&#39;int&#39;</span>&gt;
</span></span><span style=display:flex><span>&gt;&gt;&gt; type<span style=color:#f92672>(</span>True<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>&lt;class <span style=color:#e6db74>&#39;bool&#39;</span>&gt;
</span></span></code></pre></div><p>可以看到整数对象和布尔值对象的类型分别是 <code>&lt;class 'int'></code> 和 <code>&lt;class 'bool'></code>；</p><p>而实际上，在 Python 中无论是整数，布尔值还是基本数据类型，甚至自定义的 class，都是对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(type(int))
</span></span><span style=display:flex><span>print(type(Foo))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&lt;class <span style=color:#e6db74>&#39;type&#39;</span>&gt;
</span></span><span style=display:flex><span>&lt;class <span style=color:#e6db74>&#39;type&#39;</span>&gt;
</span></span></code></pre></div><p>可以看到 <code>int</code> 类型和自定义类 <code>Foo</code> 的类型都是 <code>&lt;class 'type'></code>，它们是 <code>type</code> 这个类的实例对象；<code>type</code> 类型是专门用于定义类型的类型，也称为<strong>元类型</strong>；实际上， <code>type</code> 这个类型本身也是一个对象，它所属的类也是 <code>type</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt;&gt;&gt; type<span style=color:#f92672>(</span>type<span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span>&lt;class <span style=color:#e6db74>&#39;type&#39;</span>&gt;
</span></span></code></pre></div><p>同时，Python 中的所有类型，无论是 <code>int</code>, <code>type</code>, 还是自定义类 <code>Foo</code> 都是继承自一个叫 <code>object</code> 的基类，而 <code>object</code> 则是继承链的终点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt;&gt;&gt; int.__base__
</span></span><span style=display:flex><span>&lt;class <span style=color:#e6db74>&#39;object&#39;</span>&gt;
</span></span><span style=display:flex><span>&gt;&gt;&gt; type.__base__
</span></span><span style=display:flex><span>&lt;class <span style=color:#e6db74>&#39;object&#39;</span>&gt;
</span></span><span style=display:flex><span>&gt;&gt;&gt; print<span style=color:#f92672>(</span>Foo.__base__<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>&lt;class <span style=color:#e6db74>&#39;object&#39;</span>&gt;
</span></span><span style=display:flex><span>&gt;&gt;&gt; print<span style=color:#f92672>(</span>object.__base__<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>None
</span></span></code></pre></div><p>而 <code>object</code> 基类也是一个 <code>type</code> 类型的对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt;&gt;&gt; type<span style=color:#f92672>(</span>object<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>&lt;class <span style=color:#e6db74>&#39;type&#39;</span>&gt;
</span></span></code></pre></div><p>上面的关系用图表达出来则是：</p><p><img alt=process loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/type-0.png></p><p>可以看到，所有类型的基类都是 <code>object</code>，所有类型的类型都是 <code>type</code>，这就是 Python 的<strong>对象模型</strong>（object model），也是 Objects/ 目录下源码所包含的内容。</p><h2 id=2-核心类型与对象>2 核心类型与对象<a hidden class=anchor aria-hidden=true href=#2-核心类型与对象>#</a></h2><p>虽然在 Python 的语法层面有非常多所谓的类型（包括 <code>int</code>, <code>type</code>, <code>Foo</code> 等），但实际上它们在源码（C 语言）层面上都是结构体对象。</p><h3 id=21-对象>2.1 对象<a hidden class=anchor aria-hidden=true href=#21-对象>#</a></h3><h4 id=pyobject>PyObject<a hidden class=anchor aria-hidden=true href=#pyobject>#</a></h4><p>Python 中所有的类型都由 <strong><code>PyObject</code></strong> 结构体扩展而来，这个结构体中有以下几个成员变量：</p><ol><li><code>Py_ssize_t ob_refcnt</code> 用于保存对象的<strong>引用计数</strong>；</li><li><code>PyTypeObject *ob_type</code> 指向对象的<strong>类型对象</strong>，用来标识对象属于的类型，并存储类型的<strong>元数据</strong>；</li><li><code>_PyObject_HEAD_EXTRA</code> 宏代表了两个 <code>PyObject*</code> 双向链表的指针，用于把堆上的所有对象链接起来，只会在开启了 <code>Py_TRACE_REFS</code> 宏的时候进行构造，方便调试；</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Include/object.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Define pointers to support a doubly-linked list of all live heap objects. */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _PyObject_HEAD_EXTRA            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    struct _object *_ob_next;           \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    struct _object *_ob_prev;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Nothing is actually declared to be a PyObject, but every pointer to
</span></span></span><span style=display:flex><span><span style=color:#75715e> * a Python object can be cast to a PyObject*.  This is inheritance built
</span></span></span><span style=display:flex><span><span style=color:#75715e> * by hand.  Similarly every pointer to a variable-size Python object can,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * in addition, be cast to PyVarObject*.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _object {
</span></span><span style=display:flex><span>    _PyObject_HEAD_EXTRA	<span style=color:#75715e>// 双向链表，用于追踪堆中所有对象，在开启了 Py_TRACE_REFS 宏的时候有用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Py_ssize_t ob_refcnt;	<span style=color:#75715e>// 引用计数，用于垃圾回收
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PyTypeObject <span style=color:#f92672>*</span>ob_type;	<span style=color:#75715e>// 指针，指向当前对象的类型对象，用于查询对象的类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} PyObject;
</span></span></code></pre></div><h4 id=pyvarobject>PyVarObject<a hidden class=anchor aria-hidden=true href=#pyvarobject>#</a></h4><p>Python 中有可以自由修改长度的 <code>PyVarObject</code> 变长对象，它由一个 <code>PyObject</code> 对象和一个存储变长部分的长度（元素个数）的变量 <code>ob_size</code> 组成：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    PyObject ob_base;
</span></span><span style=display:flex><span>    Py_ssize_t ob_size; <span style=color:#75715e>/* Number of items in variable part */</span>
</span></span><span style=display:flex><span>} PyVarObject;
</span></span></code></pre></div><p><code>PyObject</code> 和 <code>PyVarObject</code> 一般是作为头部被包含在一个变量结构体中的，根据该变量大小是否固定来选择使用哪一种：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Include/object.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* PyObject_HEAD defines the initial segment of every PyObject. */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PyObject_HEAD          PyObject ob_base;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* PyObject_VAR_HEAD defines the initial segment of all variable-size
</span></span></span><span style=display:flex><span><span style=color:#75715e> * container objects.  These end with a declaration of an array with 1
</span></span></span><span style=display:flex><span><span style=color:#75715e> * element, but enough space is malloc&#39;ed so that the array actually
</span></span></span><span style=display:flex><span><span style=color:#75715e> * has room for ob_size elements.  Note that ob_size is an element count,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * not necessarily a byte count.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PyObject_VAR_HEAD      PyVarObject ob_base;
</span></span></span></code></pre></div><p>Python 中最典型的变长对象就是列表 List，它和 <code>std::vector</code> 比较类似，列表对象里有三个成员变量，包括：</p><ul><li>基础的变长对象 <code>PyVarObject ob_base</code>，其中 <code>ob_base.ob_size</code> 用于表示列表当前的元素个数；</li><li>指向动态数组的指针 <code>PyObject **ob_item</code>；</li><li>动态数组当前的容量 <code>Py_ssize_t allocated</code>：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Inlucde/cpython/listobject.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    PyObject_VAR_HEAD
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>**</span>ob_item;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ob_item contains space for &#39;allocated&#39; elements.  The number
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * currently in use is ob_size.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Invariants:
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *     0 &lt;= ob_size &lt;= allocated
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *     len(list) == ob_size
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *     ob_item == NULL implies ob_size == allocated == 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * list.sort() temporarily sets allocated to -1 to detect mutations.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Items must normally not be NULL, except during construction when
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * the list is not yet visible outside the function that builds it.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    Py_ssize_t allocated;
</span></span><span style=display:flex><span>} PyListObject;
</span></span></code></pre></div><h3 id=22-类型>2.2 类型<a hidden class=anchor aria-hidden=true href=#22-类型>#</a></h3><h4 id=pytypeobject>PyTypeObject<a hidden class=anchor aria-hidden=true href=#pytypeobject>#</a></h4><p><code>PyObject</code> 类中的 <code>PyTypeObject *ob_type</code> 是一个指向<strong>对象类型</strong>的指针，它是<strong>类</strong>在 Python 中的表现形式；<code>PyTypeObject</code> 不仅决定了 <code>PyObject</code> 对象属于什么类型，还包含了非常多的<strong>元数据</strong>，例如：</p><ol><li><code>PyObject_VAR_HEAD</code> 表示 <code>PyTypeObject</code> 本身是一个<strong>变长对象</strong>；</li><li><code>const char *tp_name</code> 表示类型的名字；</li><li><code>struct _typeobject *tp_base</code> 是指向基类的指针，保存类型的继承信息；</li><li><code>Py_ssize_t tp_basicsize, tp_itemsize</code> 表示创建实力对象时分配的内存大小；</li><li><code>setattrfunc tp_setattr</code> 设置值，<code>getattrfunc tp_getattr</code> 获取值，<code>destructor tp_dealloc</code> 析构，<code>hashfunc tp_hash</code> 哈希等函数指针表示该类型所支持的标准操作；</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Include/object.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* PyTypeObject structure is defined in cpython/object.h.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   In Py_LIMITED_API, PyTypeObject is an opaque structure. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _typeobject PyTypeObject;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Include/cpython/object.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> _typeobject {
</span></span><span style=display:flex><span>    PyObject_VAR_HEAD <span style=color:#75715e>// 即 PyVarObject ob_base;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>tp_name; <span style=color:#75715e>/* For printing, in format &#34;&lt;module&gt;.&lt;name&gt;&#34; */</span>
</span></span><span style=display:flex><span>    Py_ssize_t tp_basicsize, tp_itemsize; <span style=color:#75715e>/* For allocation */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Methods to implement standard operations */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    destructor tp_dealloc;
</span></span><span style=display:flex><span>    Py_ssize_t tp_vectorcall_offset;
</span></span><span style=display:flex><span>    getattrfunc tp_getattr;
</span></span><span style=display:flex><span>    setattrfunc tp_setattr;
</span></span><span style=display:flex><span>    PyAsyncMethods <span style=color:#f92672>*</span>tp_as_async; <span style=color:#75715e>/* formerly known as tp_compare (Python 2)
</span></span></span><span style=display:flex><span><span style=color:#75715e>                                    or tp_reserved (Python 3) */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Strong reference on a heap type, borrowed reference on a static type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> _typeobject <span style=color:#f92672>*</span>tp_base;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* More standard operations (here for binary compatibility) */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>Python 中的每一种<strong>类型对象</strong>都是<strong>全局唯一</strong>的，他们在源码中以<strong>全局变量</strong>的形式存在，例如 <code>int</code> 类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/longobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PyTypeObject PyLong_Type <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;int&#34;</span>,                                      <span style=color:#75715e>/* tp_name */</span>
</span></span><span style=display:flex><span>    offsetof(PyLongObject, ob_digit),           <span style=color:#75715e>/* tp_basicsize */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sizeof</span>(digit),                              <span style=color:#75715e>/* tp_itemsize */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_dealloc */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_vectorcall_offset */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_getattr */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_setattr */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_async */</span>
</span></span><span style=display:flex><span>    long_to_decimal_string,                     <span style=color:#75715e>/* tp_repr */</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>long_as_number,                            <span style=color:#75715e>/* tp_as_number */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p><code>PyVarObject_HEAD_INIT</code> 宏用于初始化 <code>PyVarObject</code> 中的 <code>ob_refcnt</code>, <code>ob_type</code> 和 <code>ob_size</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define PyObject_HEAD_INIT(type)        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    { 1, type },
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PyVarObject_HEAD_INIT(type, size)       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    { PyObject_HEAD_INIT(type) size },
</span></span></span></code></pre></div><p>可以看到在 <code>PyLong_Type</code> 中，<code>ob_type</code> 被初始化为 <code>&amp;PyType_Type</code>，它是专门用于<strong>定义类型对象的类型</strong>，抑或叫做<strong>类型的类型</strong>或<strong>原类型</strong>。</p><h4 id=pytype_type>PyType_Type<a hidden class=anchor aria-hidden=true href=#pytype_type>#</a></h4><p>在前面已经了解到，<code>type</code> <strong>类型对象</strong>所属的类也是 <code>type</code>，那么<strong>类型对象</strong> <code>PyTypeObject</code> 本身也是一个类对象，它也拥有指向其<strong>类型对象</strong>的指针 <code>PyTypeObject *ob_type</code>；对于<strong>类型对象</strong>本身来说，它的<strong>类型对象</strong>都基于一个叫做 <code>PyType_Type</code>（即<strong>元类型</strong>）的 <code>PyTypeObject</code> 类对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/typeobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PyTypeObject PyType_Type <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)		<span style=color:#75715e>// PyType_Type 在初始化的时候将指向自身的指针传递并用于构造了一个 PyVarObject 类型的对象 ob_base，其中 ob_base-&gt;ob_type = &amp;PyType_Type，参考附录 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;type&#34;</span>,                                     <span style=color:#75715e>/* tp_name */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sizeof</span>(PyHeapTypeObject),                   <span style=color:#75715e>/* tp_basicsize */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sizeof</span>(PyMemberDef),                        <span style=color:#75715e>/* tp_itemsize */</span>
</span></span><span style=display:flex><span>    (destructor)type_dealloc,                   <span style=color:#75715e>/* tp_dealloc */</span>
</span></span><span style=display:flex><span>    offsetof(PyTypeObject, tp_vectorcall),      <span style=color:#75715e>/* tp_vectorcall_offset */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>Python 中<strong>类型对象</strong>都定义在了 Objects/ 目录下，例如 <code>bool</code> 类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/boolobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* The type object for bool.  Note that this cannot be subclassed! */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PyTypeObject PyBool_Type <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)		<span style=color:#75715e>// 同 PyType_Type，ob_base-&gt;ob_type = &amp;PyType_Type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;bool&#34;</span>,										<span style=color:#75715e>// tp_name = &#34;bool&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_longobject</span>),					<span style=color:#75715e>/* tp_basicsize */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,											<span style=color:#75715e>/* tp_itemsize */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_dealloc */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_vectorcall_offset */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_getattr */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_setattr */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_async */</span>
</span></span><span style=display:flex><span>    bool_repr,                                  <span style=color:#75715e>/* tp_repr */</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>bool_as_number,                            <span style=color:#75715e>/* tp_as_number */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_base */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>在 Python 中，无论是内建类型（<code>int</code>, <code>bool</code> 等），还是自定义类型（<code>Foo</code>），都是通过 <code>PyTypeObject</code> 这个结构体构造的，且一定满足 <code>ob_base->ob_type = &amp;PyType_Type</code>。</p><p>前文提到 <code>tp_base</code> 是指向基类的指针，保存类型的继承信息，但实际上在定义 <code>PyBool_Type</code> 的时候可以看到 <code>tp_base = 0</code>，实际上这个 <code>tp_base</code> 是在 <code>PyType_Ready</code> 函数中被赋值为 <code>PyBaseObject_Type</code> 的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/typeobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PyType_Ready</span>(PyTypeObject <span style=color:#f92672>*</span>type)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyTypeObject <span style=color:#f92672>*</span>base;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>/* Initialize tp_base (defaults to BaseObject unless that&#39;s us) */</span>
</span></span><span style=display:flex><span>    base <span style=color:#f92672>=</span> type<span style=color:#f92672>-&gt;</span>tp_base;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (base <span style=color:#f92672>==</span> NULL <span style=color:#f92672>&amp;&amp;</span> type <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>PyBaseObject_Type) {
</span></span><span style=display:flex><span>        base <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>PyBaseObject_Type;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (type<span style=color:#f92672>-&gt;</span>tp_flags <span style=color:#f92672>&amp;</span> Py_TPFLAGS_HEAPTYPE) {
</span></span><span style=display:flex><span>            type<span style=color:#f92672>-&gt;</span>tp_base <span style=color:#f92672>=</span> (PyTypeObject<span style=color:#f92672>*</span>)Py_NewRef((PyObject<span style=color:#f92672>*</span>)base);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            type<span style=color:#f92672>-&gt;</span>tp_base <span style=color:#f92672>=</span> base;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>这里 <code>PyTypeObject *base</code> 被赋值为的 <code>PyBaseObject_Type</code> 就是前文提到的<strong>基类型</strong>。</p><h4 id=pybaseobject_type>PyBaseObject_Type<a hidden class=anchor aria-hidden=true href=#pybaseobject_type>#</a></h4><p><code>PyBaseObject_Type</code> 定义在 typeobject.c 文件中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/typeobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PyTypeObject PyBaseObject_Type <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)		<span style=color:#75715e>// 同 PyType_Type，ob_base-&gt;ob_type = &amp;PyType_Type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;object&#34;</span>,                                   <span style=color:#75715e>/* tp_name */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sizeof</span>(PyObject),                           <span style=color:#75715e>/* tp_basicsize */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_itemsize */</span>
</span></span><span style=display:flex><span>    object_dealloc,                             <span style=color:#75715e>/* tp_dealloc */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    object_repr,                                <span style=color:#75715e>/* tp_repr */</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_base */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>可以看到无论是 <code>PyBool_Type</code>，<code>PyType_Type</code> 还是 <code>PyBaseObject_Type</code>，都有两个共同点：</p><ol><li>它们是以同样的方式 <code>PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</code> 定义其类型的，因此它们的类型都是 <code>PyTypeObject</code>；</li><li>它们指向基类的指针 <code>tp_base</code> 初始化时都是 NULL；</li></ol><p>不同的地方是，在使用 <code>PyType_Ready</code> 函数为它们的基类指针 <code>tp_base</code> 赋值时，只有 <code>PyBaseObject_Type.tp_base</code> 不会被赋值，其他的 <code>tp_base</code> 则都会被赋值为 <code>PyBaseObject_Type</code>，这也印证了 <code>PyBaseObject_Type</code> 是继承链的终点。</p><p>我们可以将上面的关系整理为一个图：</p><p><img alt=process loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/type-1.png></p><h2 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h2><h3 id=1-pytype_type-构造>1 PyType_Type 构造<a hidden class=anchor aria-hidden=true href=#1-pytype_type-构造>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Bar<span style=color:#f92672>*</span> p_b;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> ref_count;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Foo f;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Bar b
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Foo{ <span style=color:#f92672>&amp;</span>b, <span style=color:#ae81ff>1</span> },
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;ClassBar&#34;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, b.f.p_b<span style=color:#f92672>-&gt;</span>name);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./test
</span></span><span style=display:flex><span>ClassBar
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://prov1dence.top/posts/python/source-code-2/><span class=title>« Prev</span><br><span>Python 源码学习（2）：int 类型</span>
</a><a class=next href=https://prov1dence.top/posts/cpp/smart-pointer/smart-pointer/><span class=title>Next »</span><br><span>C++ 智能指针的简单实现</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>