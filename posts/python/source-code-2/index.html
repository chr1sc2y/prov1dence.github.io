<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python 源码学习（2）：int 类型 | 尾張</title><meta name=keywords content><meta name=description content="Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。
不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：
>>> x = 10000000000 >>> print(x) 10000000000 在 C 语言中会发生溢出：
printf(&#34;%d\n&#34;, 1000000 * 1000000); printf(&#34;%u\n&#34;, 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：
// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base; // Objects/longobject."><meta name=author content><link rel=canonical href=https://zintrulcre.vip/posts/python/source-code-2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zintrulcre.vip/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://zintrulcre.vip/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://zintrulcre.vip/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://zintrulcre.vip/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://zintrulcre.vip/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.111.3"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-132809676-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Python 源码学习（2）：int 类型"><meta property="og:description" content="Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。
不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：
>>> x = 10000000000 >>> print(x) 10000000000 在 C 语言中会发生溢出：
printf(&#34;%d\n&#34;, 1000000 * 1000000); printf(&#34;%u\n&#34;, 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：
// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base; // Objects/longobject."><meta property="og:type" content="article"><meta property="og:url" content="https://zintrulcre.vip/posts/python/source-code-2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-31T15:37:52+08:00"><meta property="article:modified_time" content="2021-03-31T15:37:52+08:00"><meta property="og:site_name" content="尾張"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python 源码学习（2）：int 类型"><meta name=twitter:description content="Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。
不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：
>>> x = 10000000000 >>> print(x) 10000000000 在 C 语言中会发生溢出：
printf(&#34;%d\n&#34;, 1000000 * 1000000); printf(&#34;%u\n&#34;, 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：
// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base; // Objects/longobject."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zintrulcre.vip/posts/"},{"@type":"ListItem","position":2,"name":"Python 源码学习（2）：int 类型","item":"https://zintrulcre.vip/posts/python/source-code-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 源码学习（2）：int 类型","name":"Python 源码学习（2）：int 类型","description":"Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。\n不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：\n\u0026gt;\u0026gt;\u0026gt; x = 10000000000 \u0026gt;\u0026gt;\u0026gt; print(x) 10000000000 在 C 语言中会发生溢出：\nprintf(\u0026#34;%d\\n\u0026#34;, 1000000 * 1000000); printf(\u0026#34;%u\\n\u0026#34;, 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：\n// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base; // Objects/longobject.","keywords":[],"articleBody":"Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。\n不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：\n\u003e\u003e\u003e x = 10000000000 \u003e\u003e\u003e print(x) 10000000000 在 C 语言中会发生溢出：\nprintf(\"%d\\n\", 1000000 * 1000000); printf(\"%u\\n\", 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：\n// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base; // Objects/longobject.h #if PYLONG_BITS_IN_DIGIT == 30 typedef uint32_t digit; // ... #elif PYLONG_BITS_IN_DIGIT == 15 typedef unsigned short digit; // ... #endif typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */ // Include/longintrepr.h struct _longobject { PyObject_VAR_HEAD digit ob_digit[1]; }; 它由两部分组成，分别是：\n一个变长对象 PyVarObject ob_base，其中包括引用计数 Py_ssize_t ob_refcnt、类型指针 PyTypeObject *ob_type、变长部分的长度 Py_ssize_t ob_size，表明 PyLongObject 也是一个变长对象；\n一个 digit 类型的数组 ob_digit ，用于存储整数值，数组长度默认为 1，在初始化时如果长度不够则会被扩大； digit 是一个被 PYLONG_BITS_IN_DIGIT 宏控制的类型，在编译 Python 解释器时可以通过修改这个宏来指定其类型；如果没有指定 PYLONG_BITS_IN_DIGIT 宏的值，则默认会根据操作系统的类型来决定，当指针占用 8 字节以上空间时（64 位以上操作系统），PYLONG_BITS_IN_DIGIT = 30，digit 即为 uint32_t，否则 PYLONG_BITS_IN_DIGIT = 15，digit 则是 unsigned short：\n#ifndef PYLONG_BITS_IN_DIGIT #if SIZEOF_VOID_P \u003e= 8 #define PYLONG_BITS_IN_DIGIT 30 #else #define PYLONG_BITS_IN_DIGIT 15 #endif #endif\n`PyLongObject` 的内存结构大致如图： ![PyLongObject](https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/PyLongObject.png) ### 1.2 数据表示 在 `ob_digit` 数组中，数据的表示遵循两个原则： 1. `ob_size` 的绝对值表示 `ob_digit` 数组的长度，`ob_size = 0` 表示 `PyLongObject` 的数值等于 0；数据的正负由 `ob_size` 的正负来标识，`ob_size \u003e 0` 表示 `PyLongObject \u003e 0`，`ob_size \u003c 0` 表示 `PyLongObject \u003c 0`； 2. `ob_digit` 数组的每一个元素都是一个最大为 `2^30`（假设 `PYLONG_BITS_IN_DIGIT == 30`）的整数，如果整数超过了这个值，则会清零并使其后一位自增 1，假设 `ob_size = n`，那么数据的绝对值则等于 `ob_digit[0] + ob_digit[1] * 2^30 + ob_digit[2] * 2^60 + ... + ob_digit[n-1] * 2^(30 * (n-1))`； 例如对于整数 4294967297，可以被表示为 `1 + 4 * 2^30`，因此其 `ob_size = 2`, `ob_digit[0] = 1`, `ob_digit[1] = 4`，其内存结构大致如图： ![PyLongObject-1](https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/PyLongObject-1.png) 通过这种大数存储方式，Python 从语言层面解决了 `2^(30*2147483648) - 1` 以下（`ob_size` 的类型 `Py_ssize_t` 是通过 `typedef long int Py_ssize_t` 定义的）的大数的溢出问题。 ### 1.3 创建对象 在 Python 中， `PyLongObject` 对象一般是通过 `_PyLong_New` 函数创建出来的： ```cpp /* Allocate a new int object with size digits. Return NULL and set exception if we run out of memory. */ #define MAX_LONG_DIGITS \\ ((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/sizeof(digit)) PyLongObject * _PyLong_New(Py_ssize_t size) { PyLongObject *result; /* Number of bytes needed is: offsetof(PyLongObject, ob_digit) + sizeof(digit)*size. Previous incarnations of this code used sizeof(PyVarObject) instead of the offsetof, but this risks being incorrect in the presence of padding between the PyVarObject header and the digits. */ if (size \u003e (Py_ssize_t)MAX_LONG_DIGITS) { PyErr_SetString(PyExc_OverflowError, \"too many digits in integer\"); return NULL; } result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) + size*sizeof(digit)); if (!result) { PyErr_NoMemory(); return NULL; } _PyObject_InitVar((PyVarObject*)result, \u0026PyLong_Type, size); return result; } 这个函数非常简单，主要是做了两件事：\n内存分配前后的检查，包括参数 size 不能超过 MAX_LONG_DIGITS，也就是说 PyLongObject 所表示的整数大小不能超过 2^(30*2147483648) - 1，以及生成使用 malloc 分配内存失败后的报错信息； 为 PyLongObject 对象申请内存，其大小分为两部分，第一部分是 PyVarObject 在内存对齐后所占用的空间，即 offsetof(PyLongObject, ob_digit)；第二部分是 ob_digit 数组所占用的空间，其中参数 size 是 ob_digit 数组的长度。 1.4 数据转化 每一个 PyLongObject 对象都拥有不同的内存地址，我们可以通过 Python 中的 id 函数来查看一个变量的标识，这个标识会因内存地址的不同而改变：\nfor i in range(5): print(id(i)) $ python3 main.py 139748219328384 139748219328416 139748219328448 139748219328480 139748219328512 可以看出 0 到 4 这 5 个数的标识里每两个都相差了 32，刚好符合每一个 PyLongObject 对象所占用的空间 32 字节，而不是 C 语言里一个 long 类型变量通常所占用的 4 字节或 8 字节，这是因为所有原始的数据都会被转化为 PyLongObject 对象。\n数据转化的方法有很多，以 PyLong_FromLong 为例，它会将一个 long 类型的整数转化为 PyLongObject 对象：\n// Objects/longobject.c /* interpreter state */ #define _PY_NSMALLPOSINTS 257 #define _PY_NSMALLNEGINTS 5 #define NSMALLNEGINTS _PY_NSMALLNEGINTS #define NSMALLPOSINTS _PY_NSMALLPOSINTS #define IS_SMALL_INT(ival) (-NSMALLNEGINTS \u003c= (ival) \u0026\u0026 (ival) \u003c NSMALLPOSINTS) PyObject * PyLong_FromLong(long ival) { PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so \u003e\u003e doesn't propagate sign bit */ int ndigits = 0; int sign; if (IS_SMALL_INT(ival)) { return get_small_int((sdigit)ival); } if (ival \u003c 0) { /* negate: can't write this as abs_ival = -ival since that invokes undefined behaviour when ival is LONG_MIN */ abs_ival = 0U-(unsigned long)ival; sign = -1; } else { abs_ival = (unsigned long)ival; sign = ival == 0 ? 0 : 1; } /* Fast path for single-digit ints */ if (!(abs_ival \u003e\u003e PyLong_SHIFT)) { v = _PyLong_New(1); if (v) { Py_SET_SIZE(v, sign); v-\u003eob_digit[0] = Py_SAFE_DOWNCAST( abs_ival, unsigned long, digit); } return (PyObject*)v; } #if PyLong_SHIFT==15 /* 2 digits */ if (!(abs_ival \u003e\u003e 2*PyLong_SHIFT)) { v = _PyLong_New(2); if (v) { Py_SET_SIZE(v, 2 * sign); v-\u003eob_digit[0] = Py_SAFE_DOWNCAST( abs_ival \u0026 PyLong_MASK, unsigned long, digit); v-\u003eob_digit[1] = Py_SAFE_DOWNCAST( abs_ival \u003e\u003e PyLong_SHIFT, unsigned long, digit); } return (PyObject*)v; } #endif /* Larger numbers: loop to determine number of digits */ t = abs_ival; while (t) { ++ndigits; t \u003e\u003e= PyLong_SHIFT; } v = _PyLong_New(ndigits); if (v != NULL) { digit *p = v-\u003eob_digit; Py_SET_SIZE(v, ndigits * sign); t = abs_ival; while (t) { *p++ = Py_SAFE_DOWNCAST( t \u0026 PyLong_MASK, unsigned long, digit); t \u003e\u003e= PyLong_SHIFT; } } return (PyObject *)v; } 虽然看起来比较长，但其实思路非常简单：\n创建用于存储返回值的指针 PyLongObject *z，保存数据绝对值的变量 unsigned long abs_ival, t，标识数组长度的 int ndigits 和标识数据正负的 int sign； 如果数据范围在 [-5, 257) 内，则通过 get_small_int 函数返回结果； 获取数据的绝对值和正负符号； 如果数据绝对值没有超过 ob_digit 数组的单个元素所能表示的大小，则通过一个快速路径返回结果； 对于较大的数据，确定其 ob_digit 数组的长度，逐位置入。 可以注意到，第 2 步针对 [-5, 257) 区间内的小整数做了特殊处理，最终在调用到 __PyLong_GetSmallInt_internal 函数时，会通过 tstate-\u003einterp-\u003esmall_ints[index] 缓存数组获取小整数对应的指针对象并将其返回，这里的 small_ints 数组是一个全局变量，一般称为小整数对象池，是针对常用的小整数做的一个优化：\n// Objects/longobject.c static inline PyObject* __PyLong_GetSmallInt_internal(int value) { PyThreadState *tstate = _PyThreadState_GET(); #ifdef Py_DEBUG _Py_EnsureTstateNotNULL(tstate); #endif assert(-_PY_NSMALLNEGINTS \u003c= value \u0026\u0026 value \u003c _PY_NSMALLPOSINTS); size_t index = _PY_NSMALLNEGINTS + value; PyObject *obj = (PyObject*)tstate-\u003einterp-\u003esmall_ints[index]; // _PyLong_GetZero() and _PyLong_GetOne() must not be called // before _PyLong_Init() nor after _PyLong_Fini() assert(obj != NULL); return obj; } 2 数学运算 PyLongObject 的类型对象是 PyLong_Type，PyLong_Type 的成员变量 PyNumberMethods *tp_as_number 由 static PyNumberMethods long_as_number* 结构体指针初始化，其中包含了许多数学运算的函数指针，当我们对 PyLong_Type 进行数学运算时，实际上会调用这些函数：\n// Objects/longobject.c PyTypeObject PyLong_Type = { // ... \u0026long_as_number, /* tp_as_number */ // ... }; static PyNumberMethods long_as_number = { (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ long_mod, /*nb_remainder*/ long_divmod, /*nb_divmod*/ long_pow, /*nb_power*/ // ... }; 2.1 加法 PyLong_Type 的加法运算对应的函数是 long_add，其实现和相关的宏定义如下：\n// Objects/longobject.c #define CHECK_BINOP(v,w) \\ do { \\ if (!PyLong_Check(v) || !PyLong_Check(w)) \\ Py_RETURN_NOTIMPLEMENTED; \\ } while(0) /* convert a PyLong of size 1, 0 or -1 to an sdigit */ #define MEDIUM_VALUE(x) (assert(-1 \u003c= Py_SIZE(x) \u0026\u0026 Py_SIZE(x) \u003c= 1), \\ Py_SIZE(x) \u003c 0 ? -(sdigit)(x)-\u003eob_digit[0] : \\ (Py_SIZE(x) == 0 ? (sdigit)0 : \\ (sdigit)(x)-\u003eob_digit[0])) static PyObject * long_add(PyLongObject *a, PyLongObject *b) { PyLongObject *z; CHECK_BINOP(a, b); if (Py_ABS(Py_SIZE(a)) \u003c= 1 \u0026\u0026 Py_ABS(Py_SIZE(b)) \u003c= 1) { return PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b)); } if (Py_SIZE(a) \u003c 0) { if (Py_SIZE(b) \u003c 0) { z = x_add(a, b); if (z != NULL) { /* x_add received at least one multiple-digit int, and thus z must be a multiple-digit int. That also means z is not an element of small_ints, so negating it in-place is safe. */ assert(Py_REFCNT(z) == 1); Py_SET_SIZE(z, -(Py_SIZE(z))); } } else z = x_sub(b, a); } else { if (Py_SIZE(b) \u003c 0) z = x_sub(a, b); else z = x_add(a, b); } return (PyObject *)z; } 可以看到它的实现非常简单，主要分为以下几个步骤：\n创建一个用于存储返回值的指针 PyLongObject *z； 检查两个参数是否都是 PyLongObject 类型的指针 CHECK_BINOP(a, b)； 如果两个参数都满足 ob_size \u003c= 1（即绝对值均小于 2^30），那么先通过 MEDIUM_VALUE 获取两个 ob_digit[0] 的值，并将两数直接相加（一定不会溢出），再通过 PyLong_FromLong 将这个数包装为一个 PyLongObject 指针并返回；通常我们进行运算的数都不会太大，因此这里可以利用简化的运算步骤和 CPU 分支预测来提高效率； 判断两者的正负关系，将问题简化为绝对值加减法，利用辅助函数 x_add 和 x_sub 进行运算并返回结果。 2.2 绝对值加法 绝对值加法函数 x_add 的定义如下：\n#if PYLONG_BITS_IN_DIGIT == 30 #define PyLong_SHIFT 30 // ... #endif #define PyLong_BASE ((digit)1 \u003c\u003c PyLong_SHIFT) #define PyLong_MASK ((digit)(PyLong_BASE - 1)) /* Add the absolute values of two integers. */ static PyLongObject * x_add(PyLongObject *a, PyLongObject *b) { Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b)); PyLongObject *z; Py_ssize_t i; digit carry = 0; /* Ensure a is the larger of the two: */ if (size_a \u003c size_b) { { PyLongObject *temp = a; a = b; b = temp; } { Py_ssize_t size_temp = size_a; size_a = size_b; size_b = size_temp; } } z = _PyLong_New(size_a+1); if (z == NULL) return NULL; for (i = 0; i \u003c size_b; ++i) { carry += a-\u003eob_digit[i] + b-\u003eob_digit[i]; z-\u003eob_digit[i] = carry \u0026 PyLong_MASK; carry \u003e\u003e= PyLong_SHIFT; } for (; i \u003c size_a; ++i) { carry += a-\u003eob_digit[i]; z-\u003eob_digit[i] = carry \u0026 PyLong_MASK; carry \u003e\u003e= PyLong_SHIFT; } z-\u003eob_digit[i] = carry; return long_normalize(z); } 其步骤大致分为以下几步：\n获取两个参数的 ob_size 的绝对值，创建存储返回值的指针 PyLongObject *z， 如果 a-\u003eob_size \u003c b-\u003eob_size 则交换两者，保证 a 的值较大； 将 z 的 ob_size 设置为 size_a + 1，保证不会溢出； 以 i = 0 为下标，从小到大依次对两数的每一位进行相加操作，将没有超过 2^30 的部分存储在 z-\u003eob_digit[i] 中，超过的部分进位保存在 carry 中；这里充分利用了两个小于 2^30 的数相加不会溢出的特性；如果 size_a \u003e size_b 还需要将 a-\u003eob_digit 多余的部分按照相同的方法置入 z-\u003eob_digit里； 得到的结果 z 中，其 ob_digit 的最后一个元素可能等于 0，因此通过 long_normalize 函数将其转换为符合 PyLongObject 定义的格式返回。 整个过程可以抽象为类似 2^30 进制的加法，和十进制加法的过程几乎完全一样，只不过是把十进制每一位的数字换成了一个最大值为 2^30 的数字，每逢 2^30 进一位；举个例，假设有 a-\u003eob_digit = {4, 5, 6}, b-\u003eob_digit = {1073741823, 1073741823}，那么整个加法的步骤为：\nv-\u003eob_digit[0] = (4 + 1073741823) % 1073741824 = 3, carry = 1； v-\u003eob_digit[1] = (5 + 1073741823 + 1) % 1073741824 = 5, carry = 1； v-\u003eob_digit[2] = (6 + 1) % 1073741824 = 7, carry = 0； v-\u003eob_digit[3] = 0； 结果即 v-\u003eob_digit = {3, 5, 7, 0}，最后一个元素 0 需要通过 long_normalize 函数去掉。\n2.3 绝对值减法 绝对值减法的实现如下：\n/* Subtract the absolute values of two integers. */ static PyLongObject * x_sub(PyLongObject *a, PyLongObject *b) { Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b)); PyLongObject *z; Py_ssize_t i; int sign = 1; digit borrow = 0; /* Ensure a is the larger of the two: */ if (size_a \u003c size_b) { sign = -1; { PyLongObject *temp = a; a = b; b = temp; } { Py_ssize_t size_temp = size_a; size_a = size_b; size_b = size_temp; } } else if (size_a == size_b) { /* Find highest digit where a and b differ: */ i = size_a; while (--i \u003e= 0 \u0026\u0026 a-\u003eob_digit[i] == b-\u003eob_digit[i]) ; if (i \u003c 0) return (PyLongObject *)PyLong_FromLong(0); if (a-\u003eob_digit[i] \u003c b-\u003eob_digit[i]) { sign = -1; { PyLongObject *temp = a; a = b; b = temp; } } size_a = size_b = i+1; } z = _PyLong_New(size_a); if (z == NULL) return NULL; for (i = 0; i \u003c size_b; ++i) { /* The following assumes unsigned arithmetic works module 2**N for some N\u003ePyLong_SHIFT. */ borrow = a-\u003eob_digit[i] - b-\u003eob_digit[i] - borrow; z-\u003eob_digit[i] = borrow \u0026 PyLong_MASK; borrow \u003e\u003e= PyLong_SHIFT; borrow \u0026= 1; /* Keep only one sign bit */ } for (; i \u003c size_a; ++i) { borrow = a-\u003eob_digit[i] - borrow; z-\u003eob_digit[i] = borrow \u0026 PyLong_MASK; borrow \u003e\u003e= PyLong_SHIFT; borrow \u0026= 1; /* Keep only one sign bit */ } assert(borrow == 0); if (sign \u003c 0) { Py_SET_SIZE(z, -Py_SIZE(z)); } return maybe_small_long(long_normalize(z)); } 其步骤和绝对值加法类似，大致分为以下几步：\n获取两个参数的 ob_size 的绝对值，创建存储返回值的指针 PyLongObject *z， 如果 a-\u003eob_size \u003c b-\u003eob_size 则交换两者，保证 a 的值较大，并用 sign 记录运算结果为负；如果 a-\u003eob_size == b-\u003eob_size 则从最高位依次往低位找到第一次出现 a-\u003eob_digit[i] != b-\u003eob_digit[i] 的位置，比较 a-\u003eob_digit[i] 和 b-\u003eob_digit[i]，并决定是否交换两者以及 sign 的值； 将 z 的 ob_size 设置为 size_a； 以 i = 0 为下标，从小到大依次对两数的每一位进行相减操作，如果被减数 a-\u003eob_digit[i] 小于减数 b-\u003eob_digit[i] 则要向高位 a-\u003eob_digit[i + 1] 借 1；在十进制的减法中向高位借到的数是 10，这里向 digit 数组的高位借到的则是 2^30；但 digit 是通过 typedef uint32_t digit 定义出来，通过公式 borrow = a-\u003eob_digit[i] - b-\u003eob_digit[i] - borrow 实际上得到的是 2^32 + a-\u003eob_digit[i] - b-\u003eob_digit[i]，所以还需要与 PyLong_MASK 做 \u0026 操作，取后 30 位，便能得到借位相减后的结果，再将结果存储在 z-\u003eob_digit[i] 中；借位部分 borrow 向右位移 30 位后还剩 2 位，只需要将其与 1 进行 \u0026 操作即可知道此次减法运算是否有借位；如果 size_a \u003e size_b 还需要将 a-\u003eob_digit 多余的部分按照相同的方法置入 z-\u003eob_digit里； 得到的结果 z 中，其 ob_digit 的最后一个元素可能等于 0，因此通过 long_normalize 函数将其转换为符合 PyLongObject 定义的格式返回。 可以看到这里的步骤也跟十进制减法几乎完全相同，都跟 NOIP 入门的大数加减法加法思路相同。\n","wordCount":"1668","inLanguage":"en","datePublished":"2021-03-31T15:37:52+08:00","dateModified":"2021-03-31T15:37:52+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zintrulcre.vip/posts/python/source-code-2/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"https://zintrulcre.vip/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zintrulcre.vip/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zintrulcre.vip/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://zintrulcre.vip/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zintrulcre.vip/>Home</a>&nbsp;»&nbsp;<a href=https://zintrulcre.vip/posts/>Posts</a></div><h1 class=post-title>Python 源码学习（2）：int 类型</h1><div class=post-meta><span title='2021-03-31 15:37:52 +0800 CST'>March 31, 2021</span>&nbsp;·&nbsp;8 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#python-%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a02int-%e7%b1%bb%e5%9e%8b aria-label="Python 源码学习（2）：int 类型">Python 源码学习（2）：int 类型</a><ul><li><a href=#1-int-%e7%b1%bb%e5%9e%8b%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e5%ad%98%e5%82%a8%e6%96%b9%e5%bc%8f aria-label="1 int 类型在内存中的存储方式">1 int 类型在内存中的存储方式</a><ul><li><a href=#11-%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84 aria-label="1.1 内存结构">1.1 内存结构</a></li><li><a href=#14-%e6%95%b0%e6%8d%ae%e8%bd%ac%e5%8c%96 aria-label="1.4 数据转化">1.4 数据转化</a></li></ul></li><li><a href=#2-%e6%95%b0%e5%ad%a6%e8%bf%90%e7%ae%97 aria-label="2 数学运算">2 数学运算</a><ul><li><a href=#21-%e5%8a%a0%e6%b3%95 aria-label="2.1 加法">2.1 加法</a></li><li><a href=#22-%e7%bb%9d%e5%af%b9%e5%80%bc%e5%8a%a0%e6%b3%95 aria-label="2.2 绝对值加法">2.2 绝对值加法</a></li><li><a href=#23-%e7%bb%9d%e5%af%b9%e5%80%bc%e5%87%8f%e6%b3%95 aria-label="2.3 绝对值减法">2.3 绝对值减法</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=python-源码学习2int-类型>Python 源码学习（2）：int 类型<a hidden class=anchor aria-hidden=true href=#python-源码学习2int-类型>#</a></h1><p>Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 <code>PyBaseObject_Type</code> 类型的 <code>PyType_Type</code> 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。</p><p>不同于 C 和 C++ 中的 <code>int</code> 类型，Python 中的 <code>int</code> 类型最大的特点是它一般是<strong>不会溢出</strong>的，对比用 C 和 Python 分别输出两个一百万相乘的结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000000000</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(x)
</span></span><span style=display:flex><span><span style=color:#ae81ff>10000000000</span>
</span></span></code></pre></div><p>在 C 语言中会发生溢出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>1000000</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000000</span>);
</span></span><span style=display:flex><span>printf(<span style=color:#e6db74>&#34;%u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>1000000</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000000</span>);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>-727379968
</span></span><span style=display:flex><span><span style=color:#ae81ff>3567587328</span>
</span></span></code></pre></div><h2 id=1-int-类型在内存中的存储方式>1 int 类型在内存中的存储方式<a hidden class=anchor aria-hidden=true href=#1-int-类型在内存中的存储方式>#</a></h2><h3 id=11-内存结构>1.1 内存结构<a hidden class=anchor aria-hidden=true href=#11-内存结构>#</a></h3><p>Python 中的 <code>int</code> 整数类型实际上是一个名为 <code>PyLongObject</code> 的结构体，定义在 <code>longintrepr.h</code> 文件中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Include/object.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define PyObject_VAR_HEAD      PyVarObject ob_base;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Objects/longobject.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#if PYLONG_BITS_IN_DIGIT == 30
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>uint32_t</span> digit;
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#elif PYLONG_BITS_IN_DIGIT == 15
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> digit;
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_longobject</span> PyLongObject; <span style=color:#75715e>/* Revealed in longintrepr.h */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Include/longintrepr.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_longobject</span> {
</span></span><span style=display:flex><span>    PyObject_VAR_HEAD
</span></span><span style=display:flex><span>    digit ob_digit[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>它由两部分组成，分别是：</p><ol><li><p>一个变长对象 <code>PyVarObject ob_base</code>，其中包括引用计数 <code>Py_ssize_t ob_refcnt</code>、类型指针 <code>PyTypeObject *ob_type</code>、变长部分的长度 <code>Py_ssize_t ob_size</code>，表明 <code>PyLongObject</code> 也是一个<strong>变长对象</strong>；</p></li><li><p>一个 <code>digit</code> 类型的数组 <code>ob_digit</code> ，用于存储整数值，数组长度默认为 1，在初始化时如果长度不够则会被扩大； <code>digit</code> 是一个被 <code>PYLONG_BITS_IN_DIGIT</code> 宏控制的类型，在编译 Python 解释器时可以通过修改这个宏来指定其类型；如果没有指定 <code>PYLONG_BITS_IN_DIGIT</code> 宏的值，则默认会根据操作系统的类型来决定，当指针占用 8 字节以上空间时（64 位以上操作系统），<code>PYLONG_BITS_IN_DIGIT = 30</code>，<code>digit</code> 即为 <code>uint32_t</code>，否则 <code>PYLONG_BITS_IN_DIGIT = 15</code>，<code>digit</code> 则是 <code>unsigned short</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp></code></pre></div></li></ol><p>#ifndef PYLONG_BITS_IN_DIGIT
#if SIZEOF_VOID_P >= 8
#define PYLONG_BITS_IN_DIGIT 30
#else
#define PYLONG_BITS_IN_DIGIT 15
#endif
#endif</p><pre tabindex=0><code>
`PyLongObject` 的内存结构大致如图：

![PyLongObject](https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/PyLongObject.png)

### 1.2 数据表示

在 `ob_digit` 数组中，数据的表示遵循两个原则：

1. `ob_size` 的绝对值表示 `ob_digit` 数组的长度，`ob_size = 0` 表示 `PyLongObject` 的数值等于 0；数据的正负由 `ob_size` 的正负来标识，`ob_size &gt; 0` 表示 `PyLongObject &gt; 0`，`ob_size &lt; 0` 表示 `PyLongObject &lt; 0`；
2. `ob_digit` 数组的每一个元素都是一个最大为 `2^30`（假设 `PYLONG_BITS_IN_DIGIT == 30`）的整数，如果整数超过了这个值，则会清零并使其后一位自增 1，假设 `ob_size = n`，那么数据的绝对值则等于 `ob_digit[0] + ob_digit[1] * 2^30 + ob_digit[2] * 2^60 + ... + ob_digit[n-1] * 2^(30 * (n-1))`；

例如对于整数 4294967297，可以被表示为 `1 + 4 * 2^30`，因此其 `ob_size = 2`, `ob_digit[0] = 1`, `ob_digit[1] = 4`，其内存结构大致如图：

![PyLongObject-1](https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/PyLongObject-1.png)

通过这种大数存储方式，Python 从语言层面解决了 `2^(30*2147483648) - 1` 以下（`ob_size` 的类型 `Py_ssize_t` 是通过 `typedef long int Py_ssize_t` 定义的）的大数的溢出问题。

### 1.3 创建对象

在 Python 中， `PyLongObject` 对象一般是通过 `_PyLong_New` 函数创建出来的：

```cpp
/* Allocate a new int object with size digits.
Return NULL and set exception if we run out of memory. */

#define MAX_LONG_DIGITS \
 ((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/sizeof(digit))

PyLongObject *
_PyLong_New(Py_ssize_t size)
{
 PyLongObject *result;
 /* Number of bytes needed is: offsetof(PyLongObject, ob_digit) +
    sizeof(digit)*size.  Previous incarnations of this code used
    sizeof(PyVarObject) instead of the offsetof, but this risks being
    incorrect in the presence of padding between the PyVarObject header
    and the digits. */
 if (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) {
     PyErr_SetString(PyExc_OverflowError,
                     &#34;too many digits in integer&#34;);
     return NULL;
 }
 result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) +
                          size*sizeof(digit));
 if (!result) {
     PyErr_NoMemory();
     return NULL;
 }
 _PyObject_InitVar((PyVarObject*)result, &amp;PyLong_Type, size);
 return result;
}
</code></pre><p>这个函数非常简单，主要是做了两件事：</p><ol><li>内存分配前后的检查，包括参数 <code>size</code> 不能超过 <code>MAX_LONG_DIGITS</code>，也就是说 <code>PyLongObject</code> 所表示的整数大小不能超过 <code>2^(30*2147483648) - 1</code>，以及生成使用 <code>malloc</code> 分配内存失败后的报错信息；</li><li>为 <code>PyLongObject</code> 对象申请内存，其大小分为两部分，第一部分是 <code>PyVarObject</code> 在内存对齐后所占用的空间，即 <code>offsetof(PyLongObject, ob_digit)</code>；第二部分是 <code>ob_digit</code> 数组所占用的空间，其中参数 <code>size</code> 是 <code>ob_digit</code> 数组的长度。</li></ol><h3 id=14-数据转化>1.4 数据转化<a hidden class=anchor aria-hidden=true href=#14-数据转化>#</a></h3><p>每一个 <code>PyLongObject</code> 对象都拥有不同的内存地址，我们可以通过 Python 中的 <code>id</code> 函数来查看一个变量的标识，这个标识会因内存地址的不同而改变：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>	print(id(i))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ python3 main.py 
</span></span><span style=display:flex><span><span style=color:#ae81ff>139748219328384</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>139748219328416</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>139748219328448</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>139748219328480</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>139748219328512</span>
</span></span></code></pre></div><p>可以看出 0 到 4 这 5 个数的标识里每两个都相差了 32，刚好符合每一个 <code>PyLongObject</code> 对象所占用的空间 32 字节，而不是 C 语言里一个 <code>long</code> 类型变量通常所占用的 4 字节或 8 字节，这是因为所有原始的数据都会被转化为 <code>PyLongObject</code> 对象。</p><p>数据转化的方法有很多，以 <code>PyLong_FromLong</code> 为例，它会将一个 <code>long</code> 类型的整数转化为 <code>PyLongObject</code> 对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/longobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* interpreter state */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _PY_NSMALLPOSINTS           257
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define _PY_NSMALLNEGINTS           5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NSMALLNEGINTS           _PY_NSMALLNEGINTS
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NSMALLPOSINTS           _PY_NSMALLPOSINTS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define IS_SMALL_INT(ival) (-NSMALLNEGINTS &lt;= (ival) &amp;&amp; (ival) &lt; NSMALLPOSINTS)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PyLong_FromLong</span>(<span style=color:#66d9ef>long</span> ival)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyLongObject <span style=color:#f92672>*</span>v;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> abs_ival;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> t;  <span style=color:#75715e>/* unsigned so &gt;&gt; doesn&#39;t propagate sign bit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ndigits <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sign;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (IS_SMALL_INT(ival)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> get_small_int((sdigit)ival);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ival <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* negate: can&#39;t write this as abs_ival = -ival since that
</span></span></span><span style=display:flex><span><span style=color:#75715e>           invokes undefined behaviour when ival is LONG_MIN */</span>
</span></span><span style=display:flex><span>        abs_ival <span style=color:#f92672>=</span> <span style=color:#ae81ff>0U</span><span style=color:#f92672>-</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)ival;
</span></span><span style=display:flex><span>        sign <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        abs_ival <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)ival;
</span></span><span style=display:flex><span>        sign <span style=color:#f92672>=</span> ival <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Fast path for single-digit ints */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(abs_ival <span style=color:#f92672>&gt;&gt;</span> PyLong_SHIFT)) {
</span></span><span style=display:flex><span>        v <span style=color:#f92672>=</span> _PyLong_New(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (v) {
</span></span><span style=display:flex><span>            Py_SET_SIZE(v, sign);
</span></span><span style=display:flex><span>            v<span style=color:#f92672>-&gt;</span>ob_digit[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(
</span></span><span style=display:flex><span>                abs_ival, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>, digit);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (PyObject<span style=color:#f92672>*</span>)v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if PyLong_SHIFT==15
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/* 2 digits */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(abs_ival <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>PyLong_SHIFT)) {
</span></span><span style=display:flex><span>        v <span style=color:#f92672>=</span> _PyLong_New(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (v) {
</span></span><span style=display:flex><span>            Py_SET_SIZE(v, <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> sign);
</span></span><span style=display:flex><span>            v<span style=color:#f92672>-&gt;</span>ob_digit[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(
</span></span><span style=display:flex><span>                abs_ival <span style=color:#f92672>&amp;</span> PyLong_MASK, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>, digit);
</span></span><span style=display:flex><span>            v<span style=color:#f92672>-&gt;</span>ob_digit[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(
</span></span><span style=display:flex><span>                  abs_ival <span style=color:#f92672>&gt;&gt;</span> PyLong_SHIFT, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>, digit);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (PyObject<span style=color:#f92672>*</span>)v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Larger numbers: loop to determine number of digits */</span>
</span></span><span style=display:flex><span>    t <span style=color:#f92672>=</span> abs_ival;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (t) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>ndigits;
</span></span><span style=display:flex><span>        t <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    v <span style=color:#f92672>=</span> _PyLong_New(ndigits);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        digit <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> v<span style=color:#f92672>-&gt;</span>ob_digit;
</span></span><span style=display:flex><span>        Py_SET_SIZE(v, ndigits <span style=color:#f92672>*</span> sign);
</span></span><span style=display:flex><span>        t <span style=color:#f92672>=</span> abs_ival;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (t) {
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>p<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(
</span></span><span style=display:flex><span>                t <span style=color:#f92672>&amp;</span> PyLong_MASK, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>, digit);
</span></span><span style=display:flex><span>            t <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (PyObject <span style=color:#f92672>*</span>)v;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>虽然看起来比较长，但其实思路非常简单：</p><ol><li>创建用于存储返回值的指针 <code>PyLongObject *z</code>，保存数据绝对值的变量 <code>unsigned long abs_ival, t</code>，标识数组长度的 <code>int ndigits</code> 和标识数据正负的 <code>int sign</code>；</li><li>如果数据范围在 [-5, 257) 内，则通过 <code>get_small_int</code> 函数返回结果；</li><li>获取数据的绝对值和正负符号；</li><li>如果数据绝对值没有超过 <code>ob_digit</code> 数组的单个元素所能表示的大小，则通过一个快速路径返回结果；</li><li>对于较大的数据，确定其 <code>ob_digit</code> 数组的长度，逐位置入。</li></ol><p>可以注意到，第 2 步针对 [-5, 257) 区间内的小整数做了特殊处理，最终在调用到 <code>__PyLong_GetSmallInt_internal</code> 函数时，会通过 <code>tstate->interp->small_ints[index]</code> 缓存数组获取小整数对应的指针对象并将其返回，这里的 <code>small_ints</code> 数组是一个全局变量，一般称为<strong>小整数对象池</strong>，是针对常用的小整数做的一个优化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/longobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> PyObject<span style=color:#f92672>*</span> <span style=color:#a6e22e>__PyLong_GetSmallInt_internal</span>(<span style=color:#66d9ef>int</span> value)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyThreadState <span style=color:#f92672>*</span>tstate <span style=color:#f92672>=</span> _PyThreadState_GET();
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef Py_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _Py_EnsureTstateNotNULL(tstate);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    assert(<span style=color:#f92672>-</span>_PY_NSMALLNEGINTS <span style=color:#f92672>&lt;=</span> value <span style=color:#f92672>&amp;&amp;</span> value <span style=color:#f92672>&lt;</span> _PY_NSMALLPOSINTS);
</span></span><span style=display:flex><span>    size_t index <span style=color:#f92672>=</span> _PY_NSMALLNEGINTS <span style=color:#f92672>+</span> value;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>obj <span style=color:#f92672>=</span> (PyObject<span style=color:#f92672>*</span>)tstate<span style=color:#f92672>-&gt;</span>interp<span style=color:#f92672>-&gt;</span>small_ints[index];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// _PyLong_GetZero() and _PyLong_GetOne() must not be called
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// before _PyLong_Init() nor after _PyLong_Fini()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    assert(obj <span style=color:#f92672>!=</span> NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> obj;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=2-数学运算>2 数学运算<a hidden class=anchor aria-hidden=true href=#2-数学运算>#</a></h2><p><code>PyLongObject</code> 的类型对象是 <code>PyLong_Type</code>，<code>PyLong_Type</code> 的成员变量 <code>PyNumberMethods *tp_as_number</code> 由 <code>static PyNumberMethods long_as_number*</code> 结构体指针初始化，其中包含了许多数学运算的函数指针，当我们对 <code>PyLong_Type</code> 进行数学运算时，实际上会调用这些函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/longobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PyTypeObject PyLong_Type <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&amp;</span>long_as_number,                            <span style=color:#75715e>/* tp_as_number */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> PyNumberMethods long_as_number <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    (binaryfunc)long_add,       <span style=color:#75715e>/*nb_add*/</span>
</span></span><span style=display:flex><span>    (binaryfunc)long_sub,       <span style=color:#75715e>/*nb_subtract*/</span>
</span></span><span style=display:flex><span>    (binaryfunc)long_mul,       <span style=color:#75715e>/*nb_multiply*/</span>
</span></span><span style=display:flex><span>    long_mod,                   <span style=color:#75715e>/*nb_remainder*/</span>
</span></span><span style=display:flex><span>    long_divmod,                <span style=color:#75715e>/*nb_divmod*/</span>
</span></span><span style=display:flex><span>    long_pow,                   <span style=color:#75715e>/*nb_power*/</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h3 id=21-加法>2.1 加法<a hidden class=anchor aria-hidden=true href=#21-加法>#</a></h3><p><code>PyLong_Type</code> 的加法运算对应的函数是 <code>long_add</code>，其实现和相关的宏定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Objects/longobject.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define CHECK_BINOP(v,w)                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    do {                                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        if (!PyLong_Check(v) || !PyLong_Check(w))       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            Py_RETURN_NOTIMPLEMENTED;                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    } while(0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* convert a PyLong of size 1, 0 or -1 to an sdigit */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MEDIUM_VALUE(x) (assert(-1 &lt;= Py_SIZE(x) &amp;&amp; Py_SIZE(x) &lt;= 1),   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>         Py_SIZE(x) &lt; 0 ? -(sdigit)(x)-&gt;ob_digit[0] :   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             (Py_SIZE(x) == 0 ? (sdigit)0 :                             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>              (sdigit)(x)-&gt;ob_digit[0]))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>long_add</span>(PyLongObject <span style=color:#f92672>*</span>a, PyLongObject <span style=color:#f92672>*</span>b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyLongObject <span style=color:#f92672>*</span>z;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CHECK_BINOP(a, b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Py_ABS(Py_SIZE(a)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> Py_ABS(Py_SIZE(b)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> PyLong_FromLong(MEDIUM_VALUE(a) <span style=color:#f92672>+</span> MEDIUM_VALUE(b));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Py_SIZE(a) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Py_SIZE(b) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            z <span style=color:#f92672>=</span> x_add(a, b);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (z <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* x_add received at least one multiple-digit int,
</span></span></span><span style=display:flex><span><span style=color:#75715e>                   and thus z must be a multiple-digit int.
</span></span></span><span style=display:flex><span><span style=color:#75715e>                   That also means z is not an element of
</span></span></span><span style=display:flex><span><span style=color:#75715e>                   small_ints, so negating it in-place is safe. */</span>
</span></span><span style=display:flex><span>                assert(Py_REFCNT(z) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                Py_SET_SIZE(z, <span style=color:#f92672>-</span>(Py_SIZE(z)));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            z <span style=color:#f92672>=</span> x_sub(b, a);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Py_SIZE(b) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            z <span style=color:#f92672>=</span> x_sub(a, b);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            z <span style=color:#f92672>=</span> x_add(a, b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (PyObject <span style=color:#f92672>*</span>)z;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到它的实现非常简单，主要分为以下几个步骤：</p><ol><li>创建一个用于存储返回值的指针 <code>PyLongObject *z</code>；</li><li>检查两个参数是否都是 <code>PyLongObject</code> 类型的指针 <code>CHECK_BINOP(a, b)</code>；</li><li>如果两个参数都满足 <code>ob_size &lt;= 1</code>（即绝对值均小于 <code>2^30</code>），那么先通过 <code>MEDIUM_VALUE</code> 获取两个 <code>ob_digit[0]</code> 的值，并将两数直接相加（一定不会溢出），再通过 <code>PyLong_FromLong</code> 将这个数包装为一个 <code>PyLongObject</code> 指针并返回；通常我们进行运算的数都不会太大，因此这里可以利用简化的运算步骤和 CPU 分支预测来提高效率；</li><li>判断两者的正负关系，将问题简化为绝对值加减法，利用辅助函数 <code>x_add</code> 和 <code>x_sub</code> 进行运算并返回结果。</li></ol><h3 id=22-绝对值加法>2.2 绝对值加法<a hidden class=anchor aria-hidden=true href=#22-绝对值加法>#</a></h3><p>绝对值加法函数 <code>x_add</code> 的定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#if PYLONG_BITS_IN_DIGIT == 30
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PyLong_SHIFT    30
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PyLong_BASE     ((digit)1 &lt;&lt; PyLong_SHIFT)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PyLong_MASK     ((digit)(PyLong_BASE - 1))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Add the absolute values of two integers. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> PyLongObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>x_add</span>(PyLongObject <span style=color:#f92672>*</span>a, PyLongObject <span style=color:#f92672>*</span>b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Py_ssize_t size_a <span style=color:#f92672>=</span> Py_ABS(Py_SIZE(a)), size_b <span style=color:#f92672>=</span> Py_ABS(Py_SIZE(b));
</span></span><span style=display:flex><span>    PyLongObject <span style=color:#f92672>*</span>z;
</span></span><span style=display:flex><span>    Py_ssize_t i;
</span></span><span style=display:flex><span>    digit carry <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Ensure a is the larger of the two: */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size_a <span style=color:#f92672>&lt;</span> size_b) {
</span></span><span style=display:flex><span>        { PyLongObject <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> a; a <span style=color:#f92672>=</span> b; b <span style=color:#f92672>=</span> temp; }
</span></span><span style=display:flex><span>        { Py_ssize_t size_temp <span style=color:#f92672>=</span> size_a;
</span></span><span style=display:flex><span>            size_a <span style=color:#f92672>=</span> size_b;
</span></span><span style=display:flex><span>            size_b <span style=color:#f92672>=</span> size_temp; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    z <span style=color:#f92672>=</span> _PyLong_New(size_a<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (z <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size_b; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        carry <span style=color:#f92672>+=</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>+</span> b<span style=color:#f92672>-&gt;</span>ob_digit[i];
</span></span><span style=display:flex><span>        z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> carry <span style=color:#f92672>&amp;</span> PyLong_MASK;
</span></span><span style=display:flex><span>        carry <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (; i <span style=color:#f92672>&lt;</span> size_a; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        carry <span style=color:#f92672>+=</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i];
</span></span><span style=display:flex><span>        z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> carry <span style=color:#f92672>&amp;</span> PyLong_MASK;
</span></span><span style=display:flex><span>        carry <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> carry;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> long_normalize(z);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其步骤大致分为以下几步：</p><ol><li>获取两个参数的 <code>ob_size</code> 的绝对值，创建存储返回值的指针 <code>PyLongObject *z</code>，</li><li>如果 <code>a->ob_size &lt; b->ob_size</code> 则交换两者，保证 a 的值较大；</li><li>将 z 的 <code>ob_size</code> 设置为 <code>size_a + 1</code>，保证不会溢出；</li><li>以 <code>i = 0</code> 为下标，从小到大依次对两数的每一位进行相加操作，将没有超过 <code>2^30</code> 的部分存储在 <code>z->ob_digit[i]</code> 中，超过的部分进位保存在 <code>carry</code> 中；这里充分利用了两个小于 <code>2^30</code> 的数相加不会溢出的特性；如果 <code>size_a > size_b</code> 还需要将 <code>a->ob_digit</code> 多余的部分按照相同的方法置入 <code>z->ob_digit</code>里；</li><li>得到的结果 <code>z</code> 中，其 <code>ob_digit</code> 的最后一个元素可能等于 0，因此通过 <code>long_normalize</code> 函数将其转换为符合 <code>PyLongObject</code> 定义的格式返回。</li></ol><p>整个过程可以抽象为类似 <code>2^30</code> 进制的加法，和十进制加法的过程几乎完全一样，只不过是把十进制每一位的数字换成了一个最大值为 <code>2^30</code> 的数字，每逢 <code>2^30</code> 进一位；举个例，假设有 <code>a->ob_digit = {4, 5, 6}</code>, <code>b->ob_digit = {1073741823, 1073741823}</code>，那么整个加法的步骤为：</p><ol><li><code>v->ob_digit[0] = (4 + 1073741823) % 1073741824 = 3</code>, <code>carry = 1</code>；</li><li><code>v->ob_digit[1] = (5 + 1073741823 + 1) % 1073741824 = 5</code>, <code>carry = 1</code>；</li><li><code>v->ob_digit[2] = (6 + 1) % 1073741824 = 7</code>, <code>carry = 0</code>；</li><li><code>v->ob_digit[3] = 0</code>；</li></ol><p>结果即 <code>v->ob_digit = {3, 5, 7, 0}</code>，最后一个元素 0 需要通过 <code>long_normalize</code> 函数去掉。</p><h3 id=23-绝对值减法>2.3 绝对值减法<a hidden class=anchor aria-hidden=true href=#23-绝对值减法>#</a></h3><p>绝对值减法的实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Subtract the absolute values of two integers. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> PyLongObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>x_sub</span>(PyLongObject <span style=color:#f92672>*</span>a, PyLongObject <span style=color:#f92672>*</span>b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Py_ssize_t size_a <span style=color:#f92672>=</span> Py_ABS(Py_SIZE(a)), size_b <span style=color:#f92672>=</span> Py_ABS(Py_SIZE(b));
</span></span><span style=display:flex><span>    PyLongObject <span style=color:#f92672>*</span>z;
</span></span><span style=display:flex><span>    Py_ssize_t i;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sign <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    digit borrow <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Ensure a is the larger of the two: */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size_a <span style=color:#f92672>&lt;</span> size_b) {
</span></span><span style=display:flex><span>        sign <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        { PyLongObject <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> a; a <span style=color:#f92672>=</span> b; b <span style=color:#f92672>=</span> temp; }
</span></span><span style=display:flex><span>        { Py_ssize_t size_temp <span style=color:#f92672>=</span> size_a;
</span></span><span style=display:flex><span>            size_a <span style=color:#f92672>=</span> size_b;
</span></span><span style=display:flex><span>            size_b <span style=color:#f92672>=</span> size_temp; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (size_a <span style=color:#f92672>==</span> size_b) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Find highest digit where a and b differ: */</span>
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> size_a;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>--</span>i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>==</span> b<span style=color:#f92672>-&gt;</span>ob_digit[i])
</span></span><span style=display:flex><span>            ;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> (PyLongObject <span style=color:#f92672>*</span>)PyLong_FromLong(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>&lt;</span> b<span style=color:#f92672>-&gt;</span>ob_digit[i]) {
</span></span><span style=display:flex><span>            sign <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            { PyLongObject <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> a; a <span style=color:#f92672>=</span> b; b <span style=color:#f92672>=</span> temp; }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        size_a <span style=color:#f92672>=</span> size_b <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    z <span style=color:#f92672>=</span> _PyLong_New(size_a);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (z <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size_b; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* The following assumes unsigned arithmetic
</span></span></span><span style=display:flex><span><span style=color:#75715e>           works module 2**N for some N&gt;PyLong_SHIFT. */</span>
</span></span><span style=display:flex><span>        borrow <span style=color:#f92672>=</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>-</span> b<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>-</span> borrow;
</span></span><span style=display:flex><span>        z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> borrow <span style=color:#f92672>&amp;</span> PyLong_MASK;
</span></span><span style=display:flex><span>        borrow <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
</span></span><span style=display:flex><span>        borrow <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/* Keep only one sign bit */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (; i <span style=color:#f92672>&lt;</span> size_a; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        borrow <span style=color:#f92672>=</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>-</span> borrow;
</span></span><span style=display:flex><span>        z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> borrow <span style=color:#f92672>&amp;</span> PyLong_MASK;
</span></span><span style=display:flex><span>        borrow <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
</span></span><span style=display:flex><span>        borrow <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/* Keep only one sign bit */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    assert(borrow <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sign <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Py_SET_SIZE(z, <span style=color:#f92672>-</span>Py_SIZE(z));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> maybe_small_long(long_normalize(z));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其步骤和绝对值加法类似，大致分为以下几步：</p><ol><li>获取两个参数的 <code>ob_size</code> 的绝对值，创建存储返回值的指针 <code>PyLongObject *z</code>，</li><li>如果 <code>a->ob_size &lt; b->ob_size</code> 则交换两者，保证 a 的值较大，并用 <code>sign</code> 记录运算结果为负；如果 <code>a->ob_size == b->ob_size</code> 则从最高位依次往低位找到第一次出现 <code>a->ob_digit[i] != b->ob_digit[i]</code> 的位置，比较 <code>a->ob_digit[i]</code> 和 <code>b->ob_digit[i]</code>，并决定是否交换两者以及 <code>sign</code> 的值；</li><li>将 z 的 <code>ob_size</code> 设置为 <code>size_a</code>；</li><li>以 <code>i = 0</code> 为下标，从小到大依次对两数的每一位进行相减操作，如果被减数 <code>a->ob_digit[i]</code> 小于减数 <code>b->ob_digit[i]</code> 则要向高位 <code>a->ob_digit[i + 1]</code> 借 1；在十进制的减法中向高位借到的数是 10，这里向 <code>digit</code> 数组的高位借到的则是 <code>2^30</code>；但 <code>digit</code> 是通过 <code>typedef uint32_t digit</code> 定义出来，通过公式 <code>borrow = a->ob_digit[i] - b->ob_digit[i] - borrow</code> 实际上得到的是 <code>2^32 + a->ob_digit[i] - b->ob_digit[i]</code>，所以还需要与 <code>PyLong_MASK</code> 做 <code>&</code> 操作，取后 30 位，便能得到借位相减后的结果，再将结果存储在 <code>z->ob_digit[i]</code> 中；借位部分 <code>borrow</code> 向右位移 30 位后还剩 2 位，只需要将其与 1 进行 <code>&</code> 操作即可知道此次减法运算是否有借位；如果 <code>size_a > size_b</code> 还需要将 <code>a->ob_digit</code> 多余的部分按照相同的方法置入 <code>z->ob_digit</code>里；</li><li>得到的结果 <code>z</code> 中，其 <code>ob_digit</code> 的最后一个元素可能等于 0，因此通过 <code>long_normalize</code> 函数将其转换为符合 <code>PyLongObject</code> 定义的格式返回。</li></ol><p>可以看到这里的步骤也跟十进制减法几乎完全相同，都跟 NOIP 入门的大数加减法加法思路相同。</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://zintrulcre.vip/posts/serialization/protocol-buffer/><span class=title>« Prev Page</span><br><span>ProtoBuf 语法和编码原理入门</span></a>
<a class=next href=https://zintrulcre.vip/posts/python/source-code-1/><span class=title>Next Page »</span><br><span>Python 源码学习（1）：类型和对象</span></a></nav></footer></article></main><footer class=footer><span>Zhengyu &copy; 2023</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>