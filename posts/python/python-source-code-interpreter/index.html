<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python 源码学习（4）：编译器和虚拟机 | 尾張</title>
<meta name=keywords content><meta name=description content='Python 源码学习（4）：编译器和虚拟机
Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。
Python 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。
1 Python 编译器
1.1 代码对象
Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：
# test.py
def Square(a):
    return a * a

print(f"result:\t\t{Square(5)}")

# main.py
f = "test.py"
code_obj = compile(open(f).read(), f, &#39;exec&#39;)
exec(code_obj)
print(f"code_obj:\t{code_obj}")
print(f"type:\t\t{type(code_obj)}")
$ python3 main.py
result:         25
code_obj:       <code object <module> at 0x7f052c156b30, file "test.py", line 1>
type:           <class &#39;code&#39;>
可以看到生成的 code_obj 对象的类型是 class &#39;code&#39;，它在源码中对应的结构体是代码对象 PyCodeObject；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：'><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/python/python-source-code-interpreter/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.143.1"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/python/python-source-code-interpreter/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Python 源码学习（4）：编译器和虚拟机"><meta property="og:description" content='Python 源码学习（4）：编译器和虚拟机
Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。
Python 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。
1 Python 编译器
1.1 代码对象
Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：
# test.py
def Square(a):
    return a * a

print(f"result:\t\t{Square(5)}")

# main.py
f = "test.py"
code_obj = compile(open(f).read(), f, &#39;exec&#39;)
exec(code_obj)
print(f"code_obj:\t{code_obj}")
print(f"type:\t\t{type(code_obj)}")
$ python3 main.py
result:         25
code_obj:       <code object <module> at 0x7f052c156b30, file "test.py", line 1>
type:           <class &#39;code&#39;>
可以看到生成的 code_obj 对象的类型是 class &#39;code&#39;，它在源码中对应的结构体是代码对象 PyCodeObject；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：'><meta property="og:type" content="article"><meta property="og:url" content="https://prov1dence.top/posts/python/python-source-code-interpreter/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-26T10:18:52+08:00"><meta property="article:modified_time" content="2021-05-26T10:18:52+08:00"><meta property="og:site_name" content="尾張"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python 源码学习（4）：编译器和虚拟机"><meta name=twitter:description content='Python 源码学习（4）：编译器和虚拟机
Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。
Python 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。
1 Python 编译器
1.1 代码对象
Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：
# test.py
def Square(a):
    return a * a

print(f"result:\t\t{Square(5)}")

# main.py
f = "test.py"
code_obj = compile(open(f).read(), f, &#39;exec&#39;)
exec(code_obj)
print(f"code_obj:\t{code_obj}")
print(f"type:\t\t{type(code_obj)}")
$ python3 main.py
result:         25
code_obj:       <code object <module> at 0x7f052c156b30, file "test.py", line 1>
type:           <class &#39;code&#39;>
可以看到生成的 code_obj 对象的类型是 class &#39;code&#39;，它在源码中对应的结构体是代码对象 PyCodeObject；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"Python 源码学习（4）：编译器和虚拟机","item":"https://prov1dence.top/posts/python/python-source-code-interpreter/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 源码学习（4）：编译器和虚拟机","name":"Python 源码学习（4）：编译器和虚拟机","description":"Python 源码学习（4）：编译器和虚拟机 Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。\nPython 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。\n1 Python 编译器 1.1 代码对象 Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：\n# test.py def Square(a): return a * a print(f\u0026#34;result:\\t\\t{Square(5)}\u0026#34;) # main.py f = \u0026#34;test.py\u0026#34; code_obj = compile(open(f).read(), f, \u0026#39;exec\u0026#39;) exec(code_obj) print(f\u0026#34;code_obj:\\t{code_obj}\u0026#34;) print(f\u0026#34;type:\\t\\t{type(code_obj)}\u0026#34;) $ python3 main.py result: 25 code_obj: \u0026lt;code object \u0026lt;module\u0026gt; at 0x7f052c156b30, file \u0026#34;test.py\u0026#34;, line 1\u0026gt; type: \u0026lt;class \u0026#39;code\u0026#39;\u0026gt; 可以看到生成的 code_obj 对象的类型是 class 'code'，它在源码中对应的结构体是代码对象 PyCodeObject；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：\n","keywords":[],"articleBody":"Python 源码学习（4）：编译器和虚拟机 Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。\nPython 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。\n1 Python 编译器 1.1 代码对象 Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：\n# test.py def Square(a): return a * a print(f\"result:\\t\\t{Square(5)}\") # main.py f = \"test.py\" code_obj = compile(open(f).read(), f, 'exec') exec(code_obj) print(f\"code_obj:\\t{code_obj}\") print(f\"type:\\t\\t{type(code_obj)}\") $ python3 main.py result: 25 code_obj: ","wordCount":"2572","inLanguage":"en","datePublished":"2021-05-26T10:18:52+08:00","dateModified":"2021-05-26T10:18:52+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/python/python-source-code-interpreter/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://prov1dence.top/>Home</a>&nbsp;»&nbsp;<a href=https://prov1dence.top/posts/>Posts</a></div><h1 class=post-title>Python 源码学习（4）：编译器和虚拟机</h1><div class=post-meta>2021-05-26 10:18:52 · 13 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#python-%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a04%e7%bc%96%e8%af%91%e5%99%a8%e5%92%8c%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label="Python 源码学习（4）：编译器和虚拟机">Python 源码学习（4）：编译器和虚拟机</a><ul><li><a href=#1-python-%e7%bc%96%e8%af%91%e5%99%a8 aria-label="1 Python 编译器">1 Python 编译器</a><ul><li><a href=#11-%e4%bb%a3%e7%a0%81%e5%af%b9%e8%b1%a1 aria-label="1.1 代码对象">1.1 代码对象</a></li><li><a href=#12-%e5%ad%97%e8%8a%82%e7%a0%81 aria-label="1.2 字节码">1.2 字节码</a></li><li><a href=#13-%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86 aria-label="1.3 编译原理">1.3 编译原理</a></li></ul></li><li><a href=#2-python-%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label="2 Python 虚拟机">2 Python 虚拟机</a><ul><li><a href=#21-%e8%b0%83%e7%94%a8%e6%a0%88 aria-label="2.1 调用栈">2.1 调用栈</a></li><li><a href=#22-%e6%a0%88%e5%b8%a7%e5%af%b9%e8%b1%a1 aria-label="2.2 栈帧对象">2.2 栈帧对象</a><ul><li><a href=#221-%e5%9b%9e%e6%94%b6%e5%92%8c%e5%88%86%e9%85%8d aria-label="2.2.1 回收和分配">2.2.1 回收和分配</a></li></ul></li><li><a href=#23-%e8%bf%90%e8%a1%8c%e8%bf%87%e7%a8%8b aria-label="2.3 运行过程">2.3 运行过程</a><ul><li><a href=#231-%e8%b0%83%e7%94%a8%e6%b5%81%e7%a8%8b aria-label="2.3.1 调用流程">2.3.1 调用流程</a></li><li><a href=#232-%e8%bf%90%e8%a1%8c%e6%a0%88%e5%b8%a7 aria-label="2.3.2 运行栈帧">2.3.2 运行栈帧</a></li><li><a href=#233-%e8%b0%83%e8%af%95 aria-label="2.3.3 调试">2.3.3 调试</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=python-源码学习4编译器和虚拟机>Python 源码学习（4）：编译器和虚拟机<a hidden class=anchor aria-hidden=true href=#python-源码学习4编译器和虚拟机>#</a></h1><p>Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 <a href=https://github.com/python/cpython>CPython</a>。</p><p><strong>Python 解释器</strong>（<em>Python Interpreter</em>）由 <strong>Python 编译器</strong>（<em>Python Compiler</em>）和 <strong>Python 虚拟机</strong>（<em>Python Virutal Machine</em>）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 <strong>Python 字节码</strong>（<em><a href=https://www.quora.com/What-is-the-difference-between-byte-code-and-machine-code-and-what-are-its-advantages>bytecode</a></em>）；随后 Python 虚拟机会读取并逐步执行这些字节码。</p><h2 id=1-python-编译器>1 Python 编译器<a hidden class=anchor aria-hidden=true href=#1-python-编译器>#</a></h2><h3 id=11-代码对象>1.1 代码对象<a hidden class=anchor aria-hidden=true href=#11-代码对象>#</a></h3><p>Python 提供了内置函数 <code>compile</code>，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># test.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>Square</span>(a):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>*</span> a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;result:</span><span style=color:#ae81ff>\t\t</span><span style=color:#e6db74>{</span>Square(<span style=color:#ae81ff>5</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># main.py</span>
</span></span><span style=display:flex><span>f <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;test.py&#34;</span>
</span></span><span style=display:flex><span>code_obj <span style=color:#f92672>=</span> compile(open(f)<span style=color:#f92672>.</span>read(), f, <span style=color:#e6db74>&#39;exec&#39;</span>)
</span></span><span style=display:flex><span>exec(code_obj)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;code_obj:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>code_obj<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;type:</span><span style=color:#ae81ff>\t\t</span><span style=color:#e6db74>{</span>type(code_obj)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ python3 main.py
</span></span><span style=display:flex><span>result:         <span style=color:#ae81ff>25</span>
</span></span><span style=display:flex><span>code_obj:       &lt;code object &lt;module&gt; at 0x7f052c156b30, file <span style=color:#e6db74>&#34;test.py&#34;</span>, line 1&gt;
</span></span><span style=display:flex><span>type:           &lt;class <span style=color:#e6db74>&#39;code&#39;</span>&gt;
</span></span></code></pre></div><p>可以看到生成的 <code>code_obj</code> 对象的类型是 <code>class 'code'</code>，它在源码中对应的结构体是<strong>代码对象</strong> <em>PyCodeObject</em>；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Include/cpython/code.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Bytecode object */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> PyCodeObject {
</span></span><span style=display:flex><span>    PyObject_HEAD
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> co_argcount;            <span style=color:#75715e>/* #arguments, except *args */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> co_posonlyargcount;     <span style=color:#75715e>/* #positional only arguments */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> co_kwonlyargcount;      <span style=color:#75715e>/* #keyword only arguments */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> co_nlocals;             <span style=color:#75715e>/* #local variables */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> co_stacksize;           <span style=color:#75715e>/* #entries needed for evaluation stack */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> co_flags;               <span style=color:#75715e>/* CO_..., see below */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> co_firstlineno;         <span style=color:#75715e>/* first source line number */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_code;          <span style=color:#75715e>/* instruction opcodes */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_consts;        <span style=color:#75715e>/* list (constants used) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_names;         <span style=color:#75715e>/* list of strings (names used) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_varnames;      <span style=color:#75715e>/* tuple of strings (local variable names) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_freevars;      <span style=color:#75715e>/* tuple of strings (free variable names) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_cellvars;      <span style=color:#75715e>/* tuple of strings (cell variable names) */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* The rest aren&#39;t used in either hash or comparisons, except for co_name,
</span></span></span><span style=display:flex><span><span style=color:#75715e>       used in both. This is done to preserve the name and line number
</span></span></span><span style=display:flex><span><span style=color:#75715e>       for tracebacks and debuggers; otherwise, constant de-duplication
</span></span></span><span style=display:flex><span><span style=color:#75715e>       would collapse identical functions/lambdas defined on different lines.
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    Py_ssize_t <span style=color:#f92672>*</span>co_cell2arg;    <span style=color:#75715e>/* Maps cell vars which are arguments. */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_filename;      <span style=color:#75715e>/* unicode (where it was loaded from) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_name;          <span style=color:#75715e>/* unicode (name, for reference) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_lnotab;        <span style=color:#75715e>/* string (encoding addr&lt;-&gt;lineno mapping) See
</span></span></span><span style=display:flex><span><span style=color:#75715e>                                   Objects/lnotab_notes.txt for details. */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>co_zombieframe;       <span style=color:#75715e>/* for optimization only (see frameobject.c) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>co_weakreflist;   <span style=color:#75715e>/* to support weakrefs to code objects */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Scratch space for extra data relating to the code object.
</span></span></span><span style=display:flex><span><span style=color:#75715e>       Type is a void* to keep the format private in codeobject.c to force
</span></span></span><span style=display:flex><span><span style=color:#75715e>       people to go through the proper APIs. */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>co_extra;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Per opcodes just-in-time cache
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * To reduce cache size, we use indirect mapping from opcode index to
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * cache object:
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *   cache = co_opcache[co_opcache_map[next_instr - first_instr] - 1]
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// co_opcache_map is indexed by (next_instr - first_instr).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//  * 0 means there is no cache for this opcode.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//  * n &gt; 0 means there is cache in co_opcache[n-1].
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>co_opcache_map;
</span></span><span style=display:flex><span>    _PyOpcache <span style=color:#f92672>*</span>co_opcache;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> co_opcache_flag;  <span style=color:#75715e>// used to determine when create a cache.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> co_opcache_size;  <span style=color:#75715e>// length of co_opcache.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>其中比较重要的成员有两个，分别是编译后生成的指令序列 <code>co_code</code> 和执行当前代码块所需的栈空间大小 <code>co_stacksize</code>。</p><h3 id=12-字节码>1.2 字节码<a hidden class=anchor aria-hidden=true href=#12-字节码>#</a></h3><p>在所有的这些成员变量中，<code>PyObject *co_code</code> 存储了编译后生成的指令序列，它是以字节的方式存储的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># test.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>Square</span>(a):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>*</span> a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;result:</span><span style=color:#ae81ff>\t\t</span><span style=color:#e6db74>{</span>Square(<span style=color:#ae81ff>5</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># main.py</span>
</span></span><span style=display:flex><span>f <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;test.py&#34;</span>
</span></span><span style=display:flex><span>code_obj <span style=color:#f92672>=</span> compile(open(f)<span style=color:#f92672>.</span>read(), f, <span style=color:#e6db74>&#39;exec&#39;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;code obj:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>code_obj<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;stack size:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>code_obj<span style=color:#f92672>.</span>co_stacksize<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>result <span style=color:#f92672>=</span> exec(code_obj)
</span></span><span style=display:flex><span>bytecode <span style=color:#f92672>=</span> code_obj<span style=color:#f92672>.</span>co_code
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;bytecode:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>bytecode<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ python3 main.py
</span></span><span style=display:flex><span>code obj:       &lt;code object &lt;module&gt; at 0x7f26cea5ab30, file <span style=color:#e6db74>&#34;test.py&#34;</span>, line 1&gt;
</span></span><span style=display:flex><span>stack size:     <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>result:         <span style=color:#ae81ff>25</span>
</span></span><span style=display:flex><span>bytecode:       b<span style=color:#e6db74>&#39;d\x00d\x01\x84\x00Z\x00e\x01d\x02e\x00d\x03\x83\x01\x9b\x00\x9d\x02\x83\x01\x01\x00d\x04S\x00&#39;</span>
</span></span></code></pre></div><p>我们可以使用 Python 内置模块 dis 来将这些字节码反编译成类似于汇编语言的格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> dis
</span></span><span style=display:flex><span>dis<span style=color:#f92672>.</span>dis(bytecode)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>          <span style=color:#ae81ff>0</span> LOAD_CONST               <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>2</span> LOAD_CONST               <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>4</span> MAKE_FUNCTION            <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>6</span> STORE_NAME               <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>8</span> LOAD_NAME                <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>10</span> LOAD_CONST               <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>12</span> LOAD_NAME                <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>14</span> LOAD_CONST               <span style=color:#ae81ff>3</span> <span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>16</span> CALL_FUNCTION            <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>18</span> FORMAT_VALUE             <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>20</span> BUILD_STRING             <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>22</span> CALL_FUNCTION            <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>24</span> POP_TOP
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>26</span> LOAD_CONST               <span style=color:#ae81ff>4</span> <span style=color:#f92672>(</span>4<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>28</span> RETURN_VALUE
</span></span></code></pre></div><p>在反编译后的输出结果中，第一列代表字节码中每一条指令的<strong>偏移量</strong> <em>offset</em>；第二列代表各条<strong>助记符</strong> <em>mnemonics</em> 的名称，这些助记符可以很方便地帮助我们理解在后续的步骤中 Python 虚拟机要执行的事件；第三列则是每条指令的<strong>操作数</strong> <em>opargs</em>。</p><p>同时，在字节码对应的十六进制表示中，每一位数字也分别代表了不同的助记符和操作数，我们可以直接通过打印出字节码的十六进制以查看其内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(bytecode<span style=color:#f92672>.</span>hex())
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#ae81ff>64</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>84</span> <span style=color:#ae81ff>00</span> 5a <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>65</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>02</span> <span style=color:#ae81ff>65</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>03</span> <span style=color:#ae81ff>83</span> <span style=color:#ae81ff>01</span> 9b <span style=color:#ae81ff>00</span> 9d <span style=color:#ae81ff>02</span> <span style=color:#ae81ff>83</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>04</span> <span style=color:#ae81ff>53</span> <span style=color:#ae81ff>00</span>
</span></span></code></pre></div><p>以上面反编译后的输出为例，在 offset == 0 的地方可以找到数字 64，即 LOAD_CONST 加载常量助记符对应的<strong>操作码 opcode</strong>，其后紧跟着的是它的操作数 opargs == 0；而指令第四行对应的 offset == 6，可以看到 STORE_NAME 助记符对应的操作码 opcode == 5a ，其操作数 opargs == 0；以此类推。</p><p>Python 的 opcode 模块提供了关于 Python 虚拟机中助记符和操作码的相关信息，也可以在源码的 Include/opcode.h 中找到相关定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> opcode
</span></span><span style=display:flex><span>print(opcode<span style=color:#f92672>.</span>opname[<span style=color:#ae81ff>0x64</span>])
</span></span><span style=display:flex><span>print(opcode<span style=color:#f92672>.</span>opname[<span style=color:#ae81ff>0x5a</span>])
</span></span><span style=display:flex><span>print(opcode<span style=color:#f92672>.</span>opmap[<span style=color:#e6db74>&#39;LOAD_NAME&#39;</span>])
</span></span><span style=display:flex><span>print(opcode<span style=color:#f92672>.</span>opmap[<span style=color:#e6db74>&#39;RETURN_VALUE&#39;</span>])
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>LOAD_CONST
</span></span><span style=display:flex><span>STORE_NAME
</span></span><span style=display:flex><span><span style=color:#ae81ff>101</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>83</span>
</span></span></code></pre></div><h3 id=13-编译原理>1.3 编译原理<a hidden class=anchor aria-hidden=true href=#13-编译原理>#</a></h3><p>Python 编译器的实现和其他语言类似，包含了<strong>词法分析</strong> <em>Lexical</em>，<strong>语法分析</strong> <em>Syntax Analysis</em> 和<strong>语义分析</strong> <em>Semantic Analysis</em> 等步骤，本文不再赘述编译原理的部分。</p><h2 id=2-python-虚拟机>2 Python 虚拟机<a hidden class=anchor aria-hidden=true href=#2-python-虚拟机>#</a></h2><p>类似于 x86-64, arm 平台和 Java 虚拟机，Python 虚拟机也是 <strong>基于栈的</strong>（<em>Stack-Based</em>），它的函数调用都是通过<strong>调用栈</strong> <em>call stack</em> 和<strong>栈帧</strong> <em>stackframe</em> 来实现的。</p><h3 id=21-调用栈>2.1 调用栈<a hidden class=anchor aria-hidden=true href=#21-调用栈>#</a></h3><p>调用栈是 CPU 寄存器中的一块内存区域，它是一种 FILO 的数据结构，可以进行插入或删除操作的一边称为栈顶，另一边则称为栈底；对于最常见的 x86-64 架构来说，栈地址空间是自顶向下（<em>head down</em>）增长的：</p><p><img loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/call-stack-1.png alt=call-stack-1></p><p>在 x86-64 平台下，它拥有 16 个<strong>通用寄存器</strong> <em>general-purpose registers</em>，寄存器被集成在 CPU 芯片上，其中 rbp 寄存器保存当前栈帧的栈底（本次函数调用开始时的位置），rsp 寄存器保存当前栈帧的栈顶（函数运行时的当前位置），rbp 和 rsp 之间的空间则被称为本次函数调用的<strong>栈帧</strong> <em>stack frame</em>；在每一次发生函数调用时，调用栈上都会维护一个独立的栈帧以存储函数返回值、参数、局部变量等信息；其他通用寄存器的功能如下。</p><p><img loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/x86-64-registers.png alt=x86-64-registers></p><p>栈相关的最常见操作有 push 和 pop，push 操作会将一个操作数插入栈顶，这包含了两个步骤，分别是先将 rsp 寄存器保存的地址减去 8，再将操作数写入到这个地址中；而 pop 则正好相反，它先从 rsp 寄存器存储的地址取出数据，写入到其他寄存器中，再对其地址加上 8。</p><p>以调试一个简单的 Swap 函数调用为例；本文使用的所有汇编语言都是 <em><a href=https://csiflabs.cs.ucdavis.edu/~ssdavis/50/att-syntax.htm>AT&amp;T Syntax</a></em> 的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// main.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Swap</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>    a <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>    b <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>    Swap(a, b);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> b <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>用 gdb 打开并在 main 函数处断点；在 main 函数栈帧中，会通过 movl 指令将两个常量拷贝到内存中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ g++ -g -O0 -o main main.cpp
</span></span><span style=display:flex><span>$ gdb main
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b main
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> r
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> layout reg
</span></span></code></pre></div><pre tabindex=0><code>&gt; 0x400852 &lt;main()+9&gt;      movl  $0x5,-0x14(%rbp)  # 将常量 9 保存在 rbp - 18 的位置
  0x400859 &lt;main()+16&gt;     movl  $0x9,-0x18(%rbp)  # 将常量 5 保存在 rbp - 14 的位置
</code></pre><p>在调用函数 Swap 前，会分别将两个参数存入 rdi 和 rsi 寄存器中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  0x400860 &lt;main<span style=color:#f92672>()</span>+23&gt;     lea   -0x18<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>,%rdx
</span></span><span style=display:flex><span>  0x400864 &lt;main<span style=color:#f92672>()</span>+27&gt;     lea   -0x14<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>,%rax
</span></span><span style=display:flex><span>  0x400868 &lt;main<span style=color:#f92672>()</span>+31&gt;     mov    %rdx,%rsi
</span></span><span style=display:flex><span>  0x40086b &lt;main<span style=color:#f92672>()</span>+34&gt;     mov    %rax,%rdi
</span></span><span style=display:flex><span>&gt; 0x40086e &lt;main<span style=color:#f92672>()</span>+37&gt;     callq  0x40081d &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p *$rsi
</span></span><span style=display:flex><span>$6 <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p *$rdi
</span></span><span style=display:flex><span>$7 <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span></code></pre></div><p>在 callq 指令处使用 stepi 进入到 Swap 函数中，此时 rbp 和 rsp 指针还分别指向 main 函数栈帧的底部和顶部，能够发现栈地址空间的确是向下增长的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; 0x40086e &lt;main<span style=color:#f92672>()</span>+37&gt;     callq  0x40081d &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> si
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; 0x40081d &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>&gt;     push   %rbp
</span></span><span style=display:flex><span>  0x40081e &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+1&gt;   mov    %rsp,%rbp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rbp            0x7fffffffe110   0x7fffffffe110
</span></span><span style=display:flex><span>rsp            0x7fffffffe0e8   0x7fffffffe0e8
</span></span></code></pre></div><p>此时栈帧结构大致如下：</p><p><img loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/call-stack-2.png alt=call-stack-2></p><p>执行接下来的 push 指令，将 rbp 的值存入栈顶，可以看到 rsp 的值发生了变化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> ni
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  0x40081d &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>&gt;     push   %rbp
</span></span><span style=display:flex><span>&gt; 0x40081e &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+1&gt;   mov    %rsp,%rbp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rbp            0x7fffffffe110   0x7fffffffe110
</span></span><span style=display:flex><span>rsp            0x7fffffffe0e0   0x7fffffffe0e0
</span></span></code></pre></div><p>继续执行下一条 mov 指令，重置 rbp 的值，进入新的栈帧：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> ni
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rbp            0x7fffffffe0e0   0x7fffffffe0e0
</span></span><span style=display:flex><span>rsp            0x7fffffffe0e0   0x7fffffffe0e0
</span></span></code></pre></div><p>此时栈帧结构变成了如下：</p><p><img loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/call-stack-3.png alt=call-stack-3></p><p>再经过一系列的 mov 指令操作，将 a 和 b 的值交换之后，执行下一条 pop 指令，将存储的上一个栈帧地址写入 rbp 中，同时修改 rsp；之后再执行 retq 指令即可继续运行 main 函数的下一条汇编指令了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; 0x400847 &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+42&gt;  pop    %rbp
</span></span><span style=display:flex><span>  0x400848 &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+43&gt;  retq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rbp            0x7fffffffe0e0   0x7fffffffe0e0
</span></span><span style=display:flex><span>rsp            0x7fffffffe0e0   0x7fffffffe0e0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> ni
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  0x400847 &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+42&gt;  pop    %rbp
</span></span><span style=display:flex><span>&gt; 0x400848 &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+43&gt;  retq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rbp            0x7fffffffe110   0x7fffffffe110
</span></span><span style=display:flex><span>rsp            0x7fffffffe0e8   0x7fffffffe0e8
</span></span></code></pre></div><p>Python 中函数调用链和调用栈之间的关系也和 x86-64 平台类似，只不过是把代码块和栈帧分别进行了封装而已。</p><h3 id=22-栈帧对象>2.2 栈帧对象<a hidden class=anchor aria-hidden=true href=#22-栈帧对象>#</a></h3><p>Python 中的代码对象 PyCodeObject 本身只包含了字节码相关的信息，并不具备用于执行字节码所需要的上下文信息，因此需要引入<strong>栈帧对象 PyFrameObject</strong>，作为代码对象运行的容器，并用来模拟其他平台下的栈帧：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// cpython/Include/frameobject.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> _frame {
</span></span><span style=display:flex><span>    PyObject_VAR_HEAD
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> _frame <span style=color:#f92672>*</span>f_back;      <span style=color:#75715e>/* previous frame, or NULL */</span>
</span></span><span style=display:flex><span>    PyCodeObject <span style=color:#f92672>*</span>f_code;       <span style=color:#75715e>/* code segment */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_builtins;       <span style=color:#75715e>/* builtin symbol table (PyDictObject) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_globals;        <span style=color:#75715e>/* global symbol table (PyDictObject) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_locals;         <span style=color:#75715e>/* local symbol table (any mapping) */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>**</span>f_valuestack;    <span style=color:#75715e>/* points after the last local */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_trace;          <span style=color:#75715e>/* Trace function */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> f_stackdepth;           <span style=color:#75715e>/* Depth of value stack */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> f_trace_lines;         <span style=color:#75715e>/* Emit per-line trace events? */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> f_trace_opcodes;       <span style=color:#75715e>/* Emit per-opcode trace events? */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Borrowed reference to a generator, or NULL */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_gen;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> f_lasti;                <span style=color:#75715e>/* Last instruction if called */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Call PyFrame_GetLineNumber() instead of reading this field
</span></span></span><span style=display:flex><span><span style=color:#75715e>       directly.  As of 2.3 f_lineno is only valid when tracing is
</span></span></span><span style=display:flex><span><span style=color:#75715e>       active (i.e. when f_trace is set).  At other times we use
</span></span></span><span style=display:flex><span><span style=color:#75715e>       PyCode_Addr2Line to calculate the line from the current
</span></span></span><span style=display:flex><span><span style=color:#75715e>       bytecode index. */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> f_lineno;               <span style=color:#75715e>/* Current line number */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> f_iblock;               <span style=color:#75715e>/* index in f_blockstack */</span>
</span></span><span style=display:flex><span>    PyFrameState f_state;       <span style=color:#75715e>/* What state the frame is in */</span>
</span></span><span style=display:flex><span>    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span style=color:#75715e>/* for try and loop blocks */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_localsplus[<span style=color:#ae81ff>1</span>];  <span style=color:#75715e>/* locals+stack, dynamically sized */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// cpython/Include/pyframe.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _frame PyFrameObject;
</span></span></code></pre></div><p>可以看到栈帧对象中大致包含了以下数据，它们构成了 Python 虚拟机执行当前栈帧所需要的所有上下文：</p><ul><li>上一个运行的栈帧对象的指针 <code>struct _frame *f_back</code>；Python 虚拟机中运行的所有栈帧对象的 <code>*f_back</code> 共同组成调用栈结构，仅有初始栈帧有 <code>f_back == NULL</code>；</li><li>代码对象指针 <code>PyCodeObject *f_code</code>，它包含了当前运行栈帧所执行的字节码信息；</li><li>代码对象执行期间的栈结构 <code>PyObject **f_valuestack</code>，在对字节码进行运算时，需要从栈顶读取数据，并将运算结果存储在栈顶，<code>f_valuestack</code> 就是用来用来存储数据的栈结构，它的大小由对应的代码对象 <code>f_code</code> 的堆栈大小决定；</li><li>代码对象执行期间使用的栈结构的深度 <code>int f_stackdepth</code>；</li><li>上一条执行过的字节码指令 <code>int f_lasti</code>，类似于 rip 寄存器；</li><li>内置命名空间、全局命名空间、局部命名空间的指针 <code>PyObject *f_builtins</code>, <code>PyObject *f_globals</code>, <code>PyObject *f_locals</code>，它们是用来实现 Python 中从符号到对象的映射的结构，一般用字典实现，暂不讨论；</li><li>用于跟踪代码执行情况的函数指针 <code>PyObject *f_trace</code> 和相关数据 <code>char f_trace_lines</code>, <code>char f_trace_opcodes</code>，暂不讨论；</li><li>用于执行生成器代码的数据 <code>PyObject *f_gen</code>，暂不讨论；</li></ul><p>Python 在 <code>sys</code> 模块中提供了 <code>_getframe</code> 函数来获取栈帧对象；以一个简单的 Swap 函数为例，在最深层的函数调用处打印出栈帧对象的信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>Swap</span>(a, b):
</span></span><span style=display:flex><span>    frame <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>_getframe()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> frame <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;frame:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>frame<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;name:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>frame<span style=color:#f92672>.</span>f_code<span style=color:#f92672>.</span>co_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;locals:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>frame<span style=color:#f92672>.</span>f_locals<span style=color:#f92672>.</span>keys()<span style=color:#e6db74>}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;back:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>frame<span style=color:#f92672>.</span>f_back<span style=color:#e6db74>}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        frame <span style=color:#f92672>=</span> frame<span style=color:#f92672>.</span>f_back
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> b, a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    a, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>    a, b <span style=color:#f92672>=</span> Swap(a, b)
</span></span><span style=display:flex><span>    print(a, b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><p>运行后可以观察到，在 Python 程序开始执行时会先创建一个叫做 module 的栈帧对象用于执行当前脚本中的代码；在每次函数调用的过程中，都会创建出一个新的栈帧对象，这些栈帧对象会使用 <code>f_back</code> 指针保存上一个执行栈帧的地址，并在之后调用其他函数的时候被压入栈顶：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ python3 main.py
</span></span><span style=display:flex><span>frame:  &lt;frame at 0x7fe37d7e5900, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 36, code Swap&gt;
</span></span><span style=display:flex><span>name:   Swap
</span></span><span style=display:flex><span>locals: dict_keys<span style=color:#f92672>([</span><span style=color:#e6db74>&#39;a&#39;</span>, <span style=color:#e6db74>&#39;b&#39;</span>, <span style=color:#e6db74>&#39;frame&#39;</span><span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>back:   &lt;frame at 0x7fe71ca65040, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 46, code main&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>frame:  &lt;frame at 0x7fe376115040, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 46, code main&gt;
</span></span><span style=display:flex><span>name:   main
</span></span><span style=display:flex><span>locals: dict_keys<span style=color:#f92672>([</span><span style=color:#e6db74>&#39;a&#39;</span>, <span style=color:#e6db74>&#39;b&#39;</span><span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>back:   &lt;frame at 0x141f6f0, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 50, code &lt;module&gt;&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>frame:  &lt;frame at 0x1ade6f0, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 50, code &lt;module&gt;&gt;
</span></span><span style=display:flex><span>name:   &lt;module&gt;
</span></span><span style=display:flex><span>locals: dict_keys<span style=color:#f92672>([</span><span style=color:#e6db74>&#39;__name__&#39;</span>, <span style=color:#e6db74>&#39;__doc__&#39;</span>, <span style=color:#e6db74>&#39;__package__&#39;</span>, <span style=color:#e6db74>&#39;__loader__&#39;</span>, <span style=color:#e6db74>&#39;__spec__&#39;</span>, <span style=color:#e6db74>&#39;__annotations__&#39;</span>, <span style=color:#e6db74>&#39;__builtins__&#39;</span>, <span style=color:#e6db74>&#39;__file__&#39;</span>, <span style=color:#e6db74>&#39;__cached__&#39;</span>, <span style=color:#e6db74>&#39;sys&#39;</span>, <span style=color:#e6db74>&#39;Swap&#39;</span>, <span style=color:#e6db74>&#39;main&#39;</span><span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>back:   None
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>9</span> <span style=color:#ae81ff>5</span>
</span></span></code></pre></div><h4 id=221-回收和分配>2.2.1 回收和分配<a hidden class=anchor aria-hidden=true href=#221-回收和分配>#</a></h4><p>前文讨论过类型对象，从刚才获取栈帧对象的例子里能够看到通过 <code>sys._getframe()</code> 获取的 <code>frame</code> 对象的类型名为 <code>frame</code>，不难找到它的类型对象实际上是 <code>PyFrame_Type</code>，我们可以从类型对象初始化时使用的函数指针找到它的相关操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>PyTypeObject PyFrame_Type <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;frame&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sizeof</span>(PyFrameObject),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>sizeof</span>(PyObject <span style=color:#f92672>*</span>),
</span></span><span style=display:flex><span>    (destructor)frame_dealloc,                  <span style=color:#75715e>/* tp_dealloc */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_vectorcall_offset */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_getattr */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_setattr */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_async */</span>
</span></span><span style=display:flex><span>    (reprfunc)frame_repr,                       <span style=color:#75715e>/* tp_repr */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_number */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_sequence */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_mapping */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_hash */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_call */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_str */</span>
</span></span><span style=display:flex><span>    PyObject_GenericGetAttr,                    <span style=color:#75715e>/* tp_getattro */</span>
</span></span><span style=display:flex><span>    PyObject_GenericSetAttr,                    <span style=color:#75715e>/* tp_setattro */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_buffer */</span>
</span></span><span style=display:flex><span>    Py_TPFLAGS_DEFAULT <span style=color:#f92672>|</span> Py_TPFLAGS_HAVE_GC,<span style=color:#75715e>/* tp_flags */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_doc */</span>
</span></span><span style=display:flex><span>    (traverseproc)frame_traverse,               <span style=color:#75715e>/* tp_traverse */</span>
</span></span><span style=display:flex><span>    (inquiry)frame_tp_clear,                    <span style=color:#75715e>/* tp_clear */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_richcompare */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_weaklistoffset */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_iter */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_iternext */</span>
</span></span><span style=display:flex><span>    frame_methods,                              <span style=color:#75715e>/* tp_methods */</span>
</span></span><span style=display:flex><span>    frame_memberlist,                           <span style=color:#75715e>/* tp_members */</span>
</span></span><span style=display:flex><span>    frame_getsetlist,                           <span style=color:#75715e>/* tp_getset */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_base */</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_dict */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>其中对栈帧对象进行析构的函数是 <code>frame_dealloc</code>，此处省略了部分代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define PyFrame_MAXFREELIST 200
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> _Py_HOT_FUNCTION
</span></span><span style=display:flex><span><span style=color:#a6e22e>frame_dealloc</span>(PyFrameObject <span style=color:#f92672>*</span>f)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Py_XDECREF(f<span style=color:#f92672>-&gt;</span>f_back);
</span></span><span style=display:flex><span>    Py_DECREF(f<span style=color:#f92672>-&gt;</span>f_builtins);
</span></span><span style=display:flex><span>    Py_DECREF(f<span style=color:#f92672>-&gt;</span>f_globals);
</span></span><span style=display:flex><span>    Py_CLEAR(f<span style=color:#f92672>-&gt;</span>f_locals);
</span></span><span style=display:flex><span>    Py_CLEAR(f<span style=color:#f92672>-&gt;</span>f_trace);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    PyCodeObject <span style=color:#f92672>*</span>co <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>f_code;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (co<span style=color:#f92672>-&gt;</span>co_zombieframe  <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        co<span style=color:#f92672>-&gt;</span>co_zombieframe <span style=color:#f92672>=</span> f;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_Py_frame_state</span> <span style=color:#f92672>*</span>state <span style=color:#f92672>=</span> get_frame_state();
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef Py_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// frame_dealloc() must not be called after _PyFrame_Fini()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        assert(state<span style=color:#f92672>-&gt;</span>numfree <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (state<span style=color:#f92672>-&gt;</span>numfree <span style=color:#f92672>&lt;</span> PyFrame_MAXFREELIST) {
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>state<span style=color:#f92672>-&gt;</span>numfree;
</span></span><span style=display:flex><span>            f<span style=color:#f92672>-&gt;</span>f_back <span style=color:#f92672>=</span> state<span style=color:#f92672>-&gt;</span>free_list;
</span></span><span style=display:flex><span>            state<span style=color:#f92672>-&gt;</span>free_list <span style=color:#f92672>=</span> f;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            PyObject_GC_Del(f);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Py_DECREF(co);
</span></span><span style=display:flex><span>    Py_TRASHCAN_SAFE_END(f)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_Py_frame_state</span> {
</span></span><span style=display:flex><span>    PyFrameObject <span style=color:#f92672>*</span>free_list;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* number of frames currently in free_list */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> numfree;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这是一个使用非常高频的函数（几乎每一次栈帧退出时都会调用），因此采用了一些策略来进行优化以降低调用函数的开销；一种是在首次进行栈帧对象 <code>f</code> 的回收时会先判断栈帧对象关联的代码对象 <code>co</code> 的成员指针 <code>co_zombieframe</code> 是否为空 <code>if (co->co_zombieframe == NULL)</code>；如果是，则会将该栈帧对象 <code>f</code> 保存在代码对象的这个指针中 <code>co->co_zombieframe = f</code>，这样的话在下一次执行相同的代码对象 <code>co</code> 时，就无需再次重新进行栈帧对象 <code>f</code> 的内存分配（只要代码对象 <code>co</code> 不因为引用计数降低为 0 而被 gc）；对于栈帧对象来说，仅有 <code>ob_type</code>, <code>ob_size</code>, <code>f_code</code>, <code>f_valuestack</code> 几个成员变量会保留原有的值，因为这些成员变量与其他对象没有关联，而 <code>f_locals</code>, <code>f_trace</code>, <code>f_exc_type</code> 等指针依然会被通过 <code>Py_CLEAR</code> 置为 NULL，因为通过这些指针关联的对象可能会通过其他途径被回收，从而导致悬空指针的问题。</p><p>另一个优化策略是当代码对象 <code>co</code> 的成员指针 <code>co->co_zombieframe</code> 不为空，即再次执行相同栈帧时，会使用由 Python 线程维护的缓存栈帧链表 <code>state->free_list</code> 将栈帧对象存储下来，此时如果有新的栈帧对象被定义的话，可以直接从缓存栈帧链表 <code>state->free_list</code> 中获取一个已经分配内存的栈帧对象直接赋值并使用，以达到减少分配和回收内存的效果。此处可以结合分配栈帧的 <code>frame_alloc</code> 函数来看：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> PyFrameObject<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>frame_alloc</span>(PyCodeObject <span style=color:#f92672>*</span>code)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (state<span style=color:#f92672>-&gt;</span>free_list <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        f <span style=color:#f92672>=</span> PyObject_GC_NewVar(PyFrameObject, <span style=color:#f92672>&amp;</span>PyFrame_Type, extras);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef Py_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// frame_alloc() must not be called after _PyFrame_Fini()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        assert(state<span style=color:#f92672>-&gt;</span>numfree <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        assert(state<span style=color:#f92672>-&gt;</span>numfree <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#f92672>--</span>state<span style=color:#f92672>-&gt;</span>numfree;
</span></span><span style=display:flex><span>        f <span style=color:#f92672>=</span> state<span style=color:#f92672>-&gt;</span>free_list;
</span></span><span style=display:flex><span>        state<span style=color:#f92672>-&gt;</span>free_list <span style=color:#f92672>=</span> state<span style=color:#f92672>-&gt;</span>free_list<span style=color:#f92672>-&gt;</span>f_back;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Py_SIZE(f) <span style=color:#f92672>&lt;</span> extras) {
</span></span><span style=display:flex><span>            PyFrameObject <span style=color:#f92672>*</span>new_f <span style=color:#f92672>=</span> PyObject_GC_Resize(PyFrameObject, f, extras);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (new_f <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>                PyObject_GC_Del(f);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            f <span style=color:#f92672>=</span> new_f;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _Py_NewReference((PyObject <span style=color:#f92672>*</span>)f);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>可以看到在进行栈帧对象的分配时，会优先判断缓存栈帧链表 <code>state->free_list</code> 是否为空，不为空的话则会从其链表头部取出一个已经分配好内存的栈帧对象，对其赋值并使用。</p><p>这项优化（将未使用的栈帧对象保存在缓存栈帧链表中，并在创建其他栈帧对象时重复利用）与前者（在栈帧退出时将栈帧对象随代码对象保存下来，在执行相同代码对象时直接使用）的做法有些冲突，因此前者在最新的 <em><a href=https://github.com/python/cpython/commit/b11a951f16f0603d98de24fee5c023df83ea552c>PR 26076</a></em> 中已经被移除了。</p><p><img loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/co_zombieframe.png alt=co_zombieframe.png></p><h3 id=23-运行过程>2.3 运行过程<a hidden class=anchor aria-hidden=true href=#23-运行过程>#</a></h3><h4 id=231-调用流程>2.3.1 调用流程<a hidden class=anchor aria-hidden=true href=#231-调用流程>#</a></h4><p>Python 的 main 函数在 cpython/Programs/python.c 文件中，这部分实现比较简单，其调用链可以总结如下：</p><p><img loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/main.png alt=main.png></p><p>从调用链中可以看到，在真正执行 Python 代码之前，会先读取配置并进行初始化，这些配置会被保存到 cpython/Include/cpython/initconfig.h 文件定义的 PyConfig 结构体中，这个结构体包含了 Python 运行时的环境变量，运行模式等信息；而调用链中 <code>pymain_run_python</code> 函数后的五个分支就分别代表了 Python 通过命令行、文件、标准输入等方式运行的五种模式，但无论是那种模式，最终都会通过调用 <code>run_eval_code_obj</code> 以及 <code>PyEval_EvalCode</code> 函数来执行编译后的代码对象，后者就是 Python 虚拟机执行指令的入口之一。</p><h4 id=232-运行栈帧>2.3.2 运行栈帧<a hidden class=anchor aria-hidden=true href=#232-运行栈帧>#</a></h4><p>Python 虚拟机中执行指令的入口有 <code>PyEval_EvalCode</code> 和 <code>PyEval_EvalCodeEx</code>，前者相对于后者省略了部分参数，仅将必须的代码对象，全局变量和局部变量作为参数传入，其他参数均设为 NULL。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// cpython/Python/eval.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PyAPI_FUNC(PyObject <span style=color:#f92672>*</span>) PyEval_EvalCode(PyObject <span style=color:#f92672>*</span>, PyObject <span style=color:#f92672>*</span>, PyObject <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PyAPI_FUNC(PyObject <span style=color:#f92672>*</span>) PyEval_EvalCodeEx(PyObject <span style=color:#f92672>*</span>co,
</span></span><span style=display:flex><span>                                         PyObject <span style=color:#f92672>*</span>globals,
</span></span><span style=display:flex><span>                                         PyObject <span style=color:#f92672>*</span>locals,
</span></span><span style=display:flex><span>                                         PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>args, <span style=color:#66d9ef>int</span> argc,
</span></span><span style=display:flex><span>                                         PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwds, <span style=color:#66d9ef>int</span> kwdc,
</span></span><span style=display:flex><span>                                         PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>defs, <span style=color:#66d9ef>int</span> defc,
</span></span><span style=display:flex><span>                                         PyObject <span style=color:#f92672>*</span>kwdefs, PyObject <span style=color:#f92672>*</span>closure);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// cpython/Python/ceval.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PyEval_EvalCode</span>(PyObject <span style=color:#f92672>*</span>co, PyObject <span style=color:#f92672>*</span>globals, PyObject <span style=color:#f92672>*</span>locals)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> PyEval_EvalCodeEx(co,
</span></span><span style=display:flex><span>                      globals, locals,
</span></span><span style=display:flex><span>                      (PyObject <span style=color:#f92672>**</span>)NULL, <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                      (PyObject <span style=color:#f92672>**</span>)NULL, <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                      (PyObject <span style=color:#f92672>**</span>)NULL, <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                      NULL, NULL);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而 <code>PyEval_EvalCodeEx</code> 实际上会调用 <code>_PyEval_EvalCodeWithName</code> 函数，进行参数个数和类型的校验，以及线程状态的检查，并最终调用了 <code>_PyEval_EvalCode</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_PyEval_EvalCodeWithName</span>(PyObject <span style=color:#f92672>*</span>_co, PyObject <span style=color:#f92672>*</span>globals, PyObject <span style=color:#f92672>*</span>locals,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>args, Py_ssize_t argcount,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwnames, PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwargs,
</span></span><span style=display:flex><span>           Py_ssize_t kwcount, <span style=color:#66d9ef>int</span> kwstep,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>defs, Py_ssize_t defcount,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span>kwdefs, PyObject <span style=color:#f92672>*</span>closure,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span>name, PyObject <span style=color:#f92672>*</span>qualname)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyThreadState <span style=color:#f92672>*</span>tstate <span style=color:#f92672>=</span> _PyThreadState_GET();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _PyEval_EvalCode(tstate, _co, globals, locals,
</span></span><span style=display:flex><span>               args, argcount,
</span></span><span style=display:flex><span>               kwnames, kwargs,
</span></span><span style=display:flex><span>               kwcount, kwstep,
</span></span><span style=display:flex><span>               defs, defcount,
</span></span><span style=display:flex><span>               kwdefs, closure,
</span></span><span style=display:flex><span>               name, qualname);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PyEval_EvalCodeEx</span>(PyObject <span style=color:#f92672>*</span>_co, PyObject <span style=color:#f92672>*</span>globals, PyObject <span style=color:#f92672>*</span>locals,
</span></span><span style=display:flex><span>                  PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>args, <span style=color:#66d9ef>int</span> argcount,
</span></span><span style=display:flex><span>                  PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kws, <span style=color:#66d9ef>int</span> kwcount,
</span></span><span style=display:flex><span>                  PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>defs, <span style=color:#66d9ef>int</span> defcount,
</span></span><span style=display:flex><span>                  PyObject <span style=color:#f92672>*</span>kwdefs, PyObject <span style=color:#f92672>*</span>closure)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _PyEval_EvalCodeWithName(_co, globals, locals,
</span></span><span style=display:flex><span>                                    args, argcount,
</span></span><span style=display:flex><span>                                    kws, kws <span style=color:#f92672>!=</span> NULL <span style=color:#f92672>?</span> kws <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> NULL,
</span></span><span style=display:flex><span>                                    kwcount, <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>                                    defs, defcount,
</span></span><span style=display:flex><span>                                    kwdefs, closure,
</span></span><span style=display:flex><span>                                    NULL, NULL);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>_PyEval_EvalCode</code> 函数会对代码对象参数 <code>PyCodeObject *co</code> 及其参数进行常规检查，并初始化栈帧对象 <code>PyFrameObject *f</code>，并调用 <code>_PyEval_EvalFrame</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// cpython/Python/ceval.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_PyEval_EvalCode</span>(PyThreadState <span style=color:#f92672>*</span>tstate,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span>_co, PyObject <span style=color:#f92672>*</span>globals, PyObject <span style=color:#f92672>*</span>locals,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>args, Py_ssize_t argcount,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwnames, PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwargs,
</span></span><span style=display:flex><span>           Py_ssize_t kwcount, <span style=color:#66d9ef>int</span> kwstep,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>defs, Py_ssize_t defcount,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span>kwdefs, PyObject <span style=color:#f92672>*</span>closure,
</span></span><span style=display:flex><span>           PyObject <span style=color:#f92672>*</span>name, PyObject <span style=color:#f92672>*</span>qualname)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>retval <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Create the frame */</span>
</span></span><span style=display:flex><span>    PyFrameObject <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> _PyFrame_New_NoTrack(tstate, co, globals, locals);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>**</span>fastlocals <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>f_localsplus;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>**</span>freevars <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>f_localsplus <span style=color:#f92672>+</span> co<span style=color:#f92672>-&gt;</span>co_nlocals;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    retval <span style=color:#f92672>=</span> _PyEval_EvalFrame(tstate, f, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fail: <span style=color:#75715e>/* Jump here from prelude on failure */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* decref&#39;ing the frame can cause __del__ methods to get invoked,
</span></span></span><span style=display:flex><span><span style=color:#75715e>       which can call back into Python.  While we&#39;re done with the
</span></span></span><span style=display:flex><span><span style=color:#75715e>       current Python frame (f), the associated C stack is still in use,
</span></span></span><span style=display:flex><span><span style=color:#75715e>       so recursion_depth must be boosted for the duration.
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Py_REFCNT(f) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        Py_DECREF(f);
</span></span><span style=display:flex><span>        _PyObject_GC_TRACK(f);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>tstate<span style=color:#f92672>-&gt;</span>recursion_depth;
</span></span><span style=display:flex><span>        Py_DECREF(f);
</span></span><span style=display:flex><span>        <span style=color:#f92672>--</span>tstate<span style=color:#f92672>-&gt;</span>recursion_depth;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> retval;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>_PyEval_EvalFrame</code> 函数调用了一个函数指针，这个指针是随 Python 解释器初始化的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// cpython/Python/internal/pycore_ceval.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> PyObject<span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_PyEval_EvalFrame</span>(PyThreadState <span style=color:#f92672>*</span>tstate, PyFrameObject <span style=color:#f92672>*</span>f, <span style=color:#66d9ef>int</span> throwflag)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> tstate<span style=color:#f92672>-&gt;</span>interp<span style=color:#f92672>-&gt;</span>eval_frame(tstate, f, throwflag);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// cpython/Python/pystate.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PyInterpreterState <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PyInterpreterState_New</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    interp<span style=color:#f92672>-&gt;</span>eval_frame <span style=color:#f92672>=</span> _PyEval_EvalFrameDefault;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>_PyEval_EvalFrameDefault</code> 是整个调用链的终点，它的函数主体是一个循环，不断地读入字节码，并通过 switch 语句判断其类型并执行，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>PyObject<span style=color:#f92672>*</span> _Py_HOT_FUNCTION
</span></span><span style=display:flex><span><span style=color:#a6e22e>_PyEval_EvalFrameDefault</span>(PyThreadState <span style=color:#f92672>*</span>tstate, PyFrameObject <span style=color:#f92672>*</span>f, <span style=color:#66d9ef>int</span> throwflag)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _Py_EnsureTstateNotNULL(tstate);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>main_loop:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        opcode <span style=color:#f92672>=</span> _Py_OPCODE(<span style=color:#f92672>*</span>next_instr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> (opcode) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> TARGET(LOAD_CONST)<span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>            PREDICTED(LOAD_CONST);
</span></span><span style=display:flex><span>            PyObject <span style=color:#f92672>*</span>value <span style=color:#f92672>=</span> GETITEM(consts, oparg);
</span></span><span style=display:flex><span>            Py_INCREF(value);
</span></span><span style=display:flex><span>            PUSH(value);
</span></span><span style=display:flex><span>            FAST_DISPATCH();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>这就是整个调用和运行栈帧对象的过程了，整理如下：</p><p><img loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/python/py-eval.png alt=py-eval></p><h4 id=233-调试>2.3.3 调试<a hidden class=anchor aria-hidden=true href=#233-调试>#</a></h4><p>最后以 [1.2](#1.2 字节码) 节的 test.py 代码为例，简单地用 gdb 来进行 <code>_PyEval_EvalFrameDefault</code> 函数中逐个字节码指令的调试：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ gdb -ex r --args python3 test.py
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b _PyEval_EvalFrameDefault
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>1</span> at 0x41fa90: file Python/ceval.c, line 919.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> r
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> n
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span></code></pre></div><p>如果有对应版本的源码文件的话也可以直接断点在 <code>switch (opcode) {</code> 所在的行数，这里我们不断地往后执行直到这一行之后：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> layout split
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1487</span>            <span style=color:#66d9ef>case</span> TARGET<span style=color:#f92672>(</span>LOAD_CONST<span style=color:#f92672>)</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1488</span>                PREDICTED<span style=color:#f92672>(</span>LOAD_CONST<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>&gt; <span style=color:#ae81ff>1489</span>                PyObject *value <span style=color:#f92672>=</span> GETITEM<span style=color:#f92672>(</span>consts, oparg<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1490</span>                Py_INCREF<span style=color:#f92672>(</span>value<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1491</span>                PUSH<span style=color:#f92672>(</span>value<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1492</span>                FAST_DISPATCH<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1493</span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p opcode
</span></span><span style=display:flex><span>$1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p oparg
</span></span><span style=display:flex><span>$2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>可以看到在执行 LOAD_CONST 助记符时，其对应的 opcode 的十六进制表示为64，十进制表示为 100，LOAD_CONST 首先获取了 oparg 的值，并填入到栈顶；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  <span style=color:#ae81ff>2343</span>            <span style=color:#66d9ef>case</span> TARGET<span style=color:#f92672>(</span>STORE_NAME<span style=color:#f92672>)</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>&gt; <span style=color:#ae81ff>2344</span>                PyObject *name <span style=color:#f92672>=</span> GETITEM<span style=color:#f92672>(</span>names, oparg<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2345</span>                PyObject *v <span style=color:#f92672>=</span> POP<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2346</span>                PyObject *ns <span style=color:#f92672>=</span> f-&gt;f_locals;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2347</span>                int err;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2348</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ns <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2349</span>                    _PyErr_Format<span style=color:#f92672>(</span>tstate, PyExc_SystemError,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2350</span>                                  <span style=color:#e6db74>&#34;no locals found when storing %R&#34;</span>, name<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2351</span>                    Py_DECREF<span style=color:#f92672>(</span>v<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2352</span>                    goto error;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2353</span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2354</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>PyDict_CheckExact<span style=color:#f92672>(</span>ns<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2355</span>                    err <span style=color:#f92672>=</span> PyDict_SetItem<span style=color:#f92672>(</span>ns, name, v<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2356</span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2357</span>                    err <span style=color:#f92672>=</span> PyObject_SetItem<span style=color:#f92672>(</span>ns, name, v<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2358</span>                Py_DECREF<span style=color:#f92672>(</span>v<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2359</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>err !<span style=color:#f92672>=</span> 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2360</span>                    goto error;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2361</span>                DISPATCH<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2362</span>            <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>STORE_NAME 也是类似的，它从栈顶取出一个数值，并存储在局部命名空间中；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  <span style=color:#ae81ff>2828</span>            <span style=color:#66d9ef>case</span> TARGET<span style=color:#f92672>(</span>BUILD_MAP<span style=color:#f92672>)</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2829</span>                Py_ssize_t i;
</span></span><span style=display:flex><span>&gt; <span style=color:#ae81ff>2830</span>                PyObject *map <span style=color:#f92672>=</span> _PyDict_NewPresized<span style=color:#f92672>((</span>Py_ssize_t<span style=color:#f92672>)</span>oparg<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2831</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>map <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2832</span>                    goto error;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2833</span>                <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>i <span style=color:#f92672>=</span> oparg; i &gt; 0; i--<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2834</span>                    int err;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2835</span>                    PyObject *key <span style=color:#f92672>=</span> PEEK<span style=color:#f92672>(</span>2*i<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2836</span>                    PyObject *value <span style=color:#f92672>=</span> PEEK<span style=color:#f92672>(</span>2*i - 1<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2837</span>                    err <span style=color:#f92672>=</span> PyDict_SetItem<span style=color:#f92672>(</span>map, key, value<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2838</span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>err !<span style=color:#f92672>=</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2839</span>                        Py_DECREF<span style=color:#f92672>(</span>map<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2840</span>                        goto error;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2841</span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2842</span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2843</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2844</span>                <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>oparg--<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2845</span>                    Py_DECREF<span style=color:#f92672>(</span>POP<span style=color:#f92672>())</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2846</span>                    Py_DECREF<span style=color:#f92672>(</span>POP<span style=color:#f92672>())</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2847</span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2848</span>                PUSH<span style=color:#f92672>(</span>map<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2849</span>                DISPATCH<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2850</span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p opcode
</span></span><span style=display:flex><span>$9 <span style=color:#f92672>=</span> <span style=color:#ae81ff>105</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p oparg
</span></span><span style=display:flex><span>$10 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>BUILD_MAP 稍微复杂一些，它会构造一个 Python 中的字典对象（源码中 <code>PyDictObject</code> 结构体的实例对象，用哈希表实现），并不断地从栈帧上获取 key 和 value 插入到字典中；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  <span style=color:#ae81ff>2312</span>            <span style=color:#66d9ef>case</span> TARGET<span style=color:#f92672>(</span>LOAD_BUILD_CLASS<span style=color:#f92672>)</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2313</span>                _Py_IDENTIFIER<span style=color:#f92672>(</span>__build_class__<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2314</span>
</span></span><span style=display:flex><span>&gt; <span style=color:#ae81ff>2315</span>                PyObject *bc;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2316</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>PyDict_CheckExact<span style=color:#f92672>(</span>f-&gt;f_builtins<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2317</span>                    bc <span style=color:#f92672>=</span> _PyDict_GetItemIdWithError<span style=color:#f92672>(</span>f-&gt;f_builtins, &amp;PyId___build_class__<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2318</span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>bc <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2319</span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>!_PyErr_Occurred<span style=color:#f92672>(</span>tstate<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2320</span>                            _PyErr_SetString<span style=color:#f92672>(</span>tstate, PyExc_NameError,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2321</span>                                             <span style=color:#e6db74>&#34;__build_class__ not found&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2322</span>                        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2323</span>                        goto error;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2324</span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2325</span>                    Py_INCREF<span style=color:#f92672>(</span>bc<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2326</span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2327</span>                <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2328</span>                    PyObject *build_class_str <span style=color:#f92672>=</span> _PyUnicode_FromId<span style=color:#f92672>(</span>&amp;PyId___build_class__<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2329</span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>build_class_str <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2330</span>                        goto error;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2331</span>                    bc <span style=color:#f92672>=</span> PyObject_GetItem<span style=color:#f92672>(</span>f-&gt;f_builtins, build_class_str<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2332</span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>bc <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2333</span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>_PyErr_ExceptionMatches<span style=color:#f92672>(</span>tstate, PyExc_KeyError<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2334</span>                            _PyErr_SetString<span style=color:#f92672>(</span>tstate, PyExc_NameError,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2335</span>                                             <span style=color:#e6db74>&#34;__build_class__ not found&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2336</span>                        goto error;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2337</span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2338</span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2339</span>                PUSH<span style=color:#f92672>(</span>bc<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2340</span>                DISPATCH<span style=color:#f92672>()</span>;
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2341</span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p opcode
</span></span><span style=display:flex><span>$11 <span style=color:#f92672>=</span> <span style=color:#ae81ff>71</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p oparg
</span></span><span style=display:flex><span>$12 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>LOAD_BUILD_CLASS 则会从内置命名空间中通过哈希方法找到函数指针，并插入栈顶；</p><p>其他的字节码指令还有很多，都可以通过阅读源码或者使用 gdb 调试的方法找到其实际执行的代码；相比于汇编指令，字节码指令实际上代表了由许多行代码组成的功能，而 Python 虚拟机则是通过字节码指令模拟出了对汇编指令的执行过程。</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://prov1dence.top/posts/python/python-source-code-coroutine/><span class=title>« Prev Page</span><br><span>Python 源码学习（5）：协程</span>
</a><a class=next href=https://prov1dence.top/posts/python/source-code-3-list-and-dict/><span class=title>Next Page »</span><br><span>Python 源码学习（3）：list 类型</span></a></nav></footer></article></main><footer class=footer><span>Zhengyu &copy; 2025</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>