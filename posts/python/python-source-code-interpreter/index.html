<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Python 源码学习（4）：编译器和虚拟机 | 尾張</title>
<meta name=keywords content>
<meta name=description content="Python 源码学习（4）：编译器和虚拟机 Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。
Python 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。
1 Python 编译器 1.1 代码对象 Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：
# test.py def Square(a): return a * a print(f&#34;result:\t\t{Square(5)}&#34;) # main.py f = &#34;test.py&#34; code_obj = compile(open(f).read(), f, 'exec') exec(code_obj) print(f&#34;code_obj:\t{code_obj}&#34;) print(f&#34;type:\t\t{type(code_obj)}&#34;) $ python3 main.py result: 25 code_obj: <code object <module> at 0x7f052c156b30, file &#34;test.">
<meta name=author content="Zhengyu">
<link rel=canonical href=http://zintrulcre.github.io/posts/python/python-source-code-interpreter/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Python 源码学习（4）：编译器和虚拟机">
<meta property="og:description" content="Python 源码学习（4）：编译器和虚拟机 Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。
Python 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。
1 Python 编译器 1.1 代码对象 Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：
# test.py def Square(a): return a * a print(f&#34;result:\t\t{Square(5)}&#34;) # main.py f = &#34;test.py&#34; code_obj = compile(open(f).read(), f, 'exec') exec(code_obj) print(f&#34;code_obj:\t{code_obj}&#34;) print(f&#34;type:\t\t{type(code_obj)}&#34;) $ python3 main.py result: 25 code_obj: <code object <module> at 0x7f052c156b30, file &#34;test.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://zintrulcre.github.io/posts/python/python-source-code-interpreter/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-05-26T10:18:52+08:00">
<meta property="article:modified_time" content="2021-05-26T10:18:52+08:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Python 源码学习（4）：编译器和虚拟机">
<meta name=twitter:description content="Python 源码学习（4）：编译器和虚拟机 Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。
Python 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。
1 Python 编译器 1.1 代码对象 Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：
# test.py def Square(a): return a * a print(f&#34;result:\t\t{Square(5)}&#34;) # main.py f = &#34;test.py&#34; code_obj = compile(open(f).read(), f, 'exec') exec(code_obj) print(f&#34;code_obj:\t{code_obj}&#34;) print(f&#34;type:\t\t{type(code_obj)}&#34;) $ python3 main.py result: 25 code_obj: <code object <module> at 0x7f052c156b30, file &#34;test.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://zintrulcre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python 源码学习（4）：编译器和虚拟机","item":"http://zintrulcre.github.io/posts/python/python-source-code-interpreter/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 源码学习（4）：编译器和虚拟机","name":"Python 源码学习（4）：编译器和虚拟机","description":"Python 源码学习（4）：编译器和虚拟机 Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。\nPython 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。\n1 Python 编译器 1.1 代码对象 Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：\n# test.py def Square(a): return a * a print(f\u0026#34;result:\\t\\t{Square(5)}\u0026#34;) # main.py f = \u0026#34;test.py\u0026#34; code_obj = compile(open(f).read(), f, \u0026#39;exec\u0026#39;) exec(code_obj) print(f\u0026#34;code_obj:\\t{code_obj}\u0026#34;) print(f\u0026#34;type:\\t\\t{type(code_obj)}\u0026#34;) $ python3 main.py result: 25 code_obj: \u0026lt;code object \u0026lt;module\u0026gt; at 0x7f052c156b30, file \u0026#34;test.","keywords":[],"articleBody":"Python 源码学习（4）：编译器和虚拟机 Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 CPython。\nPython 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。\n1 Python 编译器 1.1 代码对象 Python 提供了内置函数 compile，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：\n# test.py def Square(a): return a * a print(f\"result:\\t\\t{Square(5)}\") # main.py f = \"test.py\" code_obj = compile(open(f).read(), f, 'exec') exec(code_obj) print(f\"code_obj:\\t{code_obj}\") print(f\"type:\\t\\t{type(code_obj)}\") $ python3 main.py result: 25 code_obj: at 0x7f052c156b30, file \"test.py\", line 1 type: 'code' 可以看到生成的 code_obj 对象的类型是 class 'code'，它在源码中对应的结构体是代码对象 PyCodeObject；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：\n// Include/cpython/code.h  /* Bytecode object */ struct PyCodeObject { PyObject_HEAD int co_argcount; /* #arguments, except *args */ int co_posonlyargcount; /* #positional only arguments */ int co_kwonlyargcount; /* #keyword only arguments */ int co_nlocals; /* #local variables */ int co_stacksize; /* #entries needed for evaluation stack */ int co_flags; /* CO_..., see below */ int co_firstlineno; /* first source line number */ PyObject *co_code; /* instruction opcodes */ PyObject *co_consts; /* list (constants used) */ PyObject *co_names; /* list of strings (names used) */ PyObject *co_varnames; /* tuple of strings (local variable names) */ PyObject *co_freevars; /* tuple of strings (free variable names) */ PyObject *co_cellvars; /* tuple of strings (cell variable names) */ /* The rest aren't used in either hash or comparisons, except for co_name, used in both. This is done to preserve the name and line number for tracebacks and debuggers; otherwise, constant de-duplication would collapse identical functions/lambdas defined on different lines. */ Py_ssize_t *co_cell2arg; /* Maps cell vars which are arguments. */ PyObject *co_filename; /* unicode (where it was loaded from) */ PyObject *co_name; /* unicode (name, for reference) */ PyObject *co_lnotab; /* string (encoding addrlineno mapping) See Objects/lnotab_notes.txt for details. */ void *co_zombieframe; /* for optimization only (see frameobject.c) */ PyObject *co_weakreflist; /* to support weakrefs to code objects */ /* Scratch space for extra data relating to the code object. Type is a void* to keep the format private in codeobject.c to force people to go through the proper APIs. */ void *co_extra; /* Per opcodes just-in-time cache * * To reduce cache size, we use indirect mapping from opcode index to * cache object: * cache = co_opcache[co_opcache_map[next_instr - first_instr] - 1] */ // co_opcache_map is indexed by (next_instr - first_instr).  // * 0 means there is no cache for this opcode.  // * n  0 means there is cache in co_opcache[n-1].  unsigned char *co_opcache_map; _PyOpcache *co_opcache; int co_opcache_flag; // used to determine when create a cache.  unsigned char co_opcache_size; // length of co_opcache. }; 其中比较重要的成员有两个，分别是编译后生成的指令序列 co_code 和执行当前代码块所需的栈空间大小 co_stacksize。\n1.2 字节码 在所有的这些成员变量中，PyObject *co_code 存储了编译后生成的指令序列，它是以字节的方式存储的：\n# test.py def Square(a): return a * a print(f\"result:\\t\\t{Square(5)}\") # main.py f = \"test.py\" code_obj = compile(open(f).read(), f, 'exec') print(f\"code obj:\\t{code_obj}\") print(f\"stack size:\\t{code_obj.co_stacksize}\") result = exec(code_obj) bytecode = code_obj.co_code print(f\"bytecode:\\t{bytecode}\") $ python3 main.py code obj: at 0x7f26cea5ab30, file \"test.py\", line 1 stack size: 4 result: 25 bytecode: b'd\\x00d\\x01\\x84\\x00Z\\x00e\\x01d\\x02e\\x00d\\x03\\x83\\x01\\x9b\\x00\\x9d\\x02\\x83\\x01\\x01\\x00d\\x04S\\x00' 我们可以使用 Python 内置模块 dis 来将这些字节码反编译成类似于汇编语言的格式：\nimport dis dis.dis(bytecode) 0 LOAD_CONST 0 (0) 2 LOAD_CONST 1 (1) 4 MAKE_FUNCTION 0 6 STORE_NAME 0 (0) 8 LOAD_NAME 1 (1) 10 LOAD_CONST 2 (2) 12 LOAD_NAME 0 (0) 14 LOAD_CONST 3 (3) 16 CALL_FUNCTION 1 18 FORMAT_VALUE 0 20 BUILD_STRING 2 22 CALL_FUNCTION 1 24 POP_TOP 26 LOAD_CONST 4 (4) 28 RETURN_VALUE 在反编译后的输出结果中，第一列代表字节码中每一条指令的偏移量 offset；第二列代表各条助记符 mnemonics 的名称，这些助记符可以很方便地帮助我们理解在后续的步骤中 Python 虚拟机要执行的事件；第三列则是每条指令的操作数 opargs。\n同时，在字节码对应的十六进制表示中，每一位数字也分别代表了不同的助记符和操作数，我们可以直接通过打印出字节码的十六进制以查看其内容：\nprint(bytecode.hex()) 64 00 64 01 84 00 5a 00 65 01 64 02 65 00 64 03 83 01 9b 00 9d 02 83 01 01 00 64 04 53 00 以上面反编译后的输出为例，在 offset == 0 的地方可以找到数字 64，即 LOAD_CONST 加载常量助记符对应的操作码 opcode，其后紧跟着的是它的操作数 opargs == 0；而指令第四行对应的 offset == 6，可以看到 STORE_NAME 助记符对应的操作码 opcode == 5a ，其操作数 opargs == 0；以此类推。\nPython 的 opcode 模块提供了关于 Python 虚拟机中助记符和操作码的相关信息，也可以在源码的 Include/opcode.h 中找到相关定义：\nimport opcode print(opcode.opname[0x64]) print(opcode.opname[0x5a]) print(opcode.opmap['LOAD_NAME']) print(opcode.opmap['RETURN_VALUE']) LOAD_CONST STORE_NAME 101 83 1.3 编译原理 Python 编译器的实现和其他语言类似，包含了词法分析 Lexical，语法分析 Syntax Analysis 和语义分析 Semantic Analysis 等步骤，本文不再赘述编译原理的部分。\n2 Python 虚拟机 类似于 x86-64, arm 平台和 Java 虚拟机，Python 虚拟机也是 基于栈的（Stack-Based），它的函数调用都是通过调用栈 call stack 和栈帧 stackframe 来实现的。\n2.1 调用栈 调用栈是 CPU 寄存器中的一块内存区域，它是一种 FILO 的数据结构，可以进行插入或删除操作的一边称为栈顶，另一边则称为栈底；对于最常见的 x86-64 架构来说，栈地址空间是自顶向下（head down）增长的：\n在 x86-64 平台下，它拥有 16 个通用寄存器 general-purpose registers，寄存器被集成在 CPU 芯片上，其中 rbp 寄存器保存当前栈帧的栈底（本次函数调用开始时的位置），rsp 寄存器保存当前栈帧的栈顶（函数运行时的当前位置），rbp 和 rsp 之间的空间则被称为本次函数调用的栈帧 stack frame；在每一次发生函数调用时，调用栈上都会维护一个独立的栈帧以存储函数返回值、参数、局部变量等信息；其他通用寄存器的功能如下。\n栈相关的最常见操作有 push 和 pop，push 操作会将一个操作数插入栈顶，这包含了两个步骤，分别是先将 rsp 寄存器保存的地址减去 8，再将操作数写入到这个地址中；而 pop 则正好相反，它先从 rsp 寄存器存储的地址取出数据，写入到其他寄存器中，再对其地址加上 8。\n以调试一个简单的 Swap 函数调用为例；本文使用的所有汇编语言都是 AT\u0026T Syntax 的：\n// main.cpp #include  using namespace std; void Swap(int\u0026 a, int \u0026b) { int c = a; a = b; b = c; } int main() { int a = 5, b = 9; Swap(a, b); cout  a  ' '  b  endl; return 0; } 用 gdb 打开并在 main 函数处断点；在 main 函数栈帧中，会通过 movl 指令将两个常量拷贝到内存中：\n$ g++ -g -O0 -o main main.cpp $ gdb main (gdb) b main (gdb) r (gdb) layout reg  0x400852  movl $0x5,-0x14(%rbp) # 将常量 9 保存在 rbp - 18 的位置 0x400859  movl $0x9,-0x18(%rbp) # 将常量 5 保存在 rbp - 14 的位置 在调用函数 Swap 前，会分别将两个参数存入 rdi 和 rsi 寄存器中：\n0x400860 ()+23 lea -0x18(%rbp),%rdx 0x400864 ()+27 lea -0x14(%rbp),%rax 0x400868 ()+31 mov %rdx,%rsi 0x40086b ()+34 mov %rax,%rdi  0x40086e ()+37 callq 0x40081d (int\u0026, int\u0026) (gdb) p *$rsi $6 = 9 (gdb) p *$rdi $7 = 5 在 callq 指令处使用 stepi 进入到 Swap 函数中，此时 rbp 和 rsp 指针还分别指向 main 函数栈帧的底部和顶部，能够发现栈地址空间的确是向下增长的：\n 0x40086e ()+37 callq 0x40081d (int\u0026, int\u0026) (gdb) si  0x40081d (int\u0026, int\u0026) push %rbp 0x40081e (int\u0026, int\u0026)+1 mov %rsp,%rbp rbp 0x7fffffffe110 0x7fffffffe110 rsp 0x7fffffffe0e8 0x7fffffffe0e8 此时栈帧结构大致如下：\n执行接下来的 push 指令，将 rbp 的值存入栈顶，可以看到 rsp 的值发生了变化：\n(gdb) ni 0x40081d (int\u0026, int\u0026) push %rbp  0x40081e (int\u0026, int\u0026)+1 mov %rsp,%rbp rbp 0x7fffffffe110 0x7fffffffe110 rsp 0x7fffffffe0e0 0x7fffffffe0e0 继续执行下一条 mov 指令，重置 rbp 的值，进入新的栈帧：\n(gdb) ni rbp 0x7fffffffe0e0 0x7fffffffe0e0 rsp 0x7fffffffe0e0 0x7fffffffe0e0 此时栈帧结构变成了如下：\n再经过一系列的 mov 指令操作，将 a 和 b 的值交换之后，执行下一条 pop 指令，将存储的上一个栈帧地址写入 rbp 中，同时修改 rsp；之后再执行 retq 指令即可继续运行 main 函数的下一条汇编指令了：\n 0x400847 (int\u0026, int\u0026)+42 pop %rbp 0x400848 (int\u0026, int\u0026)+43 retq rbp 0x7fffffffe0e0 0x7fffffffe0e0 rsp 0x7fffffffe0e0 0x7fffffffe0e0 (gdb) ni 0x400847 (int\u0026, int\u0026)+42 pop %rbp  0x400848 (int\u0026, int\u0026)+43 retq rbp 0x7fffffffe110 0x7fffffffe110 rsp 0x7fffffffe0e8 0x7fffffffe0e8 Python 中函数调用链和调用栈之间的关系也和 x86-64 平台类似，只不过是把代码块和栈帧分别进行了封装而已。\n2.2 栈帧对象 Python 中的代码对象 PyCodeObject 本身只包含了字节码相关的信息，并不具备用于执行字节码所需要的上下文信息，因此需要引入栈帧对象 PyFrameObject，作为代码对象运行的容器，并用来模拟其他平台下的栈帧：\n// cpython/Include/frameobject.h struct _frame { PyObject_VAR_HEAD struct _frame *f_back; /* previous frame, or NULL */ PyCodeObject *f_code; /* code segment */ PyObject *f_builtins; /* builtin symbol table (PyDictObject) */ PyObject *f_globals; /* global symbol table (PyDictObject) */ PyObject *f_locals; /* local symbol table (any mapping) */ PyObject **f_valuestack; /* points after the last local */ PyObject *f_trace; /* Trace function */ int f_stackdepth; /* Depth of value stack */ char f_trace_lines; /* Emit per-line trace events? */ char f_trace_opcodes; /* Emit per-opcode trace events? */ /* Borrowed reference to a generator, or NULL */ PyObject *f_gen; int f_lasti; /* Last instruction if called */ /* Call PyFrame_GetLineNumber() instead of reading this field directly. As of 2.3 f_lineno is only valid when tracing is active (i.e. when f_trace is set). At other times we use PyCode_Addr2Line to calculate the line from the current bytecode index. */ int f_lineno; /* Current line number */ int f_iblock; /* index in f_blockstack */ PyFrameState f_state; /* What state the frame is in */ PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */ PyObject *f_localsplus[1]; /* locals+stack, dynamically sized */ }; // cpython/Include/pyframe.h typedef struct _frame PyFrameObject; 可以看到栈帧对象中大致包含了以下数据，它们构成了 Python 虚拟机执行当前栈帧所需要的所有上下文：\n 上一个运行的栈帧对象的指针 struct _frame *f_back；Python 虚拟机中运行的所有栈帧对象的 *f_back 共同组成调用栈结构，仅有初始栈帧有 f_back == NULL； 代码对象指针 PyCodeObject *f_code，它包含了当前运行栈帧所执行的字节码信息； 代码对象执行期间的栈结构 PyObject **f_valuestack，在对字节码进行运算时，需要从栈顶读取数据，并将运算结果存储在栈顶，f_valuestack 就是用来用来存储数据的栈结构，它的大小由对应的代码对象 f_code 的堆栈大小决定； 代码对象执行期间使用的栈结构的深度 int f_stackdepth； 上一条执行过的字节码指令 int f_lasti，类似于 rip 寄存器； 内置命名空间、全局命名空间、局部命名空间的指针 PyObject *f_builtins, PyObject *f_globals, PyObject *f_locals，它们是用来实现 Python 中从符号到对象的映射的结构，一般用字典实现，暂不讨论； 用于跟踪代码执行情况的函数指针 PyObject *f_trace 和相关数据 char f_trace_lines, char f_trace_opcodes，暂不讨论； 用于执行生成器代码的数据 PyObject *f_gen，暂不讨论；  Python 在 sys 模块中提供了 _getframe 函数来获取栈帧对象；以一个简单的 Swap 函数为例，在最深层的函数调用处打印出栈帧对象的信息：\nimport sys def Swap(a, b): frame = sys._getframe() while frame is not None: print(f\"frame:\\t{frame}\") print(f\"name:\\t{frame.f_code.co_name}\") print(f\"locals:\\t{frame.f_locals.keys()}\\n\") print(f\"back:\\t{frame.f_back}\\n\") frame = frame.f_back return b, a def main(): a, b = 5, 9 a, b = Swap(a, b) print(a, b) if __name__ == \"__main__\": main() 运行后可以观察到，在 Python 程序开始执行时会先创建一个叫做 module 的栈帧对象用于执行当前脚本中的代码；在每次函数调用的过程中，都会创建出一个新的栈帧对象，这些栈帧对象会使用 f_back 指针保存上一个执行栈帧的地址，并在之后调用其他函数的时候被压入栈顶：\n$ python3 main.py frame: '/main.py', line 36, code Swap name: Swap locals: dict_keys(['a', 'b', 'frame']) back: '/main.py', line 46, code main frame: '/main.py', line 46, code main name: main locals: dict_keys(['a', 'b']) back: '/main.py', line 50, code  frame: '/main.py', line 50, code  name:  locals: dict_keys(['__name__', '__doc__', '__package__', '__loader__', '__spec__', '__annotations__', '__builtins__', '__file__', '__cached__', 'sys', 'Swap', 'main']) back: None 9 5 2.2.1 回收和分配 前文讨论过类型对象，从刚才获取栈帧对象的例子里能够看到通过 sys._getframe() 获取的 frame 对象的类型名为 frame，不难找到它的类型对象实际上是 PyFrame_Type，我们可以从类型对象初始化时使用的函数指针找到它的相关操作：\nPyTypeObject PyFrame_Type = { PyVarObject_HEAD_INIT(\u0026PyType_Type, 0) \"frame\", sizeof(PyFrameObject), sizeof(PyObject *), (destructor)frame_dealloc, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ (reprfunc)frame_repr, /* tp_repr */ 0, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ 0, /* tp_hash */ 0, /* tp_call */ 0, /* tp_str */ PyObject_GenericGetAttr, /* tp_getattro */ PyObject_GenericSetAttr, /* tp_setattro */ 0, /* tp_as_buffer */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */ 0, /* tp_doc */ (traverseproc)frame_traverse, /* tp_traverse */ (inquiry)frame_tp_clear, /* tp_clear */ 0, /* tp_richcompare */ 0, /* tp_weaklistoffset */ 0, /* tp_iter */ 0, /* tp_iternext */ frame_methods, /* tp_methods */ frame_memberlist, /* tp_members */ frame_getsetlist, /* tp_getset */ 0, /* tp_base */ 0, /* tp_dict */ }; 其中对栈帧对象进行析构的函数是 frame_dealloc，此处省略了部分代码：\n#define PyFrame_MAXFREELIST 200  static void _Py_HOT_FUNCTION frame_dealloc(PyFrameObject *f) { // ...  Py_XDECREF(f-f_back); Py_DECREF(f-f_builtins); Py_DECREF(f-f_globals); Py_CLEAR(f-f_locals); Py_CLEAR(f-f_trace); PyCodeObject *co = f-f_code; if (co-co_zombieframe == NULL) { co-co_zombieframe = f; } else { struct _Py_frame_state *state = get_frame_state(); #ifdef Py_DEBUG  // frame_dealloc() must not be called after _PyFrame_Fini()  assert(state-numfree != -1); #endif  if (state-numfree  PyFrame_MAXFREELIST) { ++state-numfree; f-f_back = state-free_list; state-free_list = f; } else { PyObject_GC_Del(f); } } Py_DECREF(co); Py_TRASHCAN_SAFE_END(f) } struct _Py_frame_state { PyFrameObject *free_list; /* number of frames currently in free_list */ int numfree; }; 这是一个使用非常高频的函数（几乎每一次栈帧退出时都会调用），因此采用了一些策略来进行优化以降低调用函数的开销；一种是在首次进行栈帧对象 f 的回收时会先判断栈帧对象关联的代码对象 co 的成员指针 co_zombieframe 是否为空 if (co-co_zombieframe == NULL)；如果是，则会将该栈帧对象 f 保存在代码对象的这个指针中 co-co_zombieframe = f，这样的话在下一次执行相同的代码对象 co 时，就无需再次重新进行栈帧对象 f 的内存分配（只要代码对象 co 不因为引用计数降低为 0 而被 gc）；对于栈帧对象来说，仅有 ob_type, ob_size, f_code, f_valuestack 几个成员变量会保留原有的值，因为这些成员变量与其他对象没有关联，而 f_locals, f_trace, f_exc_type 等指针依然会被通过 Py_CLEAR 置为 NULL，因为通过这些指针关联的对象可能会通过其他途径被回收，从而导致悬空指针的问题。\n另一个优化策略是当代码对象 co 的成员指针 co-co_zombieframe 不为空，即再次执行相同栈帧时，会使用由 Python 线程维护的缓存栈帧链表 state-free_list 将栈帧对象存储下来，此时如果有新的栈帧对象被定义的话，可以直接从缓存栈帧链表 state-free_list 中获取一个已经分配内存的栈帧对象直接赋值并使用，以达到减少分配和回收内存的效果。此处可以结合分配栈帧的 frame_alloc 函数来看：\nstatic inline PyFrameObject* frame_alloc(PyCodeObject *code) { // ...  if (state-free_list == NULL) { f = PyObject_GC_NewVar(PyFrameObject, \u0026PyFrame_Type, extras); if (f == NULL) { return NULL; } } else { #ifdef Py_DEBUG  // frame_alloc() must not be called after _PyFrame_Fini()  assert(state-numfree != -1); #endif  assert(state-numfree  0); --state-numfree; f = state-free_list; state-free_list = state-free_list-f_back; if (Py_SIZE(f)  extras) { PyFrameObject *new_f = PyObject_GC_Resize(PyFrameObject, f, extras); if (new_f == NULL) { PyObject_GC_Del(f); return NULL; } f = new_f; } _Py_NewReference((PyObject *)f); } // ... } 可以看到在进行栈帧对象的分配时，会优先判断缓存栈帧链表 state-free_list 是否为空，不为空的话则会从其链表头部取出一个已经分配好内存的栈帧对象，对其赋值并使用。\n这项优化（将未使用的栈帧对象保存在缓存栈帧链表中，并在创建其他栈帧对象时重复利用）与前者（在栈帧退出时将栈帧对象随代码对象保存下来，在执行相同代码对象时直接使用）的做法有些冲突，因此前者在最新的 PR 26076 中已经被移除了。\n2.3 运行过程 2.3.1 调用流程 Python 的 main 函数在 cpython/Programs/python.c 文件中，这部分实现比较简单，其调用链可以总结如下：\n从调用链中可以看到，在真正执行 Python 代码之前，会先读取配置并进行初始化，这些配置会被保存到 cpython/Include/cpython/initconfig.h 文件定义的 PyConfig 结构体中，这个结构体包含了 Python 运行时的环境变量，运行模式等信息；而调用链中 pymain_run_python 函数后的五个分支就分别代表了 Python 通过命令行、文件、标准输入等方式运行的五种模式，但无论是那种模式，最终都会通过调用 run_eval_code_obj 以及 PyEval_EvalCode 函数来执行编译后的代码对象，后者就是 Python 虚拟机执行指令的入口之一。\n2.3.2 运行栈帧 Python 虚拟机中执行指令的入口有 PyEval_EvalCode 和 PyEval_EvalCodeEx，前者相对于后者省略了部分参数，仅将必须的代码对象，全局变量和局部变量作为参数传入，其他参数均设为 NULL。\n// cpython/Python/eval.h PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyObject *, PyObject *, PyObject *); PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure); // cpython/Python/ceval.c PyObject * PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals) { return PyEval_EvalCodeEx(co, globals, locals, (PyObject **)NULL, 0, (PyObject **)NULL, 0, (PyObject **)NULL, 0, NULL, NULL); } 而 PyEval_EvalCodeEx 实际上会调用 _PyEval_EvalCodeWithName 函数，进行参数个数和类型的校验，以及线程状态的检查，并最终调用了 _PyEval_EvalCode 函数：\nPyObject * _PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals, PyObject *const *args, Py_ssize_t argcount, PyObject *const *kwnames, PyObject *const *kwargs, Py_ssize_t kwcount, int kwstep, PyObject *const *defs, Py_ssize_t defcount, PyObject *kwdefs, PyObject *closure, PyObject *name, PyObject *qualname) { PyThreadState *tstate = _PyThreadState_GET(); return _PyEval_EvalCode(tstate, _co, globals, locals, args, argcount, kwnames, kwargs, kwcount, kwstep, defs, defcount, kwdefs, closure, name, qualname); } PyObject * PyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals, PyObject *const *args, int argcount, PyObject *const *kws, int kwcount, PyObject *const *defs, int defcount, PyObject *kwdefs, PyObject *closure) { return _PyEval_EvalCodeWithName(_co, globals, locals, args, argcount, kws, kws != NULL ? kws + 1 : NULL, kwcount, 2, defs, defcount, kwdefs, closure, NULL, NULL); } _PyEval_EvalCode 函数会对代码对象参数 PyCodeObject *co 及其参数进行常规检查，并初始化栈帧对象 PyFrameObject *f，并调用 _PyEval_EvalFrame：\n// cpython/Python/ceval.c PyObject * _PyEval_EvalCode(PyThreadState *tstate, PyObject *_co, PyObject *globals, PyObject *locals, PyObject *const *args, Py_ssize_t argcount, PyObject *const *kwnames, PyObject *const *kwargs, Py_ssize_t kwcount, int kwstep, PyObject *const *defs, Py_ssize_t defcount, PyObject *kwdefs, PyObject *closure, PyObject *name, PyObject *qualname) { PyObject *retval = NULL; /* Create the frame */ PyFrameObject *f = _PyFrame_New_NoTrack(tstate, co, globals, locals); if (f == NULL) { return NULL; } PyObject **fastlocals = f-f_localsplus; PyObject **freevars = f-f_localsplus + co-co_nlocals; // ...  retval = _PyEval_EvalFrame(tstate, f, 0); fail: /* Jump here from prelude on failure */ /* decref'ing the frame can cause __del__ methods to get invoked, which can call back into Python. While we're done with the current Python frame (f), the associated C stack is still in use, so recursion_depth must be boosted for the duration. */ if (Py_REFCNT(f)  1) { Py_DECREF(f); _PyObject_GC_TRACK(f); } else { ++tstate-recursion_depth; Py_DECREF(f); --tstate-recursion_depth; } return retval; } _PyEval_EvalFrame 函数调用了一个函数指针，这个指针是随 Python 解释器初始化的：\n// cpython/Python/internal/pycore_ceval.h static inline PyObject* _PyEval_EvalFrame(PyThreadState *tstate, PyFrameObject *f, int throwflag) { return tstate-interp-eval_frame(tstate, f, throwflag); } // cpython/Python/pystate.c PyInterpreterState * PyInterpreterState_New(void) { // ...  interp-eval_frame = _PyEval_EvalFrameDefault; // ... } _PyEval_EvalFrameDefault 是整个调用链的终点，它的函数主体是一个循环，不断地读入字节码，并通过 switch 语句判断其类型并执行，\nPyObject* _Py_HOT_FUNCTION _PyEval_EvalFrameDefault(PyThreadState *tstate, PyFrameObject *f, int throwflag) { _Py_EnsureTstateNotNULL(tstate); // ...  main_loop: for (;;) { opcode = _Py_OPCODE(*next_instr); switch (opcode) { case TARGET(LOAD_CONST): { PREDICTED(LOAD_CONST); PyObject *value = GETITEM(consts, oparg); Py_INCREF(value); PUSH(value); FAST_DISPATCH(); // ...  } // ... 这就是整个调用和运行栈帧对象的过程了，整理如下：\n2.3.3 调试 最后以 [1.2](#1.2 字节码) 节的 test.py 代码为例，简单地用 gdb 来进行 _PyEval_EvalFrameDefault 函数中逐个字节码指令的调试：\n$ gdb -ex r --args python3 test.py (gdb) b _PyEval_EvalFrameDefault Breakpoint 1 at 0x41fa90: file Python/ceval.c, line 919. (gdb) r (gdb) n # ... 如果有对应版本的源码文件的话也可以直接断点在 switch (opcode) { 所在的行数，这里我们不断地往后执行直到这一行之后：\n(gdb) layout split 1487 case TARGET(LOAD_CONST): { 1488 PREDICTED(LOAD_CONST);  1489 PyObject *value = GETITEM(consts, oparg); 1490 Py_INCREF(value); 1491 PUSH(value); 1492 FAST_DISPATCH(); 1493 } (gdb) p opcode $1 = 100 (gdb) p oparg $2 = 0 可以看到在执行 LOAD_CONST 助记符时，其对应的 opcode 的十六进制表示为64，十进制表示为 100，LOAD_CONST 首先获取了 oparg 的值，并填入到栈顶；\n2343 case TARGET(STORE_NAME): {  2344 PyObject *name = GETITEM(names, oparg); 2345 PyObject *v = POP(); 2346 PyObject *ns = f-f_locals; 2347 int err; 2348 if (ns == NULL) { 2349 _PyErr_Format(tstate, PyExc_SystemError, 2350 \"no locals found when storing %R\", name); 2351 Py_DECREF(v); 2352 goto error; 2353 } 2354 if (PyDict_CheckExact(ns)) 2355 err = PyDict_SetItem(ns, name, v); 2356 else 2357 err = PyObject_SetItem(ns, name, v); 2358 Py_DECREF(v); 2359 if (err != 0) 2360 goto error; 2361 DISPATCH(); 2362 } STORE_NAME 也是类似的，它从栈顶取出一个数值，并存储在局部命名空间中；\n2828 case TARGET(BUILD_MAP): { 2829 Py_ssize_t i;  2830 PyObject *map = _PyDict_NewPresized((Py_ssize_t)oparg); 2831 if (map == NULL) 2832 goto error; 2833 for (i = oparg; i  0; i--) { 2834 int err; 2835 PyObject *key = PEEK(2*i); 2836 PyObject *value = PEEK(2*i - 1); 2837 err = PyDict_SetItem(map, key, value); 2838 if (err != 0) { 2839 Py_DECREF(map); 2840 goto error; 2841 } 2842 } 2843 2844 while (oparg--) { 2845 Py_DECREF(POP()); 2846 Py_DECREF(POP()); 2847 } 2848 PUSH(map); 2849 DISPATCH(); 2850 } (gdb) p opcode $9 = 105 (gdb) p oparg $10 = 0 BUILD_MAP 稍微复杂一些，它会构造一个 Python 中的字典对象（源码中 PyDictObject 结构体的实例对象，用哈希表实现），并不断地从栈帧上获取 key 和 value 插入到字典中；\n2312 case TARGET(LOAD_BUILD_CLASS): { 2313 _Py_IDENTIFIER(__build_class__); 2314  2315 PyObject *bc; 2316 if (PyDict_CheckExact(f-f_builtins)) { 2317 bc = _PyDict_GetItemIdWithError(f-f_builtins, \u0026PyId___build_class__); 2318 if (bc == NULL) { 2319 if (!_PyErr_Occurred(tstate)) { 2320 _PyErr_SetString(tstate, PyExc_NameError, 2321 \"__build_class__ not found\"); 2322 } 2323 goto error; 2324 } 2325 Py_INCREF(bc); 2326 } 2327 else { 2328 PyObject *build_class_str = _PyUnicode_FromId(\u0026PyId___build_class__); 2329 if (build_class_str == NULL) 2330 goto error; 2331 bc = PyObject_GetItem(f-f_builtins, build_class_str); 2332 if (bc == NULL) { 2333 if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) 2334 _PyErr_SetString(tstate, PyExc_NameError, 2335 \"__build_class__ not found\"); 2336 goto error; 2337 } 2338 } 2339 PUSH(bc); 2340 DISPATCH(); 2341 } (gdb) p opcode $11 = 71 (gdb) p oparg $12 = 0 LOAD_BUILD_CLASS 则会从内置命名空间中通过哈希方法找到函数指针，并插入栈顶；\n其他的字节码指令还有很多，都可以通过阅读源码或者使用 gdb 调试的方法找到其实际执行的代码；相比于汇编指令，字节码指令实际上代表了由许多行代码组成的功能，而 Python 虚拟机则是通过字节码指令模拟出了对汇编指令的执行过程。\n","wordCount":"2572","inLanguage":"en","datePublished":"2021-05-26T10:18:52+08:00","dateModified":"2021-05-26T10:18:52+08:00","author":{"@type":"Person","name":"Zhengyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://zintrulcre.github.io/posts/python/python-source-code-interpreter/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://zintrulcre.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://zintrulcre.github.io/archives/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=http://zintrulcre.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://zintrulcre.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://zintrulcre.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Python 源码学习（4）：编译器和虚拟机
</h1>
<div class=post-meta><span title="2021-05-26 10:18:52 +0800 CST">May 26, 2021</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Zhengyu&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/python/python-source-code-interpreter.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#python-%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a04%e7%bc%96%e8%af%91%e5%99%a8%e5%92%8c%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label="Python 源码学习（4）：编译器和虚拟机">Python 源码学习（4）：编译器和虚拟机</a><ul>
<li>
<a href=#1-python-%e7%bc%96%e8%af%91%e5%99%a8 aria-label="1 Python 编译器">1 Python 编译器</a><ul>
<li>
<a href=#11-%e4%bb%a3%e7%a0%81%e5%af%b9%e8%b1%a1 aria-label="1.1 代码对象">1.1 代码对象</a></li>
<li>
<a href=#12-%e5%ad%97%e8%8a%82%e7%a0%81 aria-label="1.2 字节码">1.2 字节码</a></li>
<li>
<a href=#13-%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86 aria-label="1.3 编译原理">1.3 编译原理</a></li></ul>
</li>
<li>
<a href=#2-python-%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label="2 Python 虚拟机">2 Python 虚拟机</a><ul>
<li>
<a href=#21-%e8%b0%83%e7%94%a8%e6%a0%88 aria-label="2.1 调用栈">2.1 调用栈</a></li>
<li>
<a href=#22-%e6%a0%88%e5%b8%a7%e5%af%b9%e8%b1%a1 aria-label="2.2 栈帧对象">2.2 栈帧对象</a><ul>
<li>
<a href=#221-%e5%9b%9e%e6%94%b6%e5%92%8c%e5%88%86%e9%85%8d aria-label="2.2.1 回收和分配">2.2.1 回收和分配</a></li></ul>
</li>
<li>
<a href=#23-%e8%bf%90%e8%a1%8c%e8%bf%87%e7%a8%8b aria-label="2.3 运行过程">2.3 运行过程</a><ul>
<li>
<a href=#231-%e8%b0%83%e7%94%a8%e6%b5%81%e7%a8%8b aria-label="2.3.1 调用流程">2.3.1 调用流程</a></li>
<li>
<a href=#232-%e8%bf%90%e8%a1%8c%e6%a0%88%e5%b8%a7 aria-label="2.3.2 运行栈帧">2.3.2 运行栈帧</a></li>
<li>
<a href=#233-%e8%b0%83%e8%af%95 aria-label="2.3.3 调试">2.3.3 调试</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=python-源码学习4编译器和虚拟机>Python 源码学习（4）：编译器和虚拟机<a hidden class=anchor aria-hidden=true href=#python-源码学习4编译器和虚拟机>#</a></h1>
<p>Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 <a href=https://github.com/python/cpython>CPython</a>。</p>
<p><strong>Python 解释器</strong>（<em>Python Interpreter</em>）由 <strong>Python 编译器</strong>（<em>Python Compiler</em>）和 <strong>Python 虚拟机</strong>（<em>Python Virutal Machine</em>）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 <strong>Python 字节码</strong>（<em><a href=https://www.quora.com/What-is-the-difference-between-byte-code-and-machine-code-and-what-are-its-advantages>bytecode</a></em>）；随后 Python 虚拟机会读取并逐步执行这些字节码。</p>
<h2 id=1-python-编译器>1 Python 编译器<a hidden class=anchor aria-hidden=true href=#1-python-编译器>#</a></h2>
<h3 id=11-代码对象>1.1 代码对象<a hidden class=anchor aria-hidden=true href=#11-代码对象>#</a></h3>
<p>Python 提供了内置函数 <code>compile</code>，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># test.py</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>Square</span>(a):
    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>*</span> a

print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;result:</span><span style=color:#ae81ff>\t\t</span><span style=color:#e6db74>{</span>Square(<span style=color:#ae81ff>5</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)

<span style=color:#75715e># main.py</span>
f <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;test.py&#34;</span>
code_obj <span style=color:#f92672>=</span> compile(open(f)<span style=color:#f92672>.</span>read(), f, <span style=color:#e6db74>&#39;exec&#39;</span>)
exec(code_obj)
print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;code_obj:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>code_obj<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;type:</span><span style=color:#ae81ff>\t\t</span><span style=color:#e6db74>{</span>type(code_obj)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ python3 main.py
result:         <span style=color:#ae81ff>25</span>
code_obj:       &lt;code object &lt;module&gt; at 0x7f052c156b30, file <span style=color:#e6db74>&#34;test.py&#34;</span>, line 1&gt;
type:           &lt;class <span style=color:#e6db74>&#39;code&#39;</span>&gt;
</code></pre></div><p>可以看到生成的 <code>code_obj</code> 对象的类型是 <code>class 'code'</code>，它在源码中对应的结构体是<strong>代码对象</strong> <em>PyCodeObject</em>；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// Include/cpython/code.h
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* Bytecode object */</span>
<span style=color:#66d9ef>struct</span> PyCodeObject {
    PyObject_HEAD
    <span style=color:#66d9ef>int</span> co_argcount;            <span style=color:#75715e>/* #arguments, except *args */</span>
    <span style=color:#66d9ef>int</span> co_posonlyargcount;     <span style=color:#75715e>/* #positional only arguments */</span>
    <span style=color:#66d9ef>int</span> co_kwonlyargcount;      <span style=color:#75715e>/* #keyword only arguments */</span>
    <span style=color:#66d9ef>int</span> co_nlocals;             <span style=color:#75715e>/* #local variables */</span>
    <span style=color:#66d9ef>int</span> co_stacksize;           <span style=color:#75715e>/* #entries needed for evaluation stack */</span>
    <span style=color:#66d9ef>int</span> co_flags;               <span style=color:#75715e>/* CO_..., see below */</span>
    <span style=color:#66d9ef>int</span> co_firstlineno;         <span style=color:#75715e>/* first source line number */</span>
    PyObject <span style=color:#f92672>*</span>co_code;          <span style=color:#75715e>/* instruction opcodes */</span>
    PyObject <span style=color:#f92672>*</span>co_consts;        <span style=color:#75715e>/* list (constants used) */</span>
    PyObject <span style=color:#f92672>*</span>co_names;         <span style=color:#75715e>/* list of strings (names used) */</span>
    PyObject <span style=color:#f92672>*</span>co_varnames;      <span style=color:#75715e>/* tuple of strings (local variable names) */</span>
    PyObject <span style=color:#f92672>*</span>co_freevars;      <span style=color:#75715e>/* tuple of strings (free variable names) */</span>
    PyObject <span style=color:#f92672>*</span>co_cellvars;      <span style=color:#75715e>/* tuple of strings (cell variable names) */</span>
    <span style=color:#75715e>/* The rest aren&#39;t used in either hash or comparisons, except for co_name,
</span><span style=color:#75715e>       used in both. This is done to preserve the name and line number
</span><span style=color:#75715e>       for tracebacks and debuggers; otherwise, constant de-duplication
</span><span style=color:#75715e>       would collapse identical functions/lambdas defined on different lines.
</span><span style=color:#75715e>    */</span>
    Py_ssize_t <span style=color:#f92672>*</span>co_cell2arg;    <span style=color:#75715e>/* Maps cell vars which are arguments. */</span>
    PyObject <span style=color:#f92672>*</span>co_filename;      <span style=color:#75715e>/* unicode (where it was loaded from) */</span>
    PyObject <span style=color:#f92672>*</span>co_name;          <span style=color:#75715e>/* unicode (name, for reference) */</span>
    PyObject <span style=color:#f92672>*</span>co_lnotab;        <span style=color:#75715e>/* string (encoding addr&lt;-&gt;lineno mapping) See
</span><span style=color:#75715e>                                   Objects/lnotab_notes.txt for details. */</span>
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>co_zombieframe;       <span style=color:#75715e>/* for optimization only (see frameobject.c) */</span>
    PyObject <span style=color:#f92672>*</span>co_weakreflist;   <span style=color:#75715e>/* to support weakrefs to code objects */</span>
    <span style=color:#75715e>/* Scratch space for extra data relating to the code object.
</span><span style=color:#75715e>       Type is a void* to keep the format private in codeobject.c to force
</span><span style=color:#75715e>       people to go through the proper APIs. */</span>
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>co_extra;

    <span style=color:#75715e>/* Per opcodes just-in-time cache
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * To reduce cache size, we use indirect mapping from opcode index to
</span><span style=color:#75715e>     * cache object:
</span><span style=color:#75715e>     *   cache = co_opcache[co_opcache_map[next_instr - first_instr] - 1]
</span><span style=color:#75715e>     */</span>

    <span style=color:#75715e>// co_opcache_map is indexed by (next_instr - first_instr).
</span><span style=color:#75715e></span>    <span style=color:#75715e>//  * 0 means there is no cache for this opcode.
</span><span style=color:#75715e></span>    <span style=color:#75715e>//  * n &gt; 0 means there is cache in co_opcache[n-1].
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>co_opcache_map;
    _PyOpcache <span style=color:#f92672>*</span>co_opcache;
    <span style=color:#66d9ef>int</span> co_opcache_flag;  <span style=color:#75715e>// used to determine when create a cache.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> co_opcache_size;  <span style=color:#75715e>// length of co_opcache.
</span><span style=color:#75715e></span>};
</code></pre></div><p>其中比较重要的成员有两个，分别是编译后生成的指令序列 <code>co_code</code> 和执行当前代码块所需的栈空间大小 <code>co_stacksize</code>。</p>
<h3 id=12-字节码>1.2 字节码<a hidden class=anchor aria-hidden=true href=#12-字节码>#</a></h3>
<p>在所有的这些成员变量中，<code>PyObject *co_code</code> 存储了编译后生成的指令序列，它是以字节的方式存储的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># test.py</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>Square</span>(a):
    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>*</span> a

print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;result:</span><span style=color:#ae81ff>\t\t</span><span style=color:#e6db74>{</span>Square(<span style=color:#ae81ff>5</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)

<span style=color:#75715e># main.py</span>
f <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;test.py&#34;</span>
code_obj <span style=color:#f92672>=</span> compile(open(f)<span style=color:#f92672>.</span>read(), f, <span style=color:#e6db74>&#39;exec&#39;</span>)
print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;code obj:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>code_obj<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;stack size:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>code_obj<span style=color:#f92672>.</span>co_stacksize<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
result <span style=color:#f92672>=</span> exec(code_obj)
bytecode <span style=color:#f92672>=</span> code_obj<span style=color:#f92672>.</span>co_code
print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;bytecode:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>bytecode<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ python3 main.py
code obj:       &lt;code object &lt;module&gt; at 0x7f26cea5ab30, file <span style=color:#e6db74>&#34;test.py&#34;</span>, line 1&gt;
stack size:     <span style=color:#ae81ff>4</span>
result:         <span style=color:#ae81ff>25</span>
bytecode:       b<span style=color:#e6db74>&#39;d\x00d\x01\x84\x00Z\x00e\x01d\x02e\x00d\x03\x83\x01\x9b\x00\x9d\x02\x83\x01\x01\x00d\x04S\x00&#39;</span>
</code></pre></div><p>我们可以使用 Python 内置模块 dis 来将这些字节码反编译成类似于汇编语言的格式：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> dis
dis<span style=color:#f92672>.</span>dis(bytecode)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>          <span style=color:#ae81ff>0</span> LOAD_CONST               <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>
          <span style=color:#ae81ff>2</span> LOAD_CONST               <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
          <span style=color:#ae81ff>4</span> MAKE_FUNCTION            <span style=color:#ae81ff>0</span>
          <span style=color:#ae81ff>6</span> STORE_NAME               <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>
          <span style=color:#ae81ff>8</span> LOAD_NAME                <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
         <span style=color:#ae81ff>10</span> LOAD_CONST               <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>
         <span style=color:#ae81ff>12</span> LOAD_NAME                <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>
         <span style=color:#ae81ff>14</span> LOAD_CONST               <span style=color:#ae81ff>3</span> <span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>
         <span style=color:#ae81ff>16</span> CALL_FUNCTION            <span style=color:#ae81ff>1</span>
         <span style=color:#ae81ff>18</span> FORMAT_VALUE             <span style=color:#ae81ff>0</span>
         <span style=color:#ae81ff>20</span> BUILD_STRING             <span style=color:#ae81ff>2</span>
         <span style=color:#ae81ff>22</span> CALL_FUNCTION            <span style=color:#ae81ff>1</span>
         <span style=color:#ae81ff>24</span> POP_TOP
         <span style=color:#ae81ff>26</span> LOAD_CONST               <span style=color:#ae81ff>4</span> <span style=color:#f92672>(</span>4<span style=color:#f92672>)</span>
         <span style=color:#ae81ff>28</span> RETURN_VALUE
</code></pre></div><p>在反编译后的输出结果中，第一列代表字节码中每一条指令的<strong>偏移量</strong> <em>offset</em>；第二列代表各条<strong>助记符</strong> <em>mnemonics</em> 的名称，这些助记符可以很方便地帮助我们理解在后续的步骤中 Python 虚拟机要执行的事件；第三列则是每条指令的<strong>操作数</strong> <em>opargs</em>。</p>
<p>同时，在字节码对应的十六进制表示中，每一位数字也分别代表了不同的助记符和操作数，我们可以直接通过打印出字节码的十六进制以查看其内容：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>print(bytecode<span style=color:#f92672>.</span>hex())
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#ae81ff>64</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>84</span> <span style=color:#ae81ff>00</span> 5a <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>65</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>02</span> <span style=color:#ae81ff>65</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>03</span> <span style=color:#ae81ff>83</span> <span style=color:#ae81ff>01</span> 9b <span style=color:#ae81ff>00</span> 9d <span style=color:#ae81ff>02</span> <span style=color:#ae81ff>83</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>04</span> <span style=color:#ae81ff>53</span> <span style=color:#ae81ff>00</span>
</code></pre></div><p>以上面反编译后的输出为例，在 offset == 0 的地方可以找到数字 64，即 LOAD_CONST 加载常量助记符对应的<strong>操作码 opcode</strong>，其后紧跟着的是它的操作数 opargs == 0；而指令第四行对应的 offset == 6，可以看到 STORE_NAME 助记符对应的操作码 opcode == 5a ，其操作数 opargs == 0；以此类推。</p>
<p>Python 的 opcode 模块提供了关于 Python 虚拟机中助记符和操作码的相关信息，也可以在源码的 Include/opcode.h 中找到相关定义：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> opcode
print(opcode<span style=color:#f92672>.</span>opname[<span style=color:#ae81ff>0x64</span>])
print(opcode<span style=color:#f92672>.</span>opname[<span style=color:#ae81ff>0x5a</span>])
print(opcode<span style=color:#f92672>.</span>opmap[<span style=color:#e6db74>&#39;LOAD_NAME&#39;</span>])
print(opcode<span style=color:#f92672>.</span>opmap[<span style=color:#e6db74>&#39;RETURN_VALUE&#39;</span>])
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>LOAD_CONST
STORE_NAME
<span style=color:#ae81ff>101</span>
<span style=color:#ae81ff>83</span>
</code></pre></div><h3 id=13-编译原理>1.3 编译原理<a hidden class=anchor aria-hidden=true href=#13-编译原理>#</a></h3>
<p>Python 编译器的实现和其他语言类似，包含了<strong>词法分析</strong> <em>Lexical</em>，<strong>语法分析</strong> <em>Syntax Analysis</em> 和<strong>语义分析</strong> <em>Semantic Analysis</em> 等步骤，本文不再赘述编译原理的部分。</p>
<h2 id=2-python-虚拟机>2 Python 虚拟机<a hidden class=anchor aria-hidden=true href=#2-python-虚拟机>#</a></h2>
<p>类似于 x86-64, arm 平台和 Java 虚拟机，Python 虚拟机也是 <strong>基于栈的</strong>（<em>Stack-Based</em>），它的函数调用都是通过<strong>调用栈</strong> <em>call stack</em> 和<strong>栈帧</strong> <em>stackframe</em> 来实现的。</p>
<h3 id=21-调用栈>2.1 调用栈<a hidden class=anchor aria-hidden=true href=#21-调用栈>#</a></h3>
<p>调用栈是 CPU 寄存器中的一块内存区域，它是一种 FILO 的数据结构，可以进行插入或删除操作的一边称为栈顶，另一边则称为栈底；对于最常见的 x86-64 架构来说，栈地址空间是自顶向下（<em>head down</em>）增长的：</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/call-stack-1.png alt=call-stack-1>
</p>
<p>在 x86-64 平台下，它拥有 16 个<strong>通用寄存器</strong> <em>general-purpose registers</em>，寄存器被集成在 CPU 芯片上，其中 rbp 寄存器保存当前栈帧的栈底（本次函数调用开始时的位置），rsp 寄存器保存当前栈帧的栈顶（函数运行时的当前位置），rbp 和 rsp 之间的空间则被称为本次函数调用的<strong>栈帧</strong> <em>stack frame</em>；在每一次发生函数调用时，调用栈上都会维护一个独立的栈帧以存储函数返回值、参数、局部变量等信息；其他通用寄存器的功能如下。</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/x86-64-registers.png alt=x86-64-registers>
</p>
<p>栈相关的最常见操作有 push 和 pop，push 操作会将一个操作数插入栈顶，这包含了两个步骤，分别是先将 rsp 寄存器保存的地址减去 8，再将操作数写入到这个地址中；而 pop 则正好相反，它先从 rsp 寄存器存储的地址取出数据，写入到其他寄存器中，再对其地址加上 8。</p>
<p>以调试一个简单的 Swap 函数调用为例；本文使用的所有汇编语言都是 <em><a href=https://csiflabs.cs.ucdavis.edu/~ssdavis/50/att-syntax.htm>AT&T Syntax</a></em> 的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// main.cpp
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Swap</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>b)
{
    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> a;
    a <span style=color:#f92672>=</span> b;
    b <span style=color:#f92672>=</span> c;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>;
    Swap(a, b);
    cout <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> b <span style=color:#f92672>&lt;&lt;</span> endl;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>用 gdb 打开并在 main 函数处断点；在 main 函数栈帧中，会通过 movl 指令将两个常量拷贝到内存中：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ g++ -g -O0 -o main main.cpp
$ gdb main
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b main
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> r
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> layout reg
</code></pre></div><pre tabindex=0><code>&gt; 0x400852 &lt;main()+9&gt;      movl  $0x5,-0x14(%rbp)  # 将常量 9 保存在 rbp - 18 的位置
  0x400859 &lt;main()+16&gt;     movl  $0x9,-0x18(%rbp)  # 将常量 5 保存在 rbp - 14 的位置
</code></pre><p>在调用函数 Swap 前，会分别将两个参数存入 rdi 和 rsi 寄存器中：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>  0x400860 &lt;main<span style=color:#f92672>()</span>+23&gt;     lea   -0x18<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>,%rdx
  0x400864 &lt;main<span style=color:#f92672>()</span>+27&gt;     lea   -0x14<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>,%rax
  0x400868 &lt;main<span style=color:#f92672>()</span>+31&gt;     mov    %rdx,%rsi
  0x40086b &lt;main<span style=color:#f92672>()</span>+34&gt;     mov    %rax,%rdi
&gt; 0x40086e &lt;main<span style=color:#f92672>()</span>+37&gt;     callq  0x40081d &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>&gt;

<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p *$rsi
$6 <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p *$rdi
$7 <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</code></pre></div><p>在 callq 指令处使用 stepi 进入到 Swap 函数中，此时 rbp 和 rsp 指针还分别指向 main 函数栈帧的底部和顶部，能够发现栈地址空间的确是向下增长的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; 0x40086e &lt;main<span style=color:#f92672>()</span>+37&gt;     callq  0x40081d &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>&gt;

<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> si

&gt; 0x40081d &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>&gt;     push   %rbp
  0x40081e &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+1&gt;   mov    %rsp,%rbp

rbp            0x7fffffffe110   0x7fffffffe110
rsp            0x7fffffffe0e8   0x7fffffffe0e8
</code></pre></div><p>此时栈帧结构大致如下：</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/call-stack-2.png alt=call-stack-2>
</p>
<p>执行接下来的 push 指令，将 rbp 的值存入栈顶，可以看到 rsp 的值发生了变化：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> ni

  0x40081d &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>&gt;     push   %rbp
&gt; 0x40081e &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+1&gt;   mov    %rsp,%rbp

rbp            0x7fffffffe110   0x7fffffffe110
rsp            0x7fffffffe0e0   0x7fffffffe0e0
</code></pre></div><p>继续执行下一条 mov 指令，重置 rbp 的值，进入新的栈帧：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> ni

rbp            0x7fffffffe0e0   0x7fffffffe0e0
rsp            0x7fffffffe0e0   0x7fffffffe0e0
</code></pre></div><p>此时栈帧结构变成了如下：</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/call-stack-3.png alt=call-stack-3>
</p>
<p>再经过一系列的 mov 指令操作，将 a 和 b 的值交换之后，执行下一条 pop 指令，将存储的上一个栈帧地址写入 rbp 中，同时修改 rsp；之后再执行 retq 指令即可继续运行 main 函数的下一条汇编指令了：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; 0x400847 &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+42&gt;  pop    %rbp
  0x400848 &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+43&gt;  retq

rbp            0x7fffffffe0e0   0x7fffffffe0e0
rsp            0x7fffffffe0e0   0x7fffffffe0e0

<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> ni

  0x400847 &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+42&gt;  pop    %rbp
&gt; 0x400848 &lt;Swap<span style=color:#f92672>(</span>int&amp;, int&amp;<span style=color:#f92672>)</span>+43&gt;  retq

rbp            0x7fffffffe110   0x7fffffffe110
rsp            0x7fffffffe0e8   0x7fffffffe0e8
</code></pre></div><p>Python 中函数调用链和调用栈之间的关系也和 x86-64 平台类似，只不过是把代码块和栈帧分别进行了封装而已。</p>
<h3 id=22-栈帧对象>2.2 栈帧对象<a hidden class=anchor aria-hidden=true href=#22-栈帧对象>#</a></h3>
<p>Python 中的代码对象 PyCodeObject 本身只包含了字节码相关的信息，并不具备用于执行字节码所需要的上下文信息，因此需要引入<strong>栈帧对象 PyFrameObject</strong>，作为代码对象运行的容器，并用来模拟其他平台下的栈帧：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// cpython/Include/frameobject.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> _frame {
    PyObject_VAR_HEAD
    <span style=color:#66d9ef>struct</span> _frame <span style=color:#f92672>*</span>f_back;      <span style=color:#75715e>/* previous frame, or NULL */</span>
    PyCodeObject <span style=color:#f92672>*</span>f_code;       <span style=color:#75715e>/* code segment */</span>
    PyObject <span style=color:#f92672>*</span>f_builtins;       <span style=color:#75715e>/* builtin symbol table (PyDictObject) */</span>
    PyObject <span style=color:#f92672>*</span>f_globals;        <span style=color:#75715e>/* global symbol table (PyDictObject) */</span>
    PyObject <span style=color:#f92672>*</span>f_locals;         <span style=color:#75715e>/* local symbol table (any mapping) */</span>
    PyObject <span style=color:#f92672>**</span>f_valuestack;    <span style=color:#75715e>/* points after the last local */</span>
    PyObject <span style=color:#f92672>*</span>f_trace;          <span style=color:#75715e>/* Trace function */</span>
    <span style=color:#66d9ef>int</span> f_stackdepth;           <span style=color:#75715e>/* Depth of value stack */</span>
    <span style=color:#66d9ef>char</span> f_trace_lines;         <span style=color:#75715e>/* Emit per-line trace events? */</span>
    <span style=color:#66d9ef>char</span> f_trace_opcodes;       <span style=color:#75715e>/* Emit per-opcode trace events? */</span>

    <span style=color:#75715e>/* Borrowed reference to a generator, or NULL */</span>
    PyObject <span style=color:#f92672>*</span>f_gen;

    <span style=color:#66d9ef>int</span> f_lasti;                <span style=color:#75715e>/* Last instruction if called */</span>
    <span style=color:#75715e>/* Call PyFrame_GetLineNumber() instead of reading this field
</span><span style=color:#75715e>       directly.  As of 2.3 f_lineno is only valid when tracing is
</span><span style=color:#75715e>       active (i.e. when f_trace is set).  At other times we use
</span><span style=color:#75715e>       PyCode_Addr2Line to calculate the line from the current
</span><span style=color:#75715e>       bytecode index. */</span>
    <span style=color:#66d9ef>int</span> f_lineno;               <span style=color:#75715e>/* Current line number */</span>
    <span style=color:#66d9ef>int</span> f_iblock;               <span style=color:#75715e>/* index in f_blockstack */</span>
    PyFrameState f_state;       <span style=color:#75715e>/* What state the frame is in */</span>
    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span style=color:#75715e>/* for try and loop blocks */</span>
    PyObject <span style=color:#f92672>*</span>f_localsplus[<span style=color:#ae81ff>1</span>];  <span style=color:#75715e>/* locals+stack, dynamically sized */</span>
};

<span style=color:#75715e>// cpython/Include/pyframe.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _frame PyFrameObject;
</code></pre></div><p>可以看到栈帧对象中大致包含了以下数据，它们构成了 Python 虚拟机执行当前栈帧所需要的所有上下文：</p>
<ul>
<li>上一个运行的栈帧对象的指针 <code>struct _frame *f_back</code>；Python 虚拟机中运行的所有栈帧对象的 <code>*f_back</code> 共同组成调用栈结构，仅有初始栈帧有 <code>f_back == NULL</code>；</li>
<li>代码对象指针 <code>PyCodeObject *f_code</code>，它包含了当前运行栈帧所执行的字节码信息；</li>
<li>代码对象执行期间的栈结构 <code>PyObject **f_valuestack</code>，在对字节码进行运算时，需要从栈顶读取数据，并将运算结果存储在栈顶，<code>f_valuestack</code> 就是用来用来存储数据的栈结构，它的大小由对应的代码对象 <code>f_code</code> 的堆栈大小决定；</li>
<li>代码对象执行期间使用的栈结构的深度 <code>int f_stackdepth</code>；</li>
<li>上一条执行过的字节码指令 <code>int f_lasti</code>，类似于 rip 寄存器；</li>
<li>内置命名空间、全局命名空间、局部命名空间的指针 <code>PyObject *f_builtins</code>, <code>PyObject *f_globals</code>, <code>PyObject *f_locals</code>，它们是用来实现 Python 中从符号到对象的映射的结构，一般用字典实现，暂不讨论；</li>
<li>用于跟踪代码执行情况的函数指针 <code>PyObject *f_trace</code> 和相关数据 <code>char f_trace_lines</code>, <code>char f_trace_opcodes</code>，暂不讨论；</li>
<li>用于执行生成器代码的数据 <code>PyObject *f_gen</code>，暂不讨论；</li>
</ul>
<p>Python 在 <code>sys</code> 模块中提供了 <code>_getframe</code> 函数来获取栈帧对象；以一个简单的 Swap 函数为例，在最深层的函数调用处打印出栈帧对象的信息：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> sys

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>Swap</span>(a, b):
    frame <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>_getframe()
    <span style=color:#66d9ef>while</span> frame <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;frame:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>frame<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;name:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>frame<span style=color:#f92672>.</span>f_code<span style=color:#f92672>.</span>co_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;locals:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>frame<span style=color:#f92672>.</span>f_locals<span style=color:#f92672>.</span>keys()<span style=color:#e6db74>}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;back:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>frame<span style=color:#f92672>.</span>f_back<span style=color:#e6db74>}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
        frame <span style=color:#f92672>=</span> frame<span style=color:#f92672>.</span>f_back

    <span style=color:#66d9ef>return</span> b, a

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
    a, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>9</span>
    a, b <span style=color:#f92672>=</span> Swap(a, b)
    print(a, b)

<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
    main()
</code></pre></div><p>运行后可以观察到，在 Python 程序开始执行时会先创建一个叫做 module 的栈帧对象用于执行当前脚本中的代码；在每次函数调用的过程中，都会创建出一个新的栈帧对象，这些栈帧对象会使用 <code>f_back</code> 指针保存上一个执行栈帧的地址，并在之后调用其他函数的时候被压入栈顶：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ python3 main.py
frame:  &lt;frame at 0x7fe37d7e5900, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 36, code Swap&gt;
name:   Swap
locals: dict_keys<span style=color:#f92672>([</span><span style=color:#e6db74>&#39;a&#39;</span>, <span style=color:#e6db74>&#39;b&#39;</span>, <span style=color:#e6db74>&#39;frame&#39;</span><span style=color:#f92672>])</span>
back:   &lt;frame at 0x7fe71ca65040, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 46, code main&gt;

frame:  &lt;frame at 0x7fe376115040, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 46, code main&gt;
name:   main
locals: dict_keys<span style=color:#f92672>([</span><span style=color:#e6db74>&#39;a&#39;</span>, <span style=color:#e6db74>&#39;b&#39;</span><span style=color:#f92672>])</span>
back:   &lt;frame at 0x141f6f0, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 50, code &lt;module&gt;&gt;

frame:  &lt;frame at 0x1ade6f0, file <span style=color:#e6db74>&#39;/main.py&#39;</span>, line 50, code &lt;module&gt;&gt;
name:   &lt;module&gt;
locals: dict_keys<span style=color:#f92672>([</span><span style=color:#e6db74>&#39;__name__&#39;</span>, <span style=color:#e6db74>&#39;__doc__&#39;</span>, <span style=color:#e6db74>&#39;__package__&#39;</span>, <span style=color:#e6db74>&#39;__loader__&#39;</span>, <span style=color:#e6db74>&#39;__spec__&#39;</span>, <span style=color:#e6db74>&#39;__annotations__&#39;</span>, <span style=color:#e6db74>&#39;__builtins__&#39;</span>, <span style=color:#e6db74>&#39;__file__&#39;</span>, <span style=color:#e6db74>&#39;__cached__&#39;</span>, <span style=color:#e6db74>&#39;sys&#39;</span>, <span style=color:#e6db74>&#39;Swap&#39;</span>, <span style=color:#e6db74>&#39;main&#39;</span><span style=color:#f92672>])</span>
back:   None

<span style=color:#ae81ff>9</span> <span style=color:#ae81ff>5</span>
</code></pre></div><h4 id=221-回收和分配>2.2.1 回收和分配<a hidden class=anchor aria-hidden=true href=#221-回收和分配>#</a></h4>
<p>前文讨论过类型对象，从刚才获取栈帧对象的例子里能够看到通过 <code>sys._getframe()</code> 获取的 <code>frame</code> 对象的类型名为 <code>frame</code>，不难找到它的类型对象实际上是 <code>PyFrame_Type</code>，我们可以从类型对象初始化时使用的函数指针找到它的相关操作：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>PyTypeObject PyFrame_Type <span style=color:#f92672>=</span> {
    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)
    <span style=color:#e6db74>&#34;frame&#34;</span>,
    <span style=color:#66d9ef>sizeof</span>(PyFrameObject),
    <span style=color:#66d9ef>sizeof</span>(PyObject <span style=color:#f92672>*</span>),
    (destructor)frame_dealloc,                  <span style=color:#75715e>/* tp_dealloc */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_vectorcall_offset */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_getattr */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_setattr */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_async */</span>
    (reprfunc)frame_repr,                       <span style=color:#75715e>/* tp_repr */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_number */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_sequence */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_mapping */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_hash */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_call */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_str */</span>
    PyObject_GenericGetAttr,                    <span style=color:#75715e>/* tp_getattro */</span>
    PyObject_GenericSetAttr,                    <span style=color:#75715e>/* tp_setattro */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_buffer */</span>
    Py_TPFLAGS_DEFAULT <span style=color:#f92672>|</span> Py_TPFLAGS_HAVE_GC,<span style=color:#75715e>/* tp_flags */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_doc */</span>
    (traverseproc)frame_traverse,               <span style=color:#75715e>/* tp_traverse */</span>
    (inquiry)frame_tp_clear,                    <span style=color:#75715e>/* tp_clear */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_richcompare */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_weaklistoffset */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_iter */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_iternext */</span>
    frame_methods,                              <span style=color:#75715e>/* tp_methods */</span>
    frame_memberlist,                           <span style=color:#75715e>/* tp_members */</span>
    frame_getsetlist,                           <span style=color:#75715e>/* tp_getset */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_base */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_dict */</span>
};
</code></pre></div><p>其中对栈帧对象进行析构的函数是 <code>frame_dealloc</code>，此处省略了部分代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#define PyFrame_MAXFREELIST 200
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> _Py_HOT_FUNCTION
<span style=color:#a6e22e>frame_dealloc</span>(PyFrameObject <span style=color:#f92672>*</span>f)
{
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    Py_XDECREF(f<span style=color:#f92672>-&gt;</span>f_back);
    Py_DECREF(f<span style=color:#f92672>-&gt;</span>f_builtins);
    Py_DECREF(f<span style=color:#f92672>-&gt;</span>f_globals);
    Py_CLEAR(f<span style=color:#f92672>-&gt;</span>f_locals);
    Py_CLEAR(f<span style=color:#f92672>-&gt;</span>f_trace);

    PyCodeObject <span style=color:#f92672>*</span>co <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>f_code;
    <span style=color:#66d9ef>if</span> (co<span style=color:#f92672>-&gt;</span>co_zombieframe  <span style=color:#f92672>==</span> NULL) {
        co<span style=color:#f92672>-&gt;</span>co_zombieframe <span style=color:#f92672>=</span> f;
    }
    <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_Py_frame_state</span> <span style=color:#f92672>*</span>state <span style=color:#f92672>=</span> get_frame_state();
<span style=color:#75715e>#ifdef Py_DEBUG
</span><span style=color:#75715e></span>        <span style=color:#75715e>// frame_dealloc() must not be called after _PyFrame_Fini()
</span><span style=color:#75715e></span>        assert(state<span style=color:#f92672>-&gt;</span>numfree <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (state<span style=color:#f92672>-&gt;</span>numfree <span style=color:#f92672>&lt;</span> PyFrame_MAXFREELIST) {
            <span style=color:#f92672>++</span>state<span style=color:#f92672>-&gt;</span>numfree;
            f<span style=color:#f92672>-&gt;</span>f_back <span style=color:#f92672>=</span> state<span style=color:#f92672>-&gt;</span>free_list;
            state<span style=color:#f92672>-&gt;</span>free_list <span style=color:#f92672>=</span> f;
        }
        <span style=color:#66d9ef>else</span> {
            PyObject_GC_Del(f);
        }
    }

    Py_DECREF(co);
    Py_TRASHCAN_SAFE_END(f)
}


<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_Py_frame_state</span> {
    PyFrameObject <span style=color:#f92672>*</span>free_list;
    <span style=color:#75715e>/* number of frames currently in free_list */</span>
    <span style=color:#66d9ef>int</span> numfree;
};

</code></pre></div><p>这是一个使用非常高频的函数（几乎每一次栈帧退出时都会调用），因此采用了一些策略来进行优化以降低调用函数的开销；一种是在首次进行栈帧对象 <code>f</code> 的回收时会先判断栈帧对象关联的代码对象 <code>co</code> 的成员指针 <code>co_zombieframe</code> 是否为空 <code>if (co->co_zombieframe == NULL)</code>；如果是，则会将该栈帧对象 <code>f</code> 保存在代码对象的这个指针中 <code>co->co_zombieframe = f</code>，这样的话在下一次执行相同的代码对象 <code>co</code> 时，就无需再次重新进行栈帧对象 <code>f</code> 的内存分配（只要代码对象 <code>co</code> 不因为引用计数降低为 0 而被 gc）；对于栈帧对象来说，仅有 <code>ob_type</code>, <code>ob_size</code>, <code>f_code</code>, <code>f_valuestack</code> 几个成员变量会保留原有的值，因为这些成员变量与其他对象没有关联，而 <code>f_locals</code>, <code>f_trace</code>, <code>f_exc_type</code> 等指针依然会被通过 <code>Py_CLEAR</code> 置为 NULL，因为通过这些指针关联的对象可能会通过其他途径被回收，从而导致悬空指针的问题。</p>
<p>另一个优化策略是当代码对象 <code>co</code> 的成员指针 <code>co->co_zombieframe</code> 不为空，即再次执行相同栈帧时，会使用由 Python 线程维护的缓存栈帧链表 <code>state->free_list</code> 将栈帧对象存储下来，此时如果有新的栈帧对象被定义的话，可以直接从缓存栈帧链表 <code>state->free_list</code> 中获取一个已经分配内存的栈帧对象直接赋值并使用，以达到减少分配和回收内存的效果。此处可以结合分配栈帧的 <code>frame_alloc</code> 函数来看：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> PyFrameObject<span style=color:#f92672>*</span>
<span style=color:#a6e22e>frame_alloc</span>(PyCodeObject <span style=color:#f92672>*</span>code)
{
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (state<span style=color:#f92672>-&gt;</span>free_list <span style=color:#f92672>==</span> NULL)
    {
        f <span style=color:#f92672>=</span> PyObject_GC_NewVar(PyFrameObject, <span style=color:#f92672>&amp;</span>PyFrame_Type, extras);
        <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>==</span> NULL) {
            <span style=color:#66d9ef>return</span> NULL;
        }
    }
    <span style=color:#66d9ef>else</span> {
<span style=color:#75715e>#ifdef Py_DEBUG
</span><span style=color:#75715e></span>        <span style=color:#75715e>// frame_alloc() must not be called after _PyFrame_Fini()
</span><span style=color:#75715e></span>        assert(state<span style=color:#f92672>-&gt;</span>numfree <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>        assert(state<span style=color:#f92672>-&gt;</span>numfree <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);
        <span style=color:#f92672>--</span>state<span style=color:#f92672>-&gt;</span>numfree;
        f <span style=color:#f92672>=</span> state<span style=color:#f92672>-&gt;</span>free_list;
        state<span style=color:#f92672>-&gt;</span>free_list <span style=color:#f92672>=</span> state<span style=color:#f92672>-&gt;</span>free_list<span style=color:#f92672>-&gt;</span>f_back;
        <span style=color:#66d9ef>if</span> (Py_SIZE(f) <span style=color:#f92672>&lt;</span> extras) {
            PyFrameObject <span style=color:#f92672>*</span>new_f <span style=color:#f92672>=</span> PyObject_GC_Resize(PyFrameObject, f, extras);
            <span style=color:#66d9ef>if</span> (new_f <span style=color:#f92672>==</span> NULL) {
                PyObject_GC_Del(f);
                <span style=color:#66d9ef>return</span> NULL;
            }
            f <span style=color:#f92672>=</span> new_f;
        }
        _Py_NewReference((PyObject <span style=color:#f92672>*</span>)f);
    }
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>可以看到在进行栈帧对象的分配时，会优先判断缓存栈帧链表 <code>state->free_list</code> 是否为空，不为空的话则会从其链表头部取出一个已经分配好内存的栈帧对象，对其赋值并使用。</p>
<p>这项优化（将未使用的栈帧对象保存在缓存栈帧链表中，并在创建其他栈帧对象时重复利用）与前者（在栈帧退出时将栈帧对象随代码对象保存下来，在执行相同代码对象时直接使用）的做法有些冲突，因此前者在最新的 <em><a href=https://github.com/python/cpython/commit/b11a951f16f0603d98de24fee5c023df83ea552c>PR 26076</a></em> 中已经被移除了。</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/co_zombieframe.png alt=co_zombieframe.png>
</p>
<h3 id=23-运行过程>2.3 运行过程<a hidden class=anchor aria-hidden=true href=#23-运行过程>#</a></h3>
<h4 id=231-调用流程>2.3.1 调用流程<a hidden class=anchor aria-hidden=true href=#231-调用流程>#</a></h4>
<p>Python 的 main 函数在 cpython/Programs/python.c 文件中，这部分实现比较简单，其调用链可以总结如下：</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/main.png alt=main.png>
</p>
<p>从调用链中可以看到，在真正执行 Python 代码之前，会先读取配置并进行初始化，这些配置会被保存到 cpython/Include/cpython/initconfig.h 文件定义的 PyConfig 结构体中，这个结构体包含了 Python 运行时的环境变量，运行模式等信息；而调用链中 <code>pymain_run_python</code> 函数后的五个分支就分别代表了 Python 通过命令行、文件、标准输入等方式运行的五种模式，但无论是那种模式，最终都会通过调用 <code>run_eval_code_obj</code> 以及 <code>PyEval_EvalCode</code> 函数来执行编译后的代码对象，后者就是 Python 虚拟机执行指令的入口之一。</p>
<h4 id=232-运行栈帧>2.3.2 运行栈帧<a hidden class=anchor aria-hidden=true href=#232-运行栈帧>#</a></h4>
<p>Python 虚拟机中执行指令的入口有 <code>PyEval_EvalCode</code> 和 <code>PyEval_EvalCodeEx</code>，前者相对于后者省略了部分参数，仅将必须的代码对象，全局变量和局部变量作为参数传入，其他参数均设为 NULL。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// cpython/Python/eval.h
</span><span style=color:#75715e></span>PyAPI_FUNC(PyObject <span style=color:#f92672>*</span>) PyEval_EvalCode(PyObject <span style=color:#f92672>*</span>, PyObject <span style=color:#f92672>*</span>, PyObject <span style=color:#f92672>*</span>);

PyAPI_FUNC(PyObject <span style=color:#f92672>*</span>) PyEval_EvalCodeEx(PyObject <span style=color:#f92672>*</span>co,
                                         PyObject <span style=color:#f92672>*</span>globals,
                                         PyObject <span style=color:#f92672>*</span>locals,
                                         PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>args, <span style=color:#66d9ef>int</span> argc,
                                         PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwds, <span style=color:#66d9ef>int</span> kwdc,
                                         PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>defs, <span style=color:#66d9ef>int</span> defc,
                                         PyObject <span style=color:#f92672>*</span>kwdefs, PyObject <span style=color:#f92672>*</span>closure);

<span style=color:#75715e>// cpython/Python/ceval.c
</span><span style=color:#75715e></span>PyObject <span style=color:#f92672>*</span>
<span style=color:#a6e22e>PyEval_EvalCode</span>(PyObject <span style=color:#f92672>*</span>co, PyObject <span style=color:#f92672>*</span>globals, PyObject <span style=color:#f92672>*</span>locals)
{
    <span style=color:#66d9ef>return</span> PyEval_EvalCodeEx(co,
                      globals, locals,
                      (PyObject <span style=color:#f92672>**</span>)NULL, <span style=color:#ae81ff>0</span>,
                      (PyObject <span style=color:#f92672>**</span>)NULL, <span style=color:#ae81ff>0</span>,
                      (PyObject <span style=color:#f92672>**</span>)NULL, <span style=color:#ae81ff>0</span>,
                      NULL, NULL);
}
</code></pre></div><p>而 <code>PyEval_EvalCodeEx</code> 实际上会调用 <code>_PyEval_EvalCodeWithName</code> 函数，进行参数个数和类型的校验，以及线程状态的检查，并最终调用了 <code>_PyEval_EvalCode</code> 函数：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>PyObject <span style=color:#f92672>*</span>
<span style=color:#a6e22e>_PyEval_EvalCodeWithName</span>(PyObject <span style=color:#f92672>*</span>_co, PyObject <span style=color:#f92672>*</span>globals, PyObject <span style=color:#f92672>*</span>locals,
           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>args, Py_ssize_t argcount,
           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwnames, PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwargs,
           Py_ssize_t kwcount, <span style=color:#66d9ef>int</span> kwstep,
           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>defs, Py_ssize_t defcount,
           PyObject <span style=color:#f92672>*</span>kwdefs, PyObject <span style=color:#f92672>*</span>closure,
           PyObject <span style=color:#f92672>*</span>name, PyObject <span style=color:#f92672>*</span>qualname)
{
    PyThreadState <span style=color:#f92672>*</span>tstate <span style=color:#f92672>=</span> _PyThreadState_GET();
    <span style=color:#66d9ef>return</span> _PyEval_EvalCode(tstate, _co, globals, locals,
               args, argcount,
               kwnames, kwargs,
               kwcount, kwstep,
               defs, defcount,
               kwdefs, closure,
               name, qualname);
}

PyObject <span style=color:#f92672>*</span>
<span style=color:#a6e22e>PyEval_EvalCodeEx</span>(PyObject <span style=color:#f92672>*</span>_co, PyObject <span style=color:#f92672>*</span>globals, PyObject <span style=color:#f92672>*</span>locals,
                  PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>args, <span style=color:#66d9ef>int</span> argcount,
                  PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kws, <span style=color:#66d9ef>int</span> kwcount,
                  PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>defs, <span style=color:#66d9ef>int</span> defcount,
                  PyObject <span style=color:#f92672>*</span>kwdefs, PyObject <span style=color:#f92672>*</span>closure)
{
    <span style=color:#66d9ef>return</span> _PyEval_EvalCodeWithName(_co, globals, locals,
                                    args, argcount,
                                    kws, kws <span style=color:#f92672>!=</span> NULL <span style=color:#f92672>?</span> kws <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> NULL,
                                    kwcount, <span style=color:#ae81ff>2</span>,
                                    defs, defcount,
                                    kwdefs, closure,
                                    NULL, NULL);
}

</code></pre></div><p><code>_PyEval_EvalCode</code> 函数会对代码对象参数 <code>PyCodeObject *co</code> 及其参数进行常规检查，并初始化栈帧对象 <code>PyFrameObject *f</code>，并调用 <code>_PyEval_EvalFrame</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// cpython/Python/ceval.c
</span><span style=color:#75715e></span>PyObject <span style=color:#f92672>*</span>
<span style=color:#a6e22e>_PyEval_EvalCode</span>(PyThreadState <span style=color:#f92672>*</span>tstate,
           PyObject <span style=color:#f92672>*</span>_co, PyObject <span style=color:#f92672>*</span>globals, PyObject <span style=color:#f92672>*</span>locals,
           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>args, Py_ssize_t argcount,
           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwnames, PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>kwargs,
           Py_ssize_t kwcount, <span style=color:#66d9ef>int</span> kwstep,
           PyObject <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>defs, Py_ssize_t defcount,
           PyObject <span style=color:#f92672>*</span>kwdefs, PyObject <span style=color:#f92672>*</span>closure,
           PyObject <span style=color:#f92672>*</span>name, PyObject <span style=color:#f92672>*</span>qualname)
{
    PyObject <span style=color:#f92672>*</span>retval <span style=color:#f92672>=</span> NULL;

    <span style=color:#75715e>/* Create the frame */</span>
    PyFrameObject <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> _PyFrame_New_NoTrack(tstate, co, globals, locals);
    <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>==</span> NULL) {
        <span style=color:#66d9ef>return</span> NULL;
    }
    PyObject <span style=color:#f92672>**</span>fastlocals <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>f_localsplus;
    PyObject <span style=color:#f92672>**</span>freevars <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>f_localsplus <span style=color:#f92672>+</span> co<span style=color:#f92672>-&gt;</span>co_nlocals;

    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
    retval <span style=color:#f92672>=</span> _PyEval_EvalFrame(tstate, f, <span style=color:#ae81ff>0</span>);

fail: <span style=color:#75715e>/* Jump here from prelude on failure */</span>

    <span style=color:#75715e>/* decref&#39;ing the frame can cause __del__ methods to get invoked,
</span><span style=color:#75715e>       which can call back into Python.  While we&#39;re done with the
</span><span style=color:#75715e>       current Python frame (f), the associated C stack is still in use,
</span><span style=color:#75715e>       so recursion_depth must be boosted for the duration.
</span><span style=color:#75715e>    */</span>
    <span style=color:#66d9ef>if</span> (Py_REFCNT(f) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
        Py_DECREF(f);
        _PyObject_GC_TRACK(f);
    }
    <span style=color:#66d9ef>else</span> {
        <span style=color:#f92672>++</span>tstate<span style=color:#f92672>-&gt;</span>recursion_depth;
        Py_DECREF(f);
        <span style=color:#f92672>--</span>tstate<span style=color:#f92672>-&gt;</span>recursion_depth;
    }
    <span style=color:#66d9ef>return</span> retval;
}
</code></pre></div><p><code>_PyEval_EvalFrame</code> 函数调用了一个函数指针，这个指针是随 Python 解释器初始化的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// cpython/Python/internal/pycore_ceval.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> PyObject<span style=color:#f92672>*</span>
<span style=color:#a6e22e>_PyEval_EvalFrame</span>(PyThreadState <span style=color:#f92672>*</span>tstate, PyFrameObject <span style=color:#f92672>*</span>f, <span style=color:#66d9ef>int</span> throwflag)
{
    <span style=color:#66d9ef>return</span> tstate<span style=color:#f92672>-&gt;</span>interp<span style=color:#f92672>-&gt;</span>eval_frame(tstate, f, throwflag);
}

<span style=color:#75715e>// cpython/Python/pystate.c
</span><span style=color:#75715e></span>PyInterpreterState <span style=color:#f92672>*</span>
<span style=color:#a6e22e>PyInterpreterState_New</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    interp<span style=color:#f92672>-&gt;</span>eval_frame <span style=color:#f92672>=</span> _PyEval_EvalFrameDefault;
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p><code>_PyEval_EvalFrameDefault</code> 是整个调用链的终点，它的函数主体是一个循环，不断地读入字节码，并通过 switch 语句判断其类型并执行，</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
PyObject<span style=color:#f92672>*</span> _Py_HOT_FUNCTION
<span style=color:#a6e22e>_PyEval_EvalFrameDefault</span>(PyThreadState <span style=color:#f92672>*</span>tstate, PyFrameObject <span style=color:#f92672>*</span>f, <span style=color:#66d9ef>int</span> throwflag)
{
    _Py_EnsureTstateNotNULL(tstate);
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
main_loop:
    <span style=color:#66d9ef>for</span> (;;) {
        opcode <span style=color:#f92672>=</span> _Py_OPCODE(<span style=color:#f92672>*</span>next_instr);

        <span style=color:#66d9ef>switch</span> (opcode) {
        <span style=color:#66d9ef>case</span> TARGET(LOAD_CONST)<span style=color:#f92672>:</span> {
            PREDICTED(LOAD_CONST);
            PyObject <span style=color:#f92672>*</span>value <span style=color:#f92672>=</span> GETITEM(consts, oparg);
            Py_INCREF(value);
            PUSH(value);
            FAST_DISPATCH();

            <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>        }
        <span style=color:#75715e>// ...
</span></code></pre></div><p>这就是整个调用和运行栈帧对象的过程了，整理如下：</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/py-eval.png alt=py-eval>
</p>
<h4 id=233-调试>2.3.3 调试<a hidden class=anchor aria-hidden=true href=#233-调试>#</a></h4>
<p>最后以 [1.2](#1.2 字节码) 节的 test.py 代码为例，简单地用 gdb 来进行 <code>_PyEval_EvalFrameDefault</code> 函数中逐个字节码指令的调试：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ gdb -ex r --args python3 test.py
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b _PyEval_EvalFrameDefault
Breakpoint <span style=color:#ae81ff>1</span> at 0x41fa90: file Python/ceval.c, line 919.
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> r
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> n
<span style=color:#75715e># ...</span>
</code></pre></div><p>如果有对应版本的源码文件的话也可以直接断点在 <code>switch (opcode) {</code> 所在的行数，这里我们不断地往后执行直到这一行之后：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> layout split

  <span style=color:#ae81ff>1487</span>            <span style=color:#66d9ef>case</span> TARGET<span style=color:#f92672>(</span>LOAD_CONST<span style=color:#f92672>)</span>: <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>1488</span>                PREDICTED<span style=color:#f92672>(</span>LOAD_CONST<span style=color:#f92672>)</span>;
&gt; <span style=color:#ae81ff>1489</span>                PyObject *value <span style=color:#f92672>=</span> GETITEM<span style=color:#f92672>(</span>consts, oparg<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>1490</span>                Py_INCREF<span style=color:#f92672>(</span>value<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>1491</span>                PUSH<span style=color:#f92672>(</span>value<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>1492</span>                FAST_DISPATCH<span style=color:#f92672>()</span>;
  <span style=color:#ae81ff>1493</span>            <span style=color:#f92672>}</span>

<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p opcode
$1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p oparg
$2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</code></pre></div><p>可以看到在执行 LOAD_CONST 助记符时，其对应的 opcode 的十六进制表示为64，十进制表示为 100，LOAD_CONST 首先获取了 oparg 的值，并填入到栈顶；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>  <span style=color:#ae81ff>2343</span>            <span style=color:#66d9ef>case</span> TARGET<span style=color:#f92672>(</span>STORE_NAME<span style=color:#f92672>)</span>: <span style=color:#f92672>{</span>
&gt; <span style=color:#ae81ff>2344</span>                PyObject *name <span style=color:#f92672>=</span> GETITEM<span style=color:#f92672>(</span>names, oparg<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2345</span>                PyObject *v <span style=color:#f92672>=</span> POP<span style=color:#f92672>()</span>;
  <span style=color:#ae81ff>2346</span>                PyObject *ns <span style=color:#f92672>=</span> f-&gt;f_locals;
  <span style=color:#ae81ff>2347</span>                int err;
  <span style=color:#ae81ff>2348</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ns <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2349</span>                    _PyErr_Format<span style=color:#f92672>(</span>tstate, PyExc_SystemError,
  <span style=color:#ae81ff>2350</span>                                  <span style=color:#e6db74>&#34;no locals found when storing %R&#34;</span>, name<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2351</span>                    Py_DECREF<span style=color:#f92672>(</span>v<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2352</span>                    goto error;
  <span style=color:#ae81ff>2353</span>                <span style=color:#f92672>}</span>
  <span style=color:#ae81ff>2354</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>PyDict_CheckExact<span style=color:#f92672>(</span>ns<span style=color:#f92672>))</span>
  <span style=color:#ae81ff>2355</span>                    err <span style=color:#f92672>=</span> PyDict_SetItem<span style=color:#f92672>(</span>ns, name, v<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2356</span>                <span style=color:#66d9ef>else</span>
  <span style=color:#ae81ff>2357</span>                    err <span style=color:#f92672>=</span> PyObject_SetItem<span style=color:#f92672>(</span>ns, name, v<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2358</span>                Py_DECREF<span style=color:#f92672>(</span>v<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2359</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>err !<span style=color:#f92672>=</span> 0<span style=color:#f92672>)</span>
  <span style=color:#ae81ff>2360</span>                    goto error;
  <span style=color:#ae81ff>2361</span>                DISPATCH<span style=color:#f92672>()</span>;
  <span style=color:#ae81ff>2362</span>            <span style=color:#f92672>}</span>
</code></pre></div><p>STORE_NAME 也是类似的，它从栈顶取出一个数值，并存储在局部命名空间中；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>  <span style=color:#ae81ff>2828</span>            <span style=color:#66d9ef>case</span> TARGET<span style=color:#f92672>(</span>BUILD_MAP<span style=color:#f92672>)</span>: <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2829</span>                Py_ssize_t i;
&gt; <span style=color:#ae81ff>2830</span>                PyObject *map <span style=color:#f92672>=</span> _PyDict_NewPresized<span style=color:#f92672>((</span>Py_ssize_t<span style=color:#f92672>)</span>oparg<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2831</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>map <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span>
  <span style=color:#ae81ff>2832</span>                    goto error;
  <span style=color:#ae81ff>2833</span>                <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>i <span style=color:#f92672>=</span> oparg; i &gt; 0; i--<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2834</span>                    int err;
  <span style=color:#ae81ff>2835</span>                    PyObject *key <span style=color:#f92672>=</span> PEEK<span style=color:#f92672>(</span>2*i<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2836</span>                    PyObject *value <span style=color:#f92672>=</span> PEEK<span style=color:#f92672>(</span>2*i - 1<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2837</span>                    err <span style=color:#f92672>=</span> PyDict_SetItem<span style=color:#f92672>(</span>map, key, value<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2838</span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>err !<span style=color:#f92672>=</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2839</span>                        Py_DECREF<span style=color:#f92672>(</span>map<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2840</span>                        goto error;
  <span style=color:#ae81ff>2841</span>                    <span style=color:#f92672>}</span>
  <span style=color:#ae81ff>2842</span>                <span style=color:#f92672>}</span>
  <span style=color:#ae81ff>2843</span>
  <span style=color:#ae81ff>2844</span>                <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>oparg--<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2845</span>                    Py_DECREF<span style=color:#f92672>(</span>POP<span style=color:#f92672>())</span>;
  <span style=color:#ae81ff>2846</span>                    Py_DECREF<span style=color:#f92672>(</span>POP<span style=color:#f92672>())</span>;
  <span style=color:#ae81ff>2847</span>                <span style=color:#f92672>}</span>
  <span style=color:#ae81ff>2848</span>                PUSH<span style=color:#f92672>(</span>map<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2849</span>                DISPATCH<span style=color:#f92672>()</span>;
  <span style=color:#ae81ff>2850</span>            <span style=color:#f92672>}</span>

<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p opcode
$9 <span style=color:#f92672>=</span> <span style=color:#ae81ff>105</span>
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p oparg
$10 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</code></pre></div><p>BUILD_MAP 稍微复杂一些，它会构造一个 Python 中的字典对象（源码中 <code>PyDictObject</code> 结构体的实例对象，用哈希表实现），并不断地从栈帧上获取 key 和 value 插入到字典中；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>  <span style=color:#ae81ff>2312</span>            <span style=color:#66d9ef>case</span> TARGET<span style=color:#f92672>(</span>LOAD_BUILD_CLASS<span style=color:#f92672>)</span>: <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2313</span>                _Py_IDENTIFIER<span style=color:#f92672>(</span>__build_class__<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2314</span>
&gt; <span style=color:#ae81ff>2315</span>                PyObject *bc;
  <span style=color:#ae81ff>2316</span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>PyDict_CheckExact<span style=color:#f92672>(</span>f-&gt;f_builtins<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2317</span>                    bc <span style=color:#f92672>=</span> _PyDict_GetItemIdWithError<span style=color:#f92672>(</span>f-&gt;f_builtins, &amp;PyId___build_class__<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2318</span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>bc <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2319</span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>!_PyErr_Occurred<span style=color:#f92672>(</span>tstate<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2320</span>                            _PyErr_SetString<span style=color:#f92672>(</span>tstate, PyExc_NameError,
  <span style=color:#ae81ff>2321</span>                                             <span style=color:#e6db74>&#34;__build_class__ not found&#34;</span><span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2322</span>                        <span style=color:#f92672>}</span>
  <span style=color:#ae81ff>2323</span>                        goto error;
  <span style=color:#ae81ff>2324</span>                    <span style=color:#f92672>}</span>
  <span style=color:#ae81ff>2325</span>                    Py_INCREF<span style=color:#f92672>(</span>bc<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2326</span>                <span style=color:#f92672>}</span>
  <span style=color:#ae81ff>2327</span>                <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2328</span>                    PyObject *build_class_str <span style=color:#f92672>=</span> _PyUnicode_FromId<span style=color:#f92672>(</span>&amp;PyId___build_class__<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2329</span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>build_class_str <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span>
  <span style=color:#ae81ff>2330</span>                        goto error;
  <span style=color:#ae81ff>2331</span>                    bc <span style=color:#f92672>=</span> PyObject_GetItem<span style=color:#f92672>(</span>f-&gt;f_builtins, build_class_str<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2332</span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>bc <span style=color:#f92672>==</span> NULL<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#ae81ff>2333</span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>_PyErr_ExceptionMatches<span style=color:#f92672>(</span>tstate, PyExc_KeyError<span style=color:#f92672>))</span>
  <span style=color:#ae81ff>2334</span>                            _PyErr_SetString<span style=color:#f92672>(</span>tstate, PyExc_NameError,
  <span style=color:#ae81ff>2335</span>                                             <span style=color:#e6db74>&#34;__build_class__ not found&#34;</span><span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2336</span>                        goto error;
  <span style=color:#ae81ff>2337</span>                    <span style=color:#f92672>}</span>
  <span style=color:#ae81ff>2338</span>                <span style=color:#f92672>}</span>
  <span style=color:#ae81ff>2339</span>                PUSH<span style=color:#f92672>(</span>bc<span style=color:#f92672>)</span>;
  <span style=color:#ae81ff>2340</span>                DISPATCH<span style=color:#f92672>()</span>;
  <span style=color:#ae81ff>2341</span>            <span style=color:#f92672>}</span>
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p opcode
$11 <span style=color:#f92672>=</span> <span style=color:#ae81ff>71</span>
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p oparg
$12 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</code></pre></div><p>LOAD_BUILD_CLASS 则会从内置命名空间中通过哈希方法找到函数指针，并插入栈顶；</p>
<p>其他的字节码指令还有很多，都可以通过阅读源码或者使用 gdb 调试的方法找到其实际执行的代码；相比于汇编指令，字节码指令实际上代表了由许多行代码组成的功能，而 Python 虚拟机则是通过字节码指令模拟出了对汇编指令的执行过程。</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=http://zintrulcre.github.io/posts/python/python-source-code-coroutine/>
<span class=title>« Prev Page</span>
<br>
<span>Python 源码学习（5）：协程</span>
</a>
<a class=next href=http://zintrulcre.github.io/posts/python/source-code-3-list-and-dict/>
<span class=title>Next Page »</span>
<br>
<span>Python 源码学习（3）：list 类型</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>
Zhengyu &copy; 2022
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>